{
  "chapters": [
    {
      "description": "लिनक्स क्या है? एक वितरण चुनने और स्थापना करने के साथ शुरू हो जाओ।",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "अतिरिक्त पठन:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "हे नवीन! तो आपने इस शानदार दुनिया में डाइव करने का निर्णय लिया है जिसे लिनक्स के नाम से जाना जाता है? तो आपको बेहतर है कि बेल्ट को बांध लें, क्योंकि यह एक लंबा और कठिन सड़क होने वाली है। मेरा नाम पेंगुइन पीट है और मैं आपको इस यात्रा में मार्गदर्शन करने के लिए यहाँ हूँ। चलिए लिनक्स के बारे में कुछ पिछले के बारे में शुरुआत करते हैं। \n\nलिनक्स कैसे बना, इसे जानने के लिए, हमें 1969 में वापस जाना होगा जहां केन थॉम्पसन और डेनिस रिची बेल लेबोरेटरीज़ के UNIX ऑपरेटिंग सिस्टम का विकास कर रहे थे। बाद में इसे C में फिर से लिखा गया था ताकि इसे और पोर्टेबल बनाया जा सके और आखिरकार यह एक व्यापक रूप से प्रयोग किया जाने वाला ऑपरेटिंग सिस्टम बन गया। \n\nदस वर्ष बाद या इससे थोड़ा पहले, रिचर्ड स्टॉलमैन ने GNU (GNU is Not UNIX) परियोजना पर काम शुरू किया, GNU कर्नेल जिसे हर्ड कहा गया, जो दुर्भाग्य से कभी पूरा नहीं हुआ। इसके परिणामस्वरूप GNU जनरल पब्लिक लाइसेंस (GPL), एक मुफ्त सॉफ्टवेयर लाइसेंस, भी बनाया गया।\n\nकर्नेल ऑपरेटिंग सिस्टम में सबसे महत्वपूर्ण टुकड़ा है। यह हार्डवेयर को सॉफ्टवेयर से बात करने की अनुमति देता है। यह अन्य बहुत कुछ भी करता है, लेकिन हम इसे एक अलग कोर्स में खोदेंगे। अब तक बस यह जान लें कि कर्नेल आपके सिस्टम पर होने वाली हर घटना को नियंत्रित करता है। \n\nइस समय के दौरान अन्य प्रयास जैसे कि बीएसडी, मिनिक्स, आदि UNIX जैसे सिस्टम विकसित किए गए थे। हालांकि, इन सभी UNIX जैसे सिस्टमों में एक समूहित कर्नेल की कमी थी। \n\nफिर 1991 में, एक जवान व्यक्ति नामक लिनस टोरवाल्ड्स ने वह विकसित करना शुरू किया जिसे आज हम लिनक्स कर्नेल के रूप में जानते हैं।",
          "quizAnswer": "लिनस टोरवाल्ड्स",
          "quizQuestion": "लिनक्स कर्नेल का विकास किसने किया?",
          "slug": "लिनक्सइतिहास",
          "title": "इतिहास"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 2,
          "lessonContent": "पिछले पाठ में, हमने लिनक्स कर्नेल के बारे में सीखा जो रोजाना लाखों डिवाइसों को संचालित करता है। एक बात जिससे हम आगे बढ़ने से पहले बात करें, वह यह है कि लिनक्स एक गलत नाम है, क्योंकि वास्तव में यह लिनक्स कर्नेल को संदर्भित करता है। हालांकि, कई वितरण लिनक्स कर्नेल का उपयोग करते हैं, इसलिए वे आमतौर पर लिनक्स ऑपरेटिंग सिस्टम के रूप में जाने जाते हैं।\n\nएक लिनक्स सिस्टम को तीन मुख्य हिस्सों में विभाजित किया जाता है:\n\n<ul>\n<li>हार्डवेयर - इसमें आपके सिस्टम पर चलने वाले सभी हार्डवेयर और मेमोरी, सीपीयू, डिस्क आदि शामिल हैं।</li>\n<li>लिनक्स कर्नेल - जैसा कि हमने पहले चर्चा की थी, कर्नेल ऑपरेटिंग सिस्टम का मूल है। यह हार्डवेयर का प्रबंधन करता है और इसे बताता है कि वह सिस्टम के साथ कैसे बातचीत करेगा।</li>\n<li>उपयोगकर्ता स्थान - यहाँ आप जैसे उपयोगकर्ता सीधे सिस्टम के साथ बातचीत करेंगे।</li>\n</ul>\n\nइसलिए पहला कदम जिसे हमें उठाना होगा, वह है अपनी मशीन पर लिनक्स स्थापित करना। आपके पास चुनने के लिए कई विकल्प हैं और यह पाठ्यक्रम आपको सूचित करने में मदद करेगा और आपको लिनक्स वितरण चुनने में शुरुआत करने में मदद करेगा।\n\nकई लिनक्स वितरण हैं जिनमें से चुनने के लिए, हम केवल सबसे लोकप्रिय विकल्पों पर जाएंगे।",
          "quizAnswer": "",
          "quizQuestion": "कोई प्रश्न नहीं, आगे बढ़ें!",
          "slug": "choosingalinuxdistribution",
          "title": "लिनक्स वितरण का चयन करना"
        },
        {
          "exercise": "यदि आप डेबियन को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और इसे एक बार आजमाएं: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>अवलोकन</b>\nडेबियन एक ऑपरेटिंग सिस्टम है जो पूरी तरह से मुफ्त और ओपन-सोर्स सॉफ्टवेयर से बना है। यह व्यापक रूप से जाना जाता है और 20 साल से विकास में है। इसमें तीन शाखाएँ हैं जिन्हें आप उपयोग कर सकते हैं, स्थिर, परीक्षण और अस्थिर।\n\nस्थिर एक समग्र अच्छी शाखा है। परीक्षण और अस्थिर रोलिंग रिलीज़ हैं। इसका यह मतलब है कि उन शाखाओं में किसी भी अंशकारी परिवर्तन को अंततः स्थिर हो जाएगा। उदाहरण के लिए, यदि आप Windows 8 से Windows 10 के अगले अपडेट तक पहुंचना चाहते हैं, तो आपको पूरी Windows 10 स्थापना करनी होगी। हालांकि परीक्षण रिलीज़ पर होने के कारण, आपको पूरी स्थापना किए बिना अपडेट मिल जाएगा जब तक यह अगले ऑपरेटिंग सिस्टम रिलीज़ नहीं हो जाता।\n\n<b>पैकेज प्रबंधन</b>\nडेबियन भी डेबियन पैकेज प्रबंधन उपकरण का उपयोग करता है। हर लिनक्स वितरण पैकेजों को अलग-अलग तरीके से स्थापित और प्रबंधित करता है और उन्हें अलग-अलग पैकेज प्रबंधन उपकरण का उपयोग करते हैं। हम इस पर एक बाद में पाठ्यक्रम में अधिक जानेंगे।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nडेबियन शायद नवीनतम अपडेट न मिले, लेकिन यह अत्यधिक स्थिर है। यदि आप एक अच्छा \"कोर\" ऑपरेटिंग सिस्टम चाहते हैं, तो यह आपके लिए है।\n\n<b>उपयोग</b>\nडेबियन किसी भी प्लेटफ़ॉर्म के लिए समग्र शानदार ऑपरेटिंग सिस्टम है।",
          "quizAnswer": "रोलिंग",
          "quizQuestion": "परीक्षण और अस्थिर किस प्रकार की रिलीज़ होती है?",
          "slug": "डेबियन",
          "title": "डेबियन"
        },
        {
          "exercise": "यदि आप RHEL को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और इसे एक बार आजमाएं: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>अवलोकन</b>\nरेड हैट एंटरप्राइज लिनक्स जिसे आमतौर पर RHEL के रूप में संदर्भित किया जाता है, रेड हैट द्वारा विकसित किया गया है। RHEL में मुफ्त पुनर्वितरण को प्रतिबंधित करने के लिए सख्त नियम हैं हालांकि यह फिर भी मुफ्त के लिए स्रोत कोड प्रदान करता है।\n\n<b>पैकेज प्रबंधन</b>\nRHEL डेबियन से एक विभिन्न पैकेज प्रबंधक का उपयोग करता है, RPM पैकेज प्रबंधक, जिसके बारे में हम आखिरकार सीखेंगे।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nRHEL आधारित ऑपरेटिंग सिस्टम डेबियन आधारित ऑपरेटिंग सिस्टम से थोड़ा भिन्न होंगे, सबसे अधिक नोटिसेबल पैकेज प्रबंधन में। अगर आप RHEL के साथ जाने का निर्णय करते हैं तो शायद यह अच्छा होगा कि आप जानें कि आप इसके साथ काम कर रहे हैं।\n\n<b>उपयोग</b>\nनाम से स्पष्ट है कि यह अधिकांश उद्यम में प्रयोग किया जाता है, इसलिए यदि आपको एक मजबूत सर्वर ओएस चाहिए तो यह एक अच्छा विकल्प होगा।",
          "quizAnswer": "RPM",
          "quizQuestion": "RHEL का कौन सा पैकेज प्रबंधक उपयोग करता है?",
          "slug": "redhatenterpriselinux",
          "title": "रेड हैट एंटरप्राइज लिनक्स"
        },
        {
          "exercise": "यदि आप उबंटू को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और एक प्रयास करें: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>अवलोकन</b>\nव्यक्तिगत मशीनों के लिए सबसे लोकप्रिय लिनक्स वितरणों में से एक उबंटू है। उबंटू डेस्कटॉप परिवेश प्रबंधक यूनिटी को डिफ़ॉल्ट रूप से जारी करता है।\n\n<b>पैकेज प्रबंधन</b>\nउबंटू एक कैनोनिकल द्वारा विकसित डेबियन-आधारित ऑपरेटिंग सिस्टम है। इसलिए यह एक मूल डेबियन पैकेज प्रबंधन प्रणाली का उपयोग करता है।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nउबंटू उन शुरुआती उपयोक्ताओं के लिए एक महान विकल्प है जो लिनक्स में प्रवेश करना चाहते हैं। उबंटू उपयोग सुविधा और एक महान उपयोक्ता इंटरफ़ेस अनुभव प्रदान करता है जिसने इसके व्यापक स्वीकृति का कारण बनाया है। यह व्यापक रूप से उपयोग किया जाता है और समर्थित है और उपयोगीता के मामले में ओएसएक्स और विंडोज जैसे अन्य ऑपरेटिंग सिस्टमों के तुलनात्मक रूप से सबसे अधिक है।\n\n<b>उपयोग</b>\nकिसी भी प्लेटफ़ॉर्म, डेस्कटॉप, लैपटॉप और सर्वर के लिए बढ़िया है।",
          "quizAnswer": "डेबियन",
          "quizQuestion": "उबंटू किस ऑपरेटिंग सिस्टम पर आधारित है?",
          "slug": "उबंटू",
          "title": "उबंटू"
        },
        {
          "exercise": "यदि आप फेडोरा को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और इसे एक बार आजमाएं: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>अवलोकन</b>\nरेड हैट द्वारा समर्थित, फेडोरा प्रोजेक्ट समुदाय द्वेष्य ओपन-सोर्स और मुक्त सॉफ्टवेयर से भरपूर है। रेड हैट एंटरप्राइज लिनक्स फेडोरा से शाखा बनाता है, इसलिए फेडोरा को एक अपस्ट्रीम आरएचईएल ऑपरेटिंग सिस्टम के रूप में सोचें। अंततः आरएचईएल को फेडोरा से अपडेट मिलेगा, जब ठोस परीक्षण और गुणवत्ता आश्वासन हो जाएगा। फेडोरा को एक उबंटू समतुल्य मानें जो डेबियन की बजाय रेड हैट बैकएंड का उपयोग करता है।\n\n<b>पैकेज प्रबंधन</b>\nरेड हैट पैकेज प्रबंधक का उपयोग करता है।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nयदि आप रेड हैट आधारित ऑपरेटिंग सिस्टम का उपयोग करना चाहते हैं, तो यह एक उपयोगकर्ता मित्र संस्करण है।\n\n<b>उपयोग</b>\nफेडोरा शानदार है अगर आप एक रेड हैट आधारित ऑपरेटिंग सिस्टम चाहते हैं बिना मूल्य टैग के। डेस्कटॉप और लैपटॉप के लिए सिफारिश की जाती है।",
          "quizAnswer": "फेडोरा",
          "quizQuestion": "आरएचईएल किसके शाखा है?",
          "slug": "फेडोरा",
          "title": "फेडोरा"
        },
        {
          "exercise": "यदि आप लिनक्स मिंट को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और इसे एक बार आजमाएं: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>अवलोकन</b>\nलिनक्स मिंट यूबंटू पर आधारित है। यह यूबंटू के सॉफ्टवेयर भंडार का उपयोग करता है, इसलिए दोनों वितरणों पर एक ही पैकेज उपलब्ध हैं। यूबंटू के बारे में कुछ प्रोप्राइटरी सॉफ्टवेयर शामिल नहीं है, इसलिए अन्य लोग यूबंटू की तुलना में लिनक्स मिंट को पसंद करते हैं।\n\n<b>पैकेज प्रबंधन</b>\nलिनक्स मिंट यूबंटू पर आधारित है, इसलिए यह डेबियन पैकेज प्रबंधक का उपयोग करता है।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nबढ़िया उपयोगकर्ता इंटरफेस, नए लोगों के लिए बढ़िया और यूबंटू से कम भरा हुआ है। इस पाठ्यक्रम में, मैं लिनक्स मिंट का उपयोग कर रहा हूँ, लेकिन किसी भी अन्य वितरण का उपयोग किया जा सकता है।\n\n<b>उपयोग</b>\nडेस्कटॉप और लैपटॉप के लिए बढ़िया।",
          "quizAnswer": "यूबंटू",
          "quizQuestion": "लिनक्स मिंट किस पर आधारित है?",
          "slug": "लिनक्समिंट",
          "title": "लिनक्स मिंट"
        },
        {
          "exercise": "यदि आप जेन्टू को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो स्थापना खंड पर जाएं और इसे एक बार आजमाएं: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>अवलोकन</b>\nजेन्टू ऑपरेटिंग सिस्टम के साथ अद्वितीय लचीलापन प्रदान करता है, लेकिन इसकी कीमत है। यह उन पेशेवर उपयोगकर्ताओं के लिए बनाया गया है जो सिस्टम के साथ हाथ गंदा करने से घबराते नहीं हैं।\n\n<b>पैकेज प्रबंधन</b>\nजेन्टू अपने खुद के पैकेज प्रबंधन, पोर्टेज का उपयोग करता है। पोर्टेज पैकेज प्रबंधन बहुत ही मॉड्यूलर और आसान रखने योग्य है, जो सिस्टम के सम्पूर्ण रूप में लचीलापन में बड़ा योगदान देता है।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nअगर आप लिनक्स के साथ शुरुआत कर रहे हैं और एक अधिक कठिन पथ चुनना चाहते हैं, तो मैं आपको जेन्टू या आर्च लिनक्स को अपना वितरण चुनने की सलाह दूंगा।\n\n<b>उपयोग</b>\nडेस्कटॉप और लैपटॉप के लिए बड़ा उपयोगी।",
          "quizAnswer": "पोर्टेज",
          "quizQuestion": "जेन्टू का कौन सा पैकेज प्रबंधन सिस्टम उपयोग करता है?",
          "slug": "gentoo",
          "title": "जेन्टू"
        },
        {
          "exercise": "यदि आप आर्च को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो इंस्टॉलेशन सेक्शन पर जाएं और इसे प्रयास करें: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>अवलोकन</b>\nआर्च एक हल्का और लचीला लिनक्स वितरण है जिसे समुदाय द्वारा 100% चलाया जाता है। डेबियन के समान, आर्च एक रोलिंग रिलीज मॉडल का उपयोग करता है ताकि लघु अपडेट अंततः स्थिर रिलीज बन जाते हैं। आपको वास्तव में सिस्टम और इसके कार्यों को समझने के लिए मेहनत करनी पड़ती है, लेकिन बदले में आपको अपने सिस्टम पर पूर्ण और कुल नियंत्रण मिलता है।\n\n<b>पैकेज प्रबंधन</b>\nयह अपने खुद के पैकेज प्रबंधक, पैकमैन, का उपयोग करता है पैकेज इंस्टॉल, अपडेट और पैकेजों का प्रबंधन करने के लिए।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nअगर आप एक हल्का ऑपरेटिंग सिस्टम चाहते हैं और वास्तव में लिनक्स को समझना चाहते हैं तो आर्च का उपयोग करें! इसमें एक सीखने की कुर्व है, लेकिन हार्डकोर लिनक्स उपयोगकर्ताओं के लिए, यह एक बड़ी चुनौती है।\n\n<b>उपयोग</b>\nडेस्कटॉप और लैपटॉप के लिए बड़ा उपयोगी। यदि आपके पास एक रास्पबेरी पाई जैसी छोटी उपकरण भी है और आपको उस पर एक हल्का ओएस चाहिए, तो आर्च के साथ कुछ गलत नहीं हो सकता।",
          "quizAnswer": "पैकमैन",
          "quizQuestion": "आर्च लिनक्स का कौन सा पैकेज प्रबंधक उपयोग करता है?",
          "slug": "archlinux",
          "title": "आर्च लिनक्स"
        },
        {
          "exercise": "यदि आप ओपनएसयूएसई को अपना ऑपरेटिंग सिस्टम बनाने में रुचि रखते हैं, तो डाउनलोड पेज पर जाएं और इसे एक बार प्रयास करें: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>अवलोकन</b>\nओपनएसयूएसई लिनक्स ओपनएसयूएसई प्रोजेक्ट द्वारा बनाया गया है। एक समुदाय जो लिनक्स का उपयोग सर्वत्र प्रोत्साहित करता है, एक खुले, पारदर्शी और मित्रशील तरीके से सार्वजनिक और मुक्त स्रोत सॉफ्टवेयर समुदाय का हिस्सा है। ओपनएसयूएसई दूसरा सबसे पुराना अभी भी चल रहा लिनक्स वितरण है और सूसे के पुरस्कार विजेता सूसे लिनक्स एंटरप्राइज प्रोडक्ट्स के बेस सिस्टम को साझा करता है।\n\n<b>पैकेज प्रबंधन</b>\nRPM पैकेज प्रबंधक का उपयोग करता है।\n\n<b>कॉन्फ़िगरेबिलिटी</b>\nओपनएसयूएसई एक नए लिनक्स उपयोगकर्ता के लिए एक शानदार विकल्प है। यह एक आसान इस्तेमाल के ग्राफिकल इंस्टॉलर/प्रशासन एप्लिकेशन (<a href=\"http://yast.github.io/\">YaST</a>) प्रदान करता है और एक साफ सुथरा बेस सिस्टम, जिसे आसानी से छेड़छाड़ किया जा सकता है। ओपनएसयूएसई में वायरस/स्पाईवेयर की चिंता किए बिना इंटरनेट का आनंद लेने के लिए और अपनी रचनात्मकता को जीने के लिए, चाहे वह आपकी फोटो, वीडियो, संगीत या कोड के साथ हो।\n\n<b>उपयोग</b>\nओपनएसयूएसई लीप पूरी तरह से एक डेस्कटॉप पीसी और लैपटॉप पर उपयोग के लायक है।",
          "quizAnswer": "yast",
          "quizQuestion": "ओपनएसयूएसई के प्रशासन/स्थापना उपकरण का नाम क्या है?",
          "slug": "ओपनएसयूएसई",
          "title": "ओपनएसयूएसई"
        }
      ],
      "slug": "gettingstarted",
      "title": "शुरुआत करना"
    },
    {
      "description": "कमांड लाइन की मूल बातें सीखें, फ़ाइलों, निर्देशिकाओं और अधिक में नेविगेट करें।",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "कुछ अन्य लिनक्स आदेशों का प्रयास करें और देखें कि वे क्या उत्पन्न करते हैं:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "दुनिया आपकी मोती है, या वास्तव में शैल आपकी मोती है। शैल क्या है? शैल मूल रूप से एक कार्यक्रम है जो आपके कीबोर्ड से आपके आदेश लेता है और ऑपरेटिंग सिस्टम को कार्रवाई करने के लिए भेजता है। अगर आपने GUI का उपयोग किया है, तो आपने शायद “टर्मिनल” या “कंसोल” जैसे कार्यक्रम देखे होंगे, ये बस उन कार्यक्रम हैं जो आपके लिए एक शैल लॉन्च करते हैं। इस पूरे पाठ्यक्रम में हम शैल के चमत्कारों के बारे में सीखेंगे। \n\nइस पाठ्यक्रम में हम शैल कार्यक्रम बैश (बोर्न अगेन शैल) का उपयोग करेंगे, लगभग सभी लिनक्स वितरण डिफ़ॉल्ट रूप से बैश शैल का उपयोग करेंगे। ksh, zsh, tsch जैसे अन्य शैल उपलब्ध हैं, लेकिन हम उनमें से किसी में नहीं जाएँगे। \n\nचलो शुरू करते हैं! आपके शैल प्रॉम्प्ट परिवर्तन के आधार पर भिन्न हो सकते हैं, लेकिन अधिकांश में यह निम्नलिखित प्रारूप का पालन करना चाहिए:\n<pre>username@hostname:current_directory\npete@icebox:/home/pete $</pre>\n\nप्रॉम्प्ट के अंत में $ देखें? विभिन्न शैल्स में विभिन्न प्रॉम्प्ट होते हैं, हमारे मामले में $ एक सामान्य उपयोगकर्ता के लिए है जो बैश, बोर्न या कोर्न शैल का उपयोग कर रहा है, जब आप आदेश टाइप करते हैं, तो प्रॉम्प्ट प्रतीक नहीं जोड़ते हैं, बस यह जान लें कि वहाँ है।\n\nएक सरल आदेश के साथ शुरू करते हैं, echo। इको आदेश बस पाठ तर्कों को प्रदर्शित करता है।\n\n<pre>$ echo Hello World</pre>",
          "quizAnswer": "Hello World",
          "quizQuestion": "जब आप echo Hello World टाइप करते हैं तो प्रदर्शन पर क्या उत्पन्न होना चाहिए?",
          "slug": "द शैल",
          "title": "द शैल"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 2,
          "lessonContent": "लिनक्स में सब कुछ एक फ़ाइल है। जब आप लिनक्स में गहराई से जाएंगे तो आप इसे समझेंगे, लेकिन अब तक बस इसे ध्यान में रखें। प्रत्येक फ़ाइल को एक वर्गीकृत निर्देशिका पेड़ी में संगठित किया गया है। फ़ाइल सिस्टम में पहला निर्देशिका 'मुख्य निर्देशिका' कहलाता है। मुख्य निर्देशिका में कई फ़ोल्डर और फ़ाइलें हैं, जिसमें आप और फ़ोल्डर और फ़ाइलें संग्रहित कर सकते हैं, और ऐसा ही जारी रहता है। यहाँ एक उदाहरण है कि निर्देशिका पेड़ी किस तरह से दिखती है: \n\n<pre>/\n|-- bin\n|   |-- file1\n|   |-- file2\n|-- etc\n|   |-- file3\n|   `-- directory1\n|       |-- file4\n|       `-- file5\n|-- home\n|-- var\n</pre>\n\nइन फ़ाइलों और निर्देशिकाओं की स्थानों को 'पथ' के रूप में संदर्भित किया जाता है। अगर आपके पास एक फ़ोल्डर होता 'होम' जिसमें 'पीट' नामक एक और फ़ोल्डर होता और उस फ़ोल्डर में 'फिल्में' नामक एक और फ़ोल्डर होता, तो वह पथ इस प्रकार दिखता है: '/home/pete/Movies'. काफ़ी सरल है ना?\n\nफ़ाइल सिस्टम में नेविगेट करना, जैसे कि वास्तविक जीवन में नेविगेट करना, आसान होता है अगर आप जानते हैं कि आप कहाँ हैं और आप कहाँ जा रहे हैं। जानने के लिए कि आप कहाँ हैं, आप 'pwd' कमांड का उपयोग कर सकते हैं। यह कमांड 'प्रिंट वर्किंग डायरेक्टरी' का अर्थ है और यह आपको दिखाता है कि आप किस निर्देशिका में हैं। ध्यान दें कि पथ मुख्य निर्देशिका से उत्पन्न होता है।\n\n<pre>$ pwd</pre>\n\nआप कहाँ हैं? मैं कहाँ हूँ? इसे आजमाएं।",
          "quizAnswer": "pwd",
          "quizQuestion": "मैं कैसे पता लगाऊं कि आप वर्तमान में किस निर्देशिका में हैं?",
          "slug": "printworkingdirectorypwdcommand",
          "title": "pwd (प्रिंट वर्किंग डायरेक्टरी)"
        },
        {
          "exercise": "<ol>\n<li>किसी भी फ्लैग के बिना सीडी कमांड चलाएं, यह आपको कहाँ ले जाता है?</li>\n</ol>",
          "id": 3,
          "lessonContent": "अब जब आप जान चुके हैं कि आप कहाँ हैं, तो चलिए देखते हैं कि हम फाइल सिस्टम में थोड़ा घूम सकते हैं। ध्यान रखें हमें पथ का उपयोग करके अपना मार्ग निर्धारित करना होगा। पथ को निर्दिष्ट करने के दो विभिन्न तरीके हैं, अधिसूचित और सांदरिक पथों के साथ।\n\n<ul>\n<li>अधिसूचित पथ: यह मूल डायरेक्टरी से पथ है। मूल डायरेक्टरी मुख्य है। मूल डायरेक्टरी को सामान्य रूप से एक स्लैश के रूप में दिखाया जाता है। हर बार जब आपका पथ / के साथ शुरू होता है तो इसका मतलब है कि आप मूल डायरेक्टरी से शुरू कर रहे हैं। उदाहरण के लिए, /home/pete/Desktop।</li>\n\n<li>सांदरिक पथ: यह वह पथ है जो आप वर्तमान में फाइल सिस्टम में हैं। यदि मैं स्थान /home/pete/Documents में हो और मुझे Documents के भीतर एक डायरेक्टरी में जाना है जिसका नाम taxes है, तो मुझे पूरे पथ को निर्दिष्ट करने की आवश्यकता नहीं है जैसे कि /home/pete/Documents/taxes, मैं taxes/ में जा सकता हूँ।</li>\n</ul>\n\nअब जब आपको पथ काम करने के बारे में पता चल गया है, हमें बस उस डायरेक्टरी में जाने के लिए कुछ चाहिए। भाग्य से, हमारे पास सीडी या “डायरेक्टरी बदलें” है जो ऐसा करने में मदद करेगा।\n\n<pre>$ cd /home/pete/Pictures</pre> \n\nइसलिए अब मैंने अपनी डायरेक्टरी स्थान को /home/pete/Pictures में बदल दिया है।\n\nअब इस डायरेक्टरी से मेरे पास Hawaii नामक एक फोल्डर है, मैं उस फोल्डर में जा सकता हूँ इसके साथ:\n\n<pre>$ cd Hawaii</pre>\n\nध्यान दें कि मैंने फोल्डर का नाम ही क्यों इस्तेमाल किया? यह इसलिए कि मैं पहले से ही /home/pete/Pictures में था।\n\nयह अधिसूचित और सांदरिक पथों के साथ हर समय घूमना थका देने वाला हो सकता है, भाग्य से आपकी मदद के लिए कुछ शॉर्टकट हैं।\n\n<ul>\n<li>. (वर्तमान डायरेक्टरी). यह वह डायरेक्टरी है जिसमें आप वर्तमान में हैं। </li>\n<li>.. (पिछली डायरेक्टरी). आपको आपकी वर्तमान से ऊपर की डायरेक्टरी में ले जाता है।</li>\n<li>~ (होम डायरेक्टरी). यह डायरेक्टरी आपकी “होम डायरेक्टरी” पर डिफ़ॉल्ट होती है। जैसे कि /home/pete।</li>\n<li>- (पिछली डायरेक्टरी). यह आपको उस पिछली डायरेक्टरी में ले जाएगा जिसमें आप अभी थे।</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nउन्हें एक बार आजमाएँ!",
          "quizAnswer": "cd ..",
          "quizQuestion": "/home/pete/Pictures में अगर आप /home/pete जाना चाहते हैं, तो कौन सा अच्छा शॉर्टकट उपयोग करना चाहिए?",
          "slug": "changedirectorycdcommand",
          "title": "सीडी (डायरेक्टरी बदलें)"
        },
        {
          "exercise": "विभिन्न फ्लैग्स के साथ ls चलाएं और प्राप्त की गई आउटपुट देखें।",
          "id": 4,
          "lessonContent": "अब जब हमें प्रणाली में घूमने का तरीका पता चल गया है, तो हम कैसे पता करें कि हमारे लिए क्या उपलब्ध है? अभी तक ऐसा लगता है कि हम अंधेरे में घूम रहे हैं। अच्छा, हम विचित्र ls कमांड का उपयोग कर सकते हैं ताकि डायरेक्टरी सामग्री की सूची बना सकें। ls कमांड डिफ़ॉल्ट रूप से वर्तमान डायरेक्टरी में डायरेक्टरी और फ़ाइलों की सूची दिखाएगा, हालांकि आप यह भी निर्दिष्ट कर सकते हैं कि आप किस पथ की डायरेक्टरियों की सूची देखना चाहते हैं।\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls एक काफी उपयोगी उपकरण है, यह आपको उन फ़ाइलों और डायरेक्टरियों के बारे में विस्तृत जानकारी भी दिखाता है जिन्हें आप देख रहे हैं।\n\nध्यान दें कि एक डायरेक्टरी में सभी फ़ाइलें दिखाई नहीं देती हैं। . से शुरू होने वाले फ़ाइलनाम छिपे होते हैं, आप उन्हें ls कमांड के साथ देख सकते हैं और उसे -a फ़्लैग पास कर सकते हैं (a सभी के लिए)।\n\n<pre>$ ls -a</pre>\n\nएक और उपयोगी ls फ़्लैग भी है, -l लंबा के लिए, यह एक विस्तृत सूची दिखाएगा। यह आपको विस्तृत जानकारी दिखाएगा, बाएं से शुरू होकर: फ़ाइल अनुमतियाँ, लिंकों की संख्या, मालिक का नाम, मालिक समूह, फ़ाइल का आकार, पिछले संशोधन का समयचिह्न, और फ़ाइल/डायरेक्टरी का नाम।\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nकमांड्स के पास चीज़ें होती हैं जिन्हें फ़्लैग्स (या तर्क या विकल्प भी कह सकते हैं) कहा जाता है जो अधिक कार्यक्षमता जोड़ने के लिए होते हैं। देखें कैसे हमने -a और -l जोड़ दिए, अच्छा आप उन्हें -la के साथ एक साथ जोड़ सकते हैं। फ़्लैग्स के क्रम यह निर्धारित करता है कि यह किस क्रम में जाता है, ज्यादातर समय यह काफी मायने नहीं रखता है तो आप ls -al भी कर सकते हैं और यह काम करेगा।\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "छिपी हुई फ़ाइलें देखने के लिए आप कौन सा कमांड उपयोग करेंगे?",
          "slug": "listdirectorieslscommand",
          "title": "ls (लिस्ट डायरेक्टरीज)"
        },
        {
          "exercise": "<ol>\n<li>एक नई फ़ाइल बनाएं</li>\n<li>समय चिह्नित करें</li>\n<li>फ़ाइल को touch करें और फिर समय चिह्नित एक बार फिर देखें</li>\n</ol>",
          "id": 5,
          "lessonContent": "कुछ फ़ाइलें बनाने का तरीका सीखते हैं। एक बहुत सरल तरीका है touch कमांड का उपयोग करना। Touch आपको नई खाली फ़ाइलें बनाने की अनुमति देता है।\n\n<pre>$ touch mysuperduperfile</pre>\n\nऔर धड़कन, नई फ़ाइल! \n\nTouch का उपयोग मौजूदा फ़ाइलें और निर्देशिकाओं पर समय चिह्नित करने के लिए भी किया जाता है। एक बार इसे प्रयास करें, किसी फ़ाइल पर ls -l करें और समय चिह्नित करें, फिर उस फ़ाइल को touch करें और यह समय चिह्नित करेगा।\n\nफ़ाइलें बनाने के लिए अन्य कई तरीके हैं जिनमें पुनर्निर्देशन और पाठ संपादक जैसी अन्य चीजें शामिल हैं, लेकिन हम टेक्स्ट मेनिपुलेशन पाठ्यक्रम में उस पर पहुंचेंगे।",
          "quizAnswer": "touch myfile",
          "quizQuestion": "कैसे आप एक फ़ाइल जिसका नाम myfile है बनाते हैं?",
          "slug": "touchcommand",
          "title": "स्पर्श"
        },
        {
          "exercise": "कुछ विभिन्न निर्देशिकाओं और फ़ाइलों पर फ़ाइल कमांड चलाएं और उत्पादन नोट करें।",
          "id": 6,
          "lessonContent": "पिछले पाठ में हमने टच के बारे में सीखा, थोड़ी देर के लिए वापस जाते हैं। क्या आपने ध्यान दिया कि फ़ाइल का नाम मानक नामकरण का पालन नहीं करता था जैसा कि आपने शायद अन्य ऑपरेटिंग सिस्टम जैसे Windows में देखा हो? सामान्यत: आप एक फ़ाइल जिसे banana.jpeg कहा गया है उसे देखेंगे और एक JPEG चित्र फ़ाइल की उम्मीद करेंगे।\n\nLinux में, फ़ाइलों को फ़ाइल की सामग्री को प्रस्तुत करने की आवश्यकता नहीं है। आप एक फ़ाइल बना सकते हैं जिसे funny.gif कहा गया है जो वास्तव में एक GIF नहीं है।\n\nजानने के लिए कि एक फ़ाइल किस प्रकार की है, आप file कमांड का उपयोग कर सकते हैं। यह आपको फ़ाइल की सामग्री का विवरण दिखाएगा।\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "फ़ाइल",
          "quizQuestion": "आप किस कमांड का उपयोग कर सकते हैं एक फ़ाइल के प्रकार को खोजने के लिए?",
          "slug": "filecommand",
          "title": "फ़ाइल"
        },
        {
          "exercise": "विभिन्न फ़ाइलों और निर्देशिकाओं पर cat चलाएं। फिर कोशिश करें कि एक साथ कई फ़ाइलों को cat करें।",
          "id": 7,
          "lessonContent": "हम लगभग फ़ाइलों में नेविगेट करने को पूरा कर चुके हैं, लेकिन पहले फ़ाइल पढ़ना सीखते हैं। एक सरल कमांड जिसका उपयोग करना है, वह है cat कमांड, जिसे concatenate के लिए छोटा किया गया है, यह न केवल फ़ाइल की सामग्री प्रदर्शित करता है बल्कि यह कई फ़ाइलों को मिला सकता है और आपको उनका आउटपुट दिखा सकता है।\n\n<pre>$ cat dogfile birdfile</pre>\n\nयह बड़ी फ़ाइलें देखने के लिए अच्छा नहीं है और यह केवल छोटी सामग्री के लिए है। हम बड़े पाठ फ़ाइलें देखने के लिए कई अन्य उपकरण हैं जिनका हम अगले पाठ में चर्चा करेंगे।",
          "quizAnswer": "cat",
          "quizQuestion": "एक फ़ाइल की सामग्री देखने का एक अच्छा तरीका क्या है?",
          "slug": "catcommand",
          "title": "बिल्ली"
        },
        {
          "exercise": "एक फ़ाइल पर कम चलाएं, फिर पेज अप और फ़ाइल के चारों ओर नेविगेट करें। किसी विशिष्ट शब्द की खोज करने की कोशिश करें। तेजी से फ़ाइल की शुरुआत या अंत में नेविगेट करें।",
          "id": 8,
          "lessonContent": "यदि आप एक साधारण आउटपुट से अधिक बड़े पाठ फ़ाइलों को देख रहे हैं, तो कम अधिक है। (वास्तव में एक ऐसा कमांड है जिसे ज्यादा कहा जाता है, जो कुछ ऐसा ही करता है, इसलिए यह विडंबना है)। पाठ पेज़ में प्रदर्शित किया जाता है, इसलिए आप पृष्ठ द्वारा पृष्ठ फ़ाइल में नेविगेट कर सकते हैं।\n\nएक फ़ाइल के साथ कम की सामग्री देखें। एक बार जब आप कम कमांड में होंगे, तो आप वास्तव में फ़ाइल में नेविगेट करने के लिए अन्य कीबोर्ड कमांड का उपयोग कर सकते हैं।\n\n<pre>$ कम /home/pete/Documents/text1</pre>\n\nकम के माध्यम से नेविगेट करने के लिए निम्नलिखित कमांड का उपयोग करें:\n\n<ul>\n<li>q - कम से बाहर निकलने और अपने शैली में वापस जाने के लिए उपयोग किया जाता है।</li>\n<li>पेज अप, पेज डाउन, ऊपर और नीचे - एरो कुंजी और पेज कुंजी का उपयोग करके नेविगेट करें।</li>\n<li>g - पाठ फ़ाइल की शुरुआत में जाता है।</li>\n<li>G - पाठ फ़ाइल के अंत में जाता है।</li>\n<li>/खोज - आप पाठ दस्तावेज़ के भीतर विशिष्ट पाठ की खोज कर सकते हैं। जिन शब्दों की आप खोज करना चाहते हैं, उनके पहले / के साथ।</li>\n<li>h - यदि आप कम का उपयोग करते समय कम कैसे करें इसके बारे में थोड़ी मदद चाहिए, तो मदद का उपयोग करें।</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "कैसे आप कम कमांड से बाहर निकल सकते हैं?",
          "slug": "कमकमांड",
          "title": "कम"
        },
        {
          "exercise": "ऊपर और नीचे कुंजियों के साथ अपने पिछले कमांड इतिहास में नेविगेट करें। ctrl-R रिवर्स सर्च के साथ खेलें।",
          "id": 9,
          "lessonContent": "आपके शैल में, उन कमांडों का इतिहास है जो आपने पहले दर्ज किए थे, आप वास्तव में इन कमांडों को देख सकते हैं। जब आप पहले से इस्तेमाल किए गए कमांड को खोजना और चलाना चाहते हैं तो यह काफी उपयोगी है बिना इसे फिर से टाइप किए।\n\n<pre>$ history</pre>\n\nपिछले कमांड को चलाना चाहते हैं, तो बस ऊपर की तीर को मारें।\n\nपिछले कमांड को फिर से टाइप किए बिना चलाना चाहते हैं? !! का उपयोग करें। यदि आपने cat file1 टाइप किया और इसे फिर से चलाना चाहते हैं, तो आप वास्तव में बस !! जा सकते हैं और यह आपके द्वारा चलाए गए अंतिम कमांड को चलाएगा।\n\nएक और इतिहास शॉर्टकट ctrl-R है, यह रिवर्स सर्च कमांड है, यदि आप ctrl-R दबाते हैं और आप उस कमांड के हिस्से टाइप करना शुरू करते हैं जिसे आप चाहते हैं, तो यह आपको मिलेगा और आप उन्हें ctrl-R कुंजी फिर से दबाकर उनमें नेविगेट कर सकते हैं। एक बार जब आप फिर से उपयोग करना चाहते हैं, तो बस Enter कुंजी दबाएं।\n\nहमारा टर्मिनल थोड़ा भीड़ हो रहा है ना? चलो थोड़ा साफ़ करें, अपनी डिस्प्ले को साफ करने के लिए clear कमांड का उपयोग करें।\n\n<pre>$ clear</pre>\n\nवहाँ अब बेहतर दिख रहा है ना? \n\nहम उपयोगी चीजों के बारे में बात कर रहे हैं, किसी भी कमांड-लाइन वातावरण में सबसे उपयोगी सुविधाओं में से एक टैब पूर्णता है। यदि आप किसी कमांड, फ़ाइल, निर्देशिका, आदि के शुरुआत टाइप करना शुरू करते हैं और Tab कुंजी दबाते हैं, तो यह आपके द्वारा खोजे गए निर्देशिका में क्या पाता है के आधार पर पूर्ण करेगा। जब तक उन अक्षरों से शुरू होने वाली किसी अन्य फ़ाइल न हो। उदाहरण के लिए यदि आप कमांड chrome चलाने की कोशिश कर रहे हैं, तो आप chr टाइप कर सकते हैं और टैब दबा सकते हैं और यह chrome को पूर्ण करेगा।",
          "quizAnswer": "clear",
          "quizQuestion": "टर्मिनल को साफ करने का कमांड क्या है?",
          "slug": "historycommand",
          "title": "इतिहास"
        },
        {
          "exercise": "कुछ फ़ाइलें कॉपी करें, ध्यान रखें कि कोई महत्वपूर्ण चीज़ ओवरराइट न हो जाए।",
          "id": 10,
          "lessonContent": "चलो इन फ़ाइलों की कुछ प्रतियां बनाना शुरू करते हैं। फ़ाइलें कॉपी और पेस्ट करने की तरह, शैल ने हमें इसे करने का एक और आसान तरीका दिया है।\n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile वह फ़ाइल है जिसे आप कॉपी करना चाहते हैं और /home/pete/Documents/cooldocs वहाँ है जहाँ आप फ़ाइल को कॉपी कर रहे हैं।\n\nआप मल्टीपल फ़ाइलें और निर्देशिकाएँ कॉपी कर सकते हैं साथ ही वाइल्डकार्ड का उपयोग कर सकते हैं। वाइल्डकार्ड एक वर्ण है जो एक पैटर्न आधारित चयन के लिए प्रतिस्थापन किया जा सकता है, जो आपको खोजों के साथ अधिक लचीलाई देता है। आप हर कमांड में वाइल्डकार्ड का उपयोग कर सकते हैं।\n\n<ul>\n<li>* वाइल्डकार्ड का वाइल्डकार्ड, यह एकल वर्णों या किसी भी स्ट्रिंग को प्रतिष्ठापित करने के लिए उपयोग किया जाता है।</li>\n<li>? एक वर्ण को प्रतिष्ठापित करने के लिए उपयोग किया जाता है</li>\n<li>[] इसका प्रतिनिधित्व करने के लिए उपयोग किया जाता है ब्रैकेट्स के भीतर किसी भी वर्ण का</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nयह आपके वर्तमान निर्देशिका में .jpg एक्सटेंशन वाली सभी फ़ाइलें चित्रों निर्देशिका में कॉपी करेगा।\n\nएक उपयोगी कमांड है -r फ्लैग का उपयोग करना, यह फ़ाइलें और निर्देशिकाएँ एक निर्देशिका के भीतर रूप से कॉपी करेगा।\n\nकोशिश करें कि आप अपने दस्तावेज़ निर्देशिका में कुछ फ़ाइलें कॉपी करें। काम नहीं किया ना? अच्छा, इसलिए आपको -r कमांड के साथ उसके भीतर की फ़ाइलें और निर्देशिकाएँ भी कॉपी करनी होगी।\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nएक बात ध्यान देने योग्य है, अगर आप एक फ़ाइल को एक निर्देशिका में कॉपी करते हैं जिसमें एक ही नाम है, तो फ़ाइल को आप जो कुछ भी कॉपी कर रहे हैं उससे ओवरराइट कर दिया जाएगा। यह अच्छा नहीं है अगर आपके पास एक फ़ाइल है जिसे आप गलती से ओवरराइट करना नहीं चाहते। आप -i फ्लैग (इंटरैक्टिव) का उपयोग कर सकते हैं जो आपको फ़ाइल को ओवरराइट करने से पहले पूछेगा।\n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "निर्देशिका को कॉपी करने के लिए आपको कौन सा फ्लैग निर्दिष्ट करना चाहिए?",
          "slug": "copycpcommand",
          "title": "कॉपी (Copy)"
        },
        {
          "exercise": "एक फ़ाइल का नाम बदलें, फिर उस फ़ाइल को एक अलग निर्देशिका में हटाएँ।",
          "id": 11,
          "lessonContent": "फ़ाइलें हटाने और उन्हें नाम देने के लिए उपयोग किया जाता है। झंझट और कार्यक्षमता के मामले में cp कमांड के बराबर है। \n\nआप फ़ाइलों का नाम बदल सकते हैं इस प्रकार से:\n\n<pre>$ mv oldfile newfile</pre>\n\nया आप वास्तव में एक फ़ाइल को एक अलग निर्देशिका में हटा सकते हैं: \n\n<pre>$ mv file2 /home/pete/Documents</pre>\n\nऔर एक से अधिक फ़ाइल को हटा सकते हैं:\n\n<pre>$ mv file_1 file_2 /somedirectory</pre>\n\nआप निर्देशिकाओं का भी नाम बदल सकते हैं:\n\n<pre>$ mv directory1 directory2</pre>\n\ncp की तरह, अगर आप किसी फ़ाइल या निर्देशिका को mv करते हैं तो यह उसी निर्देशिका में कुछ भी अधिलिखित कर देगा। इसलिए आप -i फ़्लैग का उपयोग कर सकते हैं जिससे कि कुछ अधिलिखित करने से पहले आपको पूछा जाए।\n\n<pre>mv -i directory1 directory2</pre>\n\nयहाँ मान लें कि आप वास्तव में एक फ़ाइल को पुरानी फ़ाइल को अधिलिखित करना चाहते थे। आप उस फ़ाइल का बैकअप बना सकते हैं और यह बस पुराने संस्करण का नाम बदल देगा ~ के साथ। \n\n<pre>$ mv -b directory1 directory2</pre>",
          "quizAnswer": "mv cat dog",
          "quizQuestion": "आप कैसे एक फ़ाइल का नाम cat से dog में बदलते हैं?",
          "slug": "movemvcommand",
          "title": "mv (हटाएँ)"
        },
        {
          "exercise": "कुछ निर्देशिकाएँ बनाएं और कुछ फ़ाइलें उस निर्देशिका में ले जाएं।",
          "id": 12,
          "lessonContent": "हमें इन सभी फ़ाइलों को संग्रहित करने के लिए कुछ निर्देशिकाएँ चाहिए होंगी। mkdir कमांड (निर्माण निर्देशिका) उसके लिए उपयोगी है, यह एक निर्देशिका बनाएगा अगर यह पहले से मौजूद नहीं है। आप एक ही समय में कई निर्देशिकाएँ भी बना सकते हैं।\n\n<pre>$ mkdir books paintings</pre>\n\nआप -p (माता झंडा) के साथ एक ही समय में उपनिर्देशिकाएँ भी बना सकते हैं।\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "निर्देशिका बनाने के लिए कौन सा कमांड उपयोग किया जाता है?",
          "slug": "nirman-nirdeshikamkdircommand",
          "title": "mkdir (निर्माण निर्देशिका)"
        },
        {
          "exercise": "<ol>\n<li>-फ़ाइल नाम की एक फ़ाइल बनाएं (डैश न भूलें!)।</li>\n<li>उस फ़ाइल को हटाएं।</li>\n</ol>",
          "id": 13,
          "lessonContent": "अब मुझे लगता है कि हमारे पास बहुत सारे फ़ाइलें हैं, चलो कुछ फ़ाइलें हटा देते हैं। फ़ाइलें हटाने के लिए आप rm कमांड का उपयोग कर सकते हैं। rm (रिमूव) कमांड का उपयोग फ़ाइलें और निर्देशिकाएँ हटाने के लिए किया जाता है। \n\n<pre>$ rm फ़ाइल1</pre>\n\nrm का उपयोग करते समय सावधानी बरतें, ऐसा कोई जादुई कड़ाक़ नहीं है जिससे आप हटाई गई फ़ाइलें वापस ले सकें। एक बार जब वे चले गए हैं, तो वे हमेशा के लिए चले गए हैं, इसलिए सावधान रहें। \n\nभाग्यवश, कुछ सुरक्षा उपाय लागू किए गए हैं, ताकि सामान्य व्यक्ति बस इम्पॉर्टेंट फ़ाइलें हटा न सकें। राइट-प्रोटेक्टेड फ़ाइलें आपसे पुष्टि मांगेंगी पहले जब उन्हें हटाने के लिए। यदि कोई निर्देशिका राइट-प्रोटेक्टेड है तो उसे भी आसानी से हटाया नहीं जा सकता। \n\nअब यदि आपको उससे कोई फ़र्क नहीं पड़ता, तो आप बिल्कुल कई फ़ाइलें हटा सकते हैं। \n\n<pre>$ rm -f फ़ाइल1</pre>\n\n-f या फोर्स विकल्प rm को सभी फ़ाइलें हटाने के लिए कहता है, चाहे वे राइट-प्रोटेक्टेड हों या न हों, उपयोगकर्ता को पुष्टि के बिना (जब तक आपके पास उपयुक्त अनुमतियाँ हों) हटा देने के लिए।\n\n<pre>$ rm -i फ़ाइल</pre>\n\nअन्य कई कमांडों की तरह -i फ्लैग जोड़ने से आपको एक प्रॉम्प्ट मिलेगा कि क्या आप वास्तव में फ़ाइलें या निर्देशिकाएँ हटाना चाहते हैं। \n\n<pre>$ rm -r निर्देशिका</pre>\n\nआप सिर्फ़ डिफ़ॉल्ट रूप से एक निर्देशिका को rm नहीं कर सकते, आपको सभी फ़ाइलें और उसके सभी उपनिर्देशिकाएँ हटाने के लिए -r फ्लैग (रिकर्सिव) जोड़ना होगा।\n\nआप rmdir कमांड के साथ एक निर्देशिका हटा सकते हैं।\n\n<pre>$ rmdir निर्देशिका</pre>",
          "quizAnswer": "",
          "quizQuestion": "मेरीफ़ाइल नाम की एक फ़ाइल कैसे हटाएं?",
          "slug": "removermcommand",
          "title": "रिमूव (Remove)"
        },
        {
          "exercise": "<ol>\n<li>मूल निर्देशिका से एक फ़ाइल खोजें जिसमें नेट शब्द है।</li>\n</ol>",
          "id": 14,
          "lessonContent": "सभी इन फ़ाइलों के साथ जब हम सिस्टम पर रखते हैं तो किसी विशेष फ़ाइल को खोजने में थोड़ी गड़बड़ी हो सकती है। अच्छा, उसके लिए हम एक कमांड का उपयोग कर सकते हैं, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nFind के साथ आपको उस निर्देशिका को निर्दिष्ट करना होगा जिसे आप खोज रहे हैं, जिसे आप खोज रहे हैं, इस मामले में हम puppies.jpg नाम की एक फ़ाइल ढूंढने की कोशिश कर रहे हैं। \n\nआप यह भी निर्दिष्ट कर सकते हैं कि आप किस प्रकार की फ़ाइल ढूंढने की कोशिश कर रहे हैं। \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nआप देख सकते हैं कि मैंने जिस प्रकार की फ़ाइल ढूंढने की कोशिश की है, उसे (d) के लिए निर्धारित किया है और मैं अभी भी MyFolder नाम से खोज रहा हूँ। \n\nएक बढ़िया बात यह है कि find उस निर्देशिका पर रुकने की जरूरत नहीं है जिसे आप खोज रहे हैं, यह उस निर्देशिका के किसी भी उप-निर्देशिकाओं में भी देखेगा।",
          "quizAnswer": "-name",
          "quizQuestion": "अगर मैं नाम से खोजना चाहता हूँ तो find के लिए मैं कौन सा विकल्प निर्दिष्ट करूँ?",
          "slug": "findcommand",
          "title": "खोजें"
        },
        {
          "exercise": "इको कमांड, लॉगआउट कमांड और पीडब्ल्यूडी कमांड पर सहायता चलाएं।",
          "id": 15,
          "lessonContent": "लिनक्स में कुछ शानदार इनबिल्ट-इन उपकरण हैं जो आपको यह बताने में मदद करते हैं कि आप किसी कमांड का उपयोग कैसे करें या किसी कमांड के लिए क्या फ्लैग उपलब्ध हैं। एक उपकरण, सहायता, एक इनबिल्ट-इन बैश कमांड है जो अन्य बैश कमांडों (एको, लॉगआउट, पीडब्ल्यूडी, आदि) के लिए सहायता प्रदान करता है।\n\n<pre>$ help echo</pre>\n\nयह आपको एक विवरण और विकल्प देगा जिन्हें आप जब आप इको चलाना चाहते हैं तो उपयोग कर सकते हैं। अन्य एक्सीक्यूटेबल प्रोग्रामों के लिए, एक विकल्प जिसे --help या कुछ इसी तरह का कहा जाता है, एक संवेदनशीलता है।\n\n<pre>$ echo --help</pre>\n\nउन सभी डेवलपर्स के लिए जो एक्सीक्यूटेबल्स शिप करते हैं, इस मानक का पालन नहीं करेंगे, लेकिन यह शायद आपके लिए किसी प्रोग्राम पर कुछ सहायता प्राप्त करने का सबसे अच्छा तरीका है।",
          "quizAnswer": "सहायता",
          "quizQuestion": "इनबिल्ट-इन बैश कमांडों के लिए त्वरित कमांड लाइन सहायता कैसे प्राप्त करें?",
          "slug": "helpcommand",
          "title": "सहायता"
        },
        {
          "exercise": "ls कमांड पर मैन कमांड चलाएं।",
          "id": 16,
          "lessonContent": "जी मुझे इन कुछ कार्यक्रमों के बारे में अधिक जानकारी देखने के लिए कुछ मैनुअल होते तो अच्छा होता। भाग्य से वे हैं! उचित नामकित मैन पेज, आप मैन कमांड के साथ किसी कमांड के मैनुअल देख सकते हैं।\n\n<pre>$ man ls</pre>\n\nमैन पेज वे मैनुअल हैं जो अधिकांश लिनक्स ऑपरेटिंग सिस्टम में डिफ़ॉल्ट रूप से शामिल होते हैं। वे कमांड्स और सिस्टम के अन्य पहलुओं के बारे में दस्तावेज़ प्रदान करते हैं।\n\nइन पर कुछ कमांडों पर इसे आजमाएं और उनके बारे में अधिक जानकारी प्राप्त करें।",
          "quizAnswer": "man",
          "quizQuestion": "किस प्रकार आप किसी कमांड के मैनुअल देखते हैं?",
          "slug": "mancommand",
          "title": "आदमी"
        },
        {
          "exercise": "less कमांड पर whatis कमांड चलाएं।",
          "id": 17,
          "lessonContent": "फ्यू, हमने अब तक कई कमांड सीख ली हैं, अगर कभी भी आपको किसी कमांड के बारे में संदेह हो रहा है, तो आप whatis कमांड का उपयोग कर सकते हैं। whatis कमांड कमांड लाइन प्रोग्रामों का संक्षिप्त विवरण प्रदान करता है।\n\n<pre>$ whatis cat</pre>\n\nविवरण प्रत्येक कमांड के मैनुअल पेज से लिया जाता है। यदि आपने whatis cat चलाया, तो आपको एक छोटा सा वर्णन दिखाई देगा।",
          "quizAnswer": "whatis",
          "quizQuestion": "किस कमांड का उपयोग करके आप किसी कमांड का एक छोटा विवरण देख सकते हैं?",
          "slug": "whatiscommand",
          "title": "क्या है"
        },
        {
          "exercise": "कुछ उपनाम बनाएं और फिर उन्हें हटाएं।",
          "id": 18,
          "lessonContent": "कभी-कभी कमांड टाइप करना वास्तव में बार-बार हो सकता है, या यदि आपको बार-बार एक लंबी कमांड टाइप करनी हो, तो उसके लिए एक उपनाम बनाना बेहतर है। किसी कमांड के लिए एक उपनाम बनाने के लिए आप बस एक उपनाम नाम निर्दिष्ट करें और उसे कमांड के लिए सेट करें।\n\n<pre>$ उपनाम फूबार = 'ls -la'</pre>\n\nअब ls -la टाइप करने की बजाय, आप फूबार टाइप कर सकते हैं और यह कमांड चलाएगा, काफी अच्छी चीज़ है। ध्यान रखें कि यह कमांड आपके उपनाम को बूट के बाद सहेजने वाला नहीं है, इसलिए आपको एक स्थायी उपनाम जोड़ने की आवश्यकता होगी:\n\n<pre>~/.bashrc</pre>\n\nया इसी तरह के फ़ाइलों में जोड़ना चाहेंगे अगर आप इसे बूट के बाद स्थायी रखना चाहते हैं।\n\nआप उपनाम को अनउपनाम कमांड के साथ हटा सकते हैं:\n\n<pre>$ अनउपनाम फूबार</pre>",
          "quizAnswer": "उपनाम",
          "quizQuestion": "उपनाम बनाने के लिए कौन सा कमांड उपयोग किया जाता है?",
          "slug": "उपनामकमांड",
          "title": "उपनाम"
        },
        {
          "exercise": "शैल से बाहर निकलें और देखें क्या होता है। सुनिश्चित करें कि आपको उस शैल में और कोई काम नहीं करना है।",
          "id": 19,
          "lessonContent": "अच्छा, आपने मूल बातों से गुजरने में अच्छा काम किया। हमने सिर्फ सतह को छू लिया है, अब जब आपने रोंगना सीख लिया है, तो अगले सेट के पाठ्यक्रम में, मैं आपको चलना सिखाऊंगा। \n\nअब तक, आप अपनी पीठ पर हाथ फेर सकते हैं और एक ब्रेक ले सकते हैं। शैल से बाहर निकलने के लिए, आप exit कमांड का उपयोग कर सकते हैं\n\n<pre>$ exit</pre>\n\nया logout कमांड का उपयोग करें:\n\n<pre>$ logout</pre>\n\nया अगर आप टर्मिनल GUI से काम कर रहे हैं, तो आप सिर्फ टर्मिनल बंद कर सकते हैं, अगले कोर्स में मिलेंगे!",
          "quizAnswer": "exit",
          "quizQuestion": "आप शैल से कैसे बाहर निकल सकते हैं?",
          "slug": "exitcommand",
          "title": "निकास"
        }
      ],
      "slug": "commandline",
      "title": "कमांड लाइन"
    },
    {
      "description": "मूल टेक्स्ट परिवर्तन और नेविगेशन सीखें।",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "कुछ कमांड का प्रयास करें: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hello World > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "अब तक, हमने कई कमांड्स और उनके आउटपुट के साथ परिचित हो गए हैं और यह हमें हमारे अगले विषय I/O (इनपुट/आउटपुट) स्ट्रीम्स तक पहुंचाता है। चलिए निम्नलिखित कमांड चलाएं और हम देखेंगे कि यह कैसे काम करता है। \n\n<pre>$ echo Hello World > peanuts.txt</pre>\n\nक्या हुआ था? अच्छा, उस डायरेक्टरी की जांच करें जहां आपने उस कमांड को चलाया था और देखें आपको एक फ़ाइल नामक peanuts.txt दिखाई देगी, उस फ़ाइल में जाएं और आपको पास में Hello World टेक्स्ट दिखाई देना चाहिए। एक कमांड में बहुत सारी चीजें हो गईं हैं, इसलिए चलिए इसे टूट दें। \n\nसबसे पहले हम पहला हिस्सा टूटें: \n\n<pre>$ echo Hello World</pre>\n\nहम जानते हैं कि यह स्क्रीन पर Hello World प्रिंट करता है, लेकिन कैसे? प्रक्रियाएँ I/O स्ट्रीम्स का उपयोग इनपुट प्राप्त करने और आउटपुट वापस देने के लिए करती हैं। डिफ़ॉल्ट रूप से एको कमांड की इनपुट (स्टैंडर्ड इनपुट या stdin) कीबोर्ड से लेता है और आउटपुट (स्टैंडर्ड आउटपुट या stdout) स्क्रीन पर वापस देता है। इसलिए जब आप अपने शैल में echo Hello World टाइप करते हैं, तो आपको स्क्रीन पर Hello World मिलता है। हालांकि, I/O पुनर्निर्देशन हमें इस डिफ़ॉल्ट व्यवहार को बदलने की अनुमति देता है जिससे हमें अधिक फ़ाइल लचीलाई मिलती है। \n\nआइए कमांड के अगले हिस्से पर बढ़ते हैं: \n\n<pre> > </pre>\n\n> एक पुनर्निर्देशन ऑपरेटर है जो हमें स्टैंडर्ड आउटपुट को कहां भेजने की अनुमति देता है। यह हमें echo Hello World का आउटपुट एक फ़ाइल में स्क्रीन के बजाय भेजने की अनुमति देता है। यदि फ़ाइल पहले से मौजूद नहीं है तो यह हमारे लिए उसे बना देगा। हालांकि, यदि यह मौजूद है तो यह उसे अधिलेखित कर देगा (आप एक शैल फ़्लैग जोड़ सकते हैं जो इसे रोकने के लिए आपके उपयोग के शैल पर निर्भर करता है)।\n\nऔर यही बुनियादी रूप से कैसे stdout पुनर्निर्देशन काम करता है!\n\nचलो मान लो कि मुझे अपनी peanuts.txt को अधिलेखित नहीं करना चाहिए था, भाग्य से उसके लिए एक पुनर्निर्देशन ऑपरेटर है, >>: \n\n<pre>$ echo Hello World >> peanuts.txt</pre>\n\nयह peanuts.txt फ़ाइल के अंत में Hello World को जोड़ देगा, यदि फ़ाइल पहले से मौजूद नहीं है तो यह हमारे लिए उसे बना देगा जैसे यह > पुनर्निर्देशक के साथ किया था!",
          "quizAnswer": ">>",
          "quizQuestion": "आप किस प्रकार के पुनर्निर्देशक का उपयोग करते हैं जिससे आउटपुट को फ़ाइल में जोड़ा जा सके?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (स्टैंडर्ड आउट)"
        },
        {
          "exercise": "कुछ कमांड का प्रयोग करें:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "हमारे पिछले पाठ में हमने सीखा कि हमें उपयोग करने के लिए विभिन्न stdout स्ट्रीम हैं, जैसे एक फ़ाइल या स्क्रीन। वैसे ही हमें उपयोग करने के लिए विभिन्न मानक इनपुट (stdin) स्ट्रीम भी हैं। हमें पता है कि हमें कीबोर्ड जैसे उपकरणों से stdin है, लेकिन हम फ़ाइलें, अन्य प्रक्रियाओं से आउटपुट और टर्मिनल भी उपयोग कर सकते हैं, चलिए एक उदाहरण देखते हैं। \n\nपिछले पाठ में हम इस उदाहरण के लिए peanuts.txt फ़ाइल का उपयोग करेंगे, याद रखें कि इसमें Hello World टेक्स्ट था। \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nहमें stdout रीडायरेक्शन के लिए <b>&gt;</b> की तरह ही stdin रीडायरेक्शन के लिए <b>&lt;</b> का उपयोग कर सकते हैं। \n\nसामान्यत: cat कमांड में, आप उसके लिए एक फ़ाइल भेजते हैं और उस फ़ाइल stdin बन जाती है, इस मामले में, हमने peanuts.txt को हमारा stdin रीडायरेक्ट किया। फिर cat peanuts.txt का आउटपुट जो कि Hello World होगा, उसे एक और फ़ाइल जिसे banana.txt कहा जाता है में रीडायरेक्ट किया जाता है।",
          "quizAnswer": "<",
          "quizQuestion": "आप stdin को रीडायरेक्ट करने के लिए कौन सा रीडायरेक्टर प्रयोग करते हैं?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (स्टैंडर्ड इन)"
        },
        {
          "exercise": "निम्नलिखित कमांड क्या कर रहा है? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "अब कुछ थोड़ा अलग करने की कोशिश करते हैं, अब आपके सिस्टम पर मौजूद नहीं होने वाले एक निर्देशिका की सामग्री को सूचीबद्ध करने की कोशिश करते हैं और फिर से आउटपुट को peanuts.txt फ़ाइल में रीडायरेक्ट करने के लिए।\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nआपको क्या दिखना चाहिए: \n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nअब आप शायद सोच रहे होंगे, क्या वह संदेश फ़ाइल में भेज दिया जाना चाहिए था? यहाँ वास्तव में एक और I/O स्ट्रीम है जिसे स्टैंडर्ड त्रुटि (stderr) कहा जाता है। डिफ़ॉल्ट रूप से, stderr भी अपना आउटपुट स्क्रीन पर भेजता है, यह stdout से पूरी तरह से भिन्न स्ट्रीम है। इसलिए आपको इसका आउटपुट एक अलग तरीके से रीडायरेक्ट करना होगा। \n\nदुर्भाग्यवश रीडायरेक्टर <b>&lt;</b> या <b>&gt;</b> का इस्तेमाल करने की तरह अच्छा नहीं है लेकिन यह काफी करीब है। हमें फाइल डिस्क्रिप्टर का उपयोग करना होगा। फाइल डिस्क्रिप्टर एक ऐसा गैर-नकारात्मक संख्या है जिसका उपयोग एक फ़ाइल या स्ट्रीम तक पहुँचने के लिए किया जाता है। हम इसके बारे में विस्तार से बात करेंगे, लेकिन अब यह जान लें कि stdin, stdout और stderr के लिए फाइल डिस्क्रिप्टर क्रमशः 0, 1, और 2 है। \n\nइसलिए अब अगर हम अपनी stderr को फ़ाइल में रीडायरेक्ट करना चाहते हैं तो हम यह कर सकते हैं: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nआपको केवल stderr संदेश peanuts.txt में दिखना चाहिए। \n\nअब अगर मैं चाहता हूँ कि मैं peanuts.txt फ़ाइल में stderr और stdout दोनों देखूँ? फाइल डिस्क्रिप्टर के साथ भी यह संभव है: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nयह ls /fake/directory के परिणाम को peanuts.txt फ़ाइल में भेजता है और फिर यह stderr को stdout के माध्यम से 2>&1 पर रीडायरेक्ट करता है। यहाँ क्रियाओं का क्रम मायने रखता है, 2>&1 stderr को वहाँ भेजता है जहाँ stdout की दिशा है। इस मामले में stdout एक फ़ाइल की दिशा में है, इसलिए 2>&1 stderr को भी एक फ़ाइल में भेजता है। इसलिए अगर आप उस peanuts.txt फ़ाइल को खोलते हैं तो आपको stderr और stdout दोनों दिखने चाहिए। हमारे मामले में, उपरोक्त कमांड केवल stderr को आउटपुट करता है।\n\nstderr और stdout दोनों को एक फ़ाइल में रीडायरेक्ट करने का एक छोटा तरीका है:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nअब अगर मुझे उस सारी कचरे को नहीं चाहिए और मैं stderr संदेशों को पूरी तरह से हटाना चाहता हूँ? तो आप आउटपुट को एक विशेष फ़ाइल /dev/null पर रीडायरेक्ट कर सकते हैं और यह किसी भी इनपुट को खारिज कर देगा।\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "stderr के लिए रीडायरेक्टर क्या है?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (स्टैंडर्ड त्रुटि)"
        },
        {
          "exercise": "निम्नलिखित कमांड का प्रयास करें: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "चलो कुछ प्लंबिंग में आते हैं, नाकि वास्तव में लेकिन किंवदंती. चलो एक कमांड त्राय करते हैं: \n\n<pre>$ ls -la /etc</pre>\n\nआपको एक बहुत लंबी सूची दिखनी चाहिए, यह थोड़ा मुश्किल है वास्तव में पढ़ने में। इस आउटपुट को एक फ़ाइल में रीडायरेक्ट करने की बजाय, क्या हमें यह अच्छा नहीं लगेगा अगर हम इस आउटपुट को एक और कमांड में देख सकें जैसे कि कम? वेल हम कर सकते हैं! \n\n<pre>$ ls -la /etc | less </pre>\n\nपाइप ऑपरेटर |, जो एक लंबी बार से प्रतिनिधित है, हमें किसी कमांड की stdout लेने देता है और उसे एक अन्य प्रक्रिया के stdin बनाता है। इस मामले में, हमने ls -la /etc की stdout ली और फिर इसे कमांड को कम किया। पाइप कमांड अत्यंत उपयोगी है और हम इसे सदा के लिए उपयोग करेंगे। \n\nअगर मैं अपने कमांड की आउटपुट को दो विभिन्न स्ट्रीम में लिखना चाहता हूँ तो? यह संभव है टी कमांड के साथ: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nआपको अपनी स्क्रीन पर ls की आउटपुट दिखाई देनी चाहिए और अगर आप peanuts.txt फ़ाइल खोलते हैं तो आपको वही जानकारी दिखनी चाहिए!",
          "quizAnswer": "|",
          "quizQuestion": "पाइप ऑपरेटर किस कुंजी को प्रतिनिधित करता है?",
          "slug": "pipeteeredirect",
          "title": "पाइप और टी"
        },
        {
          "exercise": "निम्नलिखित आउटपुट क्या है? क्यों?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "निम्नलिखित कमांड चलाएं: \n\n<pre>$ echo $HOME</pre>\n\nआपको अपने होम डायरेक्टरी का पथ दिखाई देना चाहिए, मेरा पथ /home/pete जैसा दिखता है। \n\nइस कमांड के बारे में क्या है? \n\n<pre>$ echo $USER </pre>\n\nआपको अपना उपयोगकर्ता नाम दिखना चाहिए!\n\nयह जानकारी कहाँ से आ रही है? यह आपके वातावरणीय चरों से आ रही है। आप इन्हें देख सकते हैं इस तरह से टाइप करके\n\n<pre>$ env </pre>\n\nयह आपके वर्तमान में सेट किए गए वातावरणीय चरों के बारे में बहुत सारी जानकारी आउटपुट करता है। ये चर उपयोगी जानकारी रखते हैं जिसका शैल और अन्य प्रक्रियाएँ उपयोग कर सकती हैं।\n\nयहाँ एक छोटा उदाहरण है:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nएक विशेष रूप से महत्वपूर्ण चर है PATH चर। आप इन चरों तक पहुंच सकते हैं इन चरों के नाम के आगे $ लगाकर जैसे कि निम्नलिखित:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nयह एक तार के द्वारा विभाजित पथों की सूची लौटाता है जिसे आपका सिस्टम जब एक कमांड चलाता है तो खोजता है। मान लीजिए आपने इंटरनेट से मैन्युअल डाउनलोड और इंस्टॉल किया है और उसे एक गैर मानक निर्देशिका में डाल दिया है और उस कमांड को चलाना चाहते हैं, तो आप $ coolcommand टाइप करते हैं और प्रॉम्प्ट कहता है कि कमांड नहीं मिला। वह बेवकूफ है आप एक फोल्डर में बाइनरी देख रहे हैं और जानते हैं कि यह मौजूद है। जो हो रहा है वह $PATH चर उस डायरेक्टरी को इस बाइनरी के लिए नहीं चेक करता है इसलिए यह एक त्रुटि फेंक रहा है। \n\nमान लीजिए आपके पास उस डायरेक्टरी से चलाने के लिए बहुत सारी बाइनरी होती हैं, तो आप बस PATH चर को संशोधित कर सकते हैं उस डायरेक्टरी को अपने PATH वातावरणीय चर में शामिल करने के लिए।",
          "quizAnswer": "env",
          "quizQuestion": "आप अपने वातावरणीय चर कैसे देख सकते हैं?",
          "slug": "envenvironment",
          "title": "वातावरण (Environment)"
        },
        {
          "exercise": "निम्नलिखित कमांड क्या करता है? क्यों?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "हम कुछ उपयोगी कमांड सीखेंगे जिन्हें आप पाठ को प्रसंसोधित करने के लिए उपयोग कर सकते हैं। शुरू होने से पहले, एक फ़ाइल बनाएंगे जिस पर हम काम करेंगे। निम्नलिखित कमांड कॉपी और पेस्ट करें, जब आप ऐसा करें तो lazy और dog के बीच एक टैब जोड़ें (Ctrl-v + TAB दबाएं)।\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nहम पहली कमांड के बारे में सीखेंगे कट कमांड। यह एक फ़ाइल से पाठ के भागों को निकालता है।\n\nविशेष वर्णों के द्वारा सामग्री निकालने के लिए: \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nयह फ़ाइल की प्रत्येक पंक्ति में 5वां वर्ण उत्पन्न करता है। इस मामले में यह \"q\" है, ध्यान दें कि अंतरिक्ष भी एक वर्ण के रूप में गिना जाता है।\n\nसामग्री को एक क्षेत्र द्वारा निकालने के लिए, हमें थोड़ा संशोधन करना होगा:\n\n<pre>$ cut -f 2 sample.txt</pre>\n\n-एफ या फ़ील्ड ध्वज फ़ील्ड के आधार पर पाठ काटता है, डिफ़ॉल्ट रूप से यह टैब का उपयोग करता है जैसे डिलीमिटर, इसलिए एक टैब द्वारा अलग किया गया हर कुछ एक फ़ील्ड माना जाता है। आपको अपने आउटपुट के रूप में \"dog\" देखना चाहिए।\n\nआप डिलीमिटर ध्वज के साथ फ़ील्ड ध्वज को मिला सकते हैं ताकि आप एक कस्टम डिलीमिटर द्वारा सामग्री निकाल सकें:\n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nयह टैब डिलीमिटर को एक \";\" डिलीमिटर में बदल देगा और क्योंकि हम पहले फ़ील्ड को काट रहे हैं, परिणाम \"The quick brown\" होना चाहिए।",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "एक फ़ाइल में प्रत्येक पंक्ति का पहला वर्ण प्राप्त करने के लिए आप कौन सा कमांड उपयोग करेंगे?",
          "slug": "कटकमांड",
          "title": "कट"
        },
        {
          "exercise": "कोशिश करें कि कई फ़ाइलों को एक साथ पेस्ट करें, क्या होता है?",
          "id": 7,
          "lessonContent": "पेस्ट कमांड कैट कमांड के समान है, यह एक फ़ाइल में लाइनों को एक साथ मिलाता है। निम्नलिखित सामग्री वाली एक नई फ़ाइल बनाएँ: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nआओ सभी इन लाइनों को एक लाइन में मिलाएँ: \n\n<pre>$ paste -s sample2.txt</pre>\n\nपेस्ट के लिए डिफ़ॉल्ट डिलीमिटर TAB है, इसलिए अब एक लाइन है जिसमें हर शब्द को TAB से अलग किया गया है।\n\nआओ इस डिलीमिटर (-d) को कुछ और पढ़ने योग्य बनाएँ: \n\n<pre>$ paste -d ' ' -s sample2.txt</pre>\n\nअब सब कुछ एक लाइन पर होना चाहिए और उसे अंतरित करने के लिए अंतरित किया जाना चाहिए।",
          "quizAnswer": "-s",
          "quizQuestion": "पेस्ट के साथ सब कुछ एक लाइन पर जाने के लिए आप कौन सा फ्लैग उपयोग करते हैं?",
          "slug": "pastecommand",
          "title": "पेस्ट"
        },
        {
          "exercise": "निम्नलिखित कमांड क्या करता है और क्यों? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "चलो मान लेते हैं कि हमारे पास एक बहुत लंबा फ़ाइल है, वास्तव में हमें चुनने के लिए कई हैं, आगे बढ़ें और /var/log/syslog कैट करें। आपको पृष्ठों पर पृष्ठों का पाठ देखना चाहिए। अगर मैं बस इस पाठ फ़ाइल में पहले कुछ पंक्तियाँ देखना चाहता हूँ तो क्या होगा? अच्छा हम इसे हेड कमांड के साथ कर सकते हैं, डिफ़ॉल्ट रूप से हेड कमांड आपको फ़ाइल में पहले 10 पंक्तियाँ दिखाएगा।\n\n<pre>$ head /var/log/syslog</pre>\n\nआप लाइन गणना को जो भी आप चुनें उसे संशोधित कर सकते हैं, चलो मान लेते हैं कि मैं पहले 15 पंक्तियाँ देखना चाहता हूँ।\n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\n-n ध्वज लाइनों की संख्या के लिए है।",
          "quizAnswer": "-n",
          "quizQuestion": "हेड कमांड के लिए आप कितनी पंक्तियाँ देखना चाहेंगे, उसे बदलने के लिए आप कौन सा ध्वज उपयोग करेंगे?",
          "slug": "headcommand",
          "title": "शीर्ष"
        },
        {
          "exercise": "टेल के मैन पेज पर जाएं और हमने नहीं चर्चा किए गए कुछ अन्य कमांड पढ़ें।\n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "हेड कमांड के समान, टेल कमांड आपको डिफ़ॉल्ट रूप से एक फ़ाइल के आखिरी 10 लाइन दिखाने की अनुमति देती है।\n\n<pre>$ tail /var/log/syslog</pre>\n\nहेड के साथ आप देखना चाहते हैं उन लाइनों की संख्या बदल सकते हैं।\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nएक और शानदार विकल्प जिसका उपयोग किया जा सकता है -f (फ़ॉलो) फ्लैग है, यह फ़ाइल को जब वह बढ़ती है तो फ़ॉलो करेगा। इसे एक बार आज़माएं और देखें कि क्या होता है।\n\n<pre>$ tail -f /var/log/syslog</pre>\n\nआपकी syslog फ़ाइल आपके सिस्टम के साथ इंटरैक्ट करते समय निरंतर बदल रही होगी और tail -f का उपयोग करके आप देख सकते हैं कि उस फ़ाइल में क्या जोड़ा जा रहा है।",
          "quizAnswer": "-f",
          "quizQuestion": "टेल में फ़ाइल को फ़ॉलो करने के लिए कौन सा फ्लैग उपयोग किया जाता है?",
          "slug": "tailcommand",
          "title": "खोलना"
        },
        {
          "exercise": "अगर आप केवल कोई फ़ाइल इनपुट के साथ expand लिखते हैं तो क्या होता है?",
          "id": 10,
          "lessonContent": "हमारे कट कमांड पर पाठ में, हमारे पास sample.txt फ़ाइल थी जिसमें एक टैब था। सामान्यत: टैब एक विशेष अंतर दिखाएगा लेकिन कुछ पाठ फ़ाइलें इसे पर्याप्त रूप से नहीं दिखाती हैं। पाठ फ़ाइल में टैब होना वह अंतरिक्ष नहीं है जिसे आप चाहते हैं। अपने टैब को अंतरिक्ष में बदलने के लिए, विस्तार कमांड का उपयोग करें।\n\n<pre>$ expand sample.txt</pre>\n\nऊपर का कमांड प्रत्येक टैब को एक समूह में अंतरिक्ष में परिवर्तित करके आउटपुट प्रिंट करेगा। इस आउटपुट को एक फ़ाइल में सहेजने के लिए, नीचे दिए गए तरह का आउटपुट पुन्निर्देशन का उपयोग करें।\n\n<pre>$ expand sample.txt > result.txt</pre>\n\nविस्तार के विपरीत, हम हर समूह के अंतरिक्ष को एक टैब में वापस परिवर्तित कर सकते हैं unexpand कमांड के साथ: \n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "टैब को अंतरिक्ष में परिवर्तित करने के लिए कौन सा कमांड उपयोग किया जाता है?",
          "slug": "expandunexpandcommand",
          "title": "विस्तार और अनविस्तार"
        },
        {
          "exercise": "दो फ़ाइलों को जोइन करें जिनमें प्रत्येक फ़ाइल में विभिन्न संख्या की पंक्तियाँ हैं, क्या होगा?",
          "id": 11,
          "lessonContent": "ज्वाइन कमांड आपको एक समान क्षेत्र द्वारा कई फ़ाइलों को एक साथ जोड़ने की अनुमति देता है:\n\nचलो मान लो कि मेरे पास दो फ़ाइलें हैं जिन्हें मैं एक साथ जोड़ना चाहता हूँ:\n<pre>file1.txt\n1 जॉन\n2 जेन\n3 मेरी\n\nfile2.txt\n1 डो\n2 डो\n3 स्यू\n\n$ join file1.txt file2.txt\n1 जॉन डो\n2 जेन डो\n3 मेरी स्यू\n</pre>\n\nदेखो कैसे मेरी फ़ाइलों को एक साथ जोड़ दिया गया है? वे डिफ़ॉल्ट रूप से पहले क्षेत्र द्वारा एक साथ जुड़े हुए हैं और क्षेत्रों को एकसमान होना चाहिए, अगर वे नहीं हैं तो आप उन्हें क्रमबद्ध कर सकते हैं, इस मामले में फ़ाइलें 1, 2, 3 के माध्यम से जुड़ी हैं।\n\nहम निम्नलिखित फ़ाइलें कैसे जोइन करेंगे?\n\n<pre>file1.txt\nजॉन 1\nजेन 2\nमेरी 3\n\nfile2.txt\n1 डो\n2 डो\n3 स्यू\n</pre>\n\nइस फ़ाइल को जोइन करने के लिए आपको उन क्षेत्रों को निर्दिष्ट करना होगा जिन्हें आप जोइन कर रहे हैं, इस मामले में हम चाहते हैं कि file1.txt पर क्षेत्र 2 और file2.txt पर क्षेत्र 1 हो, तो कमांड इस तरह दिखेगा:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 जॉन डो\n2 जेन डो\n3 मेरी स्यू\n</pre>\n\n-1 file1.txt को संदर्भित करता है और -2 file2.txt को संदर्भित करता है। काफी अच्छा। आप स्प्लिट कमांड के साथ भी एक फ़ाइल को विभिन्न फ़ाइलों में विभाजित कर सकते हैं:\n\n<pre>$ split कोईफ़ाइल</pre>\n\nइससे यह फ़ाइलों में विभाजित हो जाएगी, डिफ़ॉल्ट रूप से यह उन्हें एक 1000 लाइन सीमा तक विभाजित कर देगा। फ़ाइलें डिफ़ॉल्ट रूप से x** नामित होती हैं।",
          "quizAnswer": "join cat dog cow",
          "quizQuestion": "आप किस कमांड का उपयोग करेंगे ताकि फ़ाइलों को जोइन किया जा सके जिनके नाम cat dog cow हैं?",
          "slug": "joinsplitcommand",
          "title": "जोइन और स्प्लिट"
        },
        {
          "exercise": "क्रमबद्ध की असली ताकत अन्य कमांड्स के साथ मिलाकर उपयोग करने में है, निम्नलिखित कमांड का प्रयास करें और देखें क्या होता है?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "क्रमबद्ध कमांड लाइनों को क्रमबद्ध करने के लिए उपयोगी है।\n\n<pre>\nfile1.txt\ndog\ncow\ncat\nelephant\nbird\n\n$ sort file1.txt\nbird\ncat\ncow\ndog\nelephant\n</pre>\n\nआप एक उल्टा क्रमबद्ध भी कर सकते हैं: \n\n<pre>$ sort -r file1.txt\nelephant\ndog\ncow\ncat\nbird\n</pre>\n\nऔर संख्यात्मक मान के माध्यम से भी क्रमबद्ध कर सकते हैं: \n\n<pre>$ sort -n file1.txt\nbird\ncat\ncow\nelephant\ndog\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "उल्टा क्रमबद्ध करने के लिए आप कौन सा फ्लैग प्रयोग करते हैं?",
          "slug": "sortcommand",
          "title": "क्रमबद्ध"
        },
        {
          "exercise": "निम्नलिखित कमांड को कोशिश करें, क्या होता है?\n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "tr (अनुवाद) कमांड आपको एक सेट के वर्णों को दूसरे सेट के वर्णों में अनुवाद करने की अनुमति देता है। चलिए एक उदाहरण की कोशिश करते हैं, सभी लोअर केस वर्णों को अपरकेस वर्णों में अनुवाद करने की।\n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nजैसा कि आप देख सकते हैं, हमने a-z के रेंज को A-Z में बनाया और हम जो भी पाठ लिखते हैं जो लोअरकेस होता है, उसे अपरकेस में बदल दिया।",
          "quizAnswer": "tr",
          "quizQuestion": "वर्णों का अनुवाद करने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "trtranslatecommand",
          "title": "tr (अनुवाद)"
        },
        {
          "exercise": "यदि आप uniq -uc का प्रयास करते हैं तो आप क्या परिणाम प्राप्त करेंगे?",
          "id": 14,
          "lessonContent": "अद्वितीय (अद्वितीय) कमांड पाठ को पार्स करने के लिए एक और उपयोगी उपकरण है।\n\nमान लीजिए आपके पास एक फ़ाइल है जिसमें कई डुप्लिकेट हैं:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nऔर आप डुप्लिकेट को हटाना चाहते हैं, तो आप अद्वितीय कमांड का उपयोग कर सकते हैं:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nचलिए देखते हैं कि कितनी बार किस पंक्ति का होने का गणना करते हैं:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nकेवल अद्वितीय मान प्राप्त करें:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nकेवल डुप्लिकेट मान प्राप्त करें:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>नोट</b> : अद्वितीय डुप्लिकेट पंक्तियों का पता नहीं लगाता है जब तक वे आसपास न हों। उदाहरण के लिए:\n\nमान लीजिए आपके पास एक फ़ाइल है जिसमें डुप्लिकेट हैं जो आसपास नहीं हैं:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nअद्वितीय द्वारा वापसी किया गया परिणाम सभी प्रविष्टियों को शामिल करेगा जैसा कि पहले उदाहरण में था।\n\nअद्वितीय की इस सीमा को पार करने के लिए हम अद्वितीय के साथ सॉर्ट का उपयोग कर सकते हैं:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "फ़ाइल में डुप्लिकेट हटाने के लिए आप कौन सी कमांड का उपयोग करेंगे?",
          "slug": "अद्वितीयअद्वितीयकमांड",
          "title": "अद्वितीय (Unique)"
        },
        {
          "exercise": "nl फ़ाइल का पूर्ण पंक्तियों की गणना कैसे प्राप्त करेंगे बिना पूरे आउटपुट में खोज करें? संकेत: इस पाठ्यक्रम में सीखे गए अन्य कमांडों का उपयोग करें।",
          "id": 15,
          "lessonContent": "wc (शब्द गणना) कमांड फ़ाइल में शब्दों की कुल गणना दिखाता है।\n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nयह पंक्तियों की संख्या, शब्दों की संख्या और बाइट्स की संख्या को क्रमशः प्रदर्शित करता है।\n\nकिसी विशेष क्षेत्र की केवल गणना देखने के लिए, -l, -w, या -c का प्रयोग करें।\n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nएक और कमांड जिसका उपयोग फ़ाइल पर पंक्तियों की गणना करने के लिए किया जा सकता है, वह है nl (नंबर लाइन्स) कमांड।\n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "फ़ाइल में शब्दों की कुल संख्या और केवल शब्दों को प्राप्त करने के लिए आप कौन सा कमांड प्रयोग करेंगे?",
          "slug": "nlwccommand",
          "title": "wc और nl"
        },
        {
          "exercise": "आपने शायद egrep या fgrep के बारे में सुना हो, ये पुराने ग्रेप कॉल्स हैं और इन्हें ग्रेप -E और ग्रेप -F द्वारा बदल दिया गया है। अधिक जानने के लिए ग्रेप मैनपेज पढ़ें।",
          "id": 16,
          "lessonContent": "ग्रेप कमांड शायद आपका सबसे सामान्य पाठ प्रसंस्करण कमांड हो। यह आपको फ़ाइलों में ऐसे वर्णों के लिए खोजने की अनुमति देता है जो किसी निश्चित पैटर्न से मेल खाते हैं। यदि आप जानना चाहते हैं कि क्या किसी निश्चित निर्देशिका में एक फ़ाइल मौजूद है या यदि आप जानना चाहते हैं कि क्या किसी फ़ाइल में एक स्ट्रिंग मिला है? आप निश्चित रूप से हर पंक्ति के माध्यम से खोजने की जगह ग्रेप का उपयोग करेंगे!\n\nचलिए हमारे उदाहरण.txt फ़ाइल का उपयोग करें: \n\n<pre>$ grep fox sample.txt</pre>\n\nआपको देखना चाहिए कि ग्रेप ने उदाहरण.txt फ़ाइल में fox को खोज लिया है। \n\nआप वास्तव में -i झंडी के साथ मामूली रूप से ग्रेप पैटर्न को भी ग्रेप कर सकते हैं: \n\n<pre>$ grep -i somepattern somefile</pre>\n\nग्रेप के साथ और भी लचीला होने के लिए आप इसे अन्य कमांडों के साथ | के साथ कॉम्बाइन कर सकते हैं।\n\n<pre>$ env | grep -i User</pre>\n\nजैसा कि आप देख सकते हैं कि ग्रेप काफी लचीला है। आप अपने पैटर्न में नियमित अभिव्यक्तियों का भी उपयोग कर सकते हैं: \n\n<pre>$ ls /somedir | grep '.txt$'</pre>\n\nसोमेडिर में .txt से समाप्त होने वाली सभी फ़ाइलें वापस देना चाहिए।",
          "quizAnswer": "ग्रेप",
          "quizQuestion": "किस कमांड का उपयोग आप निश्चित पैटर्न खोजने के लिए करते हैं?",
          "slug": "ग्रेपकमांड",
          "title": "ग्रेप"
        }
      ],
      "slug": "textfu",
      "title": "टेक्स्ट-फू"
    },
    {
      "description": "विम और इमेक्स के साथ एक लिनक्स स्पाइडर मंकी की तरह पाठ का नेविगेट करें।",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "नियमित अभिव्यंजनों को grep के साथ मिलाकर कुछ फ़ाइलों में खोज करने का प्रयास करें।\n\n<pre>\ngrep [नियमित अभिव्यंजन यहाँ] [फ़ाइल]",
          "id": 1,
          "lessonContent": "नियमित अभिव्यंजन पैटर्न आधारित चयन करने के लिए एक शक्तिशाली उपकरण है। यह विशेष चिह्नन का उपयोग करता है जो हमने पहले ही देखे हैं जैसे कि * वाइल्डकार्ड। \n\nहम कुछ सबसे सामान्य नियमित अभिव्यंजनों के माध्यम से जाएंगे, ये किसी भी प्रोग्रामिंग भाषा के साथ लगभग सार्वत्रिक हैं।\n\nहम इस वाक्य का उपयोग अपनी परीक्षण स्ट्रिंग के रूप में करेंगे:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. पंक्ति की शुरुआत ^ के साथ</b>\n\n<pre>\n<b>^</b>by\nलाइन \"by the seashore\" को मैच करेगा\n</pre>\n\n<b>2. पंक्ति के अंत $ के साथ</b>\n\n<pre>\nseashore<b>$</b>\nलाइन \"by the seashore\" को मैच करेगा\n</pre>\n\n<b>3. . के साथ किसी भी एक वर्ण मैच करना</b>\n\n<pre>\nb<b>.</b>\nby को मैच करेगा\n</pre>\n\n<b>4. [] और () के साथ ब्रैकेट नोटेशन</b>\n\nयह थोड़ा कठिन हो सकता है, ब्रैकेट हमें ब्रैकेट के भीतर पाए जाने वाले वर्णों को निर्दिष्ट करने की अनुमति देते हैं। \n\n<pre>\nd<b>[iou]</b>g\nमैच करेगा: dig, dog, dug\n</pre>\n\nपिछला एंकर टैग ^ जब ब्रैकेट में उपयोग किया जाता है तो ब्रैकेट के भीतर वर्णों को छोड़कर कुछ भी हो सकता है। \n\n<pre>\nd<b>[^i]</b>g\nमैच करेगा: dog और dug लेकिन dig नहीं\n</pre>\n\nब्रैकेट रेंज का उपयोग कर सकते हैं ताकि आप उपयोग करने वाले वर्णों की मात्रा बढ़ा सकें। \n\n<pre>\nd<b>[a-c]</b>g\ndag, dbg और dcg जैसे पैटर्न को मैच करेगा\n</pre>\n\nहालांकि सावधान रहें क्योंकि ब्रैकेट्स मामूली रूप से मामूली हैं:\n\n<pre>\nd<b>[A-C]</b>g\ndAg, dBg और dCg को मैच करेगा लेकिन dag, dbg और dcg को नहीं\n</pre>\n\nऔर ये कुछ मूल नियमित अभिव्यंजन हैं।",
          "quizAnswer": ".",
          "quizQuestion": "एक एकल वर्ण मिलाने के लिए आप कौन सा नियमित अभिव्यंजन उपयोग करेंगे?",
          "slug": "regularexpressionsregex",
          "title": "रेजेक्स (नियमित अभिव्यंजन)"
        },
        {
          "exercise": "विम और इमैक्स का एक छोटा भ्रमण करें:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "यदि आप कुछ डायहार्ड लिनक्स उपयोगकर्ताओं को एक कमरे में ले जाते हैं और उनसे पूछते हैं कि सबसे अच्छा टेक्स्ट संपादक कौन सा है, तो आपको विम या इमैक्स की परमपरागतता के बारे में अनंत चर्चा सुनने को मिलेगी। अगर आप अपनी जान की कदर करते हैं तो GUI संपादक का उल्लेख भी मत करना।\n\nविम और इमैक्स लोकप्रिय टेक्स्ट संपादक हैं जो अधिकांश लिनक्स वितरणों पर डिफ़ॉल्ट रूप से स्थापित होते हैं और इनके अपने फायदे और नुकसान होते हैं। यदि आप अपने सिस्टम को एक निंजा की तरह उपयोग करना चाहते हैं, तो आपको इन टेक्स्ट संपादकों में से एक का चयन करना होगा। ये मूल रूप से कोडिंग, वर्ड दस्तावेज प्रसंस्करण और मौलिक रूप से सभी एक में संपादक हैं।",
          "quizAnswer": "",
          "quizQuestion": "कोई सवाल नहीं आगे बढ़ें!",
          "slug": "texteditorsvimoremacs",
          "title": "टेक्स्ट संपादक"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 3,
          "lessonContent": "Vim vi (Improved) के लिए खड़ा है जैसे ही इसका नाम है, यह vi पाठ संपादक कमांड का एक सुधारित संस्करण के लिए खड़ा है।\n\nयह अत्यंत हल्का है, vim के साथ एक फ़ाइल को खोलना और संपादित करना तेज़ और आसान है। यह लगभग हमेशा उपलब्ध है, अगर आपने किसी भी यादृच्छिक लिनक्स वितरण को बूट किया है, तो संभावना है कि vim डिफ़ॉल्ट रूप से स्थापित है।\n\nvim को चालू करने के लिए बस टाइप करें: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "कोई सवाल नहीं आगे बढ़ें!",
          "slug": "vimtexteditor",
          "title": "Vim (Vi में सुधारा गया)"
        },
        {
          "exercise": "खोज कुंजी के साथ खेलें, विम में एक टेक्स्ट फ़ाइल खोलें: vim [टेक्स्ट फ़ाइल] और खोज शुरू करें!",
          "id": 4,
          "lessonContent": "एक अभिव्यक्ति की खोज करने के लिए, विम सत्र में होते हुए / कुंजी दबाएं और फिर अपने खोज परिणाम टाइप करें। एक बार जब आप एंटर दबाते हैं, तो आप \"n\" दबा सकते हैं आगे बढ़ने के लिए या \"N\" दबा सकते हैं वापस जाने के लिए अपने खोज परिणाम में।\n\n<pre>\nमेरी सुंदर फ़ाइल बहुत सुंदर है।\n\n/सुंदर\n\nटेक्स्ट फ़ाइल में सुंदर शब्द खोजेगा।\n</pre>\n\n\n? खोज कमांड पाठ फ़ाइल की खोज पिछले की ओर करेगा, इसलिए पिछले उदाहरण में, आखिरी सुंदर पहले आएगा।\n<pre>\nमेरी सुंदर फ़ाइल बहुत सुंदर है।\n\n?सुंदर\n\nटेक्स्ट फ़ाइल में सुंदर शब्द खोजेगा।\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "विम में खोज करने के लिए कौन सी कुंजी का उपयोग किया जाता है?",
          "slug": "vimsearchpatterns",
          "title": "Vim खोज पैटर्न"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "अब आपको ध्यान देना चाहिए, यहां किसी भी जगह माउस का उपयोग नहीं है। विम में एक पाठ दस्तावेज़ का नेविगेट करने के लिए निम्नलिखित कुंजियों का उपयोग करें: \n\n<ul>\n<li>h या बाएं तीर - आपको बाएं एक वर्ण ले जाएगा</li>\n<li>k या ऊपर तीर - आपको ऊपर एक पंक्ति ले जाएगा</li>\n<li>j या नीचे तीर - आपको नीचे एक पंक्ति ले जाएगा</li>\n<li>l या दाएं तीर - आपको दाएं एक वर्ण ले जाएगा</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "नीचे जाने के लिए कौन सा अक्षर प्रयोग किया जाता है?",
          "slug": "vimnavigation",
          "title": "Vim नेविगेशन"
        },
        {
          "exercise": "इंसर्शन मोड में प्रवेश और निकासी के साथ खेलें।",
          "id": 6,
          "lessonContent": "<p>अब आपने यह देखा हो सकता है कि यदि आप कुछ टाइप करने की कोशिश करते हैं तो आपको करने की अनुमति नहीं होगी। इसका कारण यह है कि आप कमांड मोड में हैं। यह काफी भ्रांतिकर हो सकता है विशेषकर अगर आप केवल एक फ़ाइल खोलना और पाठ दर्ज करना चाहते हैं। कमांड मोड का उपयोग तब किया जाता है जब आप h, j, k, l आदि जैसे कमांड दर्ज करते हैं। पाठ डालने के लिए, आपको पहले इंसर्ट मोड में जाना होगा। </p><p></p><ul><br><li>i - कर्सर से पहले पाठ डालें</li><br><li>O - पिछली पंक्ति पर पाठ डालें</li><br><li>o - अगली पंक्ति पर पाठ डालें</li><br><li>a - कर्सर के बाद पाठ जोड़ें</li><br><li>A - पंक्ति के अंत में पाठ जोड़ें</li><br></ul><p></p><p>ध्यान दें कि जब आप इन सभी इंसर्शन मोड को टाइप करते हैं, तो आप देखेंगे कि विम ने शैल में इंसर्ट मोड में प्रवेश किया है। इंसर्ट मोड से बाहर निकलने और कमांड मोड में वापस जाने के लिए, बस Esc कुंजी दबाएं।</p>",
          "quizAnswer": "i",
          "quizQuestion": "कर्सर से पहले पाठ डालने के लिए कौन सी कुंजी का उपयोग किया जाता है?",
          "slug": "viminsertingappendingtext",
          "title": "विम पाठ जोड़ना"
        },
        {
          "exercise": "मुझे पता है कि यह सबक कुछ अजीब है, एक पाठ संपादक खोलें और इनके साथ खेलें।",
          "id": 7,
          "lessonContent": "अब हमारे पास कुछ पंक्तियाँ लिखी हैं, इसे और भी संपादित करें और कुछ अनावश्यक वस्तुओं को हटाएँ।<br><p></p><ul><br><li>x - चयनित पाठ को काटने के लिए उपयोग किया जाता है, अक्षरों को हटाने के लिए भी उपयोग किया जाता है</li><br><li>dd - वर्तमान पंक्ति को हटाने के लिए उपयोग किया जाता है</li><br><li>y - चयनित कुछ भी कॉपी या नकल करें</li><br><li>yy - वर्तमान पंक्ति की कॉपी या नकल करें</li><br><li>p - कर्सर से पहले कॉपी किए गए पाठ को पेस्ट करें</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "पूरी पंक्ति को हटाने के लिए कौन सा वर्ण प्रयोग किया जाता है?",
          "slug": "vimediting",
          "title": "Vim संपादन"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 8,
          "lessonContent": "अब जब आपने अपना संपादन कर लिया है, तो वाकई सहेजने और vim से बाहर निकलने का समय है: \n\n<ul>\n<li>:w - फ़ाइल को लिखें या सहेजें</li>\n<li>:q - vim से बाहर निकलें</li>\n<li>:wq - लिखें और फिर बाहर निकलें</li>\n<li>:q! - फ़ाइल को सहेजे बिना vim से बाहर निकलें</li>\n<li>ZZ - :wq के समान, लेकिन एक वर्ण तेज़</li>\n\n<li>u - अपने अंतिम क्रिया को वापस लें</li>\n<li>Ctrl-r - अपने अंतिम क्रिया को पुनः करें</li>\n</ul>\n\nआपको लग सकता है कि ZZ आवश्यक नहीं है, लेकिन आप अंततः देखेंगे कि आपके उंगलियां इसे :wq की बजाय इस ओर झुकने की प्रवृत्ति दिखा सकती है।\n\nविम के बारे में जानने के लिए यह बहुत सारी जानकारी थी। अब जब आपको कुछ मूल आदेश और नेविगेशन पता चल गए हैं, तो आप कुछ पाठ फ़ाइलों का संपादन शुरू कर सकते हैं। विम में अपनी क्षमता को बढ़ाने के लिए आप और विकल्प प्रयोग कर सकते हैं, विम के ऑनलाइन मार्गदर्शन पर जाएं।",
          "quizAnswer": ":q!",
          "quizQuestion": "आप vim से सहेजे बिना कैसे बाहर निकलें?",
          "slug": "vimsavingandexiting",
          "title": "Vim सहेजना और बाहर निकलना"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 9,
          "lessonContent": "ईमैक्स उन उपयोक्ताओं के लिए है जो एक अत्यधिक शक्तिशाली पाठ संपादक चाहते हैं, जो एक कम से कम उपयोग हो सकता है क्योंकि आप मूल रूप से ईमैक्स में रहते हैं। आप अपने सभी कोड संपादन, फ़ाइल परिवर्तन आदि सभी ईमैक्स के भीतर कर सकते हैं। यह विम से ज्यादा लोड होने में थोड़ा अधिक समय लेता है और सीखने का कठिनाई स्तर विम से थोड़ा अधिक है, लेकिन यदि आप एक शक्तिशाली संपादक चाहते हैं जो अत्यधिक विस्तारयुक्त है, तो यह आपके लिए है। जब मैं कहता हूँ विस्तारयुक्त, तो मैं शाब्दिक रूप से तात्कालिक अर्थ में आप ईमैक्स के लिए स्क्रिप्ट लिख सकते हैं जो इसकी क्षमता को बढ़ाते हैं।\n\nईमैक्स शुरू करने के लिए बस इस्तेमाल करें:\n\n<pre>emacs</pre>\n\nआपको डिफ़ॉल्ट स्वागत बफ़र के साथ स्वागत किया जाएगा।\n\nईमैक्स में बफ़र वहाँ है जिसमें आपका पाठ रहता है। तो यदि आप एक फ़ाइल खोलते हैं, तो उस फ़ाइल की सामग्री को संग्रहित करने के लिए एक बफ़र का उपयोग किया जाता है। आप एक साथ कई बफ़र खोल सकते हैं और आप बफ़रों के बीच आसानी से स्विच कर सकते हैं।",
          "quizAnswer": "",
          "quizQuestion": "कोई प्रश्न नहीं आगे बढ़ें!",
          "slug": "emacstexteditor",
          "title": "ईमैक्स"
        },
        {
          "exercise": "फ़ाइलें खोलने और सहेजने के साथ खेलें।",
          "id": 10,
          "lessonContent": "बहुत से (यदि नहीं सभी) ईमैक्स दस्तावेज़ में, आपको वाक्यरचना C-[अक्षर] देखने को मिलेगी। यह बस Ctrl-अक्षर दबाने का मतलब है, लेकिन संक्षेप के उद्देश्य से, हम Ctrl को C कहेंगे। यदि आप M-[अक्षर] जैसी वाक्यरचना देखते हैं, तो इसका मतलब है मेटा कुंजी का उपयोग करें, सबसे अधिक सामान्य रूप से आल्ट कुंजी।\n\n<b>फ़ाइलें सहेजना</b>\n\n<pre>\nC-x C-s - एक फ़ाइल सहेजें\nC-x C-w - फ़ाइल को दूसरे नाम से सहेजें\nC-x s - सभी को सहेजें\n</pre>\n\nसहेजने के विकल्प आपसे पूछेंगे कि क्या आप प्रत्येक फ़ाइल को सहेजना चाहते हैं।\n\n<b>एक फ़ाइल खोलना</b>\n\n<pre>\nC-x C-f\n</pre>\n\nयह आपसे एक फ़ाइल खोलने के लिए एक फ़ाइलनाम टाइप करने के लिए प्रोत्साहित करेगा। यदि आपके पास पहले से मौजूद फ़ाइल नहीं है, तो यह एक नई फ़ाइल बनाएगा। आप एक निर्दिष्ट निर्देशिका भी लोड कर सकते हैं।",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "फ़ाइल खोलने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "emacsmanipulatefiles",
          "title": "ईमैक्स फ़ाइलें मैनिपुलेट करें"
        },
        {
          "exercise": "बफर्स के साथ खेलें।",
          "id": 11,
          "lessonContent": "बफर्स में घूमने के लिए (या फाइल्स जिन्हें आप देख रहे हैं) निम्नलिखित कमांड्स का उपयोग करें:\n\n<b>बफर्स स्विच करें</b>\n\n<pre>\nC-x b - बफर स्विच करें\nC-x right arrow - दाएं ओर बफर के माध्यम से चक्रवात\nC-x left arrow - बाएं ओर बफर के माध्यम से चक्रवात\n</pre>\n\n<b>बफर को बंद करें</b>\n\n<pre>C-x k</pre>\n\n<b>वर्तमान बफर को विभाजित करें</b>\n\n<pre>C-x 2</pre>\n\nइससे आप एक स्क्रीन पर कई बफर्स देख सकते हैं। इन बफर्स के बीच घूमने के लिए इस्तेमाल करें: C-x o\n\n<b>एक एकल बफर को वर्तमान स्क्रीन के रूप में सेट करें</b>\n\n<pre>C-x 1</pre>\n\nअगर आपने कभी स्क्रीन और टीमक्स जैसे टर्मिनल मल्टीप्लेक्सर का उपयोग किया है, तो बफर कमांड बहुत परिचित लगेंगे।",
          "quizAnswer": "C-x k",
          "quizQuestion": "आप एक बफर को कैसे किल करेंगे?",
          "slug": "emacsbuffernavigation",
          "title": "ईमैक्स बफर नेविगेशन"
        },
        {
          "exercise": "टेक्स्ट नेविगेशन के साथ खेलें।",
          "id": 12,
          "lessonContent": "<b>टेक्स्ट नेविगेशन</b>\n\n<pre>\nC-up arrow : एक पैराग्राफ ऊपर जाएं\nC-down arrow: एक पैराग्राफ नीचे जाएं\nC-left arrow: एक शब्द बाएं जाएं\nC-right arrow: एक शब्द दाएं जाएं\nM-> : बफर के अंत तक जाएं\n</pre>\n\nटेक्स्ट नेविगेशन के साथ, आपके नियमित टेक्स्ट बटन काम करते हैं, होम, एंड, पेज अप, पेज डाउन और एरो की, आदि।\n\n<b>कटिंग और पेस्टिंग</b>\n\nकट (किल) या पेस्ट (यांक) करने के लिए आपको पहले टेक्स्ट का चयन करना होगा। टेक्स्ट का चयन करने के लिए, अपने कर्सर को वहाँ ले जाएं जहाँ आप कट या पेस्ट करना चाहते हैं और <pre>C-स्पेस की</pre> दबाएं फिर आप नेविगेशन कुंजियों का उपयोग करके वह टेक्स्ट चुन सकते हैं जिसे आप चाहते हैं। अब आप इस तरह से कट और पेस्ट कर सकते हैं:\n\n<pre>\nC-w : कट\nC-y : यांक\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "आप बफर के अंत में कैसे जाएं?",
          "slug": "emacsediting",
          "title": "इमैक्स संपादन"
        },
        {
          "exercise": "अधिक कमांडों के बारे में जानने के लिए इमैक्स साइट पर जाएं। <a href=\"https://www.gnu.org/software/emacs/\">इमैक्स</a>",
          "id": 13,
          "lessonContent": "<b>इमैक्स से बाहर निकलने के लिए</b>\n\n<pre>C-x C-c</pre>\n\nअगर आपके पास कोई खुली बफर है, तो यह आपसे इमैक्स से बाहर निकलने से पहले उसे सहेजने के लिए पूछेगा।\n\n<b>भ्रांत?</b>\n\n<pre>C-h C-h : मदद मेनू</pre>\n\n<b>पूर्ववत</b>\n\n<pre>C-x u</pre>\n\nजैसा कि आप देख सकते हैं, इमैक्स में और भी अधिक चीजें हैं, इसलिए सीखने की धारा थोड़ी ज्यादा टेढ़ी है। लेकिन उपलब्धियों के बदले में, आप एक बहुत शक्तिशाली पाठ संपादक प्राप्त करते हैं।",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "मदद मेनू तक कैसे पहुंचें?",
          "slug": "emacsexitingandhelp",
          "title": "Emacs Exiting and Help"
        }
      ],
      "slug": "advancedtextfu",
      "title": "उन्नत पाठ-फू"
    },
    {
      "description": "उपयोगकर्ता भूमिकाओं और प्रबंधन के बारे में जानें।",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 1,
          "lessonContent": "किसी भी पारंपरिक ऑपरेटिंग सिस्टम में, उपयोगकर्ता और समूह होते हैं। वे केवल पहुंच और अनुमतियों के लिए मौजूद होते हैं। किसी प्रक्रिया को चलाते समय, वह प्रक्रिया के मालिक के रूप में चलेगा चाहे वह जेन हो या बॉब। फ़ाइल पहुंच और स्वामित्व भी अनुमति पर निर्भर करता है। आप चाहेंगे नहीं कि जेन बॉब के दस्तावेज़ देखे और उल्टा। \n\nप्रत्येक उपयोगकर्ता का अपना होम निर्देशिका होता है जहां उनकी उपयोगकर्ता विशिष्ट फ़ाइलें संग्रहित होती हैं, यह आम तौर पर /home/username में स्थित होता है, लेकिन विभिन्न वितरणों में भिन्न हो सकता है। \n\nसिस्टम उपयोगकर्ता आईडी (UID) का उपयोग उपयोगकर्ताओं को प्रबंधित करने के लिए करता है, उपयोगकर्ता नाम उपयोगकर्ताओं को पहचान के लिए मित्रपूर्ण तरीके से जोड़ने का सहज तरीका है, लेकिन सिस्टम उपयोगकर्ताओं को उनके UID द्वारा पहचानता है। सिस्टम अनुमतियों को प्रबंधित करने के लिए समूहों का भी उपयोग करता है, समूह केवल उपयोगकर्ताओं के सेट होते हैं जिनकी अनुमति उस समूह द्वारा सेट की गई होती है, उन्हें सिस्टम उनके समूह आईडी (GID) के साथ पहचानता है।\n\nलिनक्स में, आप उपयोगकर्ता के अतिरिक्त साधारित मानवों के साथ उपयोग करने वाले उपयोगकर्ता होंगे। कभी-कभी ये उपयोगकर्ता सिस्टम डेमन होते हैं जो प्रक्रियाएँ निरंतर चलाते रहते हैं ताकि सिस्टम कार्यरत रहे। सबसे महत्वपूर्ण उपयोगकर्ता में से एक रूट या सुपरउपयोगकर्ता है, रूट सिस्टम पर सबसे शक्तिशाली उपयोगकर्ता है, रूट किसी भी फ़ाइल तक पहुंच सकता है और किसी भी प्रक्रिया को शुरू और समाप्त कर सकता है। उस कारण से, रूट के रूप में हमेशा काम करना खतरनाक हो सकता है, आप संभावित रूप से सिस्टम महत्वपूर्ण फ़ाइलें हटा सकते हैं। भाग्य से, अगर रूट पहुंच की आवश्यकता होती है और किसी उपयोगकर्ता के पास रूट पहुंच होती है, तो वे सुपरउपयोगकर्ता के रूप में एक कमांड चला सकते हैं बजाय रूट के साथ सुपरउपयोगकर्ता के रूप में। सुपरउपयोगकर्ता कमांड (सुपरउपयोगकर्ता करें) का उपयोग रूट पहुंच के साथ किसी कमांड को चलाने के लिए किया जाता है, हम एक बाद में सीखेंगे कि उपयोगकर्ता कैसे रूट पहुंच प्राप्त करता है।\n\nआगे बढ़ें और कोशिश करें किसी संरक्षित फ़ाइल जैसे /etc/shadow को देखने की:\n\n<pre>$ cat /etc/shadow</pre>\n\nध्यान दें कि आपको एक अनुमति निषेध त्रुटि मिलती है, अनुमतियों को देखें: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nहमने अभी तक अनुमतियों के माध्यम से नहीं गया है, लेकिन यहाँ क्या हो रहा है यह है कि रूट फ़ाइल का मालिक है और आपको फ़ाइल की सामग्री पढ़ने के लिए रूट पहुंच या शैडो समूह का हिस्सा होना चाहिए। अब सुपरउपयोगकर्ता के साथ कमांड चलाएँ:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nअब आप फ़ाइल की सामग्री देख सकेंगे!",
          "quizAnswer": "सुडो",
          "quizQuestion": "आप किस कमांड का उपयोग रूट के रूप में करते हैं?",
          "slug": "usersandgroups",
          "title": "उपयोगकर्ता और समूह"
        },
        {
          "exercise": "/etc/sudoers फ़ाइल खोलें और देखें कि मशीन पर अन्य उपयोगकर्ताओं को सुपरयूज़र अनुमतियाँ क्या हैं।",
          "id": 2,
          "lessonContent": "हमने सुपरयूज़र एक्सेस पाने के एक तरीके को देखा है जिसमें सुडो कमांड का उपयोग किया गया है। आप सुपरयूज़र के रूप में कमांड भी सु आदेश के साथ चला सकते हैं। यह कमांड \"उपयोगकर्ता की प्रतिस्थापना\" करेगा और यदि कोई उपयोगकर्ता निर्दिष्ट नहीं किया गया है तो एक रूट शैल खोलेगा। आप इस कमांड का उपयोग किसी भी उपयोगकर्ता के रूप में प्रतिस्थापन करने के लिए कर सकते हैं जब तक आप पासवर्ड नहीं जानते हैं।\n\n<pre>$ su</pre>\n\nइस विधि का उपयोग करने के कुछ हानियां हैं: रूट में सब कुछ चलाने में एक महत्वपूर्ण गलती करना बहुत आसान है, आपके पास जो आप उपयोग करते हैं वह कमांडों का रिकॉर्ड नहीं होगा जिन्हें आप सिस्टम विन्यास बदलने के लिए उपयोग करते हैं, आदि। मुख्य रूप से, यदि आपको सुपरयूज़र के रूप में कमांड चलाने की आवश्यकता है, तो बस सुडो का पालन करें।\n\nअब जब आप जानते हैं कि सुपरयूज़र के रूप में कौन सी कमांड चलानी हैं, तो सवाल यह है कि आप कैसे जानेंगे कि कौन इसे करने की पहुंच रखता है? सिस्टम हर एक जो श्मो उपयोगकर्ता को सुपरयूज़र के रूप में कमांड चलाने नहीं देता, तो यह कैसे जानता है? एक फ़ाइल है जिसे /etc/sudoers फ़ाइल कहा जाता है, यह फ़ाइल उन उपयोगकर्ताओं की सूची देती है जिन्हें सुडो चलाने की अनुमति है। आप इस फ़ाइल को <b>visudo</b> कमांड के साथ संपादित कर सकते हैं।",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "कौन सी फ़ाइल उपयोगकर्ताओं को सुडो उपयोग की पहुंच दिखाती है?",
          "slug": "rootuser",
          "title": "मूल"
        },
        {
          "exercise": "अपनी /etc/passwd फ़ाइल देखें, कुछ उपयोगकर्ताओं को देखें और उनकी पहुंच को नोट करें।",
          "id": 3,
          "lessonContent": "याद रखें कि उपयोगकर्ताओं के लिए यूजरनेम वास्तव में उपयोगकर्ताओं के लिए पहचान नहीं है। सिस्टम एक उपयोगकर्ता की पहचान के लिए एक उपयोगकर्ता आईडी (UID) का उपयोग करता है। किस आईडी के लिए कौन से उपयोगकर्ता मैप हैं, यह जानने के लिए /etc/passwd फ़ाइल देखें।\n\n<pre>$ cat /etc/passwd</pre>\n\nयह फ़ाइल आपको उपयोगकर्ताओं की सूची और उनके बारे में विस्तृत जानकारी दिखाती है। उदाहरण के लिए, इस फ़ाइल में पहली पंक्ति बहुत संभावना इस तरह दिखती है:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nप्रत्येक पंक्ति एक उपयोगकर्ता के लिए उपयोगकर्ता जानकारी प्रदर्शित करती है, आमतौर पर आप पहली पंक्ति में रूट उपयोगकर्ता को देखेंगे। कोलन द्वारा अलग किए गए कई क्षेत्र हैं जो आपको उपयोगकर्ता के बारे में अतिरिक्त जानकारी देते हैं, चलिए उन्हें सभी देखते हैं:\n\n<ol>\n<li>उपयोगकर्ता नाम</li>\n<li>उपयोगकर्ता का पासवर्ड - पासवर्ड वास्तव में इस फ़ाइल में स्टोर नहीं होता है, आमतौर पर यह /etc/shadow फ़ाइल में स्टोर होता है। हम अगले सबक में अधिक चर्चा करेंगे /etc/shadow के बारे में, लेकिन अब जानें कि इसमें एन्क्रिप्टेड उपयोगकर्ता पासवर्ड होते हैं। आप इस क्षेत्र में कई विभिन्न प्रतीक देख सकते हैं, यदि आप एक \"x\" देखते हैं तो इसका मतलब है कि पासवर्ड /etc/shadow फ़ाइल में स्टोर है, एक \"*\" का मतलब है कि उपयोगकर्ता को लॉगिन एक्सेस नहीं है और यदि एक खाली क्षेत्र है तो इसका मतलब है कि उपयोगकर्ता का कोई पासवर्ड नहीं है।</li>\n<li>उपयोगकर्ता आईडी - जैसा कि आप देख सकते हैं रूट का UID 0 है</li>\n<li>समूह आईडी</li>\n<li>GECOS क्षेत्र - यह उपयोगकर्ता या खाते के बारे में सामान्य टिप्पणियाँ छोड़ने के लिए उपयोग किया जाता है जैसे कि उनका असली नाम या फ़ोन नंबर, यह कॉमा विभाजित है।</li>\n<li>उपयोगकर्ता का होम डायरेक्टरी</li>\n<li>उपयोगकर्ता का शैल - आप शायद देखेंगे कि उपयोगकर्ता अपने शैल के लिए बैश को डिफ़ॉल्ट कर रहे हैं</li>\n</ol>\n\nसामान्यत: एक उपयोगकर्ता की सेटिंग पृष्ठ में, आपको केवल मानव उपयोगकर्ताओं को देखने की उम्मीद होगी। हालांकि, आप देखेंगे कि /etc/passwd में अन्य उपयोगकर्ता हैं। याद रखें कि उपयोगकर्ताएं वास्तव में केवल प्रक्रियाएँ विभिन्न अनुमतियों के साथ चलाने के लिए सिस्टम पर हैं। कभी-कभी हम पूर्व-निर्धारित अनुमतियों के साथ प्रक्रियाएँ चलाना चाहते हैं। उदाहरण के लिए, डेमन उपयोगकर्ता डेमन प्रक्रियाओं के लिए उपयोग किया जाता है।\n\nयह भी ध्यान देना चाहिए कि आप चाहें तो <b>vipw</b> उपकरण के साथ /etc/passwd फ़ाइल को हाथ से संपादित कर सकते हैं यदि आप उपयोगकर्ताओं को जोड़ना और जानकारी संशोधित करना चाहते हैं, हालांकि इस तरह की चीजें उन उपकरणों के लिए छोड़ देना बेहतर है जिनके बारे में हम बाद में सबक में चर्चा करेंगे जैसे कि useradd और userdel।",
          "quizAnswer": "*",
          "quizQuestion": "यदि एक उपयोगकर्ता को लॉगिन एक्सेस नहीं है तो /etc/passwd में वह कैसे दर्शित होता है?",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "/etc/shadow फ़ाइल पर एक नज़र डालें",
          "id": 4,
          "lessonContent": "यूज़र प्रमाणीकरण के बारे में जानकारी स्टोर करने के लिए /etc/shadow फ़ाइल का उपयोग किया जाता है। इसे सुपरयूज़र पढ़ने की अनुमति चाहिए।\n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nआप देखेंगे कि यह /etc/passwd की सामग्री के बहुत ही समान दिखता है, हालांकि पासवर्ड फ़ील्ड में आपको एक एन्क्रिप्टेड पासवर्ड दिखेगा। फ़ील्ड को दोबारा बांटने के लिए उपयुक्त अंकन के रूप में अलग किया गया है:\n\n<ol>\n<li>उपयोगकर्ता नाम</li>\n<li>एन्क्रिप्टेड पासवर्ड</li>\n<li>अंतिम पासवर्ड बदलने की तारीख - 1970 के जनवरी 1 से दिनों की संख्या के रूप में व्यक्त की गई है। अगर एक 0 है तो इसका मतलब है कि उपयोगकर्ता को अगली बार लॉगिन करने पर अपना पासवर्ड बदलना चाहिए</li>\n<li>न्यूनतम पासवर्ड आयु - उपयोगकर्ता को फिर से अपना पासवर्ड बदलने की अनुमति प्राप्त करने के लिए इंतजार करना होगा दिनों</li>\n<li>अधिकतम पासवर्ड आयु - उपयोगकर्ता को अपना पासवर्ड बदलने के लिए दिनों की अधिकतम संख्या</li>\n<li>पासवर्ड चेतावनी अवधि - पासवर्ड समाप्त होने से पहले दिनों की संख्या</li>\n<li>पासवर्ड निष्क्रियता अवधि - पासवर्ड समाप्त होने के बाद दिनों की संख्या जिसके साथ उनका पासवर्ड लॉगिन करने की अनुमति होगी</li>\n<li>खाता समाप्ति तिथि - उपयोगकर्ता लॉगिन नहीं कर पाएगा तिथि</li>\n<li>भविष्य के उपयोग के लिए रिजर्व फ़ील्ड</li>\n</ol>\n\nआजकल अधिकांश वितरणों में, उपयोगकर्ता प्रमाणीकरण केवल /etc/shadow फ़ाइल पर निर्भर नहीं है, इसके बजाय पीएएम (प्लगेबल प्रमाणीकरण मॉड्यूल्स) जैसे अन्य तंत्र हैं जो प्रमाणीकरण को बदल देते हैं।",
          "quizAnswer": "",
          "quizQuestion": "कोई सवाल नहीं आगे बढ़ें!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "<b>groups</b> कमांड चलाएं। आपको क्या दिखाई देता है?",
          "id": 5,
          "lessonContent": "एक और फ़ाइल जो उपयोगकर्ता प्रबंधन में प्रयोग की जाती है, वह है /etc/group फ़ाइल। यह फ़ाइल विभिन्न समूहों को विभिन्न अनुमतियों के साथ स्थापित करने की अनुमति देती है।\n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\n/etc/password फ़ील्ड के बहुत ही समान होने के लिए, /etc/group फ़ील्ड निम्नलिखित हैं:\n\n<ol>\n<li>समूह का नाम</li>\n<li>समूह पासवर्ड - समूह पासवर्ड सेट करने की आवश्यकता नहीं है, sudo जैसे उच्च विशेषाधिकार का उपयोग सामान्य है। डिफ़ॉल्ट मान के रूप में \"*\" डाला जाएगा।</li>\n<li>समूह आईडी (GID)</li>\n<li>उपयोगकर्ताओं की सूची - आप एक विशिष्ट समूह में रखना चाहते हैं उपयोगकर्ताओं को मैन्युअल रूप से निर्दिष्ट कर सकते हैं</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "रूट का GID क्या है?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "एक नया उपयोगकर्ता बनाएं फिर उनका पासवर्ड बदलें और नए उपयोगकर्ता के रूप में लॉगिन करें।",
          "id": 6,
          "lessonContent": "अधिकांश उद्यम परिवेश उपयोगकर्ताओं, खातों और पासवर्ड प्रबंधित करने के लिए प्रबंधन प्रणालियों का उपयोग कर रहे हैं। हालांकि, एकल मशीन कंप्यूटर पर उपयोगकर्ताओं को प्रबंधित करने के लिए उपयोगी कमांड हैं।\n\n<b>उपयोगकर्ता जोड़ना</b>\n\nआप adduser या useradd कमांड का उपयोग कर सकते हैं। adduser कमांड में और उपयोगी सुविधाएँ हैं जैसे कि होम निर्देशिका बनाना और अधिक। नए उपयोगकर्ताओं को जोड़ने के लिए कॉन्फ़िगरेशन फ़ाइलें हैं जो आपकी इच्छानुसार साज़ा की जा सकती हैं।\n\n<pre>$ sudo useradd bob</pre>\n\nआप देखेंगे कि उपरोक्त कमांड bob के लिए /etc/passwd में एक प्रविष्टि बनाता है, डिफ़ॉल्ट समूह सेट करता है और /etc/shadow फ़ाइल में एक प्रविष्टि जोड़ता है।\n\n<b>उपयोगकर्ता हटाना</b>\n\nउपयोगकर्ता हटाने के लिए, आप userdel कमांड का उपयोग कर सकते हैं।\n\n<pre>$ sudo userdel bob</pre>\n\nयह मूल रूप से useradd द्वारा किए गए फ़ाइल परिवर्तनों को वापस लेने का प्रयास करता है।\n\n<b>पासवर्ड बदलना</b>\n\n<pre>$ passwd bob</pre>\n\nइससे आप अपना पासवर्ड बदल सकेंगे या किसी अन्य उपयोगकर्ता का पासवर्ड बदल सकेंगे (अगर आप रूट हैं)।",
          "quizAnswer": "passwd",
          "quizQuestion": "पासवर्ड बदलने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "usermanagementtools",
          "title": "उपयोगकर्ता प्रबंधन उपकरण"
        }
      ],
      "slug": "usermanagement",
      "title": "उपयोगकर्ता प्रबंधन"
    },
    {
      "description": "अनुमति स्तरों और अनुमतियों को संशोधित करने के बारे में जानें।",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "एलएस -एल कमांड का उपयोग करें एक से अधिक फ़ाइलों पर और उनकी अनुमतियों, प्रयोक्ता और समूह को याद करें।",
          "id": 1,
          "lessonContent": "जैसा कि हमने पहले सीखा, फ़ाइलों के विभिन्न अनुमतियाँ या फ़ाइल मोड होते हैं। एक उदाहरण देखते हैं:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nएक फ़ाइल की अनुमतियों में चार हिस्से होते हैं। पहला हिस्सा फ़ाइल के प्रकार को दर्शाता है, जिसे अनुमतियों में पहले अक्षर से दर्शाया जाता है, हमारे मामले में हम एक निर्देशिका देख रहे हैं इसलिए फ़ाइल के प्रकार को दर्शाने के लिए <b>d</b> दिखाया गया है। सामान्यत: आप एक साधारण फ़ाइल के लिए <b>-</b> देखेंगे।\n\nफ़ाइल मोड के अगले तीन हिस्से वास्तविक अनुमतियाँ होती हैं। अनुमतियाँ 3-3 बिटों में समूहित होती हैं। पहले 3 बिट उपयोगकर्ता अनुमतियाँ हैं, फिर समूह अनुमतियाँ और फिर अन्य अनुमतियाँ। मैंने इसे अलग करने के लिए पाइप जोड़ा है।\n\n<pre>d | rwx | r-x | r-x </pre>\n\nप्रत्येक वर्ण एक विभिन्न अनुमति को प्रतिनिधित करता है:\n<ul>\n<li>r: पढ़ने योग्य</li>\n<li>w: लिखने योग्य</li>\n<li>x: क्रियाशील (मूल रूप से एक क्रियाशील कार्यक्रम)</li>\n<li>-: खाली</li>\n</ul>\n\nइस उपरोक्त उदाहरण में, हम देखते हैं कि प्रयोक्ता पीट के पास फ़ाइल पर पढ़ने, लिखने और क्रियान्वित करने की अनुमतियाँ हैं। समूह पेंग्विन्स के पास पढ़ने और क्रियान्वित करने की अनुमतियाँ हैं। और अंत में, अन्य प्रयोक्ताओं (अन्य सभी) के पास पढ़ने और क्रियान्वित करने की अनुमतियाँ हैं।",
          "quizAnswer": "x",
          "quizQuestion": "किस अनुमति बिट का उपयोग क्रियाशील के लिए किया जाता है?",
          "slug": "फ़ाइलअनुमतियाँ",
          "title": "फ़ाइल अनुमतियाँ"
        },
        {
          "exercise": "कुछ मौलिक पाठ फ़ाइल अनुमतियाँ बदलें और जब आप ls -l करते हैं तो बिट बदलते हुए देखें।",
          "id": 2,
          "lessonContent": "अनुमतियों को <b>chmod</b> कमांड के साथ आसानी से बदला जा सकता है। \n\nपहले, उस अनुमति सेट को चुनें जिसे आप बदलना चाहते हैं, उपयोगकर्ता, समूह या अन्य। आप अनुमतियों को जोड़ सकते हैं या हटा सकते हैं एक <b>+</b> या <b>-</b> के साथ, चलिए कुछ उदाहरण देखते हैं।\n\n<b>फ़ाइल पर अनुमति बिट जोड़ना</b>\n<pre>$ chmod u+x myfile</pre>\n\nऊपर का कमांड इस प्रकार पढ़ा जाता है: myfile पर अनुमति बदलें उपयोगकर्ता सेट पर एक्सीक्यूटेबल अनुमति बिट जोड़कर। तो अब उपयोगकर्ता के पास इस फ़ाइल पर एक्सीक्यूटेबल अनुमति है!\n\n<b>फ़ाइल से अनुमति बिट हटाना</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>फ़ाइल पर कई अनुमति बिट जोड़ना</b>\n<pre>$ chmod ug+w</pre>\n\nअनुमतियों को संख्यात्मक प्रारूप का उपयोग करके अनुमतियों को बदलने का एक और तरीका है। यह विधि आपको सभी एक साथ अनुमतियाँ बदलने की अनुमति देती है। अनुमतियों को प्रतिनिधित्व करने के लिए r, w, या x का उपयोग करने की बजाय, आप एकल अनुमति सेट के लिए एक संख्यात्मक प्रतिनिधित्व का उपयोग करेंगे। तो g या u के साथ समूह को निर्दिष्ट करने की आवश्यकता नहीं है।\n\nसंख्यात्मक प्रतिनिधित्व नीचे दिखाई देते हैं:\n\n<ul>\n<li>4: पढ़ने की अनुमति</li>\n<li>2: लेखन की अनुमति</li>\n<li>1: क्रियान्वयन की अनुमति</li>\n</ul>\n\nएक उदाहरण देखते हैं: \n\n<pre>$ chmod 755 myfile</pre>\n\nक्या आप अनुमान लगा सकते हैं कि हम इस फ़ाइल को कौन सी अनुमतियाँ दे रहे हैं? चलिए इसे विश्लेषण करें, तो अब 755 सभी सेट के लिए अनुमतियों को कवर करता है। पहला नंबर (7) उपयोगकर्ता अनुमतियाँ का प्रतिनिधित्व करता है, दूसरा नंबर (5) समूह अनुमतियाँ प्रतिनिधित्व करता है और आखिरकार का 5 अन्य अनुमतियाँ प्रतिनिधित्व करता है।\n\nरुकिए एक मिनट, 7 और 5 ऊपर सूचीबद्ध नहीं थे, ये नंबर कहां से आ रहे हैं? याद रखें हम अब सभी अनुमतियों को एक संख्या में मिला रहे हैं, तो आपको कुछ गणित शामिल करना होगा।\n\n7 = 4 + 2 + 1, तो 7 उपयोगकर्ता अनुमतियाँ है और इसमें पढ़ने, लेखन और क्रियान्वयन की अनुमतियाँ हैं\n\n5 = 4 + 1, समूह में पढ़ने और क्रियान्वयन की अनुमतियाँ हैं\n\n5 = 4 +1, और सभी अन्य उपयोगकर्ताओं को पढ़ने और क्रियान्वयन की अनुमतियाँ हैं\n\nएक बात का ध्यान रखें: अनुमतियाँ बिना सोचे-समझे बदलना अच्छा विचार नहीं है, आप संभावित रूप से एक संवेदनशील फ़ाइल को सभी के लिए संशोधित करने के लिए उजागर कर सकते हैं, हालांकि कई बार आप वास्तव में अनुमतियाँ बदलना चाहते हैं, तो जब आप chmod कमांड का उपयोग कर रहे हो तो सावधानी बरतें।",
          "quizAnswer": "4",
          "quizQuestion": "संख्यात्मक प्रारूप का उपयोग करते समय पढ़ने की अनुमति को किस संख्या का प्रतिनिधित्व करता है?",
          "slug": "अनुमतियाँसंशोधितकरना",
          "title": "अनुमतियाँ संशोधित करना"
        },
        {
          "exercise": "कुछ परीक्षण फ़ाइलों का समूह और उपयोगकर्ता संशोधित करें। फिर ls -l के साथ अनुमतियों को देखें।",
          "id": 3,
          "lessonContent": "फ़ाइलों पर अनुमतियों को संशोधित करने के अतिरिक्त, आप फ़ाइल के स्वामित्व का समूह और उपयोगकर्ता संपत्ति भी संशोधित कर सकते हैं। \n\n<b>उपयोगकर्ता स्वामित्व संशोधित करें</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nयह कमांड myfile के मालिक को patty पर सेट करेगा।\n\n<b>समूह स्वामित्व संशोधित करें</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nयह कमांड myfile के समूह को whales पर सेट करेगा।\n\n<b>उपयोगकर्ता और समूह दोनों स्वामित्व को एक साथ संशोधित करें</b>\nयदि आप उपयोगकर्ता के बाद एक विराम और समूहनाम जोड़ते हैं तो आप उपयोगकर्ता और समूह दोनों को एक साथ सेट कर सकते हैं।\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "आप उपयोगकर्ता स्वामित्व को बदलने के लिए कौन सा कमांड उपयोग करते हैं?",
          "slug": "स्वामित्वअनुमतियाँ",
          "title": "स्वामित्व अनुमतियाँ"
        },
        {
          "exercise": "<ol>\n<li>एक नई फ़ाइल बनाएं, फिर उसकी अनुमतियों का ध्यान रखें।</li>\n<li>यूमास्क को संशोधित करें और फिर एक और नई फ़ाइल बनाएं।</li>\n<li>नई फ़ाइल पर फिर से अनुमतियों की जाँच करें, आप क्या उम्मीद करते हैं देखने की?</li>\n<ol>",
          "id": 4,
          "lessonContent": "हर फ़ाइल जो बनती है, उसके साथ एक डिफ़ॉल्ट सेट की अनुमतियाँ आती हैं। अगर आप इस डिफ़ॉल्ट सेट की अनुमतियों को बदलना चाहते हैं, तो आप यूमास्क कमांड के साथ ऐसा कर सकते हैं। यह कमांड उन 3 बिट अनुमति सेट को लेती है जो हम संख्यात्मक अनुमतियों में देखते हैं।\n\nइन अनुमतियों को जोड़ने की बजाय, यूमास्क इन अनुमतियों को हटा देती है।\n\n<pre>$ umask 021</pre>\n\nऊपर दिए गए उदाहरण में, हम कह रहे हैं कि हम नई फ़ाइलों की डिफ़ॉल्ट अनुमतियों को उन्हें पहुंचने की अनुमति देना चाहते हैं, लेकिन समूहों के लिए हम उनकी लेखन अनुमति को हटाना चाहते हैं और अन्य उपयोगकर्ताओं की लिए हम उनकी क्रियान्वित करने की अनुमति को हटाना चाहते हैं। अधिकांश वितरणों पर डिफ़ॉल्ट यूमास्क 022 है, जिसका मतलब है सभी उपयोगकर्ता पहुंच, लेकिन समूह और अन्य उपयोगकर्ताओं के लिए कोई लेखन पहुंच नहीं।\n\nजब आप यूमास्क कमांड चलाते हैं, तो वह उस डिफ़ॉल्ट सेट की अनुमतियों को किसी भी नई फ़ाइल पर देगा। हालांकि, अगर आप चाहते हैं कि यह बना रहे, तो आपको अपनी स्टार्टअप फ़ाइल को संशोधित करना होगा (.प्रोफ़ाइल), लेकिन हम उस पर बाद में चर्चा करेंगे।",
          "quizAnswer": "यूमास्क",
          "quizQuestion": "डिफ़ॉल्ट फ़ाइल अनुमतियों को बदलने के लिए कौन सी कमांड उपयोग की जाती है?",
          "slug": "यूमास्क",
          "title": "यूमास्क"
        },
        {
          "exercise": "/etc/passwd के लिए अनुमति को विस्तार से देखें, क्या आपको कुछ और नजर आता है? SUID सक्षम फ़ाइलें भी आसानी से पहचानी जा सकती हैं।",
          "id": 5,
          "lessonContent": "बहुत सारे मामले होते हैं जिनमें सामान्य उपयोगकर्ताओं को कार्य करने के लिए उच्च एक्सेस की आवश्यकता होती है। सिस्टम प्रशासक हर समय वहाँ नहीं हो सकता कि प्रत्येक बार जब एक उपयोगकर्ता को संरक्षित फ़ाइल तक पहुंच की आवश्यकता होती है तो वह एक रूट पासवर्ड दर्ज करे, इसलिए इस व्यवहार को अनुमति देने के लिए विशेष फ़ाइल अनुमति बिट्स होते हैं। सेट यूज़र आईडी (SUID) एक उपयोगकर्ता को एक प्रोग्राम को उस प्रोग्राम फ़ाइल के मालिक के रूप में चलाने की अनुमति देता है बजाय उनके रूप में।\n\nचलो एक उदाहरण देखते हैं: \n\nकहते हैं कि मैं अपना पासवर्ड बदलना चाहता हूँ, सरल है ना? मैं बस passwd कमांड का उपयोग करता हूँ:\n\n<pre>$ passwd</pre>\n\nपासवर्ड कमांड क्या कर रहा है? यह कुछ फ़ाइलों को संशोधित कर रहा है, लेकिन सबसे महत्वपूर्ण यह है कि यह /etc/shadow फ़ाइल को संशोधित कर रहा है। चलो उस फ़ाइल को एक सेकंड के लिए देखते हैं: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nओह रुको एक मिनट, यह फ़ाइल root के पास है? हम कैसे संभव है कि हम एक फ़ाइल को संशोधित कर सकते हैं जिसका मालिक root है? \n\nएक और अनुमति सेट को देखते हैं, इस बार हमने चलाया हुआ कमांड का: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nआपको यहाँ एक नया अनुमति बिट <b>s</b> दिखाई देगा। यह अनुमति बिट SUID है, जब एक फ़ाइल के पास यह अनुमति सेट होती है, तो उन उपयोगकर्ताओं को यह अनुमति भी मिलती है जिन्होंने प्रोग्राम को लॉन्च किया है, साथ ही क्रियान्वयन अनुमति, इस मामले में root। इसलिए मूल रूप से जब एक उपयोगकर्ता पासवर्ड कमांड चला रहा होता है, तो वह root के रूप में चल रहा है।\n\nइसीलिए हम passwd कमांड चलाते समय /etc/shadow जैसी संरक्षित फ़ाइल तक पहुंच सकते हैं। अब अगर आप उस बिट को हटा देंगे, तो आप देखेंगे कि आप /etc/shadow को संशोधित नहीं कर पाएंगे और इसलिए अपना पासवर्ड नहीं बदल पाएंगे। \n\n<b>SUID को संशोधित करना</b>\n\nसामान्य अनुमतियों की तरह SUID अनुमतियों को संशोधित करने के दो तरीके होते हैं। \n\n<i>प्रतीकात्मक तरीका:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>संख्यात्मक तरीका:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nजैसा कि आप देख सकते हैं SUID को 4 द्वारा दर्शाया गया है और अनुमति सेट के लिए पूर्वारोपित किया गया है। आप देख सकते हैं कि SUID को एक बड़ा <b>S</b> के रूप में भी दर्शाया जा सकता है यह यही काम करता है, लेकिन इसमें क्रियान्वयन अनुमतियाँ नहीं होती हैं।",
          "quizAnswer": "4",
          "quizQuestion": "SUID को किस संख्या का प्रतिनिधित्व करता है?",
          "slug": "setuidsetuserid",
          "title": "सेटयूआईडी"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 6,
          "lessonContent": "सेट यूज़र आईडी अनुमति बिट के समान, एक सेट ग्रुप आईडी (एसजीआईडी) अनुमति बिट है। यह बिट एक प्रोग्राम को उस समूह के सदस्य के रूप में चलाने की अनुमति देता है। \n\nएक उदाहरण देखते हैं: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nअब हम देख सकते हैं कि अनुमति बिट समूह अनुमति सेट में है। \n\n<b>एसजीआईडी को संशोधित करना</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nएसजीआईडी के लिए संख्यात्मक प्रतिनिधित्व 2 है।",
          "quizAnswer": "2",
          "quizQuestion": "एसजीआईडी को कौन संख्या प्रतिनिधित करता है?",
          "slug": "setgidsetgroupid",
          "title": "सेटगिड"
        },
        {
          "exercise": "हमने अभी तक प्रक्रियाओं पर चर्चा नहीं की है, हम इस परिवर्तन को वास्तविक समय में हो रहे देख सकते हैं: \n\n<ol>\n<li>एक टर्मिनल विंडो खोलें, और निम्नलिखित कमांड चलाएं: <b>watch -n 1 \"ps aux | grep passwd\"</b>। यह passwd प्रक्रिया के लिए देखेगा।</li>\n<li>एक दूसरी टर्मिनल विंडो खोलें और चलाएं: <b>passwd</b></li>\n<li>पहली टर्मिनल विंडो पर देखें, आपको देखने को मिलेगा कि passwd के लिए एक प्रक्रिया आई है। प्रक्रिया सारणी में पहला स्तंभ प्रभावी उपयोगकर्ता आईडी है, देखो और देखो यह रूट उपयोगकर्ता है!</li>\n</ol>",
          "id": 7,
          "lessonContent": "थोड़ी देर के लिए प्रक्रिया अनुमतियों में प्रवेश करें, याद रखें कि मैंने आपको बताया था कि जब आप SUID अनुमति बिट सक्षम करके passwd कमांड चलाते हैं तो आप कार्यक्रम को रूट के रूप में चलाएंगे? यह सच है, हालांकि क्या इसका अर्थ है कि आप अस्थायी रूप से रूट होने के कारण अन्य उपयोगकर्ताओं के पासवर्ड को संशोधित कर सकते हैं? नहीं निराशा की बात है!\n\nयह इसलिए है क्योंकि लिनक्स ने कई यूआईडीएस का अमल किया है। प्रत्येक प्रक्रिया के साथ तीन UIDS जुड़े होते हैं:\n\nजब आप किसी प्रक्रिया को लॉन्च करते हैं, तो यह उसी अनुमतियों के साथ चलता है जो उपयोगकर्ता या समूह ने इसे चलाया है, इसे एक <b>प्रभावी उपयोगकर्ता आईडी</b> के रूप में जाना जाता है। यह यूआईडी प्रक्रिया को पहुंच अधिकार देने के लिए उपयोग किया जाता है। इसलिए यदि बॉब ने टच कमांड चलाया, तो प्रक्रिया उसी रूप में चलेगी और उसने बनाए गए किसी भी फ़ाइलें उसके स्वामित्व में होंगी।\n\nएक और UID है, जिसे <b>वास्तविक उपयोगकर्ता आईडी</b> कहा जाता है, यह प्रक्रिया लॉन्च करने वाले उपयोगकर्ता की आईडी है। यह उन्हें ट्रैक करने के लिए उपयोग किए जाते हैं जिन्होंने प्रक्रिया लॉन्च की है।\n\nएक अंतिम UID है <b>बचाया गया उपयोगकर्ता आईडी</b>, यह एक प्रक्रिया को प्रभावी UID और वास्तविक UID के बीच स्विच करने की अनुमति देता है, उल्टा-पुल्टा। यह उपयोगी है क्योंकि हम चाहते हैं कि हमारी प्रक्रिया हमेशा उच्च विशेषाधिकारों के साथ न चले, विशेष समयों पर विशेष विशेषाधिकारों का उपयोग करना अच्छा अभ्यास है।\n\nअब चलो इन सभी को एक साथ जोड़ते हैं और पासवर्ड कमांड को एक बार फिर देखते हैं।\n\nपासवर्ड कमांड चलाने पर, आपकी प्रभावी UID आपकी उपयोगकर्ता आईडी है, चलो कहें अब इसके लिए 500 है। ओह लेकिन रुको, क्या याद है, पासवर्ड कमांड के पास SUID अनुमति सक्षम है। तो जब आप इसे चलाते हैं, तो आपकी प्रभावी UID अब 0 है (0 रूट की UID है)। अब यह कार्यक्रम रूट के रूप में फ़ाइलों तक पहुंच सकता है।\n\nचलो मान लो आपने एक छोटी सी ताकत का स्वाद चखा और आप सैली का पासवर्ड संशोधित करना चाहते हैं, सैली की UID 600 है। तो आपके लिए बड़ी बात है, भाग्यशाली तौर पर प्रक्रिया में आपकी वास्तविक UID भी इस मामले में 500 है। यह जानता है कि आपकी UID 500 है और इसलिए आप 600 की UID का पासवर्ड संशोधित नहीं कर सकते। (यह तब हमेशा उन्हें छोड़ दिया जाता है अगर आप मशीन पर सुपरयूजर हैं और सबकुछ नियंत्रित और बदल सकते हैं)।\n\nजैसे ही आप passwd चलाते हैं, यह आपकी वास्तविक UID का उपयोग करके प्रक्रिया शुरू करेगा, और यह फ़ाइल के मालिक की UID (प्रभावी UID) को बचाएगा, ताकि आप दोनों के बीच स्विच कर सकें। रूट एक्सेस के साथ सभी फ़ाइलों को संशोधित करने की आवश्यकता नहीं है अगर यह आवश्यक नहीं है।\n\nअधिकांश समय वास्तविक UID और प्रभावी UID एक ही होते हैं, लेकिन ऐसे मामलों में जैसे पासवर्ड कमांड वे बदल जाएंगे।",
          "quizAnswer": "प्रभावी",
          "quizQuestion": "कौन सी UID निर्णय करती है कि किसे पहुंच देनी है?",
          "slug": "processpermissions",
          "title": "प्रक्रिया अनुमतियाँ"
        },
        {
          "exercise": "आपको लगता है कि कौन सी अन्य फ़ाइलें और निर्देशिकाएँ स्टिकी बिट सक्षम हैं?",
          "id": 8,
          "lessonContent": "एक आखिरी विशेष अनुमति बिट जिसके बारे में मैं चर्चा करना चाहता हूँ, वह है स्टिकी बिट।\n\nयह अनुमति बिट, एक फ़ाइल/निर्देशिका को 'चिपकाता है' यह यह मतलब है कि केवल मालिक या रूट उपयोगकर्ता ही फ़ाइल को हटा सकते या संशोधित कर सकते हैं। यह साझा निर्देशिकाओं के लिए बहुत उपयोगी है। नीचे दिए गए उदाहरण पर एक नज़र डालें:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nआप यहाँ एक विशेष अनुमति बिट देखेंगे <b>t</b>, इसका मतलब है कि सभी लोग /tmp निर्देशिका में फ़ाइलें जोड़ सकते हैं, फ़ाइलें लिख सकते हैं, फ़ाइलें संशोधित कर सकते हैं, लेकिन केवल रूट /tmp निर्देशिका को हटा सकते हैं।\n\n<b>स्टिकी बिट को संशोधित करें</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nस्टिकी बिट के लिए संख्यात्मक प्रतिनिधित्व <b>1</b> है।",
          "quizAnswer": "t",
          "quizQuestion": "कौन सा प्रतीक स्टिकी बिट का प्रतिनिधित्व करता है?",
          "slug": "stickybit",
          "title": "द स्टिकी बिट"
        }
      ],
      "slug": "permissions",
      "title": "अनुमतियाँ"
    },
    {
      "description": "सिस्टम पर चल रही प्रक्रियाओं के बारे में जानें।",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "विभिन्न झंडों के साथ ps कमांड का उपयोग करें और देखें कि आउटपुट कैसे बदलता है।",
          "id": 1,
          "lessonContent": "प्रक्रियाएँ वे कार्यक्रम हैं जो आपके मशीन पर चल रहे हैं। वे कर्नेल द्वारा प्रबंधित होते हैं और प्रत्येक प्रक्रिया के साथ एक पहचान संबंधित होती है जिसे <b>प्रक्रिया आईडी (PID)</b> कहा जाता है। यह PID प्रक्रियाएँ बनाई जाती हैं उसी क्रम में सौंपा जाता है। \n\nआगे बढ़ें और चलाएं ps कमांड ताकि चल रही प्रक्रियाओं की सूची देख सकें:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nयह आपको वर्तमान प्रक्रियाओं का एक त्वरित स्नैपशॉट दिखाता है:\n\n<ul>\n<li>PID: प्रक्रिया आईडी</li>\n<li>TTY: प्रक्रिया से संबंधित नियंत्रण टर्मिनल (हम इसके बारे में बाद में विस्तार से जाएंगे)</li>\n<li>STAT: प्रक्रिया स्थिति कोड</li>\n<li>TIME: कुल सीपीयू उपयोग समय</li>\n<li>CMD: क्रियाशील/कमांड का नाम</li>\n</ul>\n\nयदि आप ps के मैन पेज पर देखेंगे तो आप देखेंगे कि आप कितने सारे कमांड विकल्प पास कर सकते हैं, वे आपके उपयोग के अनुसार भिन्न होंगे - बीएसडी, जीएनयू या यूनिक्स। मेरी राय में बीएसडी शैली अधिक लोकप्रिय है इसलिए हम उसके साथ जाएंगे। यदि आपको इसमें अंतर की जानकारी चाहिए तो अंतर है कि आप कितनी डैश और झंडे का उपयोग करते हैं।\n\n<pre>$ ps aux</pre>\n\n<b>a</b> सभी प्रक्रियाएँ दिखाता है जो चल रही हैं, जिसमें अन्य उपयोगकर्ताओं द्वारा चलाई जा रही हैं। <b>u</b> प्रक्रियाओं के बारे में अधिक विवरण दिखाता है। और अंततः <b>x</b> उस सभी प्रक्रियाओं की सूची दिखाता है जिनके पास एक TTY संबंधित नहीं है, इन कार्यक्रमों में TTY क्षेत्र में ? दिखाएगा, वे सबसे अधिक सामान्य डेमन प्रक्रियाओं में होते हैं जो प्रणाली स्टार्टअप का हिस्सा होते हैं।\n\nआप अब अधिक फील्ड देख रहे हैं, इन सभी को याद रखने की आवश्यकता नहीं है, एक उन्नत प्रक्रिया पर कोर्स में हम इनमें से कुछ फिर से देखेंगे:\n\n<ul>\n<li>USER: प्रभावी उपयोगकर्ता (जिसका उपयोग हम कर रहे हैं)</li>\n<li>PID: प्रक्रिया आईडी</li>\n<li>%CPU: सीपीयू समय का उपयोग किया गया समय जिसे प्रक्रिया चल रही है</li>\n<li>%MEM: प्रक्रिया के आवासी सेट का अनुपात मशीन पर शारीरिक स्मृति के साथ</li>\n<li>VSZ: पूरी प्रक्रिया का वर्चुअल मेमोरी उपयोग</li>\n<li>RSS: रेजिडेंट सेट साइज, एक कार्य का जो कार्य किया है जिसे नहीं स्वैप किया गया है</li>\n<li>TTY: प्रक्रिया से संबंधित नियंत्रण टर्मिनल</li>\n<li>STAT: प्रक्रिया स्थिति कोड</li>\n<li>START: प्रक्रिया का समय आरंभ</li>\n<li>TIME: कुल सीपीयू उपयोग समय</li>\n<li>COMMAND: क्रियाशील/कमांड का नाम</li>\n</ul>\n\nps कमांड देखने में थोड़ा गंदा हो सकता है, अब तक हम जिन फील्ड को सबसे अधिक देखेंगे वे हैं PID, STAT और COMMAND। \n\nएक और बहुत ही उपयोगी कमांड है <b>top</b> कमांड, top आपको आपके सिस्टम पर चल रही प्रक्रियाओं के वास्तविक समय की जानकारी देता है बजाय एक स्नैपशॉट की। डिफ़ॉल्ट रूप से आपको हर 10 सेकंड में ताजगी मिलेगी। टॉप एक अत्यंत उपयोगी उपकरण है जिससे आप देख सकते हैं कि कौन सी प्रक्रियाएँ आपके संसाधनों का अधिक भाग ले रही हैं। \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "प्रक्रियाओं के बारे में विस्तृत जानकारी देखने के लिए कौन सा ps झंडा उपयोग किया जाता है?",
          "slug": "monitorprocessespscommand",
          "title": "ps (प्रक्रियाएँ)"
        },
        {
          "exercise": "अपने ps आउटपुट पर देखें और सभी अद्वितीय टीटीवाई मानों की सूची बनाएं।",
          "id": 2,
          "lessonContent": "हमने चरणों में एक टीटीवाई क्षेत्र है कैसे चरणों में एक टीटीवाई क्षेत्र है, इस पर चर्चा की। टीटीवाई वह टर्मिनल है जिसने कमांड का निष्पादन किया।\n\nदो प्रकार की टर्मिनल होती हैं, नियमित <b>टर्मिनल उपकरण</b> और <b>प्यूडोटर्मिनल उपकरण</b>। एक नियमित टर्मिनल उपकरण एक स्थानीय टर्मिनल उपकरण है जिसमें आप टाइप कर सकते हैं और अपने सिस्टम को आउटपुट भेज सकते हैं, यह वह टर्मिनल एप्लिकेशन सुनाई देती है जिसे आप अपने शैल में पहुंचने के लिए लॉन्च कर रहे हैं, लेकिन यह नहीं है।\n\nहम इस क्रिया को देखने के लिए जा रहे हैं, आगे बढ़ें और TTY1 (पहली वर्चुअल कंसोल) में पहुंचने के लिए Ctrl-Alt-F1 टाइप करें, आपको ध्यान देना चाहिए कि आपके पास कुछ भी नहीं है केवल टर्मिनल, कोई ग्राफिक्स आदि नहीं। यह एक नियमित टर्मिनल उपकरण माना जाता है, आप इसे Ctrl-Alt-F7 के साथ बाहर निकल सकते हैं।\n\nएक प्यूडोटर्मिनल वह है जिसमें आप काम करने के लिए उपयोग करते थे, वे शैल टर्मिनल विंडो के साथ टर्मिनल को अनुकरण करते हैं और PTS द्वारा दर्शाए जाते हैं। अगर आप फिर से ps देखते हैं, तो आप अपनी शैल प्रक्रिया को pts/* के तहत देखेंगे।\n\nठीक है, अब नियंत्रण टर्मिनल पर वापस आते हैं, प्रक्रियाएँ आम तौर पर एक नियंत्रण टर्मिनल से बांधी जाती हैं। उदाहरण के लिए, यदि आप अपने शैल विंडो पर कोई प्रोग्राम चला रहे होते जैसे find और आप विंडो को बंद कर देते, तो आपकी प्रक्रिया भी उसके साथ चली जाएगी।\n\nडेमन प्रक्रियाओं जैसे प्रक्रियाएँ होती हैं, जो आम तौर पर सिस्टम को चलाए रखने वाली विशेष प्रक्रियाएँ होती हैं। वे अक्सर सिस्टम बूट पर शुरू होती हैं और आम तौर पर सिस्टम बंद होने पर समाप्त हो जाती हैं। वे पिछले प्लान में चलती हैं और क्योंकि हम चाहते हैं कि ये विशेष प्रक्रियाएँ समाप्त न हों, इसलिए उन्हें नियंत्रण टर्मिनल से बांधा नहीं जाता है। ps आउटपुट में, टीटीवाई को <b>?</b> के रूप में दर्शाया गया है जिसका अर्थ है कि इसके पास एक नियंत्रण टर्मिनल नहीं है।",
          "quizAnswer": "?",
          "quizQuestion": "एक प्रक्रिया के लिए कौन सा मान दिया जाता है जिसके पास एक नियंत्रण टर्मिनल नहीं है?",
          "slug": "controllingterminal",
          "title": "टर्मिनल नियंत्रण"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 3,
          "lessonContent": "हम प्रक्रियाओं के और अधिक व्यावहारिक अनुप्रयोगों में पहुंचने से पहले, हमें पहले यह समझना होगा कि वे क्या हैं और वे कैसे काम करते हैं। यह भाग गंभीर हो सकता है क्योंकि हम विस्तार से गहराई में जा रहे हैं, इसलिए अगर आप अभी इसके बारे में सीखना नहीं चाहते हैं तो इस पाठ पर वापस आने का स्वागत है।\n\nजैसा कि हमने पहले कहा था, एक प्रक्रिया एक चल रहा प्रोग्राम है, और अधिक स्पष्टता से यह सिस्टम मेमोरी, सीपीयू, आई/ओ का आवंटन करता है ताकि प्रोग्राम चल सके। एक प्रक्रिया एक चल रहे प्रोग्राम का एक उदाहरण है, आगे बढ़ें और 3 टर्मिनल विंडोज़ खोलें, दो विंडोज़ में, <b>कैट</b> कमांड बिना किसी विकल्प के चलाएँ (कैट प्रक्रिया एक प्रक्रिया के रूप में खुली रहेगी क्योंकि यह stdin की अपेक्षा करती है)। अब तीसरी विंडो में चलाएँ: <b>ps aux | grep कैट</b>। आप देखेंगे कि कैट के लिए दो प्रक्रियाएँ हैं, हालांकि वे एक ही प्रोग्राम को कॉल कर रहे हैं।\n\nकर्नेल प्रक्रियाओं का देखभाल करता है, जब हम एक प्रोग्राम चलाते हैं तो कर्नेल प्रोग्राम का कोड मेमोरी में लोड करता है, संसाधनों का निर्धारण और आवंटन करता है और फिर हर प्रक्रिया पर नजर रखता है, इसे पता है:\n\n<ul>\n<li>प्रक्रिया की स्थिति</li>\n<li>प्रक्रिया द्वारा उपयोग और प्राप्त किए गए संसाधन</li>\n<li>प्रक्रिया के मालिक</li>\n<li>सिग्नल हैंडलिंग (इस पर बाद में अधिक)</li>\n<li>और मुख्य रूप से सब कुछ अन्य</li>\n</ul>\n\nसभी प्रक्रियाएँ उस मीठे संसाधन पाई का एक स्वाद लेने की कोशिश कर रही हैं, कर्नेल का काम है कि प्रक्रियाएँ प्रक्रिया मांगों के आधार पर सही मात्रा में संसाधन प्राप्त करें। जब कोई प्रक्रिया समाप्त होती है, तो उसे उपयोग किए गए संसाधन अब अन्य प्रक्रियाओं के लिए मुक्त हो जाते हैं।",
          "quizAnswer": "कर्नेल",
          "quizQuestion": "प्रक्रियाओं का प्रबंधन और नियंत्रण कौन करता है?",
          "slug": "प्रक्रियाविवरण",
          "title": "प्रक्रिया विवरण"
        },
        {
          "exercise": "अपनी चल रही प्रक्रियाओं की जाँच करें, क्या आप देख सकते हैं कि अन्य प्रक्रियाओं के माता हैं?",
          "id": 4,
          "lessonContent": "फिर से यह सबक और अगला केवल जानकारी है जिससे आप देख सकते हैं कि डिवाइस के नीचे क्या है, प्रक्रियाओं के साथ काम करने के बाद इस पर वापस आने का मन करता है।\n\nजब एक नई प्रक्रिया बनाई जाती है, तो एक मौजूदा प्रक्रिया ने अक्सर खुद को क्लोन करते हुए कुछ नया उत्पन्न करती है, जिसे कुछ फॉर्क सिस्टम कॉल कहा जाता है (सिस्टम कॉल को बहुत दूर भविष्य में चर्चा की जाएगी)। फॉर्क सिस्टम कॉल एक अधिकांश तौर पर एक समान बच्चा प्रक्रिया बनाता है, यह बच्चा प्रक्रिया एक नया प्रक्रिया आईडी (पीआईडी) लेती है और मूल प्रक्रिया इसकी माता प्रक्रिया बन जाती है और उसके पास कुछ नामक एक माता प्रक्रिया आईडी <b>PPID</b> होती है। इसके बाद, बच्चा प्रक्रिया या तो अपने माता द्वारा पहले उपयोग किए जाने वाले प्रोग्राम का उपयोग कर सकती है या अधिकतर नए प्रोग्राम को लॉन्च करने के लिए execve सिस्टम कॉल का उपयोग कर सकती है। यह सिस्टम कॉल उस प्रक्रिया के लिए मेमोरी प्रबंधन को नष्ट कर देता है जिसे कर्नेल ने उस प्रोग्राम के लिए रखा था और नए प्रोग्राम के लिए नए प्रबंधन को सेट करता है।\n\nहम इसे कार्रवाई में देख सकते हैं:\n\n<pre>$ ps l</pre>\n\nएल विकल्प हमें हमारी चल रही प्रक्रियाओं का \"लॉन्ग फॉर्मेट\" या और अधिक विस्तृत दृश्य देता है। आपको एक स्तंभ दिखाई देगा जिसे <b>PPID</b> लेबल किया गया है, यह माता पहचान है। अब अपने टर्मिनल पर देखें, आपको एक प्रक्रिया दिखाई देगी जो आपका शैल चल रही है, इसलिए मेरे सिस्टम पर मेरे पास एक प्रक्रिया है जो बैश चल रही है। अब जब आपने ps l कमांड चलाई थी, तो आप उस प्रक्रिया से चल रहे थे जो बैश चल रही थी। अब आप देखेंगे कि बैश शैल का <b>PID</b> ps l कमांड का <b>PPID</b> है।\n\nतो यदि प्रत्येक प्रक्रिया को माता होना चाहिए और वे एक-दूसरे के क्लोन हैं, तो सभी प्रक्रियाओं की मां होनी चाहिए, ना? आप सही हैं, जब सिस्टम बूट होता है, कर्नेल <b>init</b> नामक एक प्रक्रिया बनाता है, इसका पीआईडी 1 होता है। इनिट प्रक्रिया को सिस्टम बंद नहीं किया जा सकता है जब तक सिस्टम बंद नहीं होता। यह रूट विशेषाधिकारों के साथ चलती है और उस प्रक्रियाओं को चलाती है जो सिस्टम को चलाए रखती हैं। हम इनिट पर एक नज़र डालेंगे सिस्टम बूटअप पाठ्यक्रम में, अब केवल यह जानिए कि यह वह प्रक्रिया है जो सभी अन्य प्रक्रियाओं को उत्पन्न करती है।",
          "quizAnswer": "फोर्क",
          "quizQuestion": "कौन सिस्टम कॉल एक नई प्रक्रिया बनाता है?",
          "slug": "processcreation",
          "title": "प्रक्रिया निर्माण"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं है।",
          "id": 5,
          "lessonContent": "अब जब हमें पता चल गया है कि प्रक्रिया बनाई जाती है तो उसका क्या होता है, तो जब हमें उसकी आवश्यकता नहीं होती है तो क्या हो रहा है? सावधान रहें, कभी-कभी लिनक्स थोड़ा अंधेरा हो सकता है...\n\nएक प्रक्रिया _exit सिस्टम कॉल का उपयोग करके बाहर निकल सकती है, जिससे प्रक्रिया द्वारा उपयोग किए जा रहे संसाधनों को पुनर्निर्धारण के लिए मुक्त कर दिया जाएगा। तो जब एक प्रक्रिया समाप्त होने के लिए तैयार होती है, तो यह कर्नेल को यह बताती है कि वह क्यों समाप्त हो रही है कुछ ऐसा जिसे समाप्ति स्थिति कहा जाता है। सबसे आम रूप से स्थिति 0 का अर्थ है कि प्रक्रिया सफल रही है। हालांकि, इससे प्रक्रिया को पूरी तरह से समाप्त करने के लिए पर्याप्त नहीं है। माता प्रक्रिया को बच्चे की समाप्ति को स्वीकार करना होता है जिसे वेट सिस्टम कॉल का उपयोग करके किया जाता है और यह क्या करता है यह बच्चे की समाप्ति स्थिति की जांच करता है। मुझे इसके बारे में सोचना भयंकर लगता है, लेकिन वेट कॉल एक आवश्यकता है, उसके बाद क्या माता नहीं चाहेगी कि उसके बच्चे कैसे मरे?\n\nएक प्रक्रिया को समाप्त करने का एक और तरीका है और इसमें सिग्नल का उपयोग करना शामिल है, जिस पर हम जल्द ही चर्चा करेंगे।\n\n<b>अनाथ प्रक्रियाएँ</b>\n\nजब एक माता प्रक्रिया एक बच्ची प्रक्रिया से पहले मर जाती है, तो कर्नेल को पता होता है कि यह वेट कॉल नहीं मिलेगा, इसलिए इसे ये प्रक्रियाएँ \"अनाथ\" बना देता है और इन्हें इनिट की देखभाल में डाल देता है (सभी प्रक्रियाओं की जननी याद रखें)। इनिट अंततः इन अनाथों के लिए वेट सिस्टम कॉल करेगा ताकि वे मर सकें।\n\n<b>जॉम्बी प्रक्रियाएँ</b>\n\nजब एक बच्चा समाप्त होता है और माता प्रक्रिया ने अब तक वेट कॉल नहीं किया है, तो हमें यह देखने की अनुमति चाहिए कि एक बच्चे की प्रक्रिया कैसे समाप्त हुई, इसलिए हालांकि बच्चे की प्रक्रिया समाप्त हो गई, कर्नेल बच्चे की प्रक्रिया को जॉम्बी प्रक्रिया में बदल देता है। बच्चे की प्रक्रिया ने उपयोग किए गए संसाधन अब भी अन्य प्रक्रियाओं के लिए मुक्त हैं, हालांकि इस जॉम्बी के लिए प्रक्रिया सूची में एक प्रविष्टि है। जॉम्बी प्रक्रियाएँ भी मारी नहीं जा सकतीं, क्योंकि वे तकनीकी रूप से \"मर चुके\" हैं, इसलिए आप उन्हें मारने के लिए सिग्नल का उपयोग नहीं कर सकते। अंततः अगर माता प्रक्रिया वेट सिस्टम कॉल करती है, तो जॉम्बी गायब हो जाएगी, इसे \"बचाव\" कहा जाता है। अगर माता वेट कॉल नहीं करती है, तो इनिट जॉम्बी को गोद लेगा और स्वचालित रूप से वेट करेगा और जॉम्बी को हटा देगा। बहुत सारी जॉम्बी प्रक्रियाओं को रखना बुरा हो सकता है, क्योंकि वे प्रक्रिया सूची पर जगह लेते हैं, यदि यह भर जाता है तो यह अन्य प्रक्रियाओं को चलाने से रोकेगा।",
          "quizAnswer": "0",
          "quizQuestion": "प्रक्रिया सफल होने के लिए सबसे सामान्य समाप्ति स्थिति क्या है?",
          "slug": "processtermination",
          "title": "प्रक्रिया समाप्ति"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 6,
          "lessonContent": "एक सिग्नल प्रक्रिया को सूचित करता है कि कुछ हो गया है।\n\n<b>हमारे पास सिग्नल्स क्यों हैं</b>\n\nवे सॉफ़्टवेयर अंटरप्ट्स हैं और उनका कई उपयोग हैं:\n\n<ul>\n<li>एक उपयोगकर्ता विशेष टर्मिनल वर्ण (Ctrl-C) या (Ctrl-Z) टाइप कर सकता है ताकि प्रक्रियाओं को मार दिया जा सके, रोका जा सके या विरामित किया जा सके</li>\n<li>हार्डवेयर समस्याएँ हो सकती हैं और कर्नेल प्रक्रिया को सूचित करना चाहता है</li>\n<li>सॉफ़्टवेयर समस्याएँ हो सकती हैं और कर्नेल प्रक्रिया को सूचित करना चाहता है</li>\n<li>वे मुख्य रूप से प्रक्रियाएँ संचार कर सकती हैं</li>\n</ul>\n\n<b>सिग्नल प्रक्रिया</b>\n\nजब कोई घटना द्वारा एक सिग्नल उत्पन्न होता है, तो यह फिर प्रक्रिया को पहुंचाया जाता है, यह एक पेंडिंग स्थिति में माना जाता है जब तक यह पहुंचाया नहीं जाता है। जब प्रक्रिया चलाई जाती है, तो सिग्नल पहुंचाया जाएगा। हालांकि, प्रक्रियाओं के सिग्नल मास्क होते हैं और वे सिग्नल वितरण को निर्दिष्ट करने के लिए अगर निर्दिष्ट किया गया है तो उन्हें अवरोधित कर सकते हैं। जब एक सिग्नल पहुंचाया जाता है, तो प्रक्रिया कई चीजें कर सकती है:\n\n<ul>\n<li>सिग्नल को नजरअंदाज करें</li>\n<li>सिग्नल को \"पकड़ें\" और विशेष हैंडलर रूटीन का पालन करें</li>\n<li>प्रक्रिया को समाप्त किया जा सकता है, सामान्य बाहरी सिस्टम कॉल के विपरीत</li>\n<li>सिग्नल को अवरोधित करें, सिग्नल मास्क के आधार पर</li>\n</ul>\n\n<b>सामान्य सिग्नल्स</b>\n\nप्रत्येक सिग्नल को संकेतिक नामों के साथ पूर्णांकों द्वारा परिभाषित किया गया है जो SIGxxx के रूप में हैं। कुछ सबसे सामान्य सिग्नल्स में से कुछ हैं:\n\n<ul>\n<li>SIGHUP या HUP या 1: हैंगअप</li>\n<li>SIGINT या INT या 2: अंतर्रुप्त</li>\n<li>SIGKILL या KILL या 9: मारें</li>\n<li>SIGSEGV या SEGV या 11: सेगमेंटेशन फॉल्ट</li>\n<li>SIGTERM या TERM या 15: सॉफ़्टवेयर समाप्ति</li>\n<li>SIGSTOP या STOP: रोकें</li>\n</ul>\n\nसंख्याएँ सिग्नल्स के साथ भिन्न हो सकती हैं इसलिए वे आमतौर पर अपने नामों द्वारा संदर्भित किए जाते हैं।\n\nकुछ सिग्नल अवरोधनीय होते हैं, उनमें से एक उदाहरण है SIGKILL सिग्नल। किल सिग्नल प्रक्रिया को नष्ट कर देता है।",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "कौन सा सिग्नल अवरोधनीय है?",
          "slug": "प्रक्रियासिग्नल्स",
          "title": "सिग्नल्स"
        },
        {
          "exercise": "विभिन्न सिग्नल्स का उपयोग करके कुछ प्रक्रियाएँ मारें।",
          "id": 7,
          "lessonContent": "आप प्रक्रियाओं को समाप्त करने के लिए सिग्नल भेज सकते हैं, इस तरह का एक कमांड किल कमांड नामक है। \n\n<pre>$ kill 12445</pre>\n\n12445 प्रक्रिया की PID है जिसे आप मारना चाहते हैं। डिफ़ॉल्ट रूप से यह एक TERM सिग्नल भेजता है। SIGTERM सिग्नल प्रक्रिया को इसके संसाधनों को साफ करने और इसकी स्थिति को बचाने की अनुमति देकर इसकी समाप्ति का अनुरोध करने के लिए एक प्रक्रिया को भेजा जाता है। \n\nआप किल कमांड के साथ एक सिग्नल भी निर्दिष्ट कर सकते हैं: \n\n<pre>$ kill -9 12445</pre>\n\nयह SIGKILL सिग्नल चलाएगा और प्रक्रिया को मार देगा। \n\n<b>SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP के बीच अंतर?</b>\n\nये सभी सिग्नल समझने में उचित लगते हैं, लेकिन उनके अंतर होते हैं। \n\n<ul>\n<li>SIGHUP - हैंगअप, जब नियंत्रण टर्मिनल बंद होता है तो प्रक्रिया को भेजा जाता है। उदाहरण के लिए, अगर आपने एक टर्मिनल विंडो बंद की जिसमें एक प्रक्रिया चल रही थी, तो आपको एक SIGHUP सिग्नल मिलेगा। तो मुख्य रूप से आपको हंगअप किया गया है</li>\n<li>SIGINT - एक अंतर्रुप्त सिग्नल है, इसलिए आप Ctrl-C का उपयोग कर सकते हैं और सिस्टम प्रक्रिया को सौम्यता से मारने का प्रयास करेगा</li>\n<li>SIGTERM - प्रक्रिया को मारेगा, लेकिन इसे कुछ सफाई करने की अनुमति देगा</li>\n<li>SIGKILL - प्रक्रिया को मार देगा, आग से मार देगा, कोई सफाई नहीं करेगा</li>\n<li>SIGSTOP - एक प्रक्रिया को रोकेगा/सस्पेंड करेगा</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "डिफ़ॉल्ट किल कमांड के लिए सिग्नल का नाम क्या है?",
          "slug": "प्रक्रियाएँमारना",
          "title": "मारना (Terminate)"
        },
        {
          "exercise": "कौन सी प्रक्रियाएँ बहुत अच्छी नहीं हैं और क्यों?",
          "id": 8,
          "lessonContent": "जब आप अपने कंप्यूटर पर कई चीजें चलाते हैं, जैसे कि शायद Chrome, Microsoft Word या Photoshop एक साथ, तो ऐसा लग सकता है कि ये प्रक्रियाएँ एक साथ चल रही हैं, लेकिन यह पूरी तरह से सच नहीं है।\n\nप्रक्रियाएँ CPU का एक छोटा समय टुकड़ा उपयोग करती हैं जिसे टाइम स्लाइस कहा जाता है। फिर वे मिलीसेकंड के लिए रुक जाती हैं और एक और प्रक्रिया को थोड़ा समय स्लाइस मिलता है। डिफ़ॉल्ट रूप से, प्रक्रिया अनुसूचना इस गोल-रॉबिन फैशन में होती है। हर प्रक्रिया को पर्याप्त समय स्लाइस मिलता है जब तक वह प्रसंस्करण समाप्त नहीं हो जाता। कर्नल इन प्रक्रियाओं के स्विचिंग का सभी का सम्भाल करता है और यह ज्यादातर समय में अच्छा काम करता है।\n\nप्रक्रियाएँ CPU समय का निर्णय कब और कितना लें, यह नहीं कर सकती है, यदि सभी प्रक्रियाएँ सामान्य रूप से व्यवहार करती हैं तो वे प्रत्येक (लगभग) बराबर मात्रा में CPU समय प्राप्त करेंगी। हालांकि, कर्नल की प्रक्रिया अनुसूचना एल्गोरिदम को एक अच्छा मार्ग दिखाने का एक तरीका है नाइस मूल्य। सुंदरता एक काफी अजीब नाम है, लेकिन इसका मतलब है कि प्रक्रियाओं के प्राथमिकता को निर्धारित करने के लिए एक संख्या होती है। एक उच्च संख्या का मतलब है कि प्रक्रिया अच्छी है और उसके पास CPU के लिए निम्नतम प्राथमिकता है और एक कम या नकारात्मक संख्या का मतलब है कि प्रक्रिया बहुत अच्छी नहीं है और यह जितना संभावन है CPU को प्राप्त करना चाहती है।\n\n<pre>$ top</pre>\n\nआप अब एक NI कॉलम देख सकते हैं, यह प्रक्रिया का सुंदरता स्तर है।\n\nसुंदरता स्तर बदलने के लिए आप नाइस और रेनाइस कमांड का उपयोग कर सकते हैं:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nनाइस कमांड का उपयोग नई प्रक्रिया के लिए प्राथमिकता सेट करने के लिए किया जाता है। रेनाइस कमांड का उपयोग मौजूदा प्रक्रिया पर प्राथमिकता सेट करने के लिए किया जाता है।\n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "कम",
          "quizQuestion": "अगर मुझे किसी प्रक्रिया को अधिक CPU प्राथमिकता देनी हो, तो क्या मैं एक कम या उच्च नाइस संख्या का उपयोग करूँ?",
          "slug": "प्रक्रियासुंदरता",
          "title": "सुंदरता"
        },
        {
          "exercise": "अपने सिस्टम पर चल रही प्रक्रियाओं की जाँच करें और उनकी प्रक्रिया स्थितियों की जाँच करें।",
          "id": 9,
          "lessonContent": "चलिए फिर से ps aux कमांड पर एक नज़र डालते हैं:\n\n<pre>$ ps aux</pre>\n\nSTAT स्तंभ में, आपको कई मान दिखाई देंगे। एक लिनक्स प्रक्रिया कई विभिन्न स्थितियों में हो सकती है। आपको नीचे दिए गए सबसे सामान्य स्थिति कोड दिखाई देंगे:\n\n<ul>\n<li>R: चल रहा है या चलने योग्य, यह बस CPU का इंतजार कर रहा है कि उसे प्रोसेस करे</li>\n<li>S: अविलंब नींद, किसी घटना को पूरा करने के लिए प्रतीक्षा कर रहा है, जैसे कि टर्मिनल से इनपुट</li>\n<li>D: अविलंब नींद, प्रक्रियाएँ जिन्हें मार या सिग्नल के साथ रोका नहीं जा सकता, सामान्यत: इन्हें चलाने के लिए आपको रिबूट करना होगा या समस्या को ठीक करना होगा</li>\n<li>Z: ज़ॉम्बी, हमने पिछले सबक में चर्चा की थी कि ज़ॉम्बी अंतिम प्रक्रियाएँ हैं जो अपनी स्थितियों का संग्रहण करने के लिए प्रतीक्षा कर रही हैं</li>\n<li>T: रुका हुआ, एक प्रक्रिया जिसे निलंबित/रोक दिया गया है</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "एक अविलंब नींद को प्रतिनिधित्व करने के लिए कौन सा STAT कोड उपयोग किया जाता है?",
          "slug": "प्रक्रियास्थितियाँ",
          "title": "प्रक्रिया स्थितियाँ"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 10,
          "lessonContent": "ध्यान रखें कि लिनक्स में सभी चीजें एक फ़ाइल हैं, यहाँ तक कि प्रक्रियाएँ भी। प्रक्रिया सूचना एक विशेष फ़ाइल सिस्टम में संग्रहित होती है जिसे /proc फ़ाइल सिस्टम के रूप में जाना जाता है।\n\n<pre>$ ls /proc</pre>\n\nआपको यहाँ कई मान दिखने चाहिए, हर पीआईडी के लिए उप-निर्देशिकाएँ हैं। यदि आप ps आउटपुट में किसी पीआईडीआई को देखते हैं, तो आप /proc निर्देशिका में उसे खोज सकते हैं।\n\nआगे बढ़ें और किसी प्रक्रिया में जाएं और उस फ़ाइल को देखें:\n\n<pre>$ cat /proc/12345/status</pre>\n\nआपको प्रक्रिया स्थिति सूचना और अधिक विस्तृत जानकारी दिखनी चाहिए। /proc निर्देशिका कर्नल के द्वारा प्रणाली को कैसे देखता है, इसलिए यहाँ ps में देखने जैसी जानकारी से बहुत अधिक जानकारी है।",
          "quizAnswer": "/proc",
          "quizQuestion": "कौन सा फ़ाइल सिस्टम प्रक्रिया सूचना संग्रहित करता है?",
          "slug": "procfilesystem",
          "title": "/proc फ़ाइल सिस्टम"
        },
        {
          "exercise": "कुछ नौकरियों को पृष्ठभूमि और पृष्ठ में ले जाएं",
          "id": 11,
          "lessonContent": "चलो मान लो कि आप एक ही टर्मिनल विंडो पर काम कर रहे हैं और आपका कमांड बहुत समय ले रहा है। जब तक यह पूरा नहीं होता, तब तक आप शैल के साथ इंटरैक्ट नहीं कर सकते, हालांकि हमें अपनी मशीन पर काम करना जारी रखना है, इसलिए हमें उस शैल को खोला रखने की आवश्यकता है। भागों के साथ हम अपने प्रक्रियाओं को कैसे चलाएं इसे नियंत्रित कर सकते हैं: \n\n<b>पृष्ठभूमि पर नौकरी भेजना</b>\n\nकमांड के अंत में एम्परसैंड (&) जोड़ने से यह पृष्ठभूमि में चलाया जाएगा ताकि आप अपनी शैल का उपयोग कर सकें। चलो एक उदाहरण देखते हैं:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>सभी पृष्ठभूमि पर नौकरियाँ देखें</b>\n\nअब आप उन नौकरियों को देख सकते हैं जिन्हें आपने हाल ही में पृष्ठभूमि पर भेजा है।\n\n<pre>$ jobs\n\n[1]    Running     sleep 1000 &\n[2]-   Running     sleep 1001 &\n[3]+   Running     sleep 1002 &\n\n</pre>\n\nयह आपको पहले स्तंभ में नौकरी आईडी दिखाएगा, फिर स्थिति और उस कमांड को जो चलाया गया था। जॉब आईडी के पास <b>+</b> का मतलब है कि यह सबसे हाल ही में शुरू हुई पृष्ठभूमि नौकरी है। <b>-</b> के साथ नौकरी दूसरी सबसे हाल ही में चलाई गई कमांड है।\n\n<b>मौजूदा नौकरी पृष्ठभूमि पर भेजना</b>\n\nअगर आपने पहले से ही एक नौकरी चलाई है और उसे पृष्ठभूमि पर भेजना चाहते हैं, तो आपको उसे समाप्त नहीं करना है और फिर से शुरू करना है। पहले Ctrl-Z के साथ नौकरी को रोकें, फिर <b>bg</b> कमांड चलाएं ताकि उसे पृष्ठभूमि पर भेजा जा सके।\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Stopped     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Running     sleep 1000 &\n[2]    Running     sleep 1001 &\n[3]-   Running     sleep 1002 &\n[4]+   Running     sleep 1003 &\n</pre>\n\n<b>पृष्ठभूमि से पृष्ठ में नौकरी ले जाना</b>\n\nपृष्ठभूमि से नौकरी बाहर लेने के लिए बस उस नौकरी आईडी को निर्दिष्ट करें। यदि आप किसी विकल्प के बिना fg चलाते हैं, तो यह सबसे हाल ही में शुरू हुई पृष्ठभूमि नौकरी लाएगा (जो + चिह्न के साथ है)\n\n<pre>$ fg %1</pre>\n\n<b>पृष्ठभूमि नौकरियों को मारना</b>\n\nपृष्ठभूमि से नौकरियों को बाहर लेने के तरह, आप उन प्रक्रियाओं को मारने के लिए उनके जॉब आईडी का उपयोग कर सकते हैं।\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "पृष्ठभूमि पर नौकरियाँ सूचित करने के लिए कौन सा कमांड उपयोग किया जाता है?",
          "slug": "नौकरीनियंत्रण",
          "title": "नौकरी नियंत्रण"
        }
      ],
      "slug": "processes",
      "title": "प्रक्रियाएँ"
    },
    {
      "description": "dpkg, apt-get, rpm और yum पैकेज प्रबंधन उपकरणों के बारे में सभी जानें।",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 1,
          "lessonContent": "आपका सिस्टम इंटरनेट ब्राउज़र, टेक्स्ट संपादक, मीडिया प्लेयर आदि जैसे कई पैकेजों से मिलकर बना होता है। ये पैकेज पैकेज प्रबंधकों के माध्यम से प्रबंधित होते हैं, जो आपके सिस्टम पर सॉफ़्टवेयर को स्थापित और बनाए रखते हैं। हालांकि सभी पैकेज पैकेज प्रबंधकों के माध्यम से ही स्थापित नहीं होते, आप सामान्यत: पैकेजों को सीधे उनके स्रोत कोड से स्थापित कर सकते हैं (हम जल्द ही उस पर पहुंचेंगे)। हालांकि अधिकांश समय आप सॉफ़्टवेयर को स्थापित करने के लिए पैकेज प्रबंधक का उपयोग करेंगे, सबसे सामान्य प्रकार के पैकेज Debian (.deb) और Red Hat (.rpm) होते हैं। Debian स्टाइल के पैकेज Debian, Ubuntu, LinuxMint आदि जैसी वितरणों में प्रयोग किए जाते हैं। Red Hat स्टाइल के पैकेज Red Hat Enterprise Linux, Fedora, CentOS आदि में देखे जाते हैं।\n\nपैकेज क्या हैं? आप उन्हें Chrome, Photoshop आदि के रूप में जानते हो सकते हैं और वे ऐसे ही हैं, लेकिन वास्तव में ये केवल बहुत सारी फ़ाइलें हैं जो एक में संकलित की गई हैं। इस सॉफ़्टवेयर को लिखने वाले लोगों को <b>अपस्ट्रीम प्रदाता</b> के रूप में जाना जाता है, वे अपनी कोड को कंपाइल करते हैं और इसे स्थापित करने के लिए लिखते हैं। ये अपस्ट्रीम प्रदाता नए सॉफ़्टवेयर को बाहर निकालने और मौजूदा सॉफ़्टवेयर को अपडेट करने पर काम करते हैं। जब वे इसे दुनिया को जारी करने के लिए तैयार होते हैं, तो वे अपना पैकेज <b>पैकेज रखरखावकर्ताओं</b> को भेजते हैं, जो उपयोगकर्ताओं के हाथों में इस सॉफ़्टवेयर को पहुंचाने में सहायता करते हैं। ये पैकेज रखरखावकर्ता इस सॉफ़्टवेयर की समीक्षा, प्रबंधन और पैकेज के रूप में वितरण करते हैं।",
          "quizAnswer": "",
          "quizQuestion": "कोई प्रश्न नहीं, आगे बढ़ें!",
          "slug": "softwaredistribution",
          "title": "सॉफ़्टवेयर वितरण"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं।",
          "id": 2,
          "lessonContent": "इंटरनेट पर अपलोड किए गए पैकेज कैसे हमारे कंप्यूटर पर पहुंच जाते हैं? क्या आप हर पैकेज के डाउनलोड पेज पर जाकर डाउनलोड और इंस्टॉल करने के लिए क्लिक करते हैं? वास्तव में आप ऐसा कर सकते हैं, लेकिन इसके लिए कुछ बेहतर चीज है जिसे पैकेज रिपॉजिटरीज कहा जाता है। रिपॉजिटरीज सिर्फ पैकेजों के लिए एक केंद्रीय स्टोरेज स्थान होते हैं। बहुत सारी रिपॉजिटरीज होती हैं जो कई पैकेजों को धारण करती हैं और सबसे अच्छी बात यह है कि ये सभी इंटरनेट पर मिलती हैं, कोई मौजूदा इंस्टॉलेशन डिस्क नहीं। आपकी मशीन इन रिपॉजिटरीज को कहां देखना है यह नहीं जानती जब तक आप उसे स्पष्ट रूप से नहीं बताते।\n\nउदाहरण के लिए, मान लीजिए मुझे अपनी मशीन पर वैकीविजेट्स सॉफ़्टवेयर चाहिए। अब वैकीविजेट्स अपने विजेट पैकेजों के लिए अपनी रिपॉजिटरीज का प्रबंधन करते हैं, इस रिपॉजिटरी में 10 पैकेज हैं, कूलविजेट पैकेज, सुपरविजेट पैकेज, आदि। वैकीविजेट्स इस रिपॉजिटरी को एक स्रोत लिंक पर होस्ट करते हैं जिसे: http://download.widgets/linux/deb/ कहा जाता है।\n\nअब सीधे पैकेज डाउनलोड करने के लिए उनकी वेबसाइट पर जाने की बजाय, आप अपनी मशीन को स्रोत लिंक से वैकीविजेट्स सॉफ़्टवेयर ढूंढने के लिए बता सकते हैं।\n\nआपका वितरण पहले से ही पैकेज प्राप्त करने के लिए मंजूर स्रोतों के साथ आता है और यह वही है जिससे आपके सिस्टम पर देखने को मिलने वाले सभी मूल पैकेजों को इंस्टॉल करता है। एक डेबियन सिस्टम पर, यह स्रोत फ़ाइल <b>/etc/apt/sources.list</b> फ़ाइल होती है। आपकी मशीन जानेगी कि वहां देखने के लिए कहां देखना है और आपने किसी भी स्रोत रिपॉजिटरी जोड़ी है उसकी जांच करेगी।",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "एक डेबियन सिस्टम में स्रोत फ़ाइल कहाँ है?",
          "slug": "packagerepositories",
          "title": "पैकेज रिपॉजिटरीज"
        },
        {
          "exercise": "तार दस्तावेज़ को परिचित करें और मैनपेज में उपलब्ध अन्य विकल्पों की जाँच करें।",
          "id": 3,
          "lessonContent": "पैकेज स्थापना और विभिन्न प्रबंधकों में पहुंचने से पहले, हमें फ़ाइलों को संग्रहीत और संक्षिप्त करने की चर्चा करनी होगी, क्योंकि आपको इंटरनेट पर सॉफ़्टवेयर खोजते समय इन से अधिक परिचित होने की संभावना है।\n\nशायद आप पहले से ही जानते हैं कि फ़ाइल संग्रहण क्या है, आपने .rar और .zip जैसे फ़ाइल प्रकारों का सामना किया है। ये फ़ाइलों का संग्रहण हैं, उनमें कई फ़ाइलें होती हैं, लेकिन ये एक बहुत ही सुव्यवस्थित एकल फ़ाइल के रूप में आते हैं जिसे संग्रह कहा जाता है।\n\n<b>gzip के साथ फ़ाइलों को संक्षिप्त करना</b>\n\ngzip एक कार्यक्रम है जिसका उपयोग फ़ाइलों को संक्षिप्त करने के लिए लिनक्स में किया जाता है, इनका एक .gz एक्सटेंशन होता है।\n\nफ़ाइल को संक्षिप्त करने के लिए:\n<pre>$ gzip mycoolfile</pre>\n\nफ़ाइल को डीकंप्रेस करने के लिए:\n<pre>$ gunzip mycoolfile.gz</pre>\n\n<b>tar के साथ संग्रह बनाना</b>\nदुर्भाग्य से, gzip हमारे लिए एक संग्रह में कई फ़ाइलें नहीं जोड़ सकता। भाग्य से हमारे पास ऐसा करने वाला tar कार्यक्रम है। जब आप tar का उपयोग करके एक संग्रह बनाते हैं, तो इसमें .tar एक्सटेंशन होता है।\n\n<pre>$ tar cvf mytarfile.tar mycoolfile1 mycoolfile 2</pre>\n\n<ul>\n<li>c - बनाना</li>\n<li>v - कार्यक्रम को संवेदनशील बनाने के लिए और हमें दिखाने के लिए</li>\n<li>f - तार फ़ाइल का नाम इस विकल्प के बाद आना चाहिए, यदि आप एक तार फ़ाइल बना रहे हैं तो आपको एक नाम सोचना होगा</li>\n</ul>\n\n<b>tar के साथ संग्रह का अनपैक करना</b>\n\nतार फ़ाइल की सामग्री को निकालने के लिए, इस्तेमाल करें: \n\n<pre>$ tar xvf mytarfile.tar</pre>\n\n<ul>\n<li>x - निकालना</li>\n<li>v - कार्यक्रम को संवेदनशील बनाने के लिए और हमें दिखाने के लिए</li>\n<li>f - आप जिस फ़ाइल को निकालना चाहते हैं</li>\n</ul>\n\n<b>tar और gzip के साथ संग्रह को संक्षिप्त/असंक्षिप्त करना</b>\n\nअक्सर आपको एक संक्षिप्त तार फ़ाइल दिखाई देगी जैसे: mycompressedarchive.tar.gz, आपको केवल बाहर से काम करना है, इसलिए पहले gunzip के साथ संक्षिप्त को हटाएं और फिर आप तार फ़ाइल को अनपैक कर सकते हैं। या आप वैकल्पिक रूप से tar के साथ <b>z</b> विकल्प का उपयोग कर सकते हैं, जो बस इसे कहता है कि यह gzip या gunzip यूटिलिटी का उपयोग करेगा।\n\nएक संक्षिप्त तार फ़ाइल बनाएं:\n<pre>$ tar czf myfile.tar.gz</pre>\n\nअसंक्षिप्त और अनपैक: \n<pre>$ tar xzf file.tar</pre>\n\nयदि आपको मदद की आवश्यकता है तो याद रखें: e<b>X</b>tract all <b>Z</b>ee <b>F</b>iles!\n\ntar एक उन कमांडों में से एक है जो इतना महत्वपूर्ण है और फिर भी आप कभी वास्तव में इसे याद नहीं करते, संबंधित xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>अन्य उपयोगिताएँ</b>\n\nलिनक्स के आपके सफर के दौरान, आपको अन्य संग्रह और संक्षेपण प्रकारों से जैसे: bzip2, compress, zip, unzip, आदि का सामना होगा। वे थोड़े कम सामान्य हैं, लेकिन ध्यान रखें कि विभिन्न उपयोगिताएँ विभिन्न कमांड के लिए कह सकती हैं।",
          "quizAnswer": "c",
          "quizQuestion": "संग्रह बनाने के लिए कौन सा तार फ्लैग उपयोग किया जाता है?",
          "slug": "compressedarchivestar",
          "title": "तार और ग्जिप"
        },
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं है।",
          "id": 4,
          "lessonContent": "पैकेज अकेले काम करते हैं बहुत कम, वे अक्सर उन्हें चलाने में मदद करने वाले डिपेंडेंसीज के साथ होते हैं। उदाहरण के लिए, चलो मान लेते हैं हमारे पास कुछ रेस्तरां हैं, ये सभी विभिन्न खाना बनाते हैं, हालांकि वे सभी एक ही खेत से अपनी सामग्री प्राप्त करते हैं। उनका खाना खेत की आपूर्ति पर निर्भर है, अगर खेत अचानक खाना देना बंद कर देता है, तो फिर रेस्तरां बहुत बुरी स्थिति में होंगे। \n\nLinux में, ये डिपेंडेंसीज अक्सर अन्य पैकेज या साझा लाइब्रेरीज होती हैं। साझा लाइब्रेरीज कोड की लाइब्रेरीज हैं जिन्हें अन्य कार्यक्रम उपयोग करना चाहते हैं और वे खुद के लिए फिर से लिखना नहीं चाहते। फिर से रेस्तरां की ओर सोचें, हर रेस्तरां अपना खाना खुद ही खेती तो कितना काम होगा? बहुत ज्यादा।\n\nहम फाइल सिस्टम कोर्स में साझा लाइब्रेरीज में और अधिक जाएंगे, तो अब बस याद रखें कि पैकेजों को चलाने में मदद के लिए डिपेंडेंसीज होती हैं, चाहे वे डिपेंडेंसीज अन्य पैकेज हों या लाइब्रेरीज हों, अगर डिपेंडेंसीज नहीं हैं तो पैकेज एक टूटी हुई स्थिति में आ जाएगा और अधिकांश समय तक इंस्टॉल भी नहीं होगा।",
          "quizAnswer": "",
          "quizQuestion": "कोई प्रश्न नहीं, आगे बढ़ें!",
          "slug": "packagedependencies",
          "title": "पैकेज डिपेंडेंसीज"
        },
        {
          "exercise": "अपने सिस्टम पर Google Chrome जैसा कोई कार्यक्रम खोजें और इसे इनमें से किसी एक कमांड का उपयोग करके स्थापित करें।",
          "id": 5,
          "lessonContent": "यद्यपि इस पाठ्यक्रम का अधिकांश पैकेज प्रबंधन सिस्टमों (पैकेज प्रबंधन के बैटमैन) के बारे में है, हमें रॉबिन्स के बारे में भूलना नहीं चाहिए। ये बहुत ही उपयोगी और विश्वसनीय हैं, लेकिन उनके पास वह मिठासी बैटमोबाइल और यूटिलिटी बेल्ट नहीं हैं।\n\nजैसे .exe एकल क्रियात्मक फ़ाइल है, ठीक वैसे ही .deb और .rpm हैं। आम तौर पर आपको इन्हें नहीं देखना चाहिए अगर आप पैकेज भंडारों का उपयोग करते हैं, लेकिन यदि आप सीधे पैकेज डाउनलोड करते हैं, तो आपको अधिकांश लोकप्रिय प्रारूप में मिलेंगे। स्पष्ट है कि वे अपने वितरणों के लिए विशेष हैं, .deb डेबियन आधारित और .rpm रेड हैट आधारित।\n\nइन सीधे पैकेजों को स्थापित करने के लिए, आप पैकेज प्रबंधन कमांडों का उपयोग कर सकते हैं: rpm और dpkg। ये उपकरण पैकेज फ़ाइलें स्थापित करने के लिए उपयोग किए जाते हैं, हालांकि वे पैकेज विभाजनों को स्थापित नहीं करेंगे, इसलिए यदि आपके पैकेज में 10 विभाजन होते हैं, तो आपको उन पैकेजों को अलग-अलग स्थापित करना होगा और उनके विभाजनों को और ऐसा ही जारी रखना होगा। जैसा कि आप देख सकते हैं, यह उन कारणों में से एक था जो बाद में हम चर्चा करेंगे पूर्ण फ़्लोन प्रबंधन सिस्टमों के लिए।\n\nध्यान रखें कि आपको इन उपकरणों में से किसी एक का उपयोग करके बहुत सारी बार एक पैकेज को स्थापित, प्रश्न करें या सत्यापित करने की आवश्यकता होगी, इसलिए इन कमांडों को याद रखें।\n\n<b>पैकेज स्थापित करें</b>\n\n<pre>\nडेबियन: $ dpkg -i कुछ_deb_पैकेज.deb\nRPM: $ rpm -i कुछ_rpm_पैकेज.rpm\n</pre>\n\n<b>i</b> स्थापित के लिए है। आप लंबा स्वरूप --install का भी उपयोग कर सकते हैं।\n\n<b>एक पैकेज हटाएं</b>\n\n<pre>\nडेबियन: $ dpkg -r कुछ_deb_पैकेज.deb\nRPM: $ rpm -e कुछ_rpm_पैकेज.rpm\n</pre>\n\nडेबियन: हटाने के लिए <b>r</b>\nRPM: मिटाने के लिए <b>e</b>\n\n<b>स्थापित पैकेजों की सूची</b>\n\n<pre>\nडेबियन: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nडेबियन: सूची के लिए <b>l</b>\nRPM: प्रश्न के लिए <b>q</b> और सभी के लिए <b>a</b>",
          "quizAnswer": "dpkg",
          "quizQuestion": ".deb फ़ाइलों के लिए पैकेज प्रबंधन उपकरण क्या है?",
          "slug": "packageinstalltools",
          "title": "rpm और dpkg"
        },
        {
          "exercise": "इन पैकेज कमांड्स को चलाएं और प्राप्त की गई आउटपुट देखें।",
          "id": 6,
          "lessonContent": "अह, पैकेज प्रबंधन के बैटमैन, ये सिस्टम्स पैकेज स्थापना, हटाने और परिवर्तन को आसान बनाने के लिए सभी सुधारों के साथ आते हैं, जिसमें पैकेज निर्भरताओं को स्थापित करना भी शामिल है। दो सबसे लोकप्रिय प्रबंधन सिस्टम हैं <b>yum</b> और <b>apt</b>। Yum रेड हैट परिवार के लिए विशेष है और apt डेबियन परिवार के लिए विशेष है।\n\n<b>एक पैकेज को एक रिपॉजिटरी से स्थापित करें</b>\n\n<pre>\nडेबियन: $ apt install package_name\nRPM: $ yum install package_name\n</pre>\n\n<b>एक पैकेज को हटाएं</b>\n\n<pre>\nडेबियन: $ apt remove package_name\nRPM: $ yum erase package_name\n</pre>\n\n<b>रिपॉजिटरी के लिए पैकेजों को अपडेट करना</b>\n\nयह हमेशा अच्छी प्रथा है कि आप अपनी पैकेज रिपॉजिटरियों को अपडेट करें ताकि वे नवीनतम हों जब आप पैकेज स्थापित और अपडेट करते हैं।\n\n<pre>\nडेबियन: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>एक स्थापित पैकेज के बारे में जानकारी प्राप्त करें</b>\n\n<pre>\nडेबियन: apt show package_name\nRPM: yum info package_name\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "डेबियन सिस्टम पर पैकेज जानकारी दिखाने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "पैकेजप्रबंधनसिस्टम",
          "title": "यम और एप्ट"
        },
        {
          "exercise": "एक स्रोत कोड कार्यक्रम ढूंढें (विश्वसनीय साइट से) और स्रोत से स्थापित करें।",
          "id": 7,
          "lessonContent": "अक्सर आपको एक असाधारण पैकेज का सामान्य स्रोत कोड रूप में ही मिलेगा। आपको उस स्रोत कोड पैकेज को कंपाइल और अपने सिस्टम पर स्थापित करने के लिए कुछ कमांड्स का उपयोग करना होगा। \n\nसबसे पहली बात, आपको स्रोत कोड को कंपाइल करने के लिए उपकरण स्थापित करने के लिए सॉफ़्टवेयर होना चाहिए। \n\n<pre>$ sudo apt install build-essential</pre>\n\nइसके बाद, पैकेज फ़ाइल की सामग्री को निकालें, जो अधिकतर .tar.gz फ़ाइल होगी। \n\n<pre>$ tar -xzvf package.tar.gz</pre>\n\nकुछ करने से पहले, पैकेज में दिए गए README या INSTALL फ़ाइल को देखें। कभी-कभी विशिष्ट स्थापना निर्देश होते हैं। \n\nडेवलपर द्वारा कौन सा कंपाइल विधि उपयोग किया गया है, इस पर निर्भर करता है, आपको विभिन्न कमांड्स जैसे cmake या कुछ अन्य का उपयोग करना पड़ सकता है।\n\nहालांकि, अधिकांशतः आप बुनियादी make कंपाइलेशन देखेंगे, इसलिए हम इस पर चर्चा करेंगे:\n\nपैकेज सामग्री में एक configure स्क्रिप्ट होगा, यह स्क्रिप्ट आपके सिस्टम पर आवश्यकताओं की जाँच करता है और यदि आप कुछ भी छूट रहे हैं, तो आपको उन आवश्यकताओं को ठीक करने की आवश्यकता होगी। \n\n<pre>$ ./configure</pre>\n\n<b>./</b> आपको वर्तमान निर्देशिका में एक स्क्रिप्ट को क्रियान्वित करने की अनुमति देता है। \n\n<pre>$ make</pre>\n\nपैकेज सामग्री में, एक Makefile नामक फ़ाइल होगी जिसमें सॉफ़्टवेयर बनाने के नियम होते हैं। जब आप make कमांड चलाते हैं, तो यह फ़ाइल देखता है कि सॉफ़्टवेयर कैसे बनाना है।\n\n<pre>$ sudo make install</pre>\n\nयह कमांड वास्तव में पैकेज को स्थापित करती है, यह आपके कंप्यूटर पर सही स्थानों पर सही फ़ाइलें कॉपी करेगी।\n\nयदि आप पैकेज को अनइंस्टॉल करना चाहते हैं, तो इस्तेमाल करें:\n\n<pre>$ sudo make uninstall</pre>\n\nmake install का उपयोग करते समय सावधान रहें, आपको यह नहीं पता चल सकता कि पीछे क्या हो रहा है। यदि आप इस पैकेज को हटाने का निर्णय लेते हैं, तो आपको यह नहीं पता चल सकता कि आपके सिस्टम में क्या जोड़ा गया था। इसके बजाय, मैंने आपको बताया कि make install के बारे में सब भूल जाएं और <b>checkinstall</b> कमांड का उपयोग करें। यह कमांड आपके लिए एक .deb फ़ाइल बनाएगा जिसे आप आसानी से स्थापित और अनइंस्टॉल कर सकते हैं। \n\n<pre>$ sudo checkinstall</pre> \n\nयह कमांड मूल रूप से \"make install\" करेगा और एक .deb पैकेज बनाएगा और इसे स्थापित करेगा। इससे पैकेज को बाद में हटाना आसान हो जाता है।",
          "quizAnswer": "checkinstall",
          "quizQuestion": "हमेशा make install के बजाय आपको क्या उपयोग करना चाहिए?",
          "slug": "compilesourcecode",
          "title": "स्रोत कोड को कंपाइल करें"
        }
      ],
      "slug": "packages",
      "title": "पैकेज"
    },
    {
      "description": "लिनक्स उपकरणों के बारे में और उनके कर्नेल और उपयोगकर्ता स्थान के साथ कैसे बातचीत करते हैं, सीखें।",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "/dev निर्देशिका की सामग्री देखें, क्या आप किसी परिचित डिवाइस को पहचानते हैं?",
          "id": 1,
          "lessonContent": "जब आप अपनी मशीन से कोई डिवाइस कनेक्ट करते हैं, तो सामान्य रूप से उसे सही ढंग से काम करने के लिए एक डिवाइस ड्राइवर की आवश्यकता होती है। आप डिवाइस फ़ाइल्स या डिवाइस नोड के माध्यम से डिवाइस ड्राइवर्स के साथ आपसी क्रियान्वयन कर सकते हैं, ये विशेष फ़ाइलें हैं जो सामान्य फ़ाइलों की तरह दिखती हैं। क्योंकि ये डिवाइस फ़ाइलें सामान्य फ़ाइलों की तरह होती हैं, आप ls, cat आदि जैसे कार्यक्रमों का उपयोग करके इनके साथ आपसी क्रियान्वयन कर सकते हैं। ये डिवाइस फ़ाइलें सामान्य रूप से /dev निर्देशिका में संग्रहीत होती हैं। अपने सिस्टम पर /dev निर्देशिका ls करें, आप देखेंगे कि आपके सिस्टम पर कितनी अधिक डिवाइस फ़ाइलें हैं।\n\n<pre>$ ls /dev </pre>\n\nइनमें से कुछ डिवाइस आपने पहले ही उपयोग किए होंगे और इनके साथ आपसी क्रियान्वयन किया होगा जैसे /dev/null। याद रखें जब हम आउटपुट को /dev/null पर भेजते हैं, तो कर्नेल को पता होता है कि यह डिवाइस हमारे सभी इनपुट को लेता है और बस उसे छोड़ देता है, इसलिए कुछ भी वापस नहीं मिलता।\n\nपुराने दिनों में, अगर आप अपने सिस्टम में एक डिवाइस जोड़ना चाहते थे, तो आप /dev में डिवाइस फ़ाइल जोड़ते और फिर शायद उसके बारे में भूल जाते। अच्छा, इसे कुछ बार दोहराएं और आप देख सकते हैं कि कहाँ समस्या थी। /dev निर्देशिका स्थिर डिवाइस फ़ाइलों से भर जाता था जिनका आपने लंबे समय से उपयोग करना बंद कर दिया था, इनको अपग्रेड कर दिया था, आदि। डिवाइसों को कर्नेल उन्हें पाता है जिस क्रम में वह उन्हें पाता है। तो अगर हर बार जब आप अपने सिस्टम को बूट करते हैं, तो डिवाइस किसी भी समय पर पाए जाने पर विभिन्न डिवाइस फ़ाइलों को प्राप्त कर सकते हैं।\n\nधन्यवाद कि अब हम उस विधि का उपयोग नहीं करते, अब हमारे पास कुछ है जिसका हम वर्तमान में उपयोग कर रहे डिवाइसों को डायनामिक रूप से जोड़ने और हटाने के लिए और हम आने वाले पाठों में इस पर चर्चा करेंगे।",
          "quizAnswer": "/dev",
          "quizQuestion": "सिस्टम पर डिवाइस फ़ाइलें कहाँ संग्रहित होती हैं?",
          "slug": "devdirectory",
          "title": "/dev निर्देशिका"
        },
        {
          "exercise": "अपने /dev निर्देशिका पर नजर डालें और देखें कि आप किस प्रकार की डिवाइस देख सकते हैं।",
          "id": 2,
          "lessonContent": "हम डिवाइस कैसे प्रबंधित किए जाते हैं इसके बारे में चर्चा करने से पहले, चलो वास्तव में कुछ डिवाइसों को देखते हैं।\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nकॉलम निम्नलिखित हैं बाएं से दाएं:\n\n<ul>\n<li>अनुमतियाँ</li>\n<li>मालिक</li>\n<li>समूह</li>\n<li>मेजर डिवाइस नंबर</li>\n<li>माइनर डिवाइस नंबर</li>\n<li>समयचिह्न</li>\n<li>डिवाइस नाम</li>\n</ul>\n\nध्यान दें कि ls कमांड में आप प्रत्येक पंक्ति के पहले बिट के साथ फ़ाइल के प्रकार को देख सकते हैं। डिवाइस फ़ाइलें निम्नलिखित रूप में दर्शाई जाती हैं:\n\n<ul>\n<li>c - character</li>\n<li>b - block</li>\n<li>p - pipe</li>\n<li>s - socket</li>\n</ul>\n\n<b>चरित्र डिवाइस</b>\n\nये डिवाइस डेटा स्थानांतरित करते हैं, लेकिन एक बार में केवल एक चरित्र। आप चरित्र डिवाइस के रूप में बहुत सारी जाली डिवाइसेस (/dev/null) देखेंगे, ये डिवाइसेस वास्तव में मशीन से भौतिक रूप से जुड़े नहीं हैं, लेकिन इन्हें ऑपरेटिंग सिस्टम को अधिक कार्यक्षमता प्रदान करने दिया जाता है।\n\n<b>ब्लॉक डिवाइस</b>\n\nये डिवाइस डेटा स्थानांतरित करते हैं, लेकिन बड़े निश्चित आकार के ब्लॉक में। आप डेटा ब्लॉक का उपयोग करने वाली डिवाइसेस को ब्लॉक डिवाइस के रूप में सबसे अधिक देखेंगे, जैसे हार्ड ड्राइव्स, फ़ाइल सिस्टम्स, आदि।\n\n<b>पाइप डिवाइस</b>\n\nनेम्ड पाइप्स दो या दो से अधिक प्रक्रियाओं को एक-दूसरे के साथ संवाद करने की अनुमति देती हैं, ये चरित्र डिवाइसेस के लगभग समान हैं, लेकिन उनका आउटपुट एक डिवाइस पर भेजने की जगह, दूसरी प्रक्रिया को भेजा जाता है।\n\n<b>सॉकेट डिवाइस</b>\n\nसॉकेट डिवाइसेस प्रक्रियाओं के बीच संवाद को सुविधाजनक बनाती हैं, पाइप डिवाइसेस के समान हैं लेकिन इन्हें एक साथ कई प्रक्रियाओं के साथ संवाद करने की अनुमति होती है।\n\n<b>डिवाइस चरित्रीकरण</b>\n\nडिवाइस को दो संख्याओं, <b>मेजर डिवाइस नंबर</b> और <b>माइनर डिवाइस नंबर</b> का उपयोग करके चरित्रीकृत किया जाता है। आप उपरोक्त ls उदाहरण में इन नंबरों को देख सकते हैं, इन्हें एक कमा द्वारा अलग किया गया है। उदाहरण के लिए, चलो कहें कि एक डिवाइस के पास डिवाइस नंबर हैं: <b>8, 0</b>:\n\nमेजर डिवाइस नंबर उस डिवाइस ड्राइवर को प्रतिनिधित करता है जिसका उपयोग किया जाता है, इस मामले में 8, जो अक्सर एसडी ब्लॉक डिवाइसेस के लिए मेजर नंबर होता है। माइनर नंबर कर्नल को बताता है कि इस ड्राइवर वर्ग में यह अद्वितीय डिवाइस कौन सा है, इस मामले में 0 पहले डिवाइस (ए) को प्रतिनिधित करने के लिए उपयोग किया जाता है।",
          "quizAnswer": "c",
          "quizQuestion": "ls -l कमांड में चरित्र डिवाइस के लिए प्रतीक क्या है?",
          "slug": "devicetypes",
          "title": "डिवाइस प्रकार"
        },
        {
          "exercise": "असली उपकरणों में लिखें और देखें कि क्या होता है, इन उपकरणों पर अपनी डिस्क लिखने का ध्यान रखें!",
          "id": 3,
          "lessonContent": "यहाँ वे सबसे सामान्य उपकरण नाम हैं जो आपको सामने आ सकते हैं: \n\n<b>SCSI उपकरण</b>\n\nयदि आपके मशीन पर किसी भी प्रकार का बड़ा संग्रहण है, तो संभावना है कि यह SCSI (उच्चारित \"स्कज़ी\") प्रोटोकॉल का उपयोग कर रहा है। SCSI का मतलब है स्मॉल कंप्यूटर सिस्टम इंटरफेस, यह एक प्रोटोकॉल है जिसका उपयोग डिस्क, प्रिंटर, स्कैनर और अन्य परिफेरल को आपके सिस्टम से संचार करने के लिए किया जाता है। आपने शायद SCSI उपकरणों के बारे में सुना हो जो वास्तव में आधुनिक सिस्टम में उपयोग में नहीं हैं, हालांकि हमारे Linux सिस्टम SCSI डिस्क को हार्ड डिस्क ड्राइव्स के साथ संबोधित करते हैं /dev में। वे sd (SCSI डिस्क) के उपसर्ग द्वारा प्रतिनिधित होते हैं:\n\nसामान्य SCSI उपकरण फ़ाइलें:\n\n<ul>\n<li>/dev/sda - पहला हार्ड डिस्क</li>\n<li>/dev/sdb - दूसरा हार्ड डिस्क</li>\n<li>/dev/sda3 - पहले हार्ड डिस्क पर तीसरा विभाजन</li>\n</ul>\n\n<b>असली उपकरण</b>\n\nजैसा कि हमने पहले चर्चा की थी, असली उपकरण आपके सिस्टम से वास्तव में भौतिक रूप से जुड़े नहीं होते हैं, सबसे सामान्य असली उपकरण वर्णन उपकरण होते हैं: \n\n<ul>\n<li>/dev/zero - सभी इनपुट को स्वीकार करता है और छोड़ता है, शून्य (शून्य मान) बाइट की एक निरंतर धारा उत्पन्न करता है</li>\n<li>/dev/null - सभी इनपुट को स्वीकार करता है और कोई उत्पादन नहीं करता है</li>\n<li>/dev/random - यादृच्छिक संख्याएँ उत्पन्न करता है</li>\n</ul>\n\n<b>PATA उपकरण</b>\n\nकभी-कभी पुराने सिस्टम में आप हार्ड ड्राइव को hd उपसर्ग के साथ संदर्भित होते हुए देख सकते हैं: \n\n<ul>\n<li>/dev/hda - पहला हार्ड डिस्क</li>\n<li>/dev/hdd2 - चौथे हार्ड डिस्क पर दूसरा विभाजन</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "दूसरे SCSI डिस्क पर पहले विभाजन के लिए सामान्यत: क्या होगा उपकरण नाम?",
          "slug": "devicenames",
          "title": "उपकरण नाम"
        },
        {
          "exercise": "/sys निर्देशिका की सामग्री की जाँच करें और देखें कि वहाँ कौन सी फ़ाइलें हैं।",
          "id": 4,
          "lessonContent": "सिसएफएस को बेहतर प्रबंधन के लिए बनाया गया था जो हमारे सिस्टम पर उपकरणों का प्रबंधन करने के लिए /dev निर्देशिका नाकाम रह गई। सिसएफएस एक आभासी फाइल सिस्टम है, जो अधिकांश अक्सर /sys निर्देशिका में माउंट किया जाता है। यह हमें /dev निर्देशिका में देखने की तुलना में अधिक विस्तृत जानकारी देता है। दोनों निर्देशिकाएं /sys और /dev बहुत ही समान लगती हैं और कुछ मामलों में वे हैं, लेकिन उनमें मुख्य अंतर हैं। मूल रूप से, /dev निर्देशिका सरल है, यह अन्य कार्यक्रमों को उपकरणों तक पहुंचने की अनुमति देती है, जबकि /sys फ़ाइल सिस्टम का उपयोग जानकारी देखने और उपकरण का प्रबंधन करने के लिए किया जाता है।\n\n/sys फ़ाइल सिस्टम में आम तौर पर आपके सिस्टम पर सभी उपकरणों की सभी जानकारी होती है, जैसे निर्माता और मॉडल, उपकरण कहां प्रवेश किया गया है, उपकरण की स्थिति, उपकरणों की व्यवस्था और अधिक। यहाँ दिखाई जाने वाली फ़ाइलें उपकरण नोड नहीं हैं, इसलिए आप वास्तव में /sys निर्देशिका से उपकरणों के साथ बातचीत नहीं करते हैं, बल्कि आप उपकरणों का प्रबंधन कर रहे हैं।\n\n/sys निर्देशिका की सामग्री की जाँच करें:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "उपकरणों पर विस्तृत जानकारी देखने के लिए कौन सी निर्देशिका उपयोग की जाती है?",
          "slug": "सिसएफएस",
          "title": "सिसएफएस"
        },
        {
          "exercise": "दिए गए udevadm कमांड को चलाएं और इनपुट की जांच करें।",
          "id": 5,
          "lessonContent": "पुराने दिनों में और वास्तव में आज अगर आप वास्तव में चाहते हैं, तो आप इस तरह के कमांड का उपयोग करके डिवाइस नोड्स बना सकते थे: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nयह कमांड एक डिवाइस नोड /dev/sdb1 बनाएगा और इसे एक ब्लॉक डिवाइस (b) बनाएगा जिसका मेज़र नंबर 8 है और माइनर नंबर 3 है।\n\nएक डिवाइस को हटाने के लिए, आप बस /dev निर्देशिका में डिवाइस फ़ाइल को <b>हटा</b> देंगे।\n\nभाग्य से, हमें अब इसे करने की जरूरत नहीं है क्योंकि udev के कारण। udev सिस्टम डाइनामिक रूप से डिवाइस फ़ाइलें बनाता और हटाता है जो यहाँ तक कि वे कनेक्ट किए गए हैं या नहीं। सिस्टम पर एक udevd डेमन होता है और यह सिस्टम के लिए कनेक्ट किए गए डिवाइस के बारे में कर्नेल से संदेश सुनता है। Udevd उस सूचना को विश्लेषित करेगा और यह नियमों के साथ डेटा मिलाएगा जो /etc/udev/rules.d में निर्दिष्ट किए गए हैं, उन नियमों के आधार पर यह संभावना है कि यह डिवाइस नोड्स और प्रतीकात्मक लिंक्स बनाएगा। आप अपने खुद के udev नियम लिख सकते हैं, लेकिन यह इस पाठ के लिए थोड़ा बाहर है। भाग्य से, आपके सिस्टम में पहले से ही कई udev नियम हैं तो शायद आपको कभी अपना नियम लिखने की आवश्यकता नहीं होगी।\n\nआप udev डेटाबेस और सिस्फस को भी <b>udevadm</b> कमांड का उपयोग करके देख सकते हैं। यह उपकरण बहुत उपयोगी है, लेकिन कभी-कभी बहुत जटिल हो सकता है, एक डिवाइस के लिए जानकारी देखने के लिए एक सरल कमांड होगा:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "कौन डिवाइस डाइनामिक रूप से जोड़ता और हटाता है?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "इन कमांडों का प्रयास करें और प्राप्त करने वाले आउटपुट को देखें।",
          "id": 6,
          "lessonContent": "हम फ़ाइल और निर्देशिकाओं की सूची बनाने के लिए ls कमांड का उपयोग करते हैं, हम उसी तरह के उपकरणों का उपयोग कर सकते हैं जो उपकरणों के बारे में जानकारी की सूची बनाते हैं।\n\n<b>USB उपकरणों की सूची</b>\n\n<pre>$ lsusb </pre>\n\n<b>PCI उपकरणों की सूची</b>\n\n<pre>$ lspci </pre>\n\n<b>SCSI उपकरणों की सूची</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "यूएसबी उपकरणों को देखने के लिए कौन सा कमांड प्रयोग किया जा सकता है?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "अपने ड्राइव की बैकअप बनाने के लिए dd कमांड का उपयोग करें और आउटपुट को .img फ़ाइल में सेट करें।",
          "id": 7,
          "lessonContent": "डीडी टूल डेटा कनवर्ट और कॉपी करने के लिए बहुत उपयोगी है। यह एक फ़ाइल या डेटा स्ट्रीम से इनपुट पढ़ता है और इसे एक फ़ाइल या डेटा स्ट्रीम में लिखता है। \n\nनिम्नलिखित कमांड को ध्यान से देखें: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nयह कमांड backup.img की सामग्री को /dev/sdb पर कॉपी कर रहा है। यह 1024 बाइट के ब्लॉक में डेटा कॉपी करेगा जब तक कॉपी करने के लिए डेटा न रह जाए। \n\n<ul>\n<li>if=file - इनपुट फ़ाइल, स्टैंडर्ड इनपुट की बजाय फ़ाइल से पढ़ें</li>\n<li>of=file - आउटपुट फ़ाइल, स्टैंडर्ड आउटपुट की बजाय फ़ाइल में लिखें</li>\n<li>bs=bytes - ब्लॉक साइज़, यह इस संख्या के बाइट डेटा को पढ़ता और लिखता है। आप आकार को k के साथ निर्दिष्ट करके विभिन्न आकार मेट्रिक का उपयोग कर सकते हैं, जैसे 1024 बाइट 1k है</li>\n<li>count=number - कॉपी करने के लिए ब्लॉकों की संख्या।</li>\n</ul>\n\nआपको कुछ dd कमांड देखने को मिलेंगे जो काउंट विकल्प का उपयोग करते हैं, सामान्यत: dd if के साथ जब आप एक 1 मेगाबाइट फ़ाइल कॉपी करना चाहते हैं, तो आप उस फ़ाइल को 1 मेगाबाइट के रूप में देखना चाहेंगे। मान लें आप निम्नलिखित कमांड चलाते हैं: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nहमारी backup.img फ़ाइल 10M है, हालांकि, हम इस कमांड में केवल 1M को 2 बार कॉपी करने के लिए कह रहे हैं, इसलिए केवल 2M कॉपी किया जा रहा है, हमारा कॉपी किया डेटा अधूरा है। काउंट बहुत सी स्थितियों में उपयोगी हो सकता है, लेकिन यदि आप केवल डेटा कॉपी कर रहे हैं, तो आप काउंट और बीएस को छोड़ सकते हैं। यदि आप वास्तव में अपने डेटा स्थानांतरण को अनुकूल करना चाहते हैं, तो आपको उन विकल्पों का उपयोग करना होगा।\n\ndd अत्यधिक शक्तिशाली है, आप इसका उपयोग किसी भी चीज़ की बैकअप बनाने, पूरे डिस्क ड्राइव की बैकअप बनाने, डिस्क इमेजेस को पुनर्स्थापित करने और अधिक कुछ करने के लिए कर सकते हैं। सावधान रहें, यदि आप नहीं जानते कि आप क्या कर रहे हैं तो वह शक्तिशाली टूल एक मूल्य पर आ सकता है।",
          "quizAnswer": "bs",
          "quizQuestion": "ब्लॉक साइज़ के लिए dd विकल्प क्या है?",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "उपकरण"
    },
    {
      "description": "लिनक्स फ़ाइल सिस्टम, विभिन्न प्रकार के फ़ाइल सिस्टम, पार्टीशनिंग और अधिक के बारे में जानें।",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "अपने /usr निर्देशिका में देखें, वहाँ किस प्रकार की जानकारी स्थित है?",
          "id": 1,
          "lessonContent": "इस बिंदु पर, आप शायद अपने सिस्टम के निर्देशिका संरचना के साथ अच्छी तरह से परिचित होंगे, यदि नहीं तो जल्द ही होंगे। फ़ाइल सिस्टम अपने संरचना के साथ भिन्न हो सकते हैं, लेकिन अधिकांश भाग में वे फ़ाइल सिस्टम व्यवस्था मानक का पालन करना चाहिए। \n\nआगे बढ़ें और <b>ls -l /</b> करें ताकि जड़ निर्देशिका के तहत सूचीबद्ध निर्देशिकाएँ देखें, आपकी निर्देशिका मेरी से भिन्न दिख सकती है, लेकिन अधिकांश भाग में निर्देशिकाएँ निम्नलिखित तरह दिखनी चाहिए:\n\n<ul>\n<li>/ - पूरे फ़ाइल सिस्टम व्यवस्था का मूल निर्देशिका, सब कुछ इस निर्देशिका के नीचे छिपा है।</li>\n<li>/bin - आवश्यक तैयार-चलने योग्य कार्यक्रम (बाइनरी), ls और cp जैसे सबसे मूल कमांड शामिल हैं।</li>\n<li>/boot - कर्नेल बूट लोडर फ़ाइलें शामिल हैं।</li>\n<li>/dev - डिवाइस फ़ाइलें।</li>\n<li>/etc - मूल सिस्टम कॉन्फ़िगरेशन निर्देशिका, केवल कॉन्फ़िगरेशन फ़ाइलें और कोई बाइनरी नहीं होना चाहिए।</li>\n<li>/home - उपयोगकर्ताओं के व्यक्तिगत निर्देशिकाएँ, आपके दस्तावेज़, फ़ाइलें, सेटिंग्स, आदि रखता है। </li>\n<li>/lib - बाइनरीज़ उपयोग कर सकती हैं पुस्तकालय फ़ाइलें रखता है।</li>\n<li>/media - USB ड्राइव्स जैसे हटाने योग्य मीडिया के लिए एक अटैचमेंट प्वाइंट के रूप में उपयोग किया जाता है।</li>\n<li>/mnt - अस्थायी रूप से माउंट किए गए फ़ाइल सिस्टम।</li>\n<li>/opt - वैकल्पिक एप्लिकेशन सॉफ़्टवेयर पैकेज।</li>\n<li>/proc - वर्तमान में चल रहे प्रक्रियाओं के बारे में जानकारी।</li>\n<li>/root - रूट उपयोगकर्ता का होम निर्देशिका।</li>\n<li>/run - पिछले बूट के बाद से चल रहे सिस्टम के बारे में जानकारी।</li>\n<li>/sbin - आवश्यक सिस्टम बाइनरीज़ शामिल हैं, आम तौर पर केवल रूट द्वारा चलाया जा सकता है।</li>\n<li>/srv - सिस्टम द्वारा सेवा प्रदान की जाने वाली साइट-विशिष्ट डेटा।</li>\n<li>/tmp - अस्थायी फ़ाइलों के लिए स्टोरेज</li>\n<li>/usr - यह दुर्भाग्यपूर्ण नाम है, अक्सर यह उपयोगकर्ता फ़ाइलें नहीं शामिल करता है एक होम फ़ोल्डर के रूप में। यह उपयोगकर्ता इंस्टॉल किए गए सॉफ़्टवेयर और उपयोगिताएँ के लिए है, हालांकि यह यह नहीं कहने के लिए है कि आप उसमें व्यक्तिगत निर्देशिकाएँ नहीं जोड़ सकते। इस निर्देशिका के अंदर /usr/bin, /usr/local, आदि के लिए उप-निर्देशिकाएँ हैं।</li>\n<li>/var - बदलते रहने वाले निर्देशिका, इसे सिस्टम लॉगिंग, उपयोगकर्ता ट्रैकिंग, कैशेस, आदि के लिए उपयोग किया जाता है। बुनियादी रूप से हर समय परिवर्तित होने वाला कुछ भी।</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "लॉग रखने के लिए कौन सा निर्देशिका उपयोग किया जाता है?",
          "slug": "filesystemhierarchy",
          "title": "फ़ाइल सिस्टम व्यवस्था"
        },
        {
          "exercise": "अन्य फ़ाइलसिस्टम प्रकारों पर ऑनलाइन थोड़ी सी अनुसंधान करें: राइज़रएफएस, जेडएफएस, जेएफएस और आपको मिल सकते हैं।",
          "id": 2,
          "lessonContent": "कई विभिन्न फ़ाइलसिस्टम कार्यान्वयन उपलब्ध हैं। कुछ अन्य से तेज हैं, कुछ बड़ी क्षमता स्टोरेज का समर्थन करते हैं और अन्य केवल छोटी क्षमता स्टोरेज पर काम करते हैं। विभिन्न फ़ाइलसिस्टम के विभिन्न तरीके होते हैं अपने डेटा को संगठित करने के लिए और हम विस्तार से जानेंगे कि किस प्रकार के फ़ाइलसिस्टम होते हैं। क्योंकि इतने सारे विभिन्न कार्यान्वयन उपलब्ध हैं, ऐप्लिकेशन को विभिन्न ऑपरेशनों का सामना करने का एक तरीका चाहिए। इसलिए कुछ ऐसा है जिसे वर्चुअल फ़ाइल सिस्टम (VFS) अवस्थान परत कहा जाता है। यह ऐप्लिकेशन और विभिन्न फ़ाइलसिस्टम प्रकारों के बीच एक परत है, इसलिए चाहे आपके पास कौन सा भी फ़ाइलसिस्टम हो, आपकी ऐप्लिकेशन उसके साथ काम कर सकेंगी।\n\nआपके डिस्क पर कई फ़ाइलसिस्टम हो सकते हैं, यह उनके विभाजन के आधार पर है और हम आने वाले पाठ में इस पर जाएंगे।\n\n<b>जर्नलिंग</b>\n\nजर्नलिंग अधिकांश फ़ाइलसिस्टम प्रकार पर डिफ़ॉल्ट रूप से आता है, लेकिन यदि ऐसा नहीं है, तो आपको यह जानना चाहिए कि यह क्या करता है। मान लीजिए आप एक बड़ी फ़ाइल कॉपी कर रहे हैं और अचानक आपका पावर चला जाता है। अगर आप एक गैर-जर्नलिंग फ़ाइलसिस्टम पर हैं, तो फ़ाइल क्षतिग्रस्त हो जाएगी और आपका फ़ाइलसिस्टम असंगत हो जाएगा और फिर जब आप बूट करेंगे, तो आपका सिस्टम फ़ाइलसिस्टम जांच करेगा कि सब कुछ ठीक है। हालांकि, मरम्मत कितनी देर लेगी यह आपके फ़ाइलसिस्टम की विशालता पर निर्भर करेगी।\n\nअब अगर आप एक जर्नलिंग सिस्टम पर होते, तो जब भी आपकी मशीन फ़ाइल कॉपी करने लगती है, तो यह आपको कहानी फ़ाइल (जर्नल) में लिख देगी कि आप क्या करने वाले हैं। अब जब आप वास्तव में फ़ाइल कॉपी करते हैं, तो जब यह पूरा होता है, तो जर्नल उस कार्य को पूरा करने के रूप में चिह्नित करता है। इसके कारण फ़ाइलसिस्टम हमेशा एक संगत स्थिति में होता है, इसलिए यह यह जानेगा कि आपने अचानक अपनी मशीन बंद कर दी है तो आप कहाँ छोड़ गए थे। यह बूट समय को भी कम करता है क्योंकि पूरे फ़ाइलसिस्टम की जगह आपके जर्नल पर नजर डालता है।\n\n<b>सामान्य डेस्कटॉप फ़ाइलसिस्टम प्रकार</b>\n\n<ul>\n<li>ext4 - यह नेटिव लिनक्स फ़ाइलसिस्टम का सबसे वर्तमान संस्करण है। यह पुराने ext2 और ext3 संस्करणों के साथ संगत है। यह 1 एक्साबाइट तक डिस्क वॉल्यूम और 16 टेराबाइट तक फ़ाइल आकार का समर्थन करता है और बहुत कुछ। यह लिनक्स फ़ाइलसिस्टम के लिए मानक चयन है।</li>\n<li>Btrfs - \"बेटर या बटर एफएस\" यह लिनक्स के लिए एक नया फ़ाइलसिस्टम है जिसमें स्नैपशॉट, अतिरिक्त बैकअप, प्रदर्शन वृद्धि और बहुत कुछ शामिल है। यह व्यापक रूप से उपलब्ध है, लेकिन अभी तक स्थिर और संगत नहीं है।</li>\n<li>XFS - उच्च प्रदर्शन जर्नलिंग फ़ाइल सिस्टम, मीडिया सर्वर जैसे बड़ी फ़ाइलों के साथ एक सिस्टम के लिए बड़ा है।</li>\n<li>NTFS और FAT - विंडोज फ़ाइलसिस्टम</li>\n<li>HFS+ - मैकिंटॉश फ़ाइलसिस्टम</li>\n</ul>\n\nजांचें कि आपकी मशीन पर कौन से फ़ाइलसिस्टम हैं: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\n<b>df</b> कमांड फ़ाइल सिस्टम डिस्क स्थान का उपयोग और अपने डिस्क के बारे में अन्य विवरण रिपोर्ट करता है, हम इस उपकरण के बारे में और भी बात करेंगे।",
          "quizAnswer": "ext4",
          "quizQuestion": "सामान्य लिनक्स फ़ाइलसिस्टम प्रकार क्या है?",
          "slug": "filesystemtypes",
          "title": "फ़ाइलसिस्टम प्रकार"
        },
        {
          "exercise": "अपनी मशीन पर <b>parted -l</b> चलाएं और अपने परिणाम का मूल्यांकन करें।",
          "id": 3,
          "lessonContent": "हार्ड डिस्क को विभाजित किया जा सकता है भागों में, मुख्य रूप से कई ब्लॉक उपकरण बनाते हैं। उसी उदाहरणों को याद करें, जैसे, /dev/sda1 और /dev/sda2, /dev/sda पूरी डिस्क है, लेकिन /dev/sda1 उस डिस्क पर पहला विभाजन है। विभाजन डेटा को अलग करने के लिए बहुत उपयोगी है और यदि आपको किसी विशेष फ़ाइल सिस्टम की आवश्यकता है, तो आप आसानी से एक विभाजन बना सकते हैं बजाय पूरी डिस्क को एक ही फ़ाइल सिस्टम प्रकार बनाने की।\n\n<b>विभाजन सारणी</b>\n\nप्रत्येक डिस्क में एक विभाजन सारणी होगी, यह सारणी सिस्टम को बताती है कि डिस्क को कैसे विभाजित किया गया है। यह सारणी आपको बताती है कि विभाजन कहाँ शुरू होते हैं और कहाँ समाप्त होते हैं, कौन से विभाजन बूट करने योग्य हैं, डिस्क के कौन से सेक्टर किस विभाजन को क्या आवंटित किए गए हैं, आदि। दो मुख्य विभाजन सारणी योजनाएँ हैं, मास्टर बूट रिकॉर्ड (MBR) और GUID विभाजन सारणी (GPT)।\n\n<b>विभाजन</b>\n\nडिस्क विभाजनों से मिलकर बने होते हैं जो हमें हमारे डेटा को संगठित करने में मदद करते हैं। आप एक डिस्क पर कई विभाजन रख सकते हैं और वे एक-दूसरे के ऊपर नहीं चढ़ सकते। यदि कोई विभाजन के लिए आवंटित नहीं है, तो उसे फ्री स्पेस कहा जाता है। विभाजनों के प्रकार आपकी विभाजन सारणी पर निर्भर करते हैं। एक विभाजन के अंदर, आप एक फ़ाइल सिस्टम रख सकते हैं या एक विभाजन को स्वैप जैसी अन्य चीजों के लिए समर्पित कर सकते हैं (हम जल्द ही उस पर आएंगे)।\n\n<i>MBR</i>\n\n<ul>\n<li>पारंपरिक विभाजन सारणी, मानक के रूप में प्रयोग किया जाता था</li>\n<li>प्राथमिक, विस्तारित, और तार्किक विभाजन हो सकते हैं</li>\n<li>MBR में चार प्राथमिक विभाजनों की सीमा होती है</li>\n<li>अतिरिक्त विभाजन बनाए जा सकते हैं एक प्राथमिक विभाजन को विस्तारित विभाजन में बदलकर (एक डिस्क पर केवल एक विस्तारित विभाजन हो सकता है)। फिर विस्तारित विभाजन के अंदर आप तार्किक विभाजन जोड़ते हैं। तार्किक विभाजनों का उपयोग अन्य किसी विभाजन की तरह किया जाता है। मजाकिया, मैं जानता हूँ।</li> \n<li>2 टेराबाइट तक के डिस्क का समर्थन करता है</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>GUID विभाजन सारणी (GPT) डिस्क विभाजन के लिए नए मानक बन रहा है</li>\n<li>केवल एक प्रकार का विभाजन है और आप उनमें कई बना सकते हैं</li>\n<li>प्रत्येक विभाजन का एक वैश्विक अद्वितीय आईडी (GUID) होता है</li>\n<li>यह अधिकांशत: UEFI आधारित बूटिंग के साथ प्रयोग किया जाता है (हम एक अन्य पाठ्यक्रम में विस्तार से जाएंगे)</li> \n</ul>\n\n<b>फ़ाइल सिस्टम संरचना</b>\n\nहम पिछले सबक से जानते हैं कि एक फ़ाइल सिस्टम फ़ाइलों और निर्देशिकाओं का एक संगठित संग्रह है। इसके सरल रूप में, यह फ़ाइलों को प्रबंधित करने वाला डेटाबेस से मिलकर बना होता है और वास्तविक फ़ाइलों को। हालांकि, हम थोड़ा और विस्तार से जाएँगे।\n\n<ul>\n<li>बूट ब्लॉक - यह फ़ाइल सिस्टम द्वारा उपयोग नहीं किया जाता है, बल्कि यह ऑपरेटिंग सिस्टम को बूट करने के लिए उपयोग होने वाली जानकारी शामिल करता है। ऑपरेटिंग सिस्टम को केवल एक बूट ब्लॉक की आवश्यकता होती है। यदि आपके पास कई विभाजन हैं, तो उनमें बूट ब्लॉक होगा, लेकिन उनमें से बहुत से अप्रयोगी होते हैं।</li>\n<li>सुपर ब्लॉक - यह बूट ब्लॉक के बाद आने वाला एक एकल ब्लॉक है, और इसमें फ़ाइल सिस्टम के बारे में जानकारी होती है, जैसे आइनोड तालिका का आकार, तार्किक ब्लॉकों का आकार और फ़ाइल सिस्टम का आकार।</li>\n<li>आइनोड तालिका - इसे हमारी फ़ाइलों का प्रबंधन करने वाला डेटाबेस समझें (हमें आइनोड्स पर पूरा सबक है, इसलिए चिंता न करें)। प्रत्येक फ़ाइल या निर्देशिका का आइनोड तालिके में एक अद्वितीय प्रविष्टि होती है और इसमें फ़ाइल के बारे में विभिन्न जानकारियाँ होती हैं।</li>\n<li>डेटा ब्लॉक - यह वास्तविक डेटा है फ़ाइलों और निर्देशिकाओं के लिए।</li>\n</ul>\n \nचलिए विभिन्न विभाजन सारणियों पर एक नज़र डालते हैं। नीचे एक उदाहरण है एक विभाजन का उपयोग करके MBR विभाजन सारणी (msdos) का। आप मशीन पर प्राथमिक, विस्तारित और तार्किक विभाजन देख सकते हैं।\n\n<pre>\npete@icebox:~$ sudo parted -l\nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\n\nयह उदाहरण GPT है, जिसमें विभाजनों के लिए केवल एक अद्वितीय आईडी का उपयोग किया जाता है।\n\n<pre>\nModel: Thumb Drive (scsi)\nDisk /dev/sdb: 4041MB\nSector size (logical/physical): 512B/512B\nPartition Table: gpt\n\nNumber  Start   End     Size     File system  Name        Flags\n 1      17.4kB  1000MB  1000MB                first\n 2      1000MB  4040MB  3040MB                second\n</pre>",
          "quizAnswer": "विस्तारित",
          "quizQuestion": "MBR विभाजन सारणी योजना में 4 से अधिक विभाजन बनाने के लिए कौन सा विभाजन प्रकार प्रयोग किया जाता है?",
          "slug": "anatomyofadisk",
          "title": "डिस्क की एनाटॉमी"
        },
        {
          "exercise": "एक यूएसबी ड्राइव को पार्टीशन करें जिसमें ड्राइव का आधा हिस्सा ext4 और दूसरा आधा खाली हो।",
          "id": 4,
          "lessonContent": "एक यूएसबी ड्राइव पर फाइल सिस्टम के साथ कुछ व्यावहारिक काम करें और प्रक्रिया के माध्यम से काम करें। यदि आपके पास एक नहीं है, तो चिंता न करें, आप इन अगले कुछ पाठों का पालन कर सकते हैं। \n\nपहले हमें अपनी डिस्क को पार्टीशन करने की आवश्यकता है। इसे करने के लिए कई उपकरण उपलब्ध हैं: \n\n<ul>\n<li>fdisk - बुनियादी कमांड-लाइन पार्टीशनिंग उपकरण, यह GPT का समर्थन नहीं करता है</li>\n<li>parted - यह एक कमांड लाइन उपकरण है जो MBR और GPT पार्टीशनिंग दोनों का समर्थन करता है</li>\n<li>gparted - यह parted का GUI संस्करण है</li>\n<li>gdisk - fdisk, लेकिन यह MBR का समर्थन नहीं करता है, केवल GPT</li>\n</ul>\n\nचलो parted का उपयोग करके हमारा पार्टीशनिंग करें। मान लो मैं यूएसबी डिवाइस कनेक्ट करता हूं और हम देखते हैं कि डिवाइस का नाम /dev/sdb2 है। \n\n<b>parted को लॉन्च करें</b>\n\n<pre>$ sudo parted</pre>\n\nआप parted उपकरण में प्रवेश कर जाएंगे, यहाँ आप अपनी डिवाइस को पार्टीशन करने के लिए कमांड चला सकते हैं। \n\n<b>डिवाइस का चयन करें</b>\n\n<pre>select /dev/sdb2</pre>\n\nआपको काम कर रहे डिवाइस का चयन करने के लिए, उसे उसके डिवाइस नाम द्वारा चुनें।\n\n<b>वर्तमान पार्टीशन तालिका देखें</b>\n\n<pre>\n(parted) print                                                            \nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\nयहाँ आप डिवाइस पर उपलब्ध पार्टीशन देखेंगे। <b>शुरुआत</b> और <b>समाप्ति</b> बिंदु हैं जहाँ पार्टीशन्स हार्ड ड्राइव पर स्थान लेते हैं, आपको अपने पार्टीशन के लिए एक अच्छा शुरुआत और समाप्ति स्थान ढूंढना होगा। \n\n<b>डिवाइस को पार्टीशन करें</b>\n\n<pre>mkpart primary 123 4567</pre>\n\nअब बस एक शुरुआत और समाप्ति बिंदु चुनें और पार्टीशन बनाएं, आपको पार्टीशन के प्रकार का निर्धारण करना होगा जिस परत आपने उपयोग किया। \n\n<b>पार्टीशन को आकार दें</b>\n\nयदि आपके पास कोई स्थान नहीं है तो आप पार्टीशन का आकार बढ़ा सकते हैं। \n\n<pre>resize 2 1245 3456</pre>\n\nपार्टीशन संख्या का चयन करें और फिर उस स्थान का चयन करें जहाँ आप इसे बढ़ाना चाहते हैं। \n\nParted एक बहुत शक्तिशाली उपकरण है और जब आप अपनी डिस्क को पार्टीशन कर रहे हो तो सावधान रहना चाहिए।",
          "quizAnswer": "mkpart",
          "quizQuestion": "पार्टेड कमांड क्या है जिससे पार्टीशन बनाया जा सकता है?",
          "slug": "diskpartitioning",
          "title": "डिस्क पार्टीशनिंग"
        },
        {
          "exercise": "USB ड्राइव पर एक ext4 फ़ाइल सिस्टम बनाएँ।",
          "id": 5,
          "lessonContent": "अब जब आपने वास्तव में एक डिस्क को विभाजित कर लिया है, तो फिर एक फ़ाइल सिस्टम बनाएँ!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nइतना ही! <b>mkfs</b> (फ़ाइल सिस्टम बनाएँ) उपकरण हमें यह निर्दिष्ट करने की अनुमति देता है कि हमें कौन सा फ़ाइल सिस्टम चाहिए और हमें कहाँ चाहिए। आपको केवल एक नए विभाजित डिस्क पर या अगर आप पुराने को फिर से विभाजित कर रहे हैं तो एक फ़ाइल सिस्टम बनाना चाहिए। आपको संभावित रूप से अपने फ़ाइल सिस्टम को एक विकृत स्थिति में छोड़ देना होगा अगर आप किसी मौजूदा पर एक बनाने का प्रयास करते हैं।",
          "quizAnswer": "mkfs",
          "quizQuestion": "फ़ाइल सिस्टम बनाने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "creatingfilesystems",
          "title": "फ़ाइल सिस्टम बनाना"
        },
        {
          "exercise": "माउंट और अनमाउंट के मैनपेज देखें और देखें कि आप कौन से अन्य विकल्प उपयोग कर सकते हैं।",
          "id": 6,
          "lessonContent": "अपने फ़ाइल सिस्टम की सामग्री देखने से पहले, आपको इसे माउंट करना होगा। उसके लिए मुझे डिवाइस स्थान, फ़ाइल सिस्टम प्रकार और माउंट प्वाइंट की आवश्यकता है, माउंट प्वाइंट सिस्टम पर एक निर्देशिका है जहां फ़ाइल सिस्टम जुड़ा जाएगा। तो हम बुनियादी रूप से अपनी डिवाइस को एक माउंट प्वाइंट पर माउंट करना चाहते हैं।\n\nसबसे पहले माउंट प्वाइंट बनाएं, हमारे मामले में <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nइतना ही! अब जब हम /mydrive पर जाते हैं, हम अपनी फ़ाइल सिस्टम की सामग्री देख सकते हैं, <b>-t</b> फ़ाइल सिस्टम का प्रकार निर्दिष्ट करता है, फिर हमारे पास डिवाइस स्थान है, फिर माउंट प्वाइंट है।\n\nएक डिवाइस को माउंट प्वाइंट से अनमाउंट करने के लिए:\n\n<pre>$ sudo umount /mydrive \nया \n$ sudo umount /dev/sdb2</pre>\n\nध्यान रखें कि कर्नेल उन्हें उसी क्रम में डिवाइसों के नाम देता है जिसे वह पाता है। अगर किसी कारण से हमारे डिवाइस का नाम बदल जाता है उसके बाद हम इसे माउंट करते हैं? अच्छा भाग्य से, आप एक डिवाइस का यूनिवर्सल यूनिक आईडी (UUID) उपयोग कर सकते हैं।\n\nब्लॉक डिवाइस के लिए अपने सिस्टम पर UUID देखने के लिए:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nहम अपने डिवाइसों के नाम, उनके संबंधित फ़ाइल सिस्टम प्रकार और उनके UUID देख सकते हैं। अब जब हम कुछ माउंट करना चाहते हैं, हम इस्तेमाल कर सकते हैं:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nअधिकांश समय आपको डिवाइसों को उनके UUID के माध्यम से माउंट करने की आवश्यकता नहीं होगी, डिवाइस नाम का उपयोग करना बहुत आसान है और अक्सर ऑपरेटिंग सिस्टम सामान्य डिवाइसों जैसे USB ड्राइव को माउंट करने के लिए जानता है। यदि आप स्टार्टअप पर ऑटोमैटिक रूप से किसी फ़ाइल सिस्टम को माउंट करना चाहते हैं जैसे अगर आपने एक द्वितीय हार्ड ड्राइव जोड़ा है, तो आपको UUID का उपयोग करना चाहिए और हम अगले सबक में इस पर चर्चा करेंगे।",
          "quizAnswer": "माउंट",
          "quizQuestion": "फ़ाइल सिस्टम को जोड़ने के लिए कौन सा कमांड उपयोग किया जाता है?",
          "slug": "फ़ाइल सिस्टम को माउंट और अनमाउंट करना",
          "title": "माउंट और अनमाउंट"
        },
        {
          "exercise": "हमारे पास काम कर रहे USB ड्राइव को /etc/fstab में एक एंट्री के रूप में जोड़ें, जब आप पुनः आरंभ करेंगे तो आपको इसे माउंट किए हुए देखना चाहिए।",
          "id": 7,
          "lessonContent": "जब हम फ़ाइल सिस्टम को स्टार्टअप पर स्वचालित रूप से माउंट करना चाहते हैं, तो हम उन्हें एक फ़ाइल में जोड़ सकते हैं जिसे /etc/fstab कहा जाता है (उच्चारित किया जाता है \"इफ एस टैब\" नहीं \"इफ स्टैब\") जिसे फ़ाइल सिस्टम टेबल के लिए संक्षेप में रखा जाता है। इस फ़ाइल में एक स्थायी सूची होती है जिसमें माउंट किए गए फ़ाइल सिस्टम होते हैं।\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nप्रत्येक पंक्ति एक फ़ाइल सिस्टम को प्रतिनिधित करती है, फ़ील्ड हैं:\n\n<ul>\n<li>UUID - डिवाइस पहचानकर्ता</li>\n<li>माउंट पॉइंट - फ़ाइल सिस्टम को माउंट किया गया निर्देशिका</li>\n<li>फ़ाइल सिस्टम प्रकार</li>\n<li>विकल्प - अन्य माउंट विकल्प, अधिक विवरण के लिए मैनपेज देखें</li>\n<li>डंप - बैकअप बनाने के लिए डंप उपयोगीता द्वारा उपयोग किया जाता है, आपको केवल 0 पर डिफ़ॉल्ट करना चाहिए</li>\n<li>पास - fsck द्वारा उपयोग किया जाने वाला है ताकि फ़ाइल सिस्टम की जांच किस क्रम में की जाए, यदि मूल्य 0 है, तो इसे जांचा नहीं जाएगा</li>\n</ul>\n\nएंट्री जोड़ने के लिए, बस /etc/fstab फ़ाइल को ऊपर दिए गए एंट्री वाक्य संरचना का सीधा संशोधन करें। इस फ़ाइल को संशोधित करते समय सावधान रहें, यदि आप गलती कर दें तो आपकी जिंदगी को कुछ कठिन बना सकते हैं।",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "फ़ाइल सिस्टम को कैसे माउंट करने के लिए कौन सी फ़ाइल का उपयोग किया जाता है?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "स्वैप स्थान के लिए USB ड्राइव में फ्री स्थान को पार्टीशन करें।",
          "id": 8,
          "lessonContent": "हमारे पिछले उदाहरण में, मैंने आपको दिखाया कि आप कैसे अपनी पार्टीशन तालिका देख सकते हैं, चलो उस उदाहरण पर वापस आते हैं, और विशेष रूप से इस पंक्ति पर:\n\n<pre>\nNumber  Start   End     Size    Type      File system     Flags\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n</pre>\n\nयह स्वैप पार्टीशन क्या है? वेल स्वैप वह है जिसे हम अपने सिस्टम को वर्चुअल मेमोरी का आवंटन करने के लिए उपयोग करते थे। यदि आपके पास मेमोरी कम है, तो सिस्टम इस पार्टीशन का उपयोग करता है ताकि आपको मेमोरी के लिए बोग न हो।\n\n<b>स्वैप स्थान के लिए पार्टीशन का उपयोग</b>\n\nचलो मान लेते हैं कि हमें अपनी /dev/sdb2 पार्टीशन को स्वैप स्थान के लिए सेट करना है।\n\n<ol>\n<li>पहले यह सुनिश्चित करें कि पार्टीशन पर कुछ भी नहीं है</li>\n<li>चलाएं: mkswap /dev/sdb2 स्वैप क्षेत्रों को प्रारंभ करने के लिए</li>\n<li>चलाएं: swapon /dev/sdb2 यह स्वैप डिवाइस सक्षम करेगा</li>\n<li>यदि आप चाहते हैं कि स्वैप पार्टीशन बूटअप पर बना रहे, तो आपको /etc/fstab फ़ाइल में एक प्रविष्टि जोड़नी होगी। sw वह फ़ाइल सिस्टम प्रकार है जिसका आप उपयोग करेंगे।</li>\n<li>स्वैप हटाने के लिए: swapoff /dev/sdb2</li>\n</ol>\n\nसामान्यत: आपको आम तौर पर जितनी अधिक स्वैप स्थान का आवंटन करना चाहिए जितनी आपके पास मेमोरी है। लेकिन आजकल के सिस्टम आमतौर पर काफी शक्तिशाली हैं और पर्याप्त रैम है।",
          "quizAnswer": "swapon",
          "quizQuestion": "किस डिवाइस पर स्वैप स्थान को सक्षम करने के लिए कमांड क्या है?",
          "slug": "swapspace",
          "title": "स्वैप"
        },
        {
          "exercise": "du और df के साथ अपने डिस्क उपयोग और खाली स्थान को देखें।",
          "id": 9,
          "lessonContent": "आप अपने डिस्क के उपयोग को देखने के लिए कुछ टूल हैं: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocks    Used Available Use% Mounted on\n/dev/sda1       6.2G  2.3G   3.6G  40% /\n</pre>\n\ndf कमांड आपको वर्तमान माउंटेड फ़ाइल सिस्टम का उपयोग दिखाता है। -h फ़्लैग आपको एक मानव पठनीय प्रारूप प्रदान करता है। आप देख सकते हैं कि उपकरण क्या है, और कितना क्षमता उपयुक्त और उपलब्ध है। \n\nकहें कि आपका डिस्क भर रहा है और आप जानना चाहते हैं कि कौन सी फ़ाइलें या निर्देशिकाएँ उस स्थान को ले रही हैं, उसके लिए आप <b>du</b> कमांड का उपयोग कर सकते हैं। \n\n<pre>$ du -h</pre>\n\nयह आपको वर्तमान निर्देशिका के डिस्क उपयोग को दिखाता है, आप <b>du -h /</b> के साथ रूट निर्देशिका पर झांक सकते हैं लेकिन वह थोड़ा अधिक अव्यवस्थित हो सकता है।\n\nइन दोनों कमांडों का संयंत्र इतना समान है कि किसे उपयोग करना है यह याद करना कठिन हो सकता है, अपने <b>डिस्क</b> कितना <b>खाली</b> है यह जांचने के लिए df का उपयोग करें। <b>डिस्क उपयोग</b> जांचने के लिए, du का उपयोग करें।",
          "quizAnswer": "df",
          "quizQuestion": "आपके डिस्क पर कितना खाली स्थान है यह दिखाने के लिए कौन सी कमांड का उपयोग किया जाता है?",
          "slug": "diskusage",
          "title": "डिस्क उपयोग"
        },
        {
          "exercise": "fsck के मैनपेज पर देखें कि यह क्या और कैसे कर सकता है।",
          "id": 10,
          "lessonContent": "कभी-कभी हमारी फाइलसिस्टम हमेशा सर्वश्रेष्ठ स्थिति में नहीं होती है, अगर हमें एक अचानक बंद होने का सामना करना पड़ता है, तो हमारा डेटा क्षतिग्रस्त हो सकता है। यह सिस्टम के ऊपर है कि हमें एक काम करने वाली स्थिति में वापस ले आए (हालांकि हम खुद प्रयास कर सकते हैं)। \n\n<b>fsck</b> (फाइलसिस्टम चेक) कमांड का उपयोग फाइलसिस्टम की संगतता की जांच के लिए किया जाता है और हमारे लिए इसे मरम्मत करने की कोशिश भी कर सकता है। सामान्यत: जब आप डिस्क को बूट करते हैं, तो fsck चलाया जाएगा पहले जब तक आपकी डिस्क माउंट नहीं होती है ताकि सब कुछ ठीक हो। कभी-कभी हालात ऐसे होते हैं कि आपकी डिस्क इतनी खराब होती है कि आपको इसे मैन्युअल रूप से करना पड़ेगा। हालांकि, सुनिश्चित करें कि आप इसे ऐसे करते हैं जब आप एक रेस्क्यू डिस्क या किसी ऐसी जगह में हैं जहाँ आप अपनी फाइलसिस्टम तक पहुंच सकते हैं जिसे माउंट नहीं किया गया हो।\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "फाइलसिस्टम की पूर्णता की जांच करने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "फाइलसिस्टममरम्मत",
          "title": "फाइलसिस्टम मरम्मत"
        },
        {
          "exercise": "विभिन्न फ़ाइलों के लिए कुछ इनोड संख्याएँ देखें, जिन्हें आम तौर पर पहले बनाया जाता है?",
          "id": 11,
          "lessonContent": "हमारी फ़ाइल सिस्टम कैसे हमारी वास्तविक फ़ाइलों और इन फ़ाइलों का प्रबंधन करने वाले डेटाबेस से बना होता है? डेटाबेस को इनोड तालिका के रूप में जाना जाता है।\n\n<b>इनोड क्या है?</b>\n\nएक इनोड (इंडेक्स नोड) इस तालिका में एक प्रविष्टि है और हर फ़ाइल के लिए एक होता है। यह फ़ाइल के बारे में सब कुछ वर्णित करता है, जैसे कि:\n\n<ul>\n<li>फ़ाइल प्रकार - नियमित फ़ाइल, निर्देशिका, वर्णन उपकरण, आदि</li>\n<li>मालिक</li>\n<li>समूह</li>\n<li>पहुँच अनुमतियाँ</li>\n<li>समय चिह्न - mtime (अंतिम फ़ाइल संशोधन का समय), ctime (अंतिम गुण बदलने का समय), atime (अंतिम पहुँच का समय)</li>\n<li>फ़ाइल के लिए हार्डलिंक्स की संख्या</li>\n<li>फ़ाइल का आकार</li>\n<li>फ़ाइल के लिए निर्धारित ब्लॉकों की संख्या</li>\n<li>फ़ाइल के डेटा ब्लॉक्स के पॉइंटर - सबसे महत्वपूर्ण!</li>\n</ul>\n\nमुख्य रूप से इनोड्स फ़ाइल के बारे में सब कुछ संग्रहित करते हैं, केवल फ़ाइल का नाम और फ़ाइल स्वयं छोड़कर!\n\n<b>इनोड्स कब बनाए जाते हैं?</b>\n\nजब एक फ़ाइल सिस्टम बनाई जाती है, तो इनोड्स के लिए जगह भी आवंटित की जाती है। डिस्क के आयाम और अधिक के आधार पर आपको कितना इनोड स्थान चाहिए यह निर्धारित करने वाले एल्गोरिदम होते हैं। आपने अपने जीवन में कभी न कभी डिस्क स्थान की समस्याओं के लिए त्रुटियाँ देखी होंगी। वैसे ही इनोड्स के लिए भी यह समस्या उत्पन्न हो सकती है (हालांकि कम होती है), आप इनोड्स से खत्म हो सकते हैं और फिर अधिक फ़ाइलें नहीं बना सकते। याद रखें डेटा संग्रहण डेटा और डेटाबेस (इनोड्स) दोनों पर निर्भर करता है।\n\nअपने सिस्टम पर बचे हुए इनोड्स की संख्या देखने के लिए, आप <b>df -i</b> कमांड का उपयोग करें\n\n<b>इनोड सूचना</b>\n\nइनोड्स को संख्याओं द्वारा पहचाना जाता है, जब एक फ़ाइल बनाई जाती है तो उसे एक इनोड संख्या सौंपी जाती है, संख्या क्रमशः सौंपी जाती है। हालांकि, कभी-कभार आपको यह ध्यान देने की आवश्यकता है कि जब आप एक नई फ़ाइल बनाते हैं, तो उसे एक इनोड संख्या मिलती है जो अन्यों से कम होती है, यह इसलिए है क्योंकि एक बार जब इनोड्स हटा दिए जाते हैं, तो वे अन्य फ़ाइलों द्वारा पुनः प्रयोग किए जा सकते हैं। इनोड संख्याएँ देखने के लिए <b>ls -li</b> चलाएं:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nइस कमांड में पहला क्षेत्र इनोड संख्या सूचित करता है।\n\nआप स्टैट के साथ एक फ़ाइल के बारे में विस्तृत जानकारी भी देख सकते हैं, यह आपको इनोड के बारे में जानकारी देता है।\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  File: ‘/home/pete/Desktop/’\n  Size: 6               Blocks: 0          IO Block: 4096   directory\nDevice: 806h/2054d      Inode: 140         Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAccess: 2016-01-20 20:13:50.647435982 -0800\nModify: 2016-01-20 20:13:06.191675843 -0800\nChange: 2016-01-20 20:13:06.191675843 -0800\n Birth: -\n</pre>\n\n\n<b>इनोड्स फ़ाइलों को कैसे खोजते हैं?</b>\n\nहमें पता है कि हमारा डेटा कहीं डिस्क पर है, दुर्भाग्य से यह संभावना है कि यह क्रमशः स्टोर नहीं किया गया था, इसलिए हमें इनोड्स का उपयोग करना पड़ता है। इनोड्स आपकी फ़ाइलों के वास्तविक डेटा ब्लॉक्स को पॉइंट करते हैं। एक साधारण फ़ाइल सिस्टम में (सभी एक जैसे काम नहीं करते), प्रत्येक इनोड 15 पॉइंटर्स शामिल होते हैं, पहले 12 पॉइंटर्स सीधे डेटा ब्लॉक्स को पॉइंट करते हैं। 13वां पॉइंटर, और ब्लॉक को पॉइंट करता है जिसमें अधिक ब्लॉक्स के पॉइंटर्स होते हैं, 14वां पॉइंटर एक और नेस्टेड पॉइंटर्स के ब्लॉक को पॉइंट करता है, और 15वां पॉइंटर फिर से एक और पॉइंटर्स के ब्लॉक को पॉइंट करता है! गंभीर, मुझे पता है! इसे इस प्रकार किया जाता है क्योंकि हर इनोड के लिए इनोड संरचना को समान रखने के लिए किया जाता है, लेकिन विभिन्न आकारों की फ़ाइलों को संदर्भित करने की क्षमता रखने के लिए। यदि आपके पास एक छोटी फ़ाइल है, तो आप पहले 12 सीधे पॉइंटर्स के साथ इसे तेजी से खोज सकते हैं, बड़ी फ़ाइलें पॉइंटर्स के नेस्ट्स के साथ मिल सकती हैं। चाहे जैसे भी हो, इनोड संरचना हर इनोड के लिए समान है, लेकिन विभिन्न आकारों की फ़ाइलों का संदर्भ करने की क्षमता रखने के लिए।",
          "quizAnswer": "df -i",
          "quizQuestion": "आप अपने सिस्टम पर बचे हुए इनोड्स की संख्या कैसे देखते हैं?",
          "slug": "inodes",
          "title": "इनोड्स"
        },
        {
          "exercise": "सिम्लिंक्स और हार्डलिंक्स बनाने के साथ खेलें, कुछ हटाएं और देखें कि क्या होता है।",
          "id": 12,
          "lessonContent": "हम इनोड सूचना के पिछले उदाहरण का उपयोग करेंगे:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 जनवरी 20 20:13 डेस्कटॉप\n141 drwxr-xr-x 2 pete pete 6 जनवरी 20 20:01 दस्तावेज़\n</pre>\n\nआपने शायद नोट किया होगा कि हमने ls कमांड में तीसरे फील्ड को छोड़ दिया है, वह फ़ील्ड लिंक गणना है। लिंक गणना एक फ़ाइल के कठिन लिंकों की कुल संख्या है, जो अभी आपके लिए कुछ नहीं मतलब रखता है। तो चलिए पहले लिंक पर चर्चा करें।\n\n<b>सिम्बॉलिक लिंक्स</b>\n\nWindows ऑपरेटिंग सिस्टम में, चीज़ों को शॉर्टकट के रूप में जाना जाता है, शॉर्टकट्स बस अन्य फ़ाइलों के लिए उपनाम होते हैं। यदि आप मूल फ़ाइल पर कुछ करते हैं, तो आपको शॉर्टकट टूट सकता है। Linux में, शॉर्टकट का समकक्ष सिम्बॉलिक लिंक्स (या सॉफ्ट लिंक्स या सिमलिंक्स) हैं। सिम्बॉलिक लिंक्स हमें फ़ाइल को उसके फ़ाइलनाम से लिंक करने की अनुमति देते हैं। Linux में पाए जाने वाले अन्य प्रकार के लिंक्स हार्डलिंक्स हैं, ये वास्तव में एक इनोड को लिंक करने वाली एक और फ़ाइल हैं। चलिए देखते हैं कि मैं क्या मतलब है प्रैक्टिस करते हैं सिम्बॉलिक लिंक्स के साथ।\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 जनवरी 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 जनवरी 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 जनवरी 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 जनवरी 21 21:39 myfilelink -> myfile\n</pre>\n\nआप देख सकते हैं कि मैंने myfile को निशानिका लिंक नामित किया है जो myfile को निशानित करता है। सिम्बॉलिक लिंक्स -> द्वारा दर्शाए जाते हैं। ध्यान दें कि मुझे एक नया इनोड नंबर मिल गया है, सिम्बॉलिक लिंक्स बस फ़ाइलें हैं जो फ़ाइलनामों को निशानित करती हैं। जब आप एक सिम्बॉलिक लिंक को संशोधित करते हैं, तो फ़ाइल भी संशोधित हो जाती है। इनोड नंबर फ़ाइलसिस्टम के लिए अद्वितीय होते हैं, आप एक सिंगल फ़ाइलसिस्टम में दो एक ही इनोड नंबर नहीं रख सकते, अर्थात आप एक फ़ाइल को एक अलग फ़ाइलसिस्टम में इनोड नंबर के द्वारा संदर्भित नहीं कर सकते। हालांकि, यदि आप सिम्बॉलिक लिंक्स का उपयोग करते हैं तो वे इनोड नंबर का उपयोग नहीं करते हैं, वे फ़ाइलनामों का उपयोग करते हैं, इसलिए वे विभिन्न फ़ाइलसिस्टमों में संदर्भित किए जा सकते हैं।\n\n<b>हार्डलिंक्स</b>\n\nएक हार्डलिंक का उदाहरण देखें:\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 जनवरी 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 जनवरी 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 जनवरी 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 जनवरी 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 जनवरी 21 21:36 myhardlink\n</pre>\n\nएक हार्डलिंक बस एक और इनोड के लिए एक लिंक बनाता है। तो अगर मैं myfile2 या myhardlink की सामग्री को संशोधित करता हूं, तो परिवर्तन दोनों पर दिखाई देगा, लेकिन अगर मैं myfile2 को हटा देता हूं, तो फ़ाइल अभी भी myhardlink के माध्यम से पहुंची जा सकती है। यहाँ हमारे ls कमांड में लिंक गणना का खेल आता है। लिंक गणना एक इनोड की हार्डलिंक्स की संख्या है, जब आप एक फ़ाइल को हटाते हैं, तो वह लिंक गणना कम हो जाएगी। इनोड केवल तब हटाया जाता है जब इनोड के सभी हार्डलिंक्स हटा दिए गए होते हैं। जब आप एक फ़ाइल बनाते हैं, तो उसकी लिंक गणना 1 होती है क्योंकि यह वह एकमात्र फ़ाइल है जो उस इनोड को निशानित कर रही है। सिम्बॉलिक लिंक्स की तरह, हार्डलिंक्स फ़ाइलसिस्टम के लिए अद्वितीय होते हैं क्योंकि इनोड फ़ाइलसिस्टम के लिए अद्वितीय होते हैं।\n\n<b>सिम्बॉलिक लिंक बनाना</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nएक सिम्बॉलिक लिंक बनाने के लिए, आप -s के साथ ln कमांड का उपयोग करते हैं और फिर एक लक्ष्य फ़ाइल और फिर एक लिंक नाम निर्दिष्ट करते हैं।\n\n<b>हार्डलिंक बनाना</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nसिम्बॉलिक लिंक निर्माण के लिए समान, केवल इस बार आप -s को छोड़ देते हैं।",
          "quizAnswer": "ln -s",
          "quizQuestion": "सिम्बॉलिक लिंक बनाने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "symlinks",
          "title": "सिमलिंक्स"
        }
      ],
      "slug": "द_फ़ाइलसिस्टम",
      "title": "फ़ाइल सिस्टम"
    },
    {
      "description": "लिनक्स बूट प्रक्रिया के चरणों के बारे में जानें।",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "अपनी सिस्टम को रीबूट करें और देखें कि क्या आप अपनी मशीन को बूट होते समय प्रत्येक चरण को पहचान सकते हैं।",
          "id": 1,
          "lessonContent": "अब जब हमने लिनक्स के कुछ महत्वपूर्ण घटकों को अच्छे से समझ लिया है, तो चलिए उन्हें सभी को एक साथ जोड़कर सीखते हैं कि सिस्टम कैसे बूट होता है। जब आप अपनी मशीन को चालू करते हैं, तो कुछ दिलचस्प चीजें करती है जैसे आपको लोगो स्क्रीन दिखाना, कुछ विभिन्न संदेशों के माध्यम से चलना और फिर अंत में आपको लॉगिन विंडो के साथ प्रॉम्प्ट किया जाता है। वास्तव में जब आप पावर बटन दबाते हैं तब लॉगिन करने तक कई चीजें होती हैं और हम इस पाठ्यक्रम में उनके बारे में चर्चा करेंगे। \n\nलिनक्स बूट प्रक्रिया को 4 सरल चरणों में विभाजित किया जा सकता है: \n\n<b>1. BIOS</b>\n\nBIOS (\"बेसिक इनपुट/आउटपुट सिस्टम\" के लिए खड़ा है) हार्डवेयर को प्रारंभ करता है और सुनिश्चित करता है कि Power-on self test (POST) के साथ सभी हार्डवेयर ठीक हैं। BIOS का मुख्य काम बूटलोडर को लोड करना है।\n\n<b>2. बूटलोडर</b>\n\nबूटलोडर कर्नेल को मेमोरी में लोड करता है और फिर कर्नेल को कुछ कर्नेल पैरामीटर्स के साथ शुरू करता है। सबसे आम बूटलोडर में से एक GRUB है, जो एक सार्वभौमिक लिनक्स मानक है। \n\n<b>3. कर्नेल</b>\n\nजब कर्नेल लोड होता है, तो वह तत्काल उपकरणों और मेमोरी को प्रारंभ करता है। कर्नेल का मुख्य काम इनिट प्रक्रिया को लोड करना है। \n\n<b>4. इनिट</b>\n\nयाद रखें कि इनिट प्रक्रिया पहली प्रक्रिया है जो शुरू होती है, इनिट प्रणाली पर आवश्यक सेवा प्रक्रियाओं को शुरू और बंद करता है। लिनक्स वितरणों में इनिट के तीन प्रमुख कार्यान्वयन हैं। हम उनके बारे में संक्षेप में जाएंगे और फिर एक अन्य पाठ्यक्रम में उनमें डुबकी लगाएंगे।\n\nयह था, लिनक्स बूट प्रक्रिया का (बहुत) सरल व्याख्यान। हम आगामी पाठों में इन चरणों के बारे में अधिक विस्तार से जाएँगे।",
          "quizAnswer": "इनिट",
          "quizQuestion": "लिनक्स बूट प्रक्रिया में आखिरी चरण क्या है?",
          "slug": "bootprocessoverview",
          "title": "बूट प्रक्रिया अवलोकन"
        },
        {
          "exercise": "अपने BIOS मेनू में जाएं और देखें कि क्या आपके पास UEFI बूटिंग सक्षम है।",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nलिनक्स बूट प्रक्रिया में पहला कदम BIOS है जो सिस्टम अखंडता जांच करता है। BIOS एक फर्मवेयर है जो आजकल सबसे आम आईबीएम पीसी संगत कंप्यूटर्स में आता है, जो आजकल के कंप्यूटरों के प्रमुख प्रकार हैं। आपने संभावत: अपने हार्डडिस्क की बूट क्रम बदलने, सिस्टम समय, आपकी मशीन का मैक एड्रेस आदि जांच करने के लिए BIOS फर्मवेयर का उपयोग किया होगा। BIOS का मुख्य लक्ष्य सिस्टम बूटलोडर खोजना है।\n\nतो जब BIOS हार्ड ड्राइव को बूट करता है, तो सिस्टम को बूट करने के लिए बूट ब्लॉक खोजता है। आपके डिस्क को कैसे पार्टीशन किया गया है, इस पर निर्भर करेगा, यह मास्टर बूट रिकॉर्ड (MBR) या GPT की ओर देखेगा। MBR हार्ड ड्राइव के पहले सेक्टर में स्थित है, पहले 512 बाइट्स में। MBR में कोड होता है जो डिस्क के किसी अन्य प्रोग्राम को लोड करने के लिए होता है, यह प्रोग्राम फिर वास्तव में हमारा बूटलोडर लोड करता है।\n\nअब यदि आपने अपने डिस्क को GPT के साथ पार्टीशन किया है, तो बूटलोडर का स्थान थोड़ा बदल जाता है।\n\n<b>UEFI</b>\n\nBIOS का उपयोग करने के बजाय अपने सिस्टम को बूट करने का एक और तरीका है और वह UEFI के साथ है (जिसका मतलब है \"एकीकृत विस्तारयोग्य फर्मवेयर इंटरफेस\"). UEFI को BIOS के उत्तराधिकारी के रूप में डिज़ाइन किया गया था, आजकल के अधिकांश हार्डवेयर UEFI फर्मवेयर सहित आता है। मैकिंटॉश मशीनों ने वर्षों से EFI बूटिंग का उपयोग किया है और विंडोज ने अधिकांश अपनी चीजों को UEFI बूटिंग पर हटा दिया है। GPT प्रारूप का उपयोग EFI के साथ करने के लिए था। यदि आप GPT डिस्क को बूट कर रहे हैं तो आपको आवश्यकता नहीं है कि आपके पास EFI हो। GPT डिस्क का पहला सेक्टर एक \"संरक्षक MBR\" के लिए आरक्षित होता है ताकि BIOS आधारित मशीन को बूट करना संभव हो।\n\nUEFI स्टार्टअप के बारे में सभी जानकारी को एक .efi फ़ाइल में संग्रहित करता है। इस फ़ाइल को हार्डवेयर पर EFI सिस्टम पार्टीशन कहलाने वाले विशेष पार्टीशन पर संग्रहित किया जाता है। इस पार्टीशन के अंदर बूटलोडर होता है। UEFI ट्रेडिशनल BIOS फर्मवेयर से कई सुधार लेकर आया है। हालांकि, क्योंकि हम लिनक्स का उपयोग कर रहे हैं, हम अधिकांश लोग BIOS का उपयोग कर रहे हैं। इसलिए इन सभी सबकों के साथ यह धारणा जारी रहेगी।",
          "quizAnswer": "बूटलोडर",
          "quizQuestion": "BIOS क्या लोड करता है?",
          "slug": "bootprocessbios",
          "title": "बूट प्रक्रिया: BIOS"
        },
        {
          "exercise": "यदि आपके पास GRUB बूटलोडर है, तो 'e' के साथ GRUB मेनू में जाएं और सेटिंग्स को देखें।",
          "id": 3,
          "lessonContent": "बूटलोडर की मुख्य जिम्मेदारियाँ हैं:\n\n<ul>\n<li>ऑपरेटिंग सिस्टम में बूट करना, यह गैर-लिनक्स ऑपरेटिंग सिस्टमों में भी बूट करने के लिए उपयोग किया जा सकता है</li>\n<li>उपयोग करने के लिए कर्नेल का चयन करें</li>\n<li>कर्नेल पैरामीटर निर्दिष्ट करें</li>\n</ul>\n\nलिनक्स के लिए सबसे सामान्य बूटलोडर GRUB है, आप अपने सिस्टम पर इसका उपयोग कर रहे होंगे। आप ऐसे कई अन्य बूटलोडर्स का उपयोग कर सकते हैं जैसे कि LILO, efilinux, coreboot, SYSLINUX और अधिक। हालांकि, हम सिर्फ GRUB के साथ काम करेंगे जैसा कि हमारा बूटलोडर है।\n\nतो हमें पता है कि बूटलोडर का मुख्य लक्ष्य कर्नेल को लोड करना है, लेकिन वह कर्नेल कहाँ ढूंढता है? इसे ढूंढने के लिए, हमें अपने कर्नेल पैरामीटर्स पर नजर डालने की आवश्यकता होगी। पैरामीटर्स को ढूंढने के लिए आपको स्टार्टअप पर GRUB मेनू में जाने की आवश्यकता है और 'e' कुंजी का उपयोग करना है। अगर आपके पास GRUB नहीं है तो चिंता न करें, हम उन बूट पैरामीटर्स के माध्यम से जाएंगे जो आप देखेंगे:\n\n<ul>\n<li>initrd - प्रारंभिक रैम डिस्क का स्थान निर्दिष्ट करता है (हम अगले सबक में इसके बारे में अधिक बात करेंगे)।\n<li>BOOT_IMAGE - यहाँ कर्नेल छवि स्थित है</li>\n<li>root - रूट फ़ाइल सिस्टम का स्थान, कर्नेल इनिट खोजने के लिए इस स्थान के अंदर खोजता है। यह अक्सर उसके यूयूआईडी या डिवाइस नाम जैसे /dev/sda1 द्वारा प्रतिनिधित किया जाता है।</li>\n<li>ro - यह पैरामीटर बहुत सामान्य है, यह फाइल सिस्टम को केवल पढ़ने के मोड के रूप में माउंट करता है।</li>\n<li>quiet - इसे जोड़ा जाता है ताकि आप बूट के दौरान पृष्ठ पर चल रहे पृष्ठ संदेश न देखें।</li>\n<li>splash - यह स्प्लैश स्क्रीन दिखाने देता है।</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "जिस कर्नेल पैरामीटर से आप बूटअप संदेश नहीं देखते हैं, वह कौन सा है?",
          "slug": "bootprocessbootloader",
          "title": "बूट प्रक्रिया: बूटलोडर"
        },
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं।",
          "id": 4,
          "lessonContent": "तो अब जब हमारा बूटलोडर आवश्यक पैरामीटर पारित कर चुका है, तो चलिए देखते हैं कि यह कैसे शुरू होता है:\n\n<b>इनिटर्ड vs इनिट्रामफ्स</b>\n\nकर्नेल बूटअप के बारे में जब हम बात करते हैं तो एक कुकड़ा और अंडा समस्या होती है। कर्नेल हमारे सिस्टम के हार्डवेयर का प्रबंधन करता है, हालांकि बूटअप के दौरान कर्नेल के पास सभी ड्राइवर उपलब्ध नहीं होते। इसलिए हम एक अस्थायी रूट फ़ाइल सिस्टम पर निर्भर करते हैं जिसमें कर्नेल को बाकी हार्डवेयर तक पहुंचने के लिए आवश्यक मॉड्यूल होते हैं। लिनक्स के पुराने संस्करणों में, इस काम को इनिटर्ड (आरंभिक रैम डिस्क) को दिया गया था। कर्नेल इनिटर्ड को माउंट करता था, बूटअप ड्राइवर प्राप्त करता था, फिर जब वह सब कुछ जो उसे चाहिए लोड कर लेता था, तो वह असली रूट फ़ाइल सिस्टम के साथ इनिटर्ड को बदल देता था। आजकल, हमारे पास इनिट्रामफ्स नामक कुछ है, यह एक अस्थायी रूट फ़ाइल सिस्टम है जो कर्नेल में स्वयं बनाया गया है ताकि वास्तविक रूट फ़ाइल सिस्टम के लिए सभी आवश्यक ड्राइवर्स लोड कर सके, इसलिए अब इनिटर्ड फ़ाइल को ढूंढने की आवश्यकता नहीं है।\n\n<b>रूट फ़ाइल सिस्टम को माउंट करना</b>\n\nअब कर्नेल के पास उसे एक रूट डिवाइस बनाने और रूट पार्टीशन को माउंट करने के लिए सभी मॉड्यूल होते हैं। लेकिन आप आगे नहीं बढ़ सकते, रूट पार्टीशन वास्तव में पहले से ही केवल पढ़ने के मोड में माउंट किया जाता है ताकि fsck सुरक्षित रूप से चल सके और सिस्टम अखंडता की जांच कर सके। इसके बाद वह रूट फ़ाइल सिस्टम को पुनः राइट-राइट मोड में माउंट करता है। फिर कर्नेल इनिट प्रोग्राम को ढूंढता है और इसे निष्पादित करता है।",
          "quizAnswer": "इनिट्रामफ्स",
          "quizQuestion": "आधुनिक सिस्टमों में एक अस्थायी रूट फ़ाइल सिस्टम लोड करने के लिए क्या उपयोग किया जाता है?",
          "slug": "bootprocesskernel",
          "title": "बूट प्रक्रिया: कर्नेल"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "हमने पिछले पाठों में आरंभ की चर्चा की है और जानते हैं कि यह वह पहला प्रक्रिया है जो शुरू होती है और हमारे सिस्टम पर सभी अन्य आवश्यक सेवाएं शुरू करती है। लेकिन कैसे?\n\nवास्तव में लिनक्स में आरंभ के तीन प्रमुख कार्यान्वयन हैं: \n\n<b>सिस्टम V आरंभ (सिसवी)</b>\n\nयह पारंपरिक आरंभ सिस्टम है। यह स्वरूप से प्रक्रियाओं को क्रमशः शुरू और बंद करता है, स्टार्टअप स्क्रिप्ट के आधार पर। मशीन की स्थिति को रनलेवल्स द्वारा दर्शाया जाता है, प्रत्येक रनलेवल एक अलग तरीके से मशीन को शुरू या बंद करता है। \n\n<b>अपस्टार्ट</b>\n\nयह आरंभ आप पुराने यूबंटू स्थापनाओं पर पाएंगे। अपस्टार्ट नौकरियों और घटनाओं के विचार का उपयोग करता है और घटनाओं के प्रतिक्रिया में कुछ कार्रवाई करने वाली नौकरियां शुरू करके काम करता है। \n\n<b>सिस्टमड</b>\n\nयह आरंभ के लिए नया मानक है, यह लक्ष्य अनुसार है। मूल रूप से आपके पास एक लक्ष्य है जिसे आप पूरा करना चाहते हैं और सिस्टमड लक्ष्य की आवश्यकताओं को पूरा करने के लिए प्रयास करता है। \n\nहमारे पास आरंभ सिस्टम पर पूरा पाठ्यक्रम है जहां हम इन प्रणालियों में और अधिक विस्तार से गहराई से जाएँगे।",
          "quizAnswer": "सिस्टमड",
          "quizQuestion": "आरंभ के लिए सबसे नवीन मानक क्या है?",
          "slug": "bootprocessinit",
          "title": "बूट प्रक्रिया: आरंभ"
        }
      ],
      "slug": "bootthesystem",
      "title": "सिस्टम बूट करें"
    },
    {
      "description": "लिनक्स सिस्टम का सबसे महत्वपूर्ण हिस्सा, जानें कि यह कैसे काम करता है और इसे कैसे कॉन्फ़िगर करें।",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 1,
          "lessonContent": "जैसा कि आपने इस बिंदु तक सीखा है, कर्नेल ऑपरेटिंग सिस्टम का कोर है। हमने ऑपरेटिंग सिस्टम के अन्य हिस्सों के बारे में बात की है लेकिन अब तक दिखाना बाकी है कि वे सभी मिलकर कैसे काम करते हैं। लिनक्स ऑपरेटिंग सिस्टम को तीन विभिन्न स्तरों के रूप में व्यवस्थित किया जा सकता है।\n\nसबसे मौलिक स्तर है हार्डवेयर, इसमें हमारा सीपीयू, मेमोरी, हार्ड डिस्क, नेटवर्किंग पोर्ट्स आदि शामिल हैं। यह वास्तव में उस भौतिक परत है जो हमारी मशीन क्या कर रही है।\n\nअगला स्तर कर्नेल है, जो प्रक्रिया और मेमोरी प्रबंधन, डिवाइस संचार, सिस्टम कॉल्स, हमारी फाइल सिस्टम की स्थापना आदि संभालता है। कर्नेल का काम है हार्डवेयर से बातचीत करना ताकि वह हमारी प्रक्रियाओं को करना चाहिए वह करे।\n\nऔर वह स्तर जिसके बारे में आप परिचित हैं उसे यूजर स्पेस कहा जाता है, यूजर स्पेस में शैल, आप चलाते हैं, ग्राफिक्स आदि शामिल हैं।\n\nइस पाठ्यक्रम में, हम कर्नेल पर ध्यान केंद्रित करेंगे और इसकी जटिलताओं को सीखेंगे।",
          "quizAnswer": "कर्नेल",
          "quizQuestion": "ऑपरेटिंग सिस्टम का कौन सा स्तर उपकरणों का प्रबंधन करता है?",
          "slug": "kerneloverview",
          "title": "कर्नेल का अवलोकन"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 2,
          "lessonContent": "अगले कुछ पाठ बहुत सिद्धांतात्मक होते हैं, इसलिए यदि आप कुछ व्यावहारिक चीजें देख रहे हैं तो आप आगे बढ़ सकते हैं और बाद में वापस आ सकते हैं।\n\nहमारे पास उपयोगकर्ता स्थान और कर्नेल के लिए विभिन्न व्यवस्थापन परत हैं, इसलिए आप दोनों शक्तियों को एक ही परत में क्यों नहीं मिला सकते? अच्छा, इन दो परतों का अलग-अलग होने का एक बहुत अच्छा कारण है। वे दोनों विभिन्न मोड में काम करते हैं, कर्नेल कर्नेल मोड में काम करता है और उपयोगकर्ता स्थान उपयोगकर्ता मोड में काम करता है।\n\nकर्नेल मोड में, कर्नेल को हार्डवेयर तक पूरी पहुंच होती है, वह सब कुछ नियंत्रित करता है। उपयोगकर्ता स्थान मोड में, आपको पहुंचने की अनुमति दी जाती है एक बहुत ही छोटी सी मात्रा मेमोरी और सीपीयू की। मौजूदा, जब हम कुछ भी करना चाहते हैं जो हार्डवेयर से संबंधित होता है, अपनी डिस्क से डेटा पढ़ना, अपनी डिस्क पर डेटा लिखना, हमारी नेटवर्क को नियंत्रित करना, आदि, सब कुछ कर्नेल मोड में किया जाता है। यह क्यों आवश्यक है? कल्पना करें कि आपकी मशीन में स्पाईवेयर से संक्रमित हो गई है, आप चाहेंगे कि इसे आपके सिस्टम के हार्डवेयर का सीधा पहुंच होने की अनुमति न हो। यह आपके सभी डेटा, आपकी वेबकैम, आदि तक पहुंच सकता है और यह अच्छा नहीं है।\n\nये विभिन्न मोड को विशेषाधिकार स्तर कहा जाता है (जिन्हें आप प्राप्त करते हैं) और अक्सर सुरक्षा छलांगों के रूप में वर्णित किया जाता है। इस चित्र को आसान बनाने के लिए, चलो मान लेते हैं कि आपको पता चल गया है कि आपके स्थानीय क्लर्ब में ब्रिटनी स्पीयर्स है, उसे उसके ग्रुपीज, फिर उसके व्यक्तिगत बॉडीगार्ड्स, फिर क्लर्ब के बाहर के बाउंसर से संरक्षित किया गया है। आप उसका हस्ताक्षर प्राप्त करना चाहते हैं (क्योंकि क्यों नहीं?), लेकिन आप उस तक पहुंच नहीं सकते क्योंकि वह पूरी तरह से संरक्षित है। रिंग एक ही तरह से काम करते हैं, सबसे अंदरी रिंग सबसे अधिक विशेषाधिकार स्तर के साथ संबंधित है। एक x86 कंप्यूटर विन्यास में दो मुख्य स्तर या मोड होते हैं। रिंग #3 उपयोगकर्ता मोड एप्लिकेशन चलाता है, रिंग #0 कर्नेल चलाता है। रिंग #0 किसी भी सिस्टम निर्देश को क्रियान्वित कर सकता है और पूर्ण विश्वास दिया जाता है। तो अब जब हमें पता चल गया है कि वे विशेषाधिकार स्तर कैसे काम करते हैं, हम हार्डवेयर पर कुछ भी लिख सकते हैं कैसे? क्या हमेशा कर्नेल से भिन्न मोड में रहेंगे? \n\nउत्तर है सिस्टम कॉल के साथ, सिस्टम कॉल हमें कर्नेल मोड में एक विशेषाधिकृत निर्देश करने की अनुमति देते हैं और फिर उपयोगकर्ता मोड में वापस स्विच करने की।",
          "quizAnswer": "0",
          "quizQuestion": "सबसे अधिक विशेषाधिकारों वाला रिंग नंबर क्या है?",
          "slug": "कर्नेलविशेषाधिकारस्तर",
          "title": "विशेषाधिकार स्तर"
        },
        {
          "exercise": "इस सबक के लिए कोई व्यायाम नहीं।",
          "id": 3,
          "lessonContent": "पिछले सबक में ब्रिटनी को याद करें? चलो मान लो हम उसे देखना चाहते हैं और कुछ पेय पीने के लिए, हम खड़े होकर भी भीड़ के बाहर से उसके अंदरी वर्ग में कैसे पहुंचेंगे? हम सिस्टम कॉल्स का उपयोग करेंगे। सिस्टम कॉल्स वे VIP पास हैं जो आपको एक गुप्त साइड दरवाजे तक पहुंचाते हैं जो सीधे ब्रिटनी के पास जाता है।\n\nसिस्टम कॉल्स (सिस्कॉल) उपयोगकर्ता स्थान प्रक्रियाओं को करने के लिए कर्नेल से कुछ मांगने का एक तरीका प्रदान करते हैं। कर्नेल सिस्टम कॉल API के माध्यम से कुछ सेवाएं उपलब्ध कराता है। ये सेवाएं हमें फ़ाइल पढ़ने या लिखने, मेमोरी उपयोग में परिवर्तन करने, हमारा नेटवर्क मोडिफ़ाई करने आदि करने की अनुमति देती हैं। सेवाओं की मात्रा स्थिर है, इसलिए आप सिस्टम कॉल्स को बेहुदा जोड़ नहीं सकते, आपके सिस्टम में पहले से ही किस सिस्टम कॉल का तालिका है और प्रत्येक सिस्टम कॉल का एक अद्वितीय आईडी होता है।\n\nमैं सिस्टम कॉल्स की विशेषताओं में नहीं जाऊंगा, क्योंकि इसके लिए आपको C के थोड़े से जानकारी होनी चाहिए, लेकिन मूल बात यह है कि जब आप ls जैसे कोई प्रोग्राम कॉल करते हैं, तो इस प्रोग्राम के अंदर का कोड एक सिस्टम कॉल रैपर (इसलिए असल सिस्टम कॉल नहीं) शामिल होता है। इस रैपर के अंदर वह सिस्टम कॉल को आमंत्रित करता है जो एक फंदा कार्यान्वित करेगा, यह फंदा फिर सिस्टम कॉल हैंडलर द्वारा पकड़ा जाता है और फिर सिस्टम कॉल तालिका में सिस्टम कॉल को संदर्भित करता है। मान लो हम stat() सिस्टम कॉल को कॉल करने की कोशिश कर रहे हैं, इसे सिस्कॉल आईडी द्वारा पहचाना जाता है और stat() सिस्टम कॉल का उद्देश्य एक फ़ाइल की स्थिति का पूछताछ करना है। अब याद रखें, आप गैर-विशेषाधिकार मोड में ls प्रोग्राम चला रहे थे। तो अब यह देखता है कि आप सिस्टम कॉल करने की कोशिश कर रहे हैं, तो यह आपको कर्नेल मोड में स्विच कर देता है, वहां यह बहुत सारी चीजें करता है लेकिन सबसे महत्वपूर्ण यह है कि यह आपके सिस्कॉल नंबर को खोजता है, सिस्कॉल आईडी के आधार पर एक तालिका में इसे खोजता है और फिर आपके द्वारा चलाना चाहते फ़ंक्शन को कार्यान्वित करता है। जब यह समाप्त हो जाता है, तो यह उपयोगकर्ता मोड में वापस लौट जाता है और आपकी प्रक्रिया को यदि यह सफल था या अगर उसमें कोई त्रुटि थी तो एक रिटर्न स्थिति प्राप्त होगी। सिस्टम कॉल्स की आंतरिक कामनाएँ वास्तव में विस्तृत होती हैं, मैं आपको अधिक जानने के लिए ऑनलाइन जानकारी देखने की सिफारिश करूंगा।\n\nआप वास्तव में एक प्रक्रिया द्वारा किए गए सिस्टम कॉल्स को strace कमांड के साथ देख सकते हैं। strace कमांड एक प्रोग्राम कैसे निष्पादित हुआ है, इसकी डीबगिंग के लिए उपयोगी है।\n\n<pre>$ strace ls</pre>",
          "quizAnswer": "सिस्टम कॉल",
          "quizQuestion": "उपयोगकर्ता मोड से कर्नेल मोड में स्विच करने के लिए क्या उपयोग किया जाता है?",
          "slug": "systemcalls",
          "title": "सिस्टम कॉल्स"
        },
        {
          "exercise": "<ol>\n<li>जांचें कि आपके पास कौन सा कर्नेल संस्करण है।</li>\n<li>उपलब्ध कर्नेल संस्करणों का अनुसंधान करें</li>\n</ol>",
          "id": 4,
          "lessonContent": "ठीक है, अब जब हमने सभी उबाऊ चीजें बाहर निकाल दी हैं, तो चलिए वास्तव में कर्नेल को स्थापित और संशोधित करने के बारे में बात करें। आप अपने सिस्टम पर कई कर्नेल स्थापित कर सकते हैं, क्या आप हमारे बूट प्रक्रिया पर पाठ में याद करते हैं? हमारे GRUB मेनू में हम कर्नेल को बूट करने के लिए कौन सा कर्नेल चुन सकते हैं। \n\nअपने सिस्टम पर कौन सा कर्नेल संस्करण है, इसे देखने के लिए निम्नलिखित कमांड का उपयोग करें:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nuname कमांड सिस्टम जानकारी प्रिंट करता है, -r कमांड सभी कर्नेल रिलीज संस्करण को प्रिंट करेगा।\n\nआप लिनक्स कर्नेल को विभिन्न तरीकों से स्थापित कर सकते हैं, आप स्रोत पैकेज डाउनलोड करके स्रोत से कंपाइल कर सकते हैं या आप पैकेज प्रबंधन उपकरण का उपयोग करके इसे स्थापित कर सकते हैं।\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\nऔर फिर आप उस कर्नेल में पुनः बूट करें जिसे आपने स्थापित किया है। सरल है ना? थोड़ा, आपको अन्य लिनक्स पैकेज भी स्थापित करने की आवश्यकता होगी जैसे कि लिनक्स-हेडर्स, लिनक्स-इमेज-जेनेरिक, आदि)। आप संस्करण संख्या भी निर्दिष्ट कर सकते हैं, इसलिए उपरोक्त कमांड इस प्रकार दिख सकता है, <b>sudo apt install 3.19.0-43-generic</b>\n\nवैकल्पिक रूप से, यदि आप बस अपडेटेड कर्नेल संस्करण चाहते हैं, तो बस dist-upgrade का उपयोग करें, यह आपके सिस्टम पर सभी पैकेज को अपग्रेड करता है:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nकई विभिन्न कर्नेल संस्करण हैं, कुछ को एलटीएस (लंबे समय तक समर्थन) के रूप में उपयोग किया जाता है, कुछ नवीनतम और श्रेष्ठ होते हैं, कर्नेल संस्करणों के बीच संगतता बहुत भिन्न हो सकती है, इसलिए आपको विभिन्न कर्नेल की कोशिश करनी चाहिए।",
          "quizAnswer": "uname -r",
          "quizQuestion": "आप अपने सिस्टम का कर्नेल संस्करण कैसे देखते हैं?",
          "slug": "kernelinstallation",
          "title": "कर्नेल स्थापना"
        },
        {
          "exercise": "अपनी बूट निर्देशिका में जाएं और देखें कि वहाँ कौन सी फ़ाइलें हैं।",
          "id": 5,
          "lessonContent": "नए कर्नेल को इंस्टॉल करने पर क्या होता है? वास्तव में यह आपके सिस्टम में कुछ फ़ाइलें जोड़ता है, ये फ़ाइलें आम तौर पर /boot निर्देशिका में जोड़ी जाती हैं।\n\nआप विभिन्न कर्नेल संस्करणों के लिए कई फ़ाइलें देखेंगे:\n\n<ul>\n<li>vmlinuz - यह वास्तव में लिनक्स कर्नेल है</li>\n<li>initrd - जैसा कि हमने पहले चर्चा की है, इनिटर्ड को कर्नेल लोड होने से पहले एक अस्थायी फ़ाइल सिस्टम के रूप में उपयोग किया जाता है</li>\n<li>System.map - प्रतीकात्मक लुकअप तालिका</li>\n<li>config - कर्नेल कॉन्फ़िगरेशन सेटिंग्स, यदि आप अपना खुद का कर्नेल कंपाइल कर रहे हैं, तो आप सेट कर सकते हैं कि कौन से मॉड्यूल लोड किए जा सकते हैं</li>\n</ul>\n\nयदि आपकी /boot निर्देशिका की स्थान की समाप्ति हो जाती है, तो आप हमेशा पुराने संस्करणों की इन फ़ाइलों को हटा सकते हैं या बस एक पैकेज प्रबंधक का उपयोग कर सकते हैं, लेकिन इस निर्देशिका में रखरखाव करते समय सावधान रहें और अपने उपयोग में कर्नेल को गलती से न हटा दें।",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "/boot में कर्नेल इमेज का क्या नाम है?",
          "slug": "kernellocation",
          "title": "कर्नेल स्थान"
        },
        {
          "exercise": "अपने ब्लूटूथ मॉड्यूल को modprobe के साथ अनलोड करें और देखें क्या होता है। इसे आप कैसे ठीक करेंगे?",
          "id": 6,
          "lessonContent": "चलो मान लो कि मेरे पास एक शानदार गाड़ी है, मैंने इसमें काफी समय और पैसा लगाया है। मैंने इसमें एक स्पॉयलर, हिच, बाइक रैक और अन्य यादृच्छिक चीजें जोड़ी हैं। ये घटक वास्तव में गाड़ी के मूल कार्यक्षमता को बदलते नहीं हैं और मैं इन्हें बहुत आसानी से हटा और जोड़ सकता हूँ। कर्नेल कर्नेल मॉड्यूल के साथ एक ही अवधारणा का उपयोग करता है।\n\nकर्नेल अपने आप में एक एकटक प्रकार का सॉफ्टवेयर है, जब हम एक नए प्रकार के कीबोर्ड के लिए समर्थन जोड़ना चाहते हैं, हम इस कोड को सीधे कर्नेल कोड में नहीं लिखते। जैसे ही हम अपनी गाड़ी में बाइक रैक को मिलाने वाले नहीं होते (ठीक है, शायद कुछ लोग ऐसा करेंगे)। कर्नेल मॉड्यूल वह कोड के टुकड़े हैं जो मांग पर कर्नेल में लोड और अनलोड किए जा सकते हैं। ये हमें कर्नेल की कार्यक्षमता को बढ़ाने की अनुमति देते हैं बिना मूल कर्नेल कोड में जोड़ने के। हम भी मॉड्यूल जोड़ सकते हैं और सिस्टम को रिबूट करने की आवश्यकता नहीं है (अधिकांश मामलों में)।\n\n<b>वर्तमान मॉड्यूल की सूची देखें</b>\n\n<pre>$ lsmod</pre>\n\n<b>मॉड्यूल लोड करें</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe <b>/lib/modules/(कर्नेल संस्करण)/kernel/drivers</b> से मॉड्यूल को लोड करने का प्रयास करता है। कर्नेल मॉड्यूल की भी आवश्यकता हो सकती है, अगर वे पहले से लोड नहीं हैं तो modprobe हमारे मॉड्यूल आवश्यकताओं को लोड करता है।\n\n<b>मॉड्यूल हटाएं</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>बूटअप पर लोड करें</b>\n\nआप सिस्टम बूट के दौरान भी मॉड्यूल लोड कर सकते हैं, अस्थायी रूप से modprobe के साथ उन्हें लोड करने के बजाय (जो जब आप पुनः आरंभ करेंगे तो अनलोड हो जाएगा)। बस <b>/etc/modprobe.d</b> निर्देशिका को संशोधित करें और इसमें एक विन्यास फ़ाइल जोड़ें जैसे:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\nथोड़ा अजीब उदाहरण, लेकिन अगर आपके पास एक मॉड्यूल नामक peanut_butter है और आप type=almond के लिए एक कर्नेल पैरामीटर जोड़ना चाहते हैं, तो आप इस विन्यास फ़ाइल का उपयोग करके इसे स्टार्टअप पर लोड कर सकते हैं। यह भी ध्यान दें कि कर्नेल मॉड्यूल के अपने कर्नेल पैरामीटर होते हैं तो आपको अधिक जानने के लिए मॉड्यूल के बारे में विशेष रूप से पढ़ना चाहिए।\n\n<b>बूटअप पर लोड न करें</b>\n\nआप यह भी सुनिश्चित कर सकते हैं कि एक मॉड्यूल बूटअप पर लोड न हो जाए इस तरह की एक विन्यास फ़ाइल जोड़कर:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "मॉड्यूल को अनलोड करने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "kernelmodules",
          "title": "कर्नेल मॉड्यूल्स"
        }
      ],
      "slug": "kernel",
      "title": "कर्नेल"
    },
    {
      "description": "विभिन्न प्रारंभ प्रणालियों, सिसवी, अपस्टार्ट और सिस्टमडी के बारे में जानें।",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "यदि आप सिस्टम वी चला रहे हैं, तो अपनी मशीन का डिफ़ॉल्ट रनलेवल को कुछ और बदलें और देखें कि क्या होता है।",
          "id": 1,
          "lessonContent": "इनिट का मुख्य उद्देश्य सिस्टम पर आवश्यक प्रक्रियाओं को शुरू और बंद करना है। लिनक्स में इनिट के तीन प्रमुख कार्यान्वयन हैं, सिस्टम वी, अपस्टार्ट और सिस्टमडी। इस पाठ में, हम सबसे पारंपरिक संस्करण इनिट, सिस्टम वी इनिट या सिस वी (जिसे 'सिस्टम फाइव' के रूप में उच्चारित किया जाता है) पर जानेंगे। \n\nयदि आप सिस वी इनिट कार्यान्वयन का उपयोग कर रहे हैं, तो यदि आपके पास एक /etc/inittab फ़ाइल है तो आपकी संभावना है कि आप सिस वी चला रहे हैं। \n\nसिस वी प्रक्रियाएँ क्रमशः शुरू और बंद करता है, इसलिए यदि आप 'फू-ए' नामक सेवा को शुरू करना चाहते हैं, तो फू-बी काम कर सके, तो आपको सुनिश्चित करना होगा कि फू-ए पहले से ही चल रहा है। सिस वी इसे स्क्रिप्ट के साथ करता है, ये स्क्रिप्ट हमारे लिए सेवाएँ शुरू और बंद करती हैं, हम अपनी स्क्रिप्ट लिख सकते हैं या ज्यादातर समय उसे उपयोग कर सकते हैं जो ऑपरेटिंग सिस्टम में पहले से ही बने होते हैं और आवश्यक सेवाएँ लोड करने के लिए उपयोग किए जाते हैं। \n\nइनिट के इस कार्यान्वयन का उपयोग करने के फायदे यह हैं कि इसके आपसी आधारितता को हल करना अधिक सरल है, क्योंकि आप जानते हैं कि फू-ए फू-बी से पहले आता है, हालांकि प्रदर्शन अच्छा नहीं है क्योंकि आम तौर पर एक समय में कुछ एक चीज शुरू या बंद हो रही है। \n\nसिस वी का उपयोग करते समय, मशीन की स्थिति रनलेवल्स द्वारा परिभाषित होती है जो 0 से 6 तक सेट किए जाते हैं। ये विभिन्न मोड वितरण पर निर्भर करेंगे, लेकिन अधिकांश समय निम्नलिखित की तरह दिखेंगे: \n\n<ul>\n<li>0: शटडाउन</li>\n<li>1: एकल उपयोगकर्ता मोड</li>\n<li>2: नेटवर्किंग के बिना मल्टीयूजर मोड</li>\n<li>3: नेटवर्किंग के साथ मल्टीयूजर मोड</li>\n<li>4: अप्रयुक्त</li>\n<li>5: नेटवर्किंग और जीयूआई के साथ मल्टीयूजर मोड</li>\n<li>6: रिबूट</li>\n</ul>\n\nजब आपकी सिस्टम शुरू होती है, तो यह देखने के लिए कि आप किस रनलेवल में हैं और उस रनलेवल कॉन्फ़िगरेशन में स्थित स्क्रिप्ट को निष्पादित करती है। स्क्रिप्ट <b>/etc/rc.d/rc[रनलेवल संख्या].d/</b> या <b>/etc/init.d</b> में स्थित होती हैं। S(शुरू) या K(किल) के साथ शुरू होने वाली या बंद होने वाली स्क्रिप्ट चलेंगी, क्रमशः। इनके पास इन अक्षरों के साथ नंबर होते हैं जो उनकी क्रमशः चलने की क्रम होती है। \n\nउदाहरण के लिए:\n\n<pre>\nपीट@आइसबॉक्स:/etc/rc.d/rc0.d$ ls\nK10अपडेट  K80ओपनवीपीएन        \n</pre>\n\nहम देखते हैं कि हम जब रनलेवल 0 या शटडाउन मोड में स्विच करते हैं, हमारी मशीन को अपडेट सेवाओं को मारने की कोशिश करेगी और फिर ओपनवीपीएन। अपनी मशीन का डिफ़ॉल्ट रनलेवल क्या है, इसे जानने के लिए आप /etc/inittab फ़ाइल में डिफ़ॉल्ट रनलेवल देख सकते हैं। आप इस फ़ाइल में अपना डिफ़ॉल्ट रनलेवल भी बदल सकते हैं। \n\nएक बात ध्यान देने योग्य है, सिस्टम वी धीरे-धीरे बदल रहा है, शायद आज, या यहाँ तक कि वर्षों बाद भी नहीं। हालांकि, आपको देखने को मिल सकता है कि अन्य इनिट कार्यान्वयनों में रनलेवल आते हैं, यह मुख्य रूप से उन सेवाओं का समर्थन करने के लिए है जो केवल सिस्टम वी इनिट स्क्रिप्ट का उपयोग करके शुरू या बंद किए जाते हैं।",
          "quizAnswer": "0",
          "quizQuestion": "शटडाउन के लिए सामान्यत: कौन सा रनलेवल उपयोग किया जाता है?",
          "slug": "sysvoverview",
          "title": "सिस्टम वी अवलोकन"
        },
        {
          "exercise": "कुछ सेवाओं का प्रबंधन करें और उनकी स्थितियों को बदलें, आप क्या देखते हैं?",
          "id": 2,
          "lessonContent": "सिस वी सेवाओं को प्रबंधित करने के लिए आप कई कमांड लाइन उपकरण प्रयोग कर सकते हैं।\n\n<b>सेवाओं की सूची</b>\n\n<pre>$ service --status-all</pre>\n\n<b>सेवा शुरू करें</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>सेवा रोकें</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>सेवा पुनः आरंभ करें</b>\n\n<pre>$ sudo service networking restart</pre>\n\nये कमांड सिस वी इनिट सिस्टम के लिए विशेष नहीं हैं, आप ये कमांड अपस्टार्ट सेवाओं को प्रबंधित करने के लिए भी प्रयोग कर सकते हैं। चूंकि लिनक्स पारंपरिक सिस वी इनिट स्क्रिप्ट से दूर होने की कोशिश कर रहा है, इस संक्रिया में मदद के लिए अब भी कुछ चीजें हैं।",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "सिस वी के साथ एक सेवा जिसका नाम मूंगफली है को रोकने के लिए कमांड क्या है?",
          "slug": "sysvservices",
          "title": "सिस्टम वी सेवा"
        },
        {
          "exercise": "यदि आप अपस्टार्ट चला रहे हैं, तो देखें कि क्या आप /etc/init में नौकरी विन्यासों को समझ सकते हैं।",
          "id": 3,
          "lessonContent": "अपस्टार्ट को कैनोनिकल ने विकसित किया था, इसलिए यह उबुंटू पर एक समय के लिए आरंभन अंमलन था, हालांकि आधुनिक उबुंटू स्थापनाओं पर अब सिस्टमडी का उपयोग होता है। अपस्टार्ट को सिस वी की समस्याओं को सुधारने के लिए बनाया गया था, जैसे कि सख्त स्टार्टअप प्रक्रियाएँ, कार्यों को ब्लॉक करना, आदि। अपस्टार्ट का घटना और नौकरी निर्देशित मॉडल इसे घटनाओं का सम्मान करने की अनुमति देता है। \n\nयदि आप यह जानना चाहते हैं कि आप अपस्टार्ट का उपयोग कर रहे हैं, तो यदि आपके पास /usr/share/upstart निर्देशिका है तो यह एक अच्छा संकेत है। \n\nनौकरियाँ वे क्रियाएँ हैं जो अपस्टार्ट करता है और घटनाएँ वे संदेश हैं जो अन्य प्रक्रियाओं से प्राप्त होते हैं ताकि नौकरियाँ ट्रिगर हो सकें। नौकरियों और उनके विन्यास की सूची देखने के लिए:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nइन नौकरी विन्यासों में, नौकरियों को शुरू करने और नौकरियों को कब शुरू करना है, इस पर जानकारी शामिल होगी।\n\nउदाहरण के लिए, नेटवर्किंग.conf फ़ाइल में, यह कुछ इस प्रकार हो सकता है:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nइसका मतलब है कि यह रनलेवल 2, 3 या 5 पर नेटवर्किंग सेट करना शुरू करेगा और रनलेवल 0 पर नेटवर्किंग बंद करेगा। विन्यास फ़ाइल लिखने के कई तरीके हैं और आप उपलब्ध विभिन्न नौकरी विन्यासों को देखेंगे तो आपको यह पता चलेगा। \n\nअपस्टार्ट का काम करने का तरीका यह है: \n\n<ol>\n<li>पहले, यह /etc/init से नौकरी विन्यास लोड करता है</li>\n<li>एक स्टार्टअप घटना होने पर, उस घटना द्वारा ट्रिगर किए गए नौकरियों को चलाएगा।</li>\n<li>ये नौकरियाँ नई घटनाएँ बनाएंगी और फिर वे घटनाएँ और नौकरियों को ट्रिगर करेंगी</li>\n<li>अपस्टार्ट यह करता रहेगा जब तक वह सभी आवश्यक नौकरियाँ पूरी नहीं कर लेता</li>\n</ol>",
          "quizAnswer": "अपस्टार्ट",
          "quizQuestion": "उबुंटू द्वारा उपयोग किया जाने वाला आरंभन अंमलन क्या है?",
          "slug": "upstartoverview",
          "title": "उपस्थिति अवलोकन"
        },
        {
          "exercise": "अपनी उपस्थिति नौकरियों की सूची का अवलोकन करें, अब आज हमने सीखे किसी कमांड के साथ नौकरी स्थिति बदलें। इसके बाद आप क्या देखते हैं?",
          "id": 4,
          "lessonContent": "उपस्थिति बहुत सारे घटनाओं और नौकरियों को चालू कर सकता है, दुर्भाग्य से किसी घटना या नौकरी का मूल क्या है, इसे देखने का कोई आसान तरीका नहीं है, इसलिए आपको /etc/init में नौकरी के विन्यास के चारों ओर छेदखानी करनी पड़ेगी। अधिकांश समय, आपको कभी भी उपस्थिति नौकरी विन्यास फ़ाइलों को देखने की आवश्यकता नहीं होगी, लेकिन आप कुछ विशिष्ट नौकरियों को आसानी से नियंत्रित करना चाहेंगे। उपस्थिति प्रणाली में आपका उपयोग करने के लिए कई उपयोगी कमांड हैं।\n\n<b>नौकरियां देखें</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nआप उपस्थिति नौकरियों की सूची देखेंगे जिन पर विभिन्न स्थितियाँ लागू होती हैं। प्रत्येक पंक्ति में, नौकरी का नाम पहला मान है और दूसरा क्षेत्र (स्लेश के पहले) वास्तव में नौकरी का लक्ष्य है, तीसरा मान (स्लेश के बाद) वर्तमान स्थिति है। इसलिए हम देखते हैं कि हमारी बंद करने की नौकरी आखिरकार रुकना चाहती है, लेकिन वर्तमान में एक प्रतीक्षा की स्थिति में है। नौकरी की स्थिति और लक्ष्य जैसे ही आप नौकरियां शुरू या बंद करते हैं, वे बदल जाएंगे।\n\n<b>विशिष्ट नौकरी देखें</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nहम उपस्थिति नौकरी विन्यास कैसे लिखें के विवरण में नहीं जाएंगे, हालांकि हम यह पहले से ही जानते हैं कि नौकरियां इन विन्यासों में बंद, शुरू और पुनः आरंभ होती हैं। ये नौकरियां घटनाएँ भी उत्पन्न करती हैं, इसलिए वे अन्य नौकरियों को शुरू कर सकती हैं। हम उपस्थिति क्रियान्वयन के मैन्युअल कमांडों के माध्यम से जाएँगे, लेकिन यदि आप उत्सुक हैं, तो आपको .conf फ़ाइलों में अधिक गहराई से खोजना चाहिए।\n\n<b>मैन्युअल रूप से एक नौकरी शुरू करें</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>मैन्युअल रूप से एक नौकरी बंद करें</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>मैन्युअल रूप से एक नौकरी पुनः आरंभ करें</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>मैन्युअल रूप से एक घटना उत्पन्न करें</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "मैं कैसे मैन्युअल रूप से एक उपस्थिति नौकरी जिसे मूंगफली कहा जाता है पुनः आरंभ करूँ?",
          "slug": "upstartjobs",
          "title": "उपस्थिति नौकरियां"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "सिस्टमडी धीरे-धीरे इनिट के लिए उभरते मानक बन रहा है। यदि आपके पास /usr/lib/systemd निर्देशिका है, तो आप संभावित रूप से सिस्टमडी का उपयोग कर रहे हैं।\n\nसिस्टमडी आपके सिस्टम को चालू और चलाने के लिए लक्ष्यों का उपयोग करता है। मूल रूप से आपके पास एक लक्ष्य होता है जिसे आप प्राप्त करना चाहते हैं और इस लक्ष्य के भी ऐसे आवश्यकताएं होती हैं जिन्हें हमें प्राप्त करना होता है। सिस्टमडी अत्यंत लचीला और मजबूत है, यह प्रक्रियाओं को शुरू करने के लिए एक सख्त क्रम का पालन नहीं करता है। यहां एक सामान्य सिस्टमडी बूट के दौरान क्या होता है:\n\n<ol>\n<li>पहले, सिस्टमडी अपनी कॉन्फ़िगरेशन फ़ाइलों को लोड करता है, जो आम तौर पर /etc/systemd/system या /usr/lib/systemd/system में स्थित होती हैं</li>\n<li>फिर यह अपना बूट लक्ष्य निर्धारित करता है, जो आम तौर पर default.target होता है</li>\n<li>सिस्टमडी बूट लक्ष्य की आवश्यकताओं को खोजता है और उन्हें सक्रिय करता है</li>\n</ol>\n\nSys V रनलेवल्स के समान रूप से, सिस्टमडी विभिन्न लक्ष्यों में बूट होता है:\n\n<ul>\n<li>poweroff.target - सिस्टम बंद करें</li>\n<li>rescue.target - एकल उपयोगकर्ता मोड</li>\n<li>multi-user.target - नेटवर्किंग के साथ बहुउपयोगकर्ता</li>\n<li>graphical.target - नेटवर्किंग और GUI के साथ बहुउपयोगकर्ता</li>\n<li>reboot.target - पुनः आरंभ करें</li>\n</ul>\n\ndefault.target का डिफ़ॉल्ट बूट लक्ष्य आम तौर पर graphical.target की ओर इशारा करता है।\n\nसिस्टमडी जो विकास करता है, उसे इकाइयों के रूप में जाना जाता है। सिस्टमडी सेवाएँ बंद और चालू नहीं करता है, यह फ़ाइल सिस्टमों को माउंट कर सकता है, आपके नेटवर्क सॉकेट को मॉनिटर कर सकता है, आदि और उस मजबूती के कारण जिसके कारण इसके पास वह इकाइयों के लिए विभिन्न प्रकार की इकाइयाँ होती हैं जिनका उपयोग करता है। सबसे सामान्य इकाइयाँ हैं:\n\n<ul>\n<li>सेवा इकाइयाँ - ये सेवाएँ हैं जिन्हें हम शुरू और बंद कर रहे हैं, ये इकाइयों की फ़ाइलें .service से समाप्त होती हैं</li>\n<li>माउंट इकाइयाँ - ये फ़ाइल सिस्टमों को माउंट करती हैं, ये इकाइयों की फ़ाइलें .mount से समाप्त होती हैं</li>\n<li>टारगेट इकाइयाँ - ये अन्य इकाइयों को समूहित करती हैं, फ़ाइलें .target से समाप्त होती हैं</li>\n</ul>\n\nउदाहरण के लिए, चलो मान लो कि हम अपने default.target में बूट करते हैं, ठीक है इस लक्ष्य में नेटवर्किंग सेवा इकाई, crond सेवा इकाई, आदि को समूहित करता है, इसलिए एक बार हम एक एकल इकाई को सक्रिय करते हैं, तो उस इकाई के नीचे सभी कुछ सक्रिय हो जाता है।",
          "quizAnswer": "टारगेट",
          "quizQuestion": "अन्य इकाइयों को समूहित करने के लिए कौन सी इकाई का उपयोग किया जाता है?",
          "slug": "systemdoverview",
          "title": "सिस्टमडी अवलोकन"
        },
        {
          "exercise": "यूनिट स्थितियों को देखें और कुछ सेवाएँ शुरू और रोकें। आप क्या अनुभव करते हैं?",
          "id": 6,
          "lessonContent": "हम systemd यूनिट फ़ाइलें लिखने के विवरण में नहीं जाएंगे। हालांकि, हम एक यूनिट फ़ाइल का संक्षेप में अवलोकन करेंगे और कैसे इकाईयों को मैन्युअल रूप से नियंत्रित करें। \n\nयहाँ एक मूल सेवा यूनिट फ़ाइल है: foobar.service\n\n<pre>\n[Unit]\nDescription=मेरा फूबार\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nयह एक सरल सेवा लक्ष्य है, फ़ाइल के शुरू में हम एक खंड देखते हैं [इकाई], यह हमें हमारी यूनिट फ़ाइल को एक विवरण देने और यूनिट को सक्रिय करने के क्रम को नियंत्रित करने की अनुमति देता है। अगला हिस्सा [सेवा] खंड है, इसके तहत हम सेवा को शुरू, रोकें या पुनरारंभ कर सकते हैं। और [स्थापना] खंड आवश्यकता के लिए उपयोग किया जाता है। यह systemd फ़ाइलें लिखने के लिए केवल तिप्पणी है, इसलिए अगर आप अधिक जानना चाहते हैं तो मैं आपसे अनुरोध करता हूँ कि इस विषय पर पढ़ें। \n\nअब, चलो कुछ कमांड में प्रवेश करते हैं जिन्हें आप systemd यूनिट के साथ उपयोग कर सकते हैं: \n\n<b>इकाईयों की सूची</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>इकाई की स्थिति देखें</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>सेवा शुरू करें</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>सेवा रोकें</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>सेवा पुनरारंभ करें</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>एक यूनिट सक्षम करें</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>एक यूनिट अक्षम करें</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nफिर से, आपने अभी तक देखा है कि systemd कितनी गहराई में जाता है, इसलिए अगर आप और अधिक सीखना चाहते हैं तो इस पर पढ़ें।",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "पीनट सेवा नामक एक सेवा को शुरू करने के लिए कमांड क्या है?",
          "slug": "systemdgoals",
          "title": "सिस्टमडी लक्ष्य"
        },
        {
          "exercise": "आपको लगता है कि जब आप अपनी मशीन को बंद करते हैं तो init के साथ क्या हो रहा है?",
          "id": 7,
          "lessonContent": "यह मुश्किल है कि हमने वास्तव में अपने सिस्टम स्थिति को नियंत्रित करने के तरीके पर वास्तव में चर्चा नहीं की है, लेकिन जब हम init के बारे में बात करते हैं, तो हम सिर्फ उन मोड़ों के बारे में बात करते हैं जो हमें हमारे सिस्टम को शुरू करने के लिए मदद करते हैं, बल्कि उन्हें भी बात करते हैं जो हमारे सिस्टम को बंद करते हैं।\n\nअपने सिस्टम को बंद करने के लिए:\n\n<pre>$ sudo shutdown -h now</pre>\n\nयह सिस्टम को रोक देगा (इसे बंद करेगा), आपको इसे कब करना चाहिए यह भी निर्दिष्ट करना होगा। आप उस समय में मिनट में एक समय भी जोड़ सकते हैं जो उस समय में सिस्टम को बंद कर देगा।\n\n<pre>$ sudo shutdown -h +2</pre>\n\nयह आपके सिस्टम को दो मिनट में बंद कर देगा। आप शटडाउन कमांड के साथ पुनरारंभ भी कर सकते हैं:\n\n<pre>$ sudo shutdown -r now</pre>\n\nया बस रीबूट कमांड का उपयोग करें:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "अपने सिस्टम को 4 मिनट में पावर ऑफ करने के लिए क्या कमांड है?",
          "slug": "powerstates",
          "title": "शक्ति स्थितियाँ"
        }
      ],
      "slug": "init",
      "title": "प्रारंभ"
    },
    {
      "description": "शीर्ष, लोड औसत, आईओस्टैट और अधिक के साथ संसाधन मॉनिटरिंग सीखें!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "टॉप कमांड के साथ खेलें और देखें कि कौन सी प्रक्रियाएँ सबसे अधिक संसाधनों का उपयोग कर रही हैं।",
          "id": 1,
          "lessonContent": "इस पाठ्यक्रम में, हम आपको बताएंगे कि आपके सिस्टम पर संसाधन उपयोग को कैसे पढ़ें और विश्लेषित करें, यह पाठ कुछ शानदार उपकरण दिखाता है जिन्हें आप जब प्रक्रिया क्या कर रही है उसका ट्रैक करने की आवश्यकता होती है।\n\n<b>टॉप</b>\n\nहमने पहले भी टॉप पर चर्चा की थी, लेकिन हम इसके वास्तविक प्रदर्शन में क्या है उस पर गहराई से जाएंगे। ध्यान रखें कि टॉप एक ऐसा उपकरण है जिसका उपयोग हमने हमारी प्रक्रियाओं द्वारा सिस्टम उपयोग का वास्तविक समय दृश्य प्राप्त करने के लिए किया था:\n\n<pre>\nटॉप - 18:06:26 अप 6 दिन,  4:07,  2 उपयोगकर्ता,  लोड औसत: 0.92, 0.62, 0.59\nकार्य: कुल 389,   1 चल रहा, 387 सो रहा,   0 रुका हुआ,   1 ज़ॉम्बी\n%Cpu(s):  1.8 यूएस,  0.4 साइ,  0.0 नाई, 97.6 आईडी,  0.1 वा,  0.0 हाई,  0.0 साइ,  0.0 स्टील\nकिबी मेम:  32870888 कुल, 27467976 उपयुक्त,  5402912 खाली,   518808 बफर\nकिबी स्वैप: 33480700 कुल,    39892 उपयुक्त, 33440808 खाली। 19454152 कैश्ड मेम\n\n  पिडी उपयोगकर्ता      पीआर  एनआई    वर्ट    रेस    श्र एस  %सीपीयू %मेम     समय+ कमांड                             \n 6675 पैटी    20   0 1731472 520960  30876 एस   8.3  1.6 160:24.79 क्रोम                             \n 6926 पैटी    20   0  935888 163456  25576 एस   4.3  0.5   5:28.13 क्रोम \n</pre>\n\nआइए देखें कि यह आउटपुट क्या मतलब है, आपको इसे याद रखने की आवश्यकता नहीं है, लेकिन जब आपको संदर्भ की आवश्यकता हो तो इस पर वापस आइए।\n\n<b>1 वीं लाइन: यह वही जानकारी है जो आप अपटाइम कमांड चलाते समय देखेंगे (और भी आने वाला है)</b>\n\nफील्ड बाएं से दाएं:\n<ol>\n<li>वर्तमान समय</li>\n<li>सिस्टम कितने समय से चल रहा है</li>\n<li>वर्तमान उपयोगकर्ता कितने लॉग ऑन हैं</li>\n<li>सिस्टम लोड औसत (और भी आने वाला है)</li>\n</ol>\n\n<b>2 वीं लाइन: चल रहे, सो रहे, रुके हुए और ज़ॉम्बी प्रक्रियाएँ</b>\n\n<b>3 वीं लाइन: सीपीयू सूचना</b>\n\n<ol>\n<li>यूएस: उपयोगकर्ता सीपीयू समय - उपयोगकर्ताओं की प्रक्रियाओं को चलाने में बिताया गया सीपीयू समय का प्रतिशत जो नाईस नहीं है।</li>\n<li>साइ: सिस्टम सीपीयू समय - कर्नेल और कर्नेल प्रक्रियाओं को चलाने में बिताया गया सीपीयू समय का प्रतिशत</li>\n<li>नाई: नाईस सीपीयू समय - नाईस प्रक्रियाओं को चलाने में बिताया गया सीपीयू समय का प्रतिशत</li>\n<li>आईडी: सीपीयू खाली समय - खाली बिताया गया सीपीयू समय का प्रतिशत</li>\n<li>वा: आई/ओ प्रतीक्षा - आई/ओ के लिए प्रतीक्षा करने का सीपीयू समय का प्रतिशत। यदि यह मूल्य कम है, तो समस्या संभावना नहीं है डिस्क या नेटवर्क आई/ओ की</li> \n<li>हाई: हार्डवेयर अंतर्रुप्तियाँ - हार्डवेयर अंतर्रुप्तियों को सेवा देने में बिताया गया सीपीयू समय का प्रतिशत</li>\n<li>साइ: सॉफ्टवेयर अंतर्रुप्तियाँ - सॉफ्टवेयर अंतर्रुप्तियों को सेवा देने में बिताया गया सीपीयू समय का प्रतिशत</li>\n<li>स्टील: चुराया गया समय - यदि आप वर्चुअल मशीन चला रहे हैं, तो यह वह प्रतिशत सीपीयू समय है जो आपसे चुराया गया था अन्य कार्यों के लिए</li>\n</ol>\n\n<b>4 वीं और 5 वीं लाइन: मेमोरी उपयोग और स्वैप उपयोग</b>\n\n<b>उपयोग में होने वाली प्रक्रियाओं की सूची</b>\n\n<ol>\n<li>पिडी: प्रक्रिया की पहचान</li>\n<li>उपयोगकर्ता: प्रक्रिया के मालिक उपयोगकर्ता</li>\n<li>पीआर: प्रक्रिया की प्राथमिकता</li>\n<li>एनआई: नाईस मूल्य</li>\n<li>वर्ट: प्रक्रिया द्वारा उपयोग किया गया वर्चुअल मेमोरी</li>\n<li>रेस: प्रक्रिया से उपयोग किया गया फिजिकल मेमोरी</li>\n<li>श्र: प्रक्रिया की साझा मेमोरी</li>\n<li>एस: प्रक्रिया की स्थिति को दर्शाता है: S=सोना, R=चल रहा है, Z=ज़ॉम्बी, D=अनिरुद्ध, T=रुका हुआ</li>\n<li>%सीपीयू - यह प्रक्रिया द्वारा उपयोग किए गए सीपीयू का प्रतिशत है</li>\n<li>%मेम - इस प्रक्रिया द्वारा उपयोग किए गए रैम का प्रतिशत है</li>\n<li>समय+ - इस प्रक्रिया की कुल गतिविधि का कुल समय</li>\n<li>कमांड - प्रक्रिया का नाम</li>\n</ol>\n\nआप यह भी निर्दिष्ट कर सकते हैं यदि आप केवल कुछ प्रक्रियाओं का ट्रैक करना चाहते हैं:\n\n<pre>$ टॉप -प 1</pre>",
          "quizAnswer": "अपटाइम",
          "quizQuestion": "कौन सा कमांड टॉप में पहली लाइन के समान आउटपुट प्रदर्शित करता है?",
          "slug": "trackingprocessestop",
          "title": "प्रक्रियाओं का ट्रैकिंग: टॉप"
        },
        {
          "exercise": "lsof और fuser के मैनपेज पढ़ें, इन उपकरणों के साथ अधिक जानकारी है जिसे हमने नहीं शामिल किया है और जो आपको इन उपकरणों के साथ अधिक लचीलाई देने की अनुमति देती है।",
          "id": 2,
          "lessonContent": "चलो मान लो कि आपने एक USB ड्राइव को प्लग इन किया और कुछ फ़ाइलों पर काम करना शुरू किया, एक बार जब आप ख़त्म हो गए, तो आप जाते हैं और USB डिवाइस को अनमाउंट करने की कोशिश कर रहे हैं और आपको एक त्रुटि मिल रही है \"डिवाइस या संसाधन व्यस्त है\"। आप कैसे पता करेंगे कि USB ड्राइव में कौन सी फ़ाइलें अब भी उपयोग में हैं? वास्तव में इसके लिए दो उपकरण हैं: \n\n<b>lsof</b>\n\nयाद रखें फ़ाइलें सिर्फ पाठ फ़ाइलें, छवियाँ, आदि नहीं हैं, वे सिस्टम पर सभी चीज़ें हैं, डिस्क, पाइप, नेटवर्क सॉकेट, डिवाइस, आदि। प्रक्रिया द्वारा क्या उपयोग में है, यह देखने के लिए आप lsof कमांड का उपयोग कर सकते हैं (\"लिस्ट ओपन फ़ाइल्स\" के लिए संक्षेप में) यह आपको सभी खुली फ़ाइलों और उनकी संबंधित प्रक्रिया की सूची दिखाएगा। \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nअब मैं देख सकता हूँ कि कौन सी प्रक्रियाएँ वर्तमान में डिवाइस/फ़ाइल को खुले रख रही हैं। हमारे USB उदाहरण में, आप इन प्रक्रियाओं को बंद कर सकते हैं ताकि हम इस उपद्रवपूर्ण ड्राइव को अनमाउंट कर सकें।\n\n<b>fuser</b>\n\nएक और तरीका एक प्रक्रिया को ट्रैक करने के लिए fuser कमांड (\"फ़ाइल उपयोगकर्ता\" के लिए संक्षेप में) है, यह आपको जानकारी दिखाएगा कि कौन सी प्रक्रिया फ़ाइल या फ़ाइल उपयोगकर्ता का उपयोग कर रही है। \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nहम देख सकते हैं कि कौन सी प्रक्रियाएँ वर्तमान में हमारे /home/pete निर्देशिका का उपयोग कर रही हैं। lsof और fuser उपकरण बहुत समान हैं, इन उपकरणों को अधिक जानें और अगली बार जब आपको किसी फ़ाइल या प्रक्रिया का पता लगाना हो, तो इनका उपयोग करने की कोशिश करें।",
          "quizAnswer": "lsof",
          "quizQuestion": "खुली फ़ाइलें और उनकी प्रक्रिया जानकारी की सूची देने के लिए कौन सा कमांड प्रयोग किया जाता है?",
          "slug": "trackingprocesseslsoffuser",
          "title": "lsof और fuser"
        },
        {
          "exercise": "<b>ps m</b> कमांड चलाएं और देखें कि आपके पास कौन-कौन सी प्रक्रियाएँ चल रही हैं जो मल्टी-थ्रेडेड हैं।",
          "id": 3,
          "lessonContent": "आपने शब्दों सिंगल-थ्रेडेड और मल्टी-थ्रेडेड प्रक्रियाओं के बारे में सुना होगा। थ्रेड्स प्रक्रियाओं के बहुत ही समान होते हैं, उनका उपयोग एक ही कार्यक्रम को निष्पादित करने के लिए किया जाता है, इन्हें अक्सर हल्की प्रक्रियाएँ कहा जाता है। अगर किसी प्रक्रिया में एक थ्रेड है तो वह सिंगल-थ्रेडेड है और अगर किसी प्रक्रिया में एक से अधिक थ्रेड है तो वह मल्टी-थ्रेडेड है। हालांकि, सभी प्रक्रियाओं में कम से कम एक थ्रेड होता है।\n\nप्रक्रियाएँ अपने अलग-अलग सिस्टम संसाधनों के साथ काम करती हैं, हालांकि थ्रेड्स इन संसाधनों को आसानी से एक-दूसरे के साथ साझा कर सकते हैं, जिससे उन्हें एक-दूसरे के बीच संवाद करना और कई बार एक मल्टी-थ्रेडेड एप्लिकेशन एक मल्टी-प्रक्रिया एप्लिकेशन से अधिक कुशल होता है।\n\nमूल रूप से, चलिए मान लें कि आप लिब्रऑफिस राइटर और क्रोम खोलते हैं, प्रत्येक अपनी अलग-अलग प्रक्रिया है। अब आप राइटर में जाते हैं और पाठ संपादन शुरू करते हैं, जब आप पाठ संपादित करते हैं तो यह स्वचालित रूप से सहेजा जाता है। इन दो परस्पर \"हल्की प्रक्रियाएँ\" को सहेजने और संपादित करने के थ्रेड्स कहा जाता है।\n\nप्रक्रिया थ्रेड्स देखने के लिए, आप इस्तेमाल कर सकते हैं:\n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nप्रक्रियाएँ प्रत्येक PID के साथ दर्शाई जाती हैं और प्रक्रियाओं के नीचे उनके थ्रेड्स होते हैं (एक -- द्वारा दर्शाया जाता है)। इसलिए आप देख सकते हैं कि ऊपर की प्रक्रियाएँ दोनों सिंगल-थ्रेडेड हैं।",
          "quizAnswer": "सच",
          "quizQuestion": "सच या झूठ, सभी प्रक्रियाएँ सिंगल-थ्रेडेड से शुरू होती हैं।",
          "slug": "processthreads",
          "title": "प्रक्रिया थ्रेड्स"
        },
        {
          "exercise": "अपने सिस्टम का लोड औसत जांचें और देखें कि वह क्या कर रहा है।",
          "id": 4,
          "lessonContent": "एक उपयोगी कमांड पर चलते हैं, <b>uptime</b>।\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 up 1 day,  5:59,  2 users,  load average: 0.00, 0.02, 0.05\n</pre>\n\nहमने इस कोर्स के पहले सबक में uptime के बारे में बात की थी, लेकिन हमने लोड औसत क्षेत्र पर अभी तक नहीं गए हैं। लोड औसतें आपके सिस्टम पर सीपीयू लोड देखने का एक अच्छा तरीका है। ये नंबर 1, 5 और 15 मिनट के अंतराल में औसत सीपीयू लोड को प्रतिनिधित करते हैं। मैं सीपीयू लोड से क्या मतलब कर रहा हूँ, सीपीयू लोड वह औसत संख्या है जो सीपीयू द्वारा क्रियान्वित किए जाने की प्रतीक्षा कर रही प्रक्रियाओं की।\n\nचलिए मान लेते हैं कि आपके पास एक सिंगल-कोर सीपीयू है, इस कोर को एक ट्रैफिक में एकल लेन के रूप में सोचें। अगर फ्रीवे पर रश घंटे हैं, तो यह लेन वास्तव में बहुत व्यस्त होगा और ट्रैफिक 100% होगा या लोड 1 होगा। अब यातायात इतना खराब हो गया है कि यह फ्रीवे को पीछे कर रहा है और नियमित सड़कों को दोगुनी गाड़ियों से भर रहा है, हम कह सकते हैं कि आपका लोड 200% है या लोड 2 है। अब मान लेते हैं कि थोड़ी देर के लिए साफ हो जाता है और फ्रीवे लेन पर केवल आधी गाड़ियां हैं, हम कह सकते हैं कि लेन का लोड 0.5 है। जब यातायात अभावमय होता है और हम घर जल्दी पहुंच सकते हैं, तो लोड आदर्श रूप से बहुत कम होना चाहिए, जैसे 2 बजे का यातायात। इस मामले में गाड़ियां प्रक्रियाएँ हैं और ये प्रक्रियाएँ बस फ्रीवे से उतरने और घर पहुंचने की प्रतीक्षा कर रही हैं।\n\nअब यह नहीं कहा जा सकता कि आपके पास लोड औसत 1 है इसका यह मतलब नहीं है कि आपका कंप्यूटर धीमा चल रहा है। आजकल अधिकांश मशीनें मल्टीकोर होती हैं। यदि आपके पास एक क्वाड कोर प्रोसेसर (4 कोर) है और आपका लोड औसत 1 है, तो यह वास्तव में आपके सीपीयू का 25% प्रभावित कर रहा है। प्रत्येक कोर को एक ट्रैफिक लेन के रूप में सोचें। आप अपने सिस्टम पर कितने कोर हैं, इसे <b>cat /proc/cpuinfo</b> के साथ देख सकते हैं।\n\nलोड औसत को देखते समय, आपको कोरों की संख्या को ध्यान में रखना होगा, यदि आपको लगता है कि आपकी मशीन हमेशा से औसत से अधिक लोड कर रही है, तो कुछ गलत हो सकता है।",
          "quizAnswer": "uptime",
          "quizQuestion": "लोड औसत देखने के लिए आप कौन सा कमांड उपयोग कर सकते हैं?",
          "slug": "cpumonitoring",
          "title": "सीपीयू मॉनिटरिंग"
        },
        {
          "exercise": "अपने डिस्क उपयोग देखने के लिए iostat का उपयोग करें।",
          "id": 5,
          "lessonContent": "हम एक सहायक उपकरण के साथ CPU उपयोग और डिस्क उपयोग को मॉनिटर कर सकते हैं, जिसे <b>iostat</b> के रूप में जाना जाता है\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nपहला हिस्सा CPU जानकारी है:\n\n<ul>\n<li>%user - उपयोगकर्ता स्तर (एप्लिकेशन) पर निष्पादित होने वाले CPU उपयोग का प्रतिशत दिखाएं</li>\n<li>%nice - नाइस प्राथमिकता के साथ उपयोगकर्ता स्तर पर निष्पादित होने वाले CPU उपयोग का प्रतिशत दिखाएं</li>\n<li>%system - कर्ण (कर्नल) स्तर पर निष्पादित होने वाले CPU उपयोग का प्रतिशत दिखाएं</li>\n<li>%iowait - उस समय का प्रतिशत दिखाएं जब CPU या CPU निष्क्रिय थे जब सिस्टम में एक आउटस्टैंडिंग डिस्क I/O अनुरोध था</li>\n<li>%steal - वर्चुअल CPU या CPU द्वारा अनवशोधित प्रतिशत समय जिसमें हाइपरवाइजर एक अन्य वर्चुअल प्रोसेसर की सेवा कर रहा था में बिना इच्छापूर्वक प्रतीक्षा में व्यतीत किया गया</li>\n<li>%idle - CPU या CPU जब निष्क्रिय थे और सिस्टम में कोई आउटस्टैंडिंग डिस्क I/O अनुरोध नहीं था, तब समय का प्रतिशत दिखाएं</li>\n</ul>\n\nदूसरा हिस्सा डिस्क उपयोग है:\n\n<ul>\n<li>tps - उपकरण को जारी किए गए प्रति सेकंड स्थानांतरण की संख्या दर्शाता है। एक स्थानांतरण उपकरण के लिए एक I/O अनुरोध है। कई तार्किक अनुरोधों को एक ही I/O अनुरोध में संयोजित किया जा सकता है। एक स्थानांतरण अपरिपक्षित आकार का है।</li>\n<li>kB_read/s - उपकरण से पठित डेटा की मात्रा को किलोबाइट प्रति सेकंड में व्यक्त करता है।</li>\n<li>kB_wrtn/s - उपकरण में लिखे गए डेटा की मात्रा को किलोबाइट प्रति सेकंड में व्यक्त करता है।</li>\n<li>kB_read - पठित किलोबाइट की कुल संख्या।</li>\n<li>kB_wrtn - लिखे गए किलोबाइट की कुल संख्या।</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "I/O और CPU उपयोग देखने के लिए कौन सा कमांड उपयोग किया जा सकता है?",
          "slug": "iomonitoring",
          "title": "I/O मॉनिटरिंग"
        },
        {
          "exercise": "vmstat के साथ अपने मेमोरी उपयोग को देखें।",
          "id": 6,
          "lessonContent": "CPU मॉनिटरिंग और I/O मॉनिटरिंग के अतिरिक्त आप <b>vmstat</b> के साथ अपने मेमोरी उपयोग को मॉनिटर कर सकते हैं\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nफ़ील्ड निम्नलिखित हैं:\n\n<b>procs</b>\n<ul>\n<li>r - रन टाइम के लिए प्रक्रियाओं की संख्या</li>\n<li>b - अअंब्रेक्टेबल स्लीप में प्रक्रियाओं की संख्या</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - वर्चुअल मेमोरी का उपयोग किया गया मात्रा</li>\n<li>free - मुफ्त मेमोरी की मात्रा</li>\n<li>buff - बफर्स के रूप में उपयोग किए गए मेमोरी की मात्रा</li>\n<li>cache - कैश के रूप में उपयोग किए गए मेमोरी की मात्रा</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - डिस्क से स्वैप की गई मेमोरी की मात्रा</li>\n<li>so - डिस्क पर स्वैप की गई मेमोरी की मात्रा</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - ब्लॉक डिवाइस से प्राप्त ब्लॉकों की मात्रा</li>\n<li>bo - ब्लॉक डिवाइस पर भेजे गए ब्लॉकों की मात्रा</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - प्रति सेकंड आने वाले इंटरप्ट्स की संख्या</li>\n<li>cs - प्रति सेकंड कंटेक्स्ट स्विच की संख्या</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - उपयोगकर्ता समय में बिताया गया समय</li>\n<li>sy - कर्नेल समय में बिताया गया समय</li>\n<li>id - खाली बिताया गया समय</li>\n<li>wa - IO के लिए इंतजार किया गया समय</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "मेमोरी उपयोग को देखने के लिए कौन सा टूल उपयोग किया जाता है?",
          "slug": "memorymonitoring",
          "title": "मेमोरी मॉनिटरिंग"
        },
        {
          "exercise": "अपने सिस्टम पर sar को इंस्टॉल करें और अपनी सिस्टम संसाधन उपयोगिता का संग्रहण और विश्लेषण शुरू करें।",
          "id": 7,
          "lessonContent": "ये मॉनिटरिंग टूल अच्छे हैं जब आपकी मशीन में समस्याएँ हो रही हैं, लेकिन जब आप नहीं देख रहे हैं तो कैसे पता चलेगा कि कौन सी मशीनों में समस्याएँ हैं। उनके लिए, आपको एक निरंतर मॉनिटरिंग टूल का उपयोग करना होगा, जो आपकी सिस्टम गतिविधि जानकारी को संग्रहित, रिपोर्ट और सहेजेगा। इस पाठ में हम एक शानदार टूल <b>sar</b> का उपयोग करेंगे।\n\n<b>sar को इंस्टॉल करना</b>\nsar एक टूल है जिसका उपयोग आपकी सिस्टम पर ऐतिहासिक विश्लेषण करने के लिए किया जाता है, सबसे पहले सुनिश्चित करें कि आपके पास यह इंस्टॉल है जिसे sysstat पैकेज को इंस्टॉल करके सुनिश्चित करें <b>sudo apt install sysstat</b>।\n\n<b>डेटा संग्रहण सेटअप</b>\nआम तौर पर जब आप sysstat को इंस्टॉल करते हैं, तो आपकी सिस्टम डेटा स्वचालित रूप से संग्रहित करना शुरू कर देगा, यदि ऐसा नहीं है तो आप /etc/default/sysstat में ENABLED फ़ील्ड को संशोधित करके इसे सक्षम कर सकते हैं।\n\n<b>sar का उपयोग करना</b>\n\n<pre>$ sudo sar -q</pre>\n\nयह कमांड दिन की शुरुआत से विवरण सूचीबद्ध करेगा।\n\n<pre>$ sudo sar -r</pre>\n\nयह मेमोरी उपयोग के विवरण को दिन की शुरुआत से सूचीबद्ध करेगा।\n\n<pre>$ sudo sar -P</pre>\n\nयह CPU उपयोग के विवरण को सूचीबद्ध करेगा।\n\nएक अलग दिन का दृश्य देखने के लिए, आप /var/log/sysstat/saXX में जा सकते हैं जहां XX वह दिन है जिसे आप देखना चाहते हैं।\n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "सिस्टम संसाधनों की मॉनिटरिंग के लिए एक अच्छा टूल क्या है?",
          "slug": "continuousmonitoring",
          "title": "निरंतर मॉनिटरिंग"
        },
        {
          "exercise": "एक क्रॉनजॉब बनाएं जिसे आप निर्धारित समय पर चलाना चाहते हैं।",
          "id": 8,
          "lessonContent": "हालांकि हम संसाधन उपयोग के बारे में बात कर रहे हैं, मुझे लगता है कि यह एक अच्छा बिंदु होगा जिसे लिनक्स में कार्यों को निर्धारित करने के लिए उपयोग किया जाने वाला एक अच्छा उपकरण का उल्लेख करना चाहिए। क्रॉन का उपयोग करके कार्यों को निर्धारित करने के लिए एक सेवा है जो आपके लिए कार्यक्रम चलाती है जिसे आप जितनी बार आप निर्धारित करते हैं। यह वास्तव में उपयोगी है अगर आपके पास एक स्क्रिप्ट है जिसे आप रोज चलाना चाहते हैं जो आपके लिए कुछ करने की आवश्यकता है। \n\nउदाहरण के लिए, चलो मैंने /home/pete/scripts/change_wallpaper में स्क्रिप्ट रखी है। मैं इस स्क्रिप्ट का उपयोग अपने वॉलपेपर के लिए चित्र बदलने के लिए हर सुबह करता हूं, लेकिन हर सुबह मुझे इस स्क्रिप्ट को मैन्युअल रूप से चलाना पड़ता है। इसके बजाय मैं जो कर सकता हूं वह है कि मैं एक क्रॉन जॉब बना सकता हूं जो मेरी स्क्रिप्ट को क्रॉन के माध्यम से चलाता है। मैं इस क्रॉन जॉब को चलाने का समय निर्धारित कर सकता हूं और अपनी स्क्रिप्ट को चला सकता हूं। \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nफ़ील्ड निम्नलिखित हैं बाएं से दाएं:\n<ul>\n<li>मिनट - (0-59)</li>\n<li>घंटा - (0-23)</li>\n<li>महीने का दिन - (1-31)</li>\n<li>महीना - (1-12)</li>\n<li>सप्ताह का दिन - (0-7). 0 और 7 को रविवार के रूप में दिखाया गया है</li>\n</ul>\n\nफ़ील्ड में एस्ट्रिक्स मानता है कि हर मान के लिए मिलाना है। इसलिए मेरे उपरोक्त उदाहरण में, मैं चाहता हूं कि यह हर दिन हर महीने में सुबह 8:30 बजे चले।\n\nक्रॉनजॉब बनाने के लिए, बस क्रॉनटैब फ़ाइल को संपादित करें:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "आपके क्रॉनजॉब को संपादित करने के लिए क्या कमांड है?",
          "slug": "cronjobs",
          "title": "क्रॉन जॉब्स"
        }
      ],
      "slug": "processutilization",
      "title": "प्रक्रिया उपयोग"
    },
    {
      "description": "सिस्टम लॉग और /var/log निर्देशिका के बारे में जानें।",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "अपनी /var/log/syslog फ़ाइल देखें और देखें कि आपके मशीन पर क्या और हो रहा है।",
          "id": 1,
          "lessonContent": "आपके सिस्टम पर सेवाएं, कर्नेल, डेमन्स, आदि निरंतर कुछ कर रहे हैं, यह डेटा वास्तव में आपके सिस्टम पर लॉग के रूप में सहेजने के लिए भेजा जाता है। यह हमें हमारे सिस्टम पर हो रहे घटनाओं का एक मानव योग्य जर्नल रखने की अनुमति देता है। यह डेटा सामान्यत: /var निर्देशिका में रखा जाता है, /var निर्देशिका वहाँ है जहाँ हम अपने वेरिएबल डेटा जैसे लॉग रखते हैं!\n\nये संदेश आपके सिस्टम पर कैसे प्राप्त हो रहे हैं? इसके लिए एक सेवा है जिसे syslog कहा जाता है जो इस जानकारी को सिस्टम लॉगर को भेजती है।\n\nSyslog वास्तव में कई घटकों को शामिल करता है, उनमें से एक महत्वपूर्ण घटक एक डेमन है जिसे syslogd (नए Linux वितरण rsyslogd का उपयोग करते हैं) कहा जाता है, जो घटना संदेश होने का इंतजार करता है और उसे जिनके बारे में जानना चाहता है फ़िल्टर करता है, और उस संदेश के साथ क्या करना है, इस पर निर्भर करता है, यह उसे एक फ़ाइल, आपकी कंसोल या उसके साथ कुछ भी नहीं करेगा।\n\nआपको लग सकता है कि यह सिस्टम लॉगर लॉग को प्रबंधित करने के लिए केंद्रीकृत स्थान है, लेकिन दुर्भाग्य से ऐसा नहीं है। आप देखेंगे कि बहुत से ऐप्लिकेशन होते हैं जो अपने खुद के लॉगिंग नियम लिखते हैं और विभिन्न लॉग फ़ाइलें उत्पन्न करते हैं, हालांकि सामान्यत: लॉग का प्रारूप एक समय चिह्नक और घटना विवरण शामिल होना चाहिए।\n\nयहाँ syslog से एक पंक्ति का उदाहरण है:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nयहाँ हम देख सकते हैं कि Jan 27 07:41:32 पर हमारी क्रॉन सेवा ने क्रॉन साप्ताहिक नौकरी चलाई। आप /var/log/syslog फ़ाइल में जो सभी घटना संदेश देख सकते हैं।",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "नए Linux सिस्टम पर लॉग प्रबंधित करने वाला डेमन क्या है?",
          "slug": "systemlogging",
          "title": "सिस्टम लॉगिंग"
        },
        {
          "exercise": "अपनी /etc/rsyslog.d कॉन्फ़िगरेशन फ़ाइल देखें और देखें कि सिस्टम लॉगर के माध्यम से क्या और लॉग हो रहा है।",
          "id": 2,
          "lessonContent": "सिस्टम लॉगर को प्रबंधित और लॉग भेजने के लिए syslog सेवा का प्रबंधन करती है। Rsyslog syslog का एक उन्नत संस्करण है, जिसे अधिकांश लिनक्स वितरण इस नए संस्करण का उपयोग करना चाहिए। सिस्टम लॉगर जो सभी लॉग जुटाती है, उनका उत्पाद /var/log/syslog पर पाया जा सकता है (प्रत्येक संदेश को छोड़कर प्रमाणीकरण संदेश)।\n\nहमारे सिस्टम लॉगर द्वारा रखे गए फ़ाइलें क्या हैं, इसे देखने के लिए /etc/rsyslog.d में कॉन्फ़िगरेशन फ़ाइलों पर नज़र डालें:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nइन नियमों को लॉग फ़ाइलों द्वारा चिह्नित किया जाता है, जो वाम स्तंभ पर चयनकर्ता और दाएं स्तंभ पर क्रिया है। क्रिया हमें बताती है कि लॉग सूचना को कहां भेजना है, एक फ़ाइल, कंसोल, आदि में। ध्यान दें कि हर एप्लिकेशन और सेवा rsyslog का उपयोग अपने लॉगों को प्रबंधित करने के लिए उपयोग नहीं करती है, इसलिए यदि आप विशेष रूप से जानना चाहते हैं कि क्या लॉग किया गया है, तो आपको इस निर्देशिका के अंदर देखना होगा।\n\nआइए वास्तव में लॉगिंग को क्रियान्वित करें, आप logger कमांड के साथ मैन्युअल रूप से एक लॉग भेज सकते हैं:\n\n<pre>\nlogger -s Hello\n</pre>\n\nअब अपने /var/log/syslog के अंदर देखें और आपको अपने लॉग में इस प्रविष्टि को देखना चाहिए!",
          "quizAnswer": "logger",
          "quizQuestion": "मैन्युअल रूप से संदेश लॉग करने के लिए आप कौन सा कमांड उपयोग कर सकते हैं?",
          "slug": "syslog",
          "title": "पहले कुछ मानक लॉग फ़ाइलें। फ़ैसिलिटी द्वारा लॉग करें।"
        },
        {
          "exercise": "/var/log/messages और /var/log/syslog फ़ाइलों को देखें और देखें कि उनमें क्या अंतर है।",
          "id": 3,
          "lessonContent": "आपके सिस्टम पर देख सकते हैं कई लॉग फ़ाइलें, ज्यादातर महत्वपूर्ण लॉग /var/log के अंदर पाई जा सकती हैं। हम उन सभी का विवरण नहीं देंगे, लेकिन हम कुछ मुख्य लॉगों पर चर्चा करेंगे। \n\nआपको अपने सिस्टम के कार्यों का एक झलक प्राप्त करने के लिए दो सामान्य लॉग फ़ाइलें देखने को मिलती हैं:\n\n<b>/var/log/messages</b>\n\nयह लॉग सभी गैर-महत्वपूर्ण और गैर-डीबग संदेशों को समेटता है, इसमें बूटअप (dmesg), ऑथ, क्रॉन, डेमन, आदि के दौरान लॉग किए गए संदेश शामिल हैं। आपके मशीन के काम करने का एक झलक प्राप्त करने के लिए बहुत उपयोगी है। \n\n<b>/var/log/syslog</b>\n\nयह ऑथ संदेशों को छोड़कर सब कुछ लॉग करता है, यह आपके मशीन पर त्रुटियों को दिखाने के लिए अत्यंत उपयोगी है। \n\nजब आप अपने सिस्टम की समस्याओं को ठीक करने के लिए समस्याओं का समाधान कर रहे हों, तो ये दो लॉग काफी होने चाहिए, हालांकि, यदि आप केवल किसी विशिष्ट लॉग घटक को देखना चाहते हैं, तो उनके लिए भी अलग-अलग लॉग हैं।",
          "quizAnswer": "syslog",
          "quizQuestion": "कौन सी लॉग फ़ाइल ऑथ संदेशों को छोड़कर सब कुछ लॉग करती है?",
          "slug": "generallogging",
          "title": "सामान्य लॉगिंग"
        },
        {
          "exercise": "अपने dmesg और kern लॉग देखें, आप क्या अंतर देखते हैं?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nबूट समय पर आपकी सिस्टम कर्नल रिंग बफर के बारे में जानकारी लॉग करती है। यह हार्डवेयर ड्राइवर, कर्नल जानकारी और बूटअप के दौरान स्थिति आदि के बारे में हमें दिखाता है। यह लॉग फ़ाइल /var/log/dmesg पर मिलती है और हर बूट पर रीसेट हो जाती है, आप इसे अभी उपयोग में नहीं देख सकते हैं, लेकिन यदि आपको बूटअप के दौरान कुछ समस्या होती है या किसी हार्डवेयर समस्या का सामना करना पड़े, तो dmesg देखने के लिए सबसे अच्छा स्थान है। आप dmesg कमांड का उपयोग करके इस लॉग को भी देख सकते हैं।\n\n<b>/var/log/kern.log</b>\nकर्नल जानकारी देखने के लिए एक और लॉग जिसे आप उपयोग कर सकते हैं, वह है /var/log/kern.log फ़ाइल, यह आपकी सिस्टम पर कर्नल जानकारी और घटनाएँ लॉग करती है, यह भी dmesg आउटपुट को लॉग करती है।",
          "quizAnswer": "dmesg",
          "quizQuestion": "किस कमांड का उपयोग करके कर्नल बूटअप संदेश देखे जा सकते हैं?",
          "slug": "कर्नललॉगिंग",
          "title": "कर्नल लॉगिंग"
        },
        {
          "exercise": "कुछ विफल लॉगिन करें और फिर एक सफल, अपने /var/log/auth.log देखें और देखें क्या हुआ।",
          "id": 5,
          "lessonContent": "प्रमाणीकरण लॉगिंग बहुत उपयोगी हो सकती है यदि आप लॉगिन में समस्या है। \n\n<b>/var/log/auth.log</b>\n\nइसमें सिस्टम अधिकृति लॉग शामिल हैं, जैसे उपयोगकर्ता लॉगिन और प्रमाणीकरण विधि का उपयोग किया गया। \n\nनमूना स्निपेट:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "उपयोगकर्ता प्रमाणीकरण के लिए कौन सा लॉग प्रयोग किया जाता है?",
          "slug": "authenticationlogging",
          "title": "प्रमाणीकरण लॉगिंग"
        },
        {
          "exercise": "अपनी logrotate कॉन्फ़िगरेशन फ़ाइल देखें और देखें कि यह आपके कुछ लॉग कैसे प्रबंधित करता है।",
          "id": 6,
          "lessonContent": "लॉग फ़ाइलें बहुत सारा डेटा उत्पन्न करती हैं और यह डेटा आपके हार्ड डिस्क पर स्टोर करती हैं, हालांकि इसमें कई समस्याएँ हैं, अधिकांश समय के लिए हमें बस नए लॉग देखने की आवश्यकता है, हमें अपने डिस्क स्थान का दक्षिणात्मक प्रबंधन करना भी है, तो हम इस सब को कैसे करें? उत्तर है logrotate के साथ।\n\nlogrotate उपयोगिता हमारे लिए लॉग प्रबंधन करती है। इसमें एक कॉन्फ़िगरेशन फ़ाइल होती है जो हमें यह निर्दिष्ट करने की अनुमति देती है कि कितने और कौन से लॉग रखने हैं, अपने लॉग को कैसे संपीड़ित करें ताकि स्थान बचाया जा सके और अधिक। logrotate उपकरण आम तौर पर एक दिन में एक बार cron से चलाया जाता है और कॉन्फ़िगरेशन फ़ाइलें /etc/logrotate.d में मिल सकती हैं।\n\nआप अपने लॉग परिस्थितियों की जांच करें और देखें कि यह आपके कुछ लॉग कैसे प्रबंधित करता है।",
          "quizAnswer": "logrotate",
          "quizQuestion": "लॉग प्रबंधन के लिए कौन सा उपयोगीता उपयोग किया जाता है?",
          "slug": "लॉगफ़ाइलेंप्रबंधितकरना",
          "title": "लॉग फ़ाइलें प्रबंधित करना"
        }
      ],
      "slug": "logging",
      "title": "लॉगिंग"
    },
    {
      "description": "rsync, scp, nfs और अधिक के साथ नेटवर्क साझाकरण के बारे में जानें।",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "एक मशीन से दूसरी मशीन पर scp के साथ एक फ़ाइल कॉपी करने का प्रयास करें।",
          "id": 1,
          "lessonContent": "आपका नेटवर्क पर आम तौर पर एकमात्र कंप्यूटर नहीं होता है, यह विशेष रूप से उस स्थिति में होता है जब आप व्यावसायिक वातावरण में काम कर रहे हैं। जब हम डेटा एक मशीन से दूसरी मशीन में स्थानांतरित करना चाहते हैं, कभी-कभी यह आसान हो सकता है कि एक USB ड्राइव को कनेक्ट करके उन्हें मैन्युअल रूप से कॉपी करें। लेकिन अधिकांश समय के लिए, यदि आप एक ही नेटवर्क पर काम कर रहे हैं, तो डेटा स्थानांतरित करने का तरीका नेटवर्क फ़ाइल साझाकरण के माध्यम से है। \n\nइस पाठ्यक्रम में हम अपने नेटवर्क पर विभिन्न मशीनों के बीच डेटा कॉपी करने के कुछ विभिन्न तरीके पर चर्चा करेंगे। हम कुछ साधारण फ़ाइल कॉपी पर चर्चा करेंगे, फिर हम अपनी मशीन पर एक अलग ड्राइव के रूप में काम करने वाले पूरे निर्देशिकाओं को माउंट करने के बारे में चर्चा करेंगे। \n\nएक सरल फ़ाइल साझाकरण उपकरण <b>scp</b> कमांड है। scp कमांड सुरक्षित कॉपी के लिए है, यह एक्जेक्टली वही तरीका काम करता है जैसे cp कमांड करता है, लेकिन आपको एक होस्ट से दूसरे होस्ट पर कॉपी करने की अनुमति देता है जो एक ही नेटवर्क पर हैं। यह ssh के माध्यम से काम करता है इसलिए आपके सभी क्रियाएँ ssh के रूप में ही प्रमाणीकरण और सुरक्षा का उपयोग कर रहे हैं। \n\n<b>स्थानीय होस्ट से रिमोट होस्ट पर एक फ़ाइल कॉपी करने के लिए</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>रिमोट होस्ट से अपने स्थानीय होस्ट पर एक फ़ाइल कॉपी करने के लिए</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>अपने स्थानीय होस्ट से रिमोट होस्ट पर एक निर्देशिका कॉपी करने के लिए</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "आप किस कमांड का उपयोग कर सकते हैं ताकि एक होस्ट से दूसरे होस्ट पर सुरक्षित रूप से फ़ाइलें कॉपी की जा सकें?",
          "slug": "नेटवर्कफ़ाइलसाझाकरण",
          "title": "फ़ाइल साझाकरण अवलोकन"
        },
        {
          "exercise": "एक निर्दिष्ट निर्देशिका को दूसरे निर्देशिका के साथ सिंक करने के लिए rsync का उपयोग करें, महत्वपूर्ण निर्देशिका को अधिलेखित न करें!",
          "id": 2,
          "lessonContent": "विभिन्न होस्ट से डेटा कॉपी करने के लिए एक और उपकरण जिसे rsync कहा जाता है (दूरस्थ समक्रमण के लिए संक्षेपित) का उपयोग किया जाता है। Rsync scp के बहुत ही समान है, लेकिन इसमें एक प्रमुख अंतर है। Rsync एक विशेष एल्गोरिदम का उपयोग करता है जो अगर आप जिस डेटा को कॉपी कर रहे हैं, उसमें पहले से ही है यह जांचता है और केवल अंतर को कॉपी करेगा। उदाहरण के लिए, मान लीजिए कि आप एक फ़ाइल को कॉपी कर रहे थे और आपका नेटवर्क बाधित हो गया, इसलिए आपकी कॉपी बीच में रुक गई। शुरू से सब कुछ फिर से कॉपी करने की बजाय, rsync केवल उन हिस्सों को कॉपी करेगा जो कॉपी नहीं हुए।\n\nयह भी एक फ़ाइल जिसे आप कॉपी कर रहे हैं की अखंडता की जांच करता है जिसे चेकसम्स कहा जाता है। ये छोटे सुधार अधिक फ़ाइल स्थानांतरण लचीलाई और rsync को दूरस्थ और स्थानीय रूप से निर्देशिका समक्रमण, डेटा बैकअप, बड़े डेटा स्थानांतरण और अधिक के लिए आदर्श बनाते हैं।\n\nकुछ सामान्य रूप से उपयोग किए जाने वाले rsync विकल्प:\n\n<ul>\n<li>v - वर्बोस आउटपुट</li>\n<li>r - निरंतर निर्देशिकाओं में</li>\n<li>h - मानव पठनीय आउटपुट</li>\n<li>z - सुविधाजनक स्थानांतरण के लिए संपीड़ित, धीमे कनेक्शन के लिए बड़ा है</li>\n</ul>\n\n<b>समान होस्ट पर फ़ाइलें कॉपी/सिंक करें</b>\n\n<pre>$ rsync -zvr /my/local/directory/one /my/local/directory/two</pre>\n\n<b>लोकल होस्ट से रिमोट होस्ट पर फ़ाइलें कॉपी/सिंक करें</b>\n\n<pre>$ rsync /local/directory username@remotehost.com:/remote/directory</pre>\n\n<b>लोकल होस्ट से रिमोट होस्ट पर फ़ाइलें कॉपी/सिंक करें</b>\n\n<pre>$ rsync username@remotehost.com:/remote/directory /local/directory</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "डेटा बैकअप के लिए कौन सा कमांड उपयोगी होगा?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "एक SimpleHTTPServer सेटअप करने का प्रयास करें!",
          "id": 3,
          "lessonContent": "पाइथन के पास HTTP के माध्यम से फ़ाइल सेवा करने के लिए एक बहुत ही उपयोगी उपकरण है। यह बड़ा अच्छा है अगर आप केवल एक त्वरित नेटवर्क साझा बनाना चाहते हैं जिसे आपके नेटवर्क पर अन्य मशीन तक पहुंच सकती हैं। उसके लिए बस उस निर्देशिका में जाएं जिसे आप साझा करना चाहते हैं और निम्नलिखित को चलाएं:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nयह एक मौलिक वेबसर्वर सेट करता है जिसे आप लोकलहोस्ट पते के माध्यम से पहुंच सकते हैं। तो इसे चलाने वाली मशीन का आईपी पता प्राप्त करें और फिर दूसरी मशीन पर उसे ब्राउज़र में इस पते पर पहुंचें: http://IP_ADDRESS:8000। अपनी खुद की मशीन पर, आप अपने वेब ब्राउज़र में टाइप करके उपलब्ध फ़ाइलें देख सकते हैं: http://localhost:8000।\n\nआप इसे नोड के साथ भी कर सकते हैं या यदि आप पाइथन 3 चला रहे हैं, तो वाक्यरचना थोड़ी अलग होगी।",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "पाइथन के साथ एक सरल http सर्वर बनाने के लिए आप कौन सा उपकरण प्रयोग कर सकते हैं?",
          "slug": "simplehttpserver",
          "title": "सरल HTTP सर्वर"
        },
        {
          "exercise": "अधिक जानने के लिए NFS के मैनपेज को पढ़ें।",
          "id": 4,
          "lessonContent": "लिनक्स के लिए सबसे मानक नेटवर्क फ़ाइल साझा करने का NFS (नेटवर्क फ़ाइल सिस्टम) है, NFS एक सर्वर को नेटवर्क के माध्यम से एक या एक से अधिक क्लाइंट के साथ निर्देशिकाएँ और फ़ाइलें साझा करने की अनुमति देता है।\n\nहम NFS सर्वर कैसे बनाएं इस विवरण में नहीं जाएंगे क्योंकि यह जटिल हो सकता है, हालांकि हम NFS क्लाइंट सेटअप पर चर्चा करेंगे।\n\n<b>NFS क्लाइंट सेटअप</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>ऑटोमाउंटिंग</b>\n\nकहें आप NFS सर्वर का बहुत अक्सर उपयोग करते हैं और आप इसे स्थायी रूप से माउंट करना चाहते हैं, सामान्यत: आप सोचेंगे कि आप /etc/fstab फ़ाइल को संपादित करेंगे, लेकिन आपको कभी-कभी सर्वर से कनेक्शन नहीं मिल सकता और यह बूटअप पर समस्याएँ उत्पन्न कर सकता है। इसके बजाय आपको ऑटोमाउंटिंग सेटअप करना है ताकि आप जब चाहें तब NFS सर्वर से कनेक्ट कर सकें। यह <b>automount</b> उपकरण द्वारा किया जाता है या लिनक्स के हाल के संस्करणों में <b>amd</b> से। जब एक निर्दिष्ट निर्देशिका में एक फ़ाइल एक्सेस की जाती है, तो automount दूरस्थ सर्वर को खोजेगा और स्वचालित रूप से माउंट करेगा।",
          "quizAnswer": "automount",
          "quizQuestion": "माउंट पॉइंट को स्वचालित रूप से प्रबंधित करने के लिए कौन सा उपकरण प्रयोग किया जाता है?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "एक साम्बा शेयर सेटअप करें, अगर आपके पास नहीं है, smb.conf खोलें और कॉन्फ़िग फ़ाइल में विकल्पों को समझने के लिए अपने आप को परिचित कराएं।",
          "id": 5,
          "lessonContent": "कंप्यूटिंग के प्रारंभिक दिनों में, विंडोज मशीनों को लिनक्स मशीनों के साथ फ़ाइल साझा करने की आवश्यकता पड़ी, इसलिए सर्वर संदेश ब्लॉक (SMB) प्रोटोकॉल का जन्म हुआ। SMB का उपयोग विंडोज ऑपरेटिंग सिस्टम्स (मैक भी SMB के साथ फ़ाइल साझा करता है) के बीच फ़ाइल साझा करने के लिए किया गया था और फिर बाद में इसे सामान्य इंटरनेट फ़ाइल सिस्टम (CIFS) प्रोटोकॉल के रूप में साफ किया और अनुकूलित किया गया।\n\nसाम्बा वह है जिसे हम लिनक्स पर CIFS के साथ काम करने के लिए यूटिलिटीज़ कहते हैं। फ़ाइल साझा करने के अतिरिक्त, आप प्रिंटर जैसे संसाधनों को भी साझा कर सकते हैं।\n\n<b>साम्बा के साथ नेटवर्क शेयर बनाएं</b>\n\nचलिए उन मूलभूत कदमों के माध्यम से जाएं जिनका पालन करके एक नेटवर्क शेयर बनाएं जिसे एक विंडोज मशीन तक पहुंच सकती है:\n\n<b>साम्बा इंस्टॉल करें</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>smb.conf को सेटअप करें</b>\n\nसाम्बा के लिए कॉन्फ़िगरेशन फ़ाइल /etc/samba/smb.conf पर मिलती है, इस फ़ाइल में सिस्टम को बताना चाहिए कि कौन से निर्देशिकाएँ साझा की जानी चाहिए, उनकी पहुंच अनुमतियाँ, और अधिक विकल्प। डिफ़ॉल्ट smb.conf में पहले से ही कई कमेंट कोड शामिल हैं और आप उन्हें अपनी कॉन्फ़िगरेशन लिखने के उदाहरण के रूप में उपयोग कर सकते हैं।\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>साम्बा के लिए पासवर्ड सेटअप करें</b>\n\n<pre>$ sudo smbpasswd -a [उपयोगकर्ता नाम]</pre>\n\n<b>एक साझा निर्देशिका बनाएं</b>\n\n<pre>$ mkdir /मेरी/निर्देशिका/जिसे/साझा/करना/है</pre>\n\n<b>साम्बा सेवा को पुनः आरंभ करें</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>विंडोज के माध्यम से एक साम्बा शेयर तक पहुंचें</b>\n\nविंडोज में, रन प्रॉम्प्ट में नेटवर्क कनेक्शन टाइप करें: \\\\HOST\\शेयरनेम।\n\n<b>लिनक्स के माध्यम से एक साम्बा/विंडोज शेयर तक पहुंचें</b>\n\n<pre>$ smbclient //HOST/निर्देशिका -U उपयोगकर्ता</pre>\n\nसाम्बा पैकेज में एक कमांड लाइन टूल शामिल है जिसे <b>smbclient</b> कहा जाता है जिसका उपयोग आप किसी भी विंडोज या साम्बा सर्वर तक पहुंचने के लिए कर सकते हैं। जब आप शेयर से कनेक्ट हो जाते हैं तो आप नेविगेट और फ़ाइलें स्थानांतरित कर सकते हैं।\n\n<b>अपने सिस्टम पर एक साम्बा शेयर जोड़ें</b>\n\nएक-एक करके फ़ाइलें स्थानांतरित करने की बजाय, आप अपने सिस्टम पर नेटवर्क शेयर को माउंट कर सकते हैं।\n\n<pre>$ sudo mount -t cifs सर्वरनाम:निर्देशिका माउंटपॉइंट -o उपयोगकर्ता=उपयोगकर्तानाम,पासवर्ड=पासवर्ड</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "विंडोज और लिनक्स के बीच फ़ाइल स्थानांतरण के लिए नवीनतम प्रोटोकॉल क्या है?",
          "slug": "samba",
          "title": "साम्बा"
        }
      ],
      "slug": "networksharing",
      "title": "नेटवर्क साझाकरण"
    },
    {
      "description": "नेटवर्किंग के मूलभूत और TCP/IP मॉडल के बारे में सीखें।",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं।",
          "id": 1,
          "lessonContent": "एक सामान्य गृह नेटवर्क पर नजर डालें, आपके पास कुछ विभिन्न घटक हैं।\n\n<ul>\n<li>ISP - आपका इंटरनेट सेवा प्रदाता, जिसे आप अपने घर में इंटरनेट प्राप्त करने के लिए भुगतान करते हैं।</li>\n<li>राउटर - राउटर आपके नेटवर्क में प्रत्येक मशीन को इंटरनेट से कनेक्ट करने की अनुमति देता है। अधिकांश आधुनिक राउटर्स में, आप वायरलेस या एक इथरनेट केबल के माध्यम से कनेक्ट कर सकते हैं।</li>\n<li>WAN - व्यापक क्षेत्र नेटवर्क, इसे हम उस नेटवर्क कहते हैं जो आपके राउटर और इंटरनेट जैसे एक व्यापक नेटवर्क के बीच सभी कुछ को आवरित करता है।</li>\n<li>WLAN - वायरलेस स्थानीय क्षेत्र नेटवर्क, यह आपके राउटर और आपके पास लैपटॉप जैसे किसी भी वायरलेस उपकरण हो सकते हैं के बीच का नेटवर्क है।</li>\n<li>LAN - स्थानीय क्षेत्र नेटवर्क, यह आपके राउटर और डेस्कटॉप पीसी जैसे किसी भी वायर्ड उपकरणों के बीच का नेटवर्क है।</li>\n<li>होस्ट - नेटवर्क पर प्रत्येक मशीन को होस्ट के रूप में जाना जाता है।</li>\n</ul>\n\nनेटवर्क के माध्यम से प्रसारित होने वाला डेटा और जानकारी को पैकेट के रूप में जाना जाता है और नेटवर्किंग नोमैड खंड के अंत तक, आपको यह स्पष्ट हो जाएगा कि पैकेट होस्ट के पास से और होस्ट के पास जाता है।",
          "quizAnswer": "LAN",
          "quizQuestion": "स्थानीय क्षेत्र नेटवर्क किसे कहा जाता है?",
          "slug": "नेटवर्कमूलभूत",
          "title": "नेटवर्क मूलभूत"
        },
        {
          "exercise": "OSI मॉडल के बारे में अधिक पढ़ें: <a href=\"https://en.wikipedia.org/wiki/OSI_model\">https://en.wikipedia.org/wiki/OSI_model</a>",
          "id": 2,
          "lessonContent": "कुछ व्यावहारिक नेटवर्किंग चीजों पर नजर डालने से पहले, हमें उस उक्ति जर्गन के बारे में जानना होगा जिसे आपने संभावित रूप से पहले सुना होगा। OSI (ओपन सिस्टम्स इंटरकनेक्शन) मॉडल एक सिद्धांती नेटवर्किंग मॉडल है। यह मॉडल हमें दिखाता है कि एक पैकेट एक नेटवर्क में सात विभिन्न परतों में कैसे चलता है। मैं इस मॉडल की विशेषताओं पर नहीं जाऊंगा, क्योंकि इन नेटवर्किंग पाठ्यक्रमों का अधिकांश TCP/IP मॉडल पर केंद्रित होगा, लेकिन यह उल्लिखित करना चाहिए कि ऐसा एक सिद्धांती नेटवर्किंग मॉडल मौजूद है और वास्तव में आज हम उसका उपयोग कर रहे हैं।",
          "quizAnswer": "OSI",
          "quizQuestion": "नेटवर्किंग का सिद्धांती मॉडल क्या कहलाता है?",
          "slug": "osimodel",
          "title": "OSI मॉडल"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 3,
          "lessonContent": "OSI मॉडल ने उसे जन्म दिया जिससे आखिरकार TCP/IP मॉडल बना और यह मॉडल वास्तव में इंटरनेट पर आधारित है। यह नेटवर्किंग का वास्तविक कार्यान्वयन है। TCP/IP मॉडल TCP/IP प्रोटोकॉल सुइट का उपयोग करता है, जिसे हम सामान्य रूप से TCP/IP के रूप में संदर्भित करते हैं। ये प्रोटोकॉल एक साथ काम करके निर्दिष्ट करते हैं कि डेटा को कैसे इकट्ठा किया जाना चाहिए, पता लगाया जाना चाहिए, प्रेषित किया जाना चाहिए और नेटवर्क के माध्यम से कैसे मार्गित किया जाना चाहिए। TCP/IP मॉडल का उपयोग करके, हम देख सकते हैं कि ये प्रोटोकॉल कैसे उपयोग किए जाते हैं ताकि नेटवर्क के माध्यम से एक पैकेट का सफर दिखाया जा सके।\n\n<b>एप्लिकेशन परत</b>\n\nTCP/IP मॉडल की ऊपरी परत। यह निर्धारित करती है कि आपके कंप्यूटर के कार्यक्रम (जैसे आपका वेब ब्राउज़र) कैसे परिवहन परत से डेटा देखते हैं जो भेजा जाता है या प्राप्त होता है।\n\nइस परत में उपयोग होता है:\n<ul>\n<li>HTTP (हाइपरटेक्स्ट स्थानांतरण प्रोटोकॉल) - इंटरनेट पर वेबपेज के लिए उपयोग किया जाता है।</li>\n<li>SMTP (सिम्पल मेल स्थानांतरण प्रोटोकॉल) - इलेक्ट्रॉनिक मेल (ईमेल) स्थानांतरण</li>\n</ul>\n\n<b>परिवहन परत</b>\n\nडेटा कैसे प्रेषित किया जाएगा, सही पोर्ट्स की जांच करता है, डेटा की अखंडता की जांच करता है, और मौलिक रूप से हमारे पैकेट्स को पहुंचाता है।\n\nइस परत में उपयोग होता है:\n<ul>\n<li>TCP (ट्रांसमिशन नियंत्रण प्रोटोकॉल) - विश्वसनीय डेटा प्रेषण</li>\n<li>UDP (उपयोगकर्ता डेटाग्राम प्रोटोकॉल) - अविश्वसनीय डेटा प्रेषण</li>\n</ul>\n\n<b>नेटवर्क परत</b>\n\nयह परत यह निर्धारित करती है कि होस्ट्स और नेटवर्क के बीच पैकेट कैसे ले जाएं।\n\nइस परत में उपयोग होता है:\n<ul>\n<li>IP (इंटरनेट प्रोटोकॉल) - एक मशीन से दूसरे मशीन तक पैकेट का मार्ग निर्धारित करने में मदद करता है।</li>\n<li>ICMP (इंटरनेट नियंत्रण संदेश प्रोटोकॉल) - हमें बताने में मदद करता है कि क्या हो रहा है, जैसे त्रुटि संदेश और डीबगिंग सूचना।</li>\n</ul>\n\n<b>लिंक परत</b>\n\nयह परत निर्धारित करती है कि डेटा को एक भौतिक हार्डवेयर टुकड़े के माध्यम से कैसे भेजा जाए। जैसे डेटा ईथरनेट, फाइबर, आदि के माध्यम से यात्रा करता है।\n\nऊपर दिए गए प्रोटोकॉलों की सूचियाँ हर परत का उपयोग करती है, यह सूची सम्पूर्ण नहीं है और आपको बहुत सारे अन्य प्रोटोकॉलों का सामना करना पड़ेगा।\n\nआगामी पाठों में, हम हर परत के माध्यम से इस पैकेट का नेटवर्क में सफर कैसे करता है उस पर विचार करेंगे और चर्चा करेंगे TCP/IP मॉडल की दृष्टि से (नेटवर्क के माध्यम से पैकेट कैसे सफर करता है के कई परिप्रेक्ष्य हैं, हम उन सभी को नहीं देखेंगे, लेकिन यह जानकारी रखें कि वे मौजूद हैं)।",
          "quizAnswer": "एप्लिकेशन",
          "quizQuestion": "TCP/IP मॉडल की ऊपरी परत क्या है?",
          "slug": "tcpipmodel",
          "title": "TCP/IP मॉडल"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 4,
          "lessonContent": "हम जब नेटवर्क पर पैकेट कैसे चलता है देखने से पहले, हमें कुछ शब्दावली के साथ परिचित होना चाहिए। जब आप एक पत्र भेजते हैं, तो आपको जानना चाहिए कि यह किसे भेजा जा रहा है और कहां से आ रहा है। पैकेट्स को भी यही जानकारी चाहिए, हमारे होस्ट्स और अन्य होस्ट्स को MAC (मीडिया एक्सेस कंट्रोल) पते और IP पते का उपयोग करके पहचाना जाता है, हम इंसानों को सुविधाजनक बनाने के लिए होस्ट्नेम्स का उपयोग करते हैं।\n\n<b>MAC पते</b>\n\nएक MAC पता एक हार्डवेयर पता के रूप में उपयोग किया जाने वाला एक अद्वितीय पहचानकर्ता है। यह पता कभी नहीं बदलेगा। जब आप इंटरनेट तक पहुंचना चाहते हैं, तो आपकी मशीन के पास एक नेटवर्क इंटरफेस कार्ड नामक उपकरण होना चाहिए। इस नेटवर्क एडाप्टर के पास अपना खुद का हार्डवेयर पता होता है जिसका उपयोग आपकी मशीन की पहचान के लिए किया जाता है। एक ईथरनेट डिवाइस के लिए एक MAC पता कुछ इस प्रकार दिखता है 00:C4:B5:45:B2:43। MAC पते नेटवर्क एडाप्टर्स को उनके निर्माण किए जाने पर मिलते हैं। प्रत्येक निर्माता के पास एक संगठनात्मक अद्वितीय पहचानकर्ता (OUI) होता है जो उन्हें निर्माता के रूप में पहचानने के लिए होता है। इस OUI को MAC पते के पहले 3 बाइट्स द्वारा दर्शाया जाता है। उदाहरण के लिए, Dell के पास 00-14-22 है, इसलिए Dell से एक नेटवर्क एडाप्टर के पास एक MAC पता हो सकता है जैसे: 00-14-22-34-B2-C2।\n\n<b>IP पते</b>\n\nएक IP पता नेटवर्क पर एक उपकरण की पहचान के लिए उपयोग किया जाता है, वे हार्डवेयर निर्देशनहीन होते हैं और यह विभिन्न वाक्यरचना में भिन्न हो सकते हैं यदि आप IPv4 या IPv6 का उपयोग कर रहे हैं (इस पर बाद में अधिक जानकारी मिलेगी)। अब हम यह मान लेंगे कि आप IPv4 का उपयोग कर रहे हैं, इसलिए एक साधारण IP पता इस प्रकार दिख सकता है: 10.24.12.4। IP पते नेटवर्किंग के सॉफ्टवेयर साइड के साथ उपयोग किए जाते हैं। जब भी कोई सिस्टम इंटरनेट से जुड़ा होता है तो उसके पास एक IP पता होना चाहिए। वे यदि आपका नेटवर्क बदलता है तो बदल सकते हैं और पूरे इंटरनेट के लिए अद्वितीय होते हैं (यह हमें NAT के बारे में सीखने पर हमेशा नहीं होता है)।\n\nयाद रखें कि नेटवर्क्स के अलावा पैकेट्स को ले जाने के लिए सॉफ्टवेयर और हार्डवेयर दोनों की आवश्यकता होती है, इसलिए हमारे पास प्रत्येक के लिए दो पहचानकर्ता होते हैं, MAC (हार्डवेयर) और IP (सॉफ्टवेयर)।\n\n<b>होस्टनेम्स</b>\n\nअपनी मशीनों को पहचानने का एक अंतिम तरीका होस्टनेम्स के माध्यम से है। होस्टनेम्स आपके IP पते को लेकर आपको एक मानव योग्य नाम से जोड़ने की अनुमति देते हैं। 192.12.41.4 याद रखने के बजाय आप सिर्फ मेरीहोस्ट.कॉम याद रख सकते हैं।",
          "quizAnswer": "4",
          "quizQuestion": "एक IPv4 पते में कितने बाइट होते हैं?",
          "slug": "नेटवर्कपता",
          "title": "नेटवर्क पता"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 5,
          "lessonContent": "चलो मान लो कि मैं पैटी को ईमेल भेजना चाहता हूँ। हम हर TCP/IP परत के माध्यम से इसे काम में देखेंगे। \n\nयाद रखें कि पैकेट का उपयोग डेटा को नेटवर्कों के बीच स्थानांतरित करने के लिए किया जाता है, एक पैकेट में हेडर और पेलोड होता है। हेडर में जानकारी होती है कि पैकेट कहाँ से जा रहा है और कहाँ से आया है। पेलोड वास्तविक डेटा है जो स्थानांतरित किया जा रहा है। जब हमारा पैकेट नेटवर्क को चलता है, हर परत हेडर में जानकारी जोड़ती है। ध्यान रखें कि विभिन्न परतें हमारे \"पैकेट\" के लिए एक विभिन्न शब्द का उपयोग करती हैं। परिवहन परत में हम अपने डेटा को सिगमेंट में समाहित करते हैं और लिंक परत में हम इसे फ़्रेम के रूप में संदर्भित करते हैं, लेकिन यह जान लें कि पैकेट का उपयोग एक ही चीज के संदर्भ में किया जा सकता है।\n\nसबसे पहले हम एप्लिकेशन परत में शुरू करते हैं। जब हम अपने ईमेल को अपने ईमेल क्लाइंट के माध्यम से भेजते हैं, तो एप्लिकेशन परत इस डेटा को समाहित करेगी। एप्लिकेशन परत निर्दिष्ट पोर्ट के माध्यम से परिवहन परत से बात करती है और इस पोर्ट के माध्यम से अपना डेटा भेजती है। हमें एप्लिकेशन परत प्रोटोकॉल SMTP (सिम्पल मेल ट्रांसफर प्रोटोकॉल) के माध्यम से ईमेल भेजना है। डेटा परिवहन प्रोटोकॉल के माध्यम से भेजा जाता है जो इस पोर्ट के लिए एक कनेक्शन खोलता है (SMTP के लिए पोर्ट 25 का उपयोग किया जाता है), तो हमें इस पोर्ट के माध्यम से डेटा भेजा जाता है और वह डेटा सेगमेंट में समाहित करने के लिए परिवहन परत में भेजा जाता है।",
          "quizAnswer": "एप्लिकेशन",
          "quizQuestion": "पैकेट डेटा को उपयोगकर्ता मित्रपूर्ण प्रारूप में प्रस्तुत करने के लिए कौन सी परत का उपयोग किया जाता है?",
          "slug": "applicationlayer",
          "title": "एप्लिकेशन परत"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 6,
          "lessonContent": "परिवहन परत हमें हमारे डेटा को एक ऐसे तरीके से स्थानांतरित करने में मदद करती है जिसे नेटवर्क पढ़ सकता है। यह हमारे डेटा को टुकड़ों में विभाजित करता है जो परिवहन किए जाएंगे और सही क्रम में पुनः एक साथ रखे जाएंगे। इन टुकड़ों को सेगमेंट के रूप में जाना जाता है। सेगमेंट नेटवर्क के ऊपर डेटा को परिवहन करने को आसान बनाते हैं।\n\n<b>पोर्ट्स</b>\n\nहालांकि हम जानते हैं कि हम अपने डेटा को किस प्रक्रिया या सेवाओं को भेज रहे हैं आईपी पतों के माध्यम से, वे इतने विशिष्ट नहीं हैं कि हमारे डेटा को किसी निश्चित प्रक्रिया या सेवाओं को भेजने के लिए। HTTP जैसी सेवाएं पोर्ट के माध्यम से संचार साधन का उपयोग करती हैं। यदि हम वेबपेज डेटा भेजना चाहते हैं, तो हमें इसे HTTP पोर्ट (पोर्ट 80) के माध्यम से भेजना होगा। सेगमेंट बनाने के अतिरिक्त, परिवहन परत सेगमेंट के साथ मूल स्रोत और गंतव्य पोर्ट को भी जोड़ देगी, ताकि जब प्राप्तकर्ता अंतिम पैकेट प्राप्त करता है, तो उसे पता चल जाए कि कौन सा पोर्ट उपयोग करना है।\n\n<b>UDP</b>\n\nUDP और TCP दो प्रसिद्ध परिवहन प्रोटोकॉल हैं। हम UDP पर संक्षेप में चर्चा करेंगे और अधिकांश समय TCP पर व्यतीत करेंगे, क्योंकि यह सबसे अधिक प्रयोग किया जाने वाला है।\n\nUDP डेटा परिवहन का एक अविश्वसनीय तरीका प्रदान करता है, वास्तव में यह इसे परिवहन करते समय वास्तव में ध्यान नहीं देता। यह भयानक सुन सकता है, लेकिन इसके उपयोग हैं, जैसे कि मीडिया स्ट्रीमिंग के लिए, अगर आप कुछ फ्रेम खो देते हैं तो यह ठीक है, वापस आप अपने डेटा को थोड़ी देर में प्राप्त करते हैं।\n\n<b>TCP</b>\n\nTCP एक विश्वसनीय कनेक्शन-अनुसारी डेटा स्ट्रीम प्रदान करता है। TCP पोर्ट का उपयोग होस्ट से डेटा भेजने और प्राप्त करने के लिए करता है। एक एप्लिकेशन अपने होस्ट पर एक पोर्ट से दूसरे होस्ट पर एक और पोर्ट के साथ एक कनेक्शन खोलता है। कनेक्शन स्थापित करने के लिए, हम TCP हैंडशेक का उपयोग करते हैं।\n\n<ul>\n<li>ग्राहक (कनेक्टिंग प्रक्रिया) सर्वर को एक कनेक्शन का अनुरोध करने के लिए एक SYN सेगमेंट भेजता है</li>\n<li>सर्वर ग्राहक को उसके कनेक्शन अनुरोध को स्वीकृति देने के लिए एक SYN-ACK सेगमेंट भेजता है</li>\n<li>ग्राहक सर्वर को सर्वर के कनेक्शन अनुरोध को स्वीकृति देने के लिए एक ACK भेजता है</li>\n</ul>\n\nएक बार जब यह कनेक्शन स्थापित हो जाता है, तो डेटा एक TCP कनेक्शन के माध्यम से आदान-प्रदान किया जा सकता है। डेटा विभिन्न सेगमेंट्स में भेजा जाता है और उन्हें TCP क्रमांकों के साथ ट्रैक किया जाता है ताकि जब वे पहुंचाए जाएं, तो उन्हें सही क्रम में व्यवस्थित किया जा सके। हमारे ईमेल उदाहरण में, परिवहन परत उत्पादन होस्ट के स्रोत पोर्ट (25) को गंतव्य पोर्ट के साथ जोड़ती है।",
          "quizAnswer": "TCP",
          "quizQuestion": "एक विश्वसनीय परिवहन प्रोटोकॉल क्या है?",
          "slug": "परिवहनपरत",
          "title": "परिवहन परत"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 7,
          "lessonContent": "नेटवर्क परत हमारे पैकेट के रूटिंग का निर्धारण करती है जो हमारे स्रोत होस्ट से लक्ष्य होस्ट तक होता है। भाग्यशाली तौर पर हमारे उदाहरण में, हमारा पैकेट केवल एक ही नेटवर्क के भीतर यात्रा कर रहा है, लेकिन इंटरनेट कई नेटवर्कों से बना है। इंटरनेट के इन छोटे नेटवर्कों को सबनेट कहा जाता है। सभी सबनेट किसी न किसी तरीके से एक-दूसरे से जुड़े होते हैं, इसीलिए हम www.google.com तक पहुंच सकते हैं भले ही यह अपने नेटवर्क पर हो। मैं विस्तार से नहीं जाऊंगा क्योंकि हमारे पास सबनेट्स पर समर्पित एक पूरा कोर्स है, लेकिन अब हमारे नेटवर्क परत के संदर्भ में, यह जान लें कि आईपी पते विभिन्न सबनेट्स तक यात्रा करने के नियमों को परिभाषित करते हैं। \n\nनेटवर्क परत में, यह परिवहन परत से आने वाला सेगमेंट प्राप्त करती है और इस सेगमेंट को एक आईपी पैकेट में ढक देती है फिर इस पैकेट हेडर में स्रोत होस्ट और लक्ष्य होस्ट का आईपी पता जोड़ती है। तो इस समय, हमारे पैकेट के पास जानकारी है कि वह कहाँ जा रहा है और कहाँ से आया है। अब यह हमारे पैकेट को भौतिक हार्डवेयर परत को भेजती है।",
          "quizAnswer": "सबनेट",
          "quizQuestion": "इंटरनेट के छोटे नेटवर्क किस नाम से जाने जाते हैं?",
          "slug": "networklayer",
          "title": "नेटवर्क परत"
        },
        {
          "exercise": "इस सबक के लिए कोई व्यायाम नहीं।",
          "id": 8,
          "lessonContent": "TCP/IP मॉडल के नीचे लिंक परत होती है। यह परत हार्डवेयर विशिष्ट परत है।\n\nलिंक परत में, हमारे पैकेट को एक बार और कुछ नामक फ्रेम में बंधा जाता है। फ्रेम हेडर हमारे होस्टों के स्रोत और गंतव्य MAC पते, चेकसम और पैकेट विभाजक जोड़ता है ताकि प्राप्तकर्ता जान सके कि पैकेट कब समाप्त होता है।\n\nभाग्यवश हम एक ही नेटवर्क पर हैं, इसलिए हमारे पैकेट को बहुत दूर जाने की आवश्यकता नहीं है। पहले, लिंक परत मेरा स्रोत MAC पता फ्रेम हेडर में जोड़ती है, लेकिन यह जानने की जरूरत है कि पैटी का MAC पता कैसे पता चलेगा और मैं उसे कैसे खोजूं क्योंकि यह इंटरनेट पर नहीं है? हम ARP का उपयोग करते हैं!\n\n<b>ARP (पता संक्षेपण प्रोटोकॉल)</b>\n\nARP एक IP पते से संबंधित MAC पता खोजता है। ARP एक ही नेटवर्क के भीतर प्रयोग किया जाता है। अगर पैटी एक ही नेटवर्क पर नहीं थी, तो हम एक रूटिंग सिस्टम का उपयोग करेंगे जिससे पैकेट को प्राप्त करने वाला अगला राउटर निर्धारित होगा और एक बार हम एक ही नेटवर्क पर होंगे, हम ARP का उपयोग कर सकेंगे।\n\nजब हम एक ही नेटवर्क पर होते हैं, सिस्टम पहले ARP लुकअप तालिका का उपयोग करता है जो जानकारी संग्रहित करता है कि कौन से IP पते से कौन सा MAC पता संबंधित है। यदि मान्यता वहाँ नहीं है, तो ARP का उपयोग किया जाता है। फिर सिस्टम नेटवर्क पर ARP प्रोटोकॉल का उपयोग करते हुए नेटवर्क को एक ब्रॉडकास्ट संदेश भेजेगा ताकि पता चले कि कौन सा होस्ट IP 10.10.1.4 रखता है। एक ब्रॉडकास्ट संदेश एक विशेष संदेश है जो नेटवर्क पर सभी होस्टों को भेजा जाता है (जिसे ब्रॉडकास्ट भेजने के लिए उपयुक्त नाम दिया गया है)। अनुरोधित IP पते वाली किसी भी मशीन द्वारा एक ARP पैकेट के साथ जवाब दिया जाएगा जिसमें IP पता और MAC पता होता है।\n\nअब हमारे पास सभी आवश्यक डेटा है, हमें आवश्यक डेटा चाहिए, IP पता और MAC पते, हमारी लिंक परत इस फ्रेम को हमारे नेटवर्क इंटरफेस कार्ड के माध्यम से आगे भेजती है, अगली उपकरण तक और पैटी के नेटवर्क तक पहुंचती है। यह कदम मैंने जितना अभी व्याख्या किया है, उससे थोड़ा अधिक जटिल है, लेकिन हम रूटिंग पाठ्यक्रम में अधिक विवरण पर चर्चा करेंगे।\n\nऔर यह एक सरल (या इतना सरल नहीं) पैकेट ट्रावर्सल नीचे TCP/IP परत में। ध्यान रखें कि पैकेट इस प्रकार के एकमार्गी रूप से नहीं चलते हैं। हमने अभी तक पैटी के नेटवर्क तक पहुंचने का भी उल्लेख नहीं किया है! नेटवर्कों के माध्यम से यात्रा करते समय, किसी भी डेटा को भेजने या प्राप्त करने से पहले कम से कम दो बार TCP/IP मॉडल के माध्यम से जाना जरूरी है। वास्तव में, इस पैकेट की दिखने की तरह कुछ ऐसा होगा:\n\n<b>पैकेट ट्रावर्सल</b>\n\n<ol>\n<li>पीट पैटी को एक ईमेल भेजता है: यह डेटा परिवहन परत में भेजा जाता है।</li>\n<li>परिवहन परत डेटा को एक TCP या UDP हेडर में बंधने के लिए एक सेगमेंट में बंधती है, सेगमेंट गंतव्य और स्रोत TCP या UDP पोर्ट जोड़ता है, फिर सेगमेंट को नेटवर्क परत में भेज दिया जाता है।</li>\n<li>नेटवर्क परत एक आईपी पैकेट के भीतर TCP सेगमेंट को बंधती है, यह स्रोत और गंतव्य आईपी पता जोड़ती है। फिर पैकेट को लिंक परत में भेज दिया जाता है।</li>\n<li>पैकेट फिर पीट के भौतिक हार्डवेयर तक पहुंचता है और एक फ्रेम में बंध जाता है। स्रोत और गंतव्य MAC पता फ्रेम में जोड़ दिया जाता है।</li>\n<li>पैटी के भौतिक परत द्वारा यह डेटा फ्रेम को प्राप्त करती है और प्रत्येक फ्रेम की डेटा सत्यापन के लिए जांच करती है, फिर फ्रेम की सामग्री को अनबंधित करती है और आईपी पैकेट को नेटवर्क परत में भेजती है।</li>\n<li>नेटवर्क परत पैकेट को पढ़ती है ताकि पहले जोड़ा गया स्रोत और गंतव्य आईपी पता पाए जा सके। यह जांचती है कि उसका आईपी पता गंतव्य आईपी पते के समान है या नहीं, जो है! यह पैकेट को अनबंधित करती है और सेगमेंट को परिवहन परत में भेजती है।</li>\n<li>परिवहन परत सेगमेंट को अनबंधित करती है, TCP या UDP पोर्ट नंबर की जांच करती है और उन पोर्ट नंबरों के आधार पर एप्लिकेशन परत में एक कनेक्शन बनाती है।</li>\n<li>एप्लिकेशन परत परिवहन परत से डेटा प्राप्त करती है जो निर्धारित किए गए पोर्ट पर और इसे पैटी को अंतिम ईमेल संदेश के रूप में प्रस्तुत करती है।</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "एक ही नेटवर्क पर MAC पता खोजने के लिए क्या उपयोग किया जाता है?",
          "slug": "linklayer",
          "title": "लिंक परत"
        },
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं।",
          "id": 9,
          "lessonContent": "एक महत्वपूर्ण नेटवर्किंग अवधारणा जिस पर हमने अब तक चर्चा नहीं की है, वह है DHCP (डायनामिक होस्ट कॉन्फ़िगरेशन प्रोटोकॉल)\n\nDHCP आईपी पते, सबनेट मास्क और गेटवे को हमारी मशीनों को आवंटित करता है। उदाहरण के लिए, मान लीजिए आपके पास एक सेल फोन है और आप लोगों से बात करना शुरू करना चाहते हैं। आपको एक नंबर प्राप्त करने के लिए अपने फोन कैरियर को कॉल करना होगा और वे आपको एक नंबर देंगे। जब तक आप अपने बिल भरते रहेंगे, आप अपने फोन का उपयोग कर सकते हैं। इस मामले में DHCP फोन कैरियर है, यह आपको एक आईपी पता देता है ताकि आप अन्य आईपी पतों से बात कर सकें। आपको एक आईपी पता किराये पर भी दिया जाता है, ये किसी निश्चित समय तक चलते हैं, फिर आपके किराये सेटिंग्स के आधार पर नवीनीकृत हो जाएंगे।\n\nDHCP कई कारणों से बढ़िया है, यह एक नेटवर्क प्रशासक को आईपी पतों का आवंटन करने की चिंता नहीं करने देता है और उन्हें डुप्लिकेट आईपी पतों को सेट करने से रोकता है। हर भौतिक नेटवर्क के पास अपना DHCP सर्वर होना चाहिए ताकि एक होस्ट एक आईपी पता अनुरोध कर सके। एक साधारण घर की स्थिति में, राउटर आम तौर पर DHCP सर्वर के रूप में काम करता है।\n\nDHCP आपकी डायनामिक होस्ट सूचना कैसे प्राप्त करता है:\n\n<ol>\n<li>DHCP डिस्कवर - यह संदेश एक DHCP सर्वर के लिए खोजने के लिए प्रसारित किया जाता है।</li>\n<li>DHCP ऑफर - नेटवर्क में DHCP सर्वर एक ऑफर संदेश के साथ प्रतिक्रिया करता है। ऑफर में DHCP किराये का समय, सबनेट मास्क, आईपी पता, आदि समेत होता है।</li>\n<li>DHCP रिक्वेस्ट - ग्राहक एक और प्रसारण भेजता है ताकि सभी DHCP सर्वरों को पता चले कि वह किस ऑफर को स्वीकार किया है।</li>\n<li>DHCP ऐक - सर्वर द्वारा पुष्टि भेजी जाती है।</li>\n</ol>\n\nDHCP इससे अधिक जुड़ जाता है, लेकिन यह उसका सार है।",
          "quizAnswer": "डिस्कवर, ऑफर, रिक्वेस्ट, ऐक",
          "quizQuestion": "एक DHCP अनुरोध में क्या कदम हैं?",
          "slug": "dhcpoverview",
          "title": "DHCP अवलोकन"
        }
      ],
      "slug": "networkbasics",
      "title": "नेटवर्क मूलभूत"
    },
    {
      "description": "सबनेट्स के बारे में सीखें और सबनेट अंकगणित कैसे करें!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "ifconfig के साथ अपना आईपी पता खोजें।",
          "id": 1,
          "lessonContent": "प्रत्येक नेटवर्क होस्ट का एक अद्वितीय पता होता है, और प्रत्येक अद्वितीय पता का उपयोग नेटवर्क के भीतर होस्ट को ढूंढने के लिए किया जा सकता है। इन अद्वितीय पतों को 'आईपी पते' के रूप में जाना जाता है। एक IPv4 पता कुछ इस प्रकार दिखता है:\n\n<pre>204.23.124.23</pre>\n\nयह पता वास्तव में दो हिस्सों में बाँटा हुआ है: नेटवर्क भाग (जो यह निश्चित करता है कि वह किस नेटवर्क पर है), और होस्ट भाग (जो होस्ट को पहचानता है)। इस पाठ्यक्रम के लिए, हम अधिकांशत: IPv4 पतों पर चर्चा करेंगे, जिन्हें आप आमतौर पर 'आईपी पते' के रूप में संदर्भित करते समय देखेंगे।\n\nएक आईपी पता डीट्स से अलग होता है। एक IPv4 पते में 4 डीट्स होते हैं। यदि आप कंप्यूटर विज्ञान के थोड़े से जानकार हैं, तो आप जानते होंगे कि एक डीट 8 बिट होता है, और आप जानते होंगे कि 8 बिट वास्तव में 1 बाइट के बराबर होते हैं। इसका अर्थ है कि एक IPv4 पता 4 बाइट होता है। हम सबनेट्स और आईपी पतों के साथ काम करते समय अक्सर बिट्स का उपयोग करते हैं।\n\nआप अपना आईपी पता 'ifconfig -a' कमांड के साथ देख सकते हैं:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nजैसा कि आप देख सकते हैं मेरा IPv4 पता है: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "एक IPv4 पते में कितने बाइट होते हैं?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "अपनी सबनेट मास्क देखने के लिए ifconfig का उपयोग करें।",
          "id": 2,
          "lessonContent": "मैं कैसे पता लगा सकता हूं कि मैं पैटी के समान नेटवर्क पर हूं? अच्छा हम बस सबनेट देख सकते हैं जिसे सबनेटवर्क के लिए छोटा कहा जाता है। एक सबनेट एक समान ढंग से आईपी पतों वाले होस्टों का एक समूह है। इन होस्ट्स के बीच सामान्यत: एक पास की स्थिति में होते हैं और आप आसानी से एक समान सबनेट पर होस्ट्स को डेटा भेज सकते हैं और प्राप्त कर सकते हैं। इसे एक जिप कोड में मेल भेजने के रूप में सोचें, यह एक अलग राज्य में मेल भेजने से कहीं बेहतर है। \n\nउदाहरण के लिए, एक आईपी पति के साथ शुरू होने वाले सभी होस्ट एक ही सबनेट पर होंगे। मेरे होस्ट का आईपी 123.45.67.8 है और पैटी का 123.45.67.9 है। सामान्य संख्याएँ मेरा नेटवर्क प्रिफिक्स हैं और 8 और 9 हमारे होस्ट हैं, इसलिए मेरा नेटवर्क पैटी के समान है। एक सबनेट को एक नेटवर्क प्रिफिक्स में विभाजित किया जाता है, जैसे 123.45.67.0 और एक सबनेट मास्क।\n\n<b>सबनेट मास्क</b>\n\nसबनेट मास्क यह निर्धारित करते हैं कि आपके आईपी पते का कौन सा हिस्सा नेटवर्क हिस्सा है और कौन सा होस्ट हिस्सा है। \n\nएक साधारण सबनेट मास्क इस तरह दिख सकता है:\n\n<pre>255.255.255.0</pre>\n\n255 हिस्सा वास्तव में हमारी मास्क है। इसे समझने के लिए थोड़ा सहज बनाने के लिए, याद रखें कि हम प्रत्येक ऑक्टेट को 8 बिट के रूप में कैसे संदर्भित करते हैं? कंप्यूटर विज्ञान में एक बिट को बाइनरी रूप में 0 या 1 द्वारा दर्शाया जाता है। जब बाइनरी संख्याएँ उपयोग की जाती हैं, तो 1 का अर्थ है चालू और 0 का अर्थ है बंद। तो 8 0 या 1 का अर्थ क्या है?\n\nGoogle में \"बाइनरी से दशमलव कैलकुलेटर\" में प्रवेश करें और 11111111 को दशमलव रूप में परिवर्तित करें। आपको क्या मिलता है? 255! तो एक ऑक्टेट 0 से 255 तक की श्रेणी होती है। तो अगर हमारा सबनेट मास्क 255.255.255.0 है, और एक आईपी पता 192.168.1.0 है, तो उस सबनेट पर कितने होस्ट हैं? हम सबनेट गणित सबक के उत्तर को पता करेंगे।\n\nइसके अलावा जब हम अपने सबनेट के बारे में बात करते हैं, तो हम सामान्यत: नेटवर्क प्रिफिक्स के बाद सबनेट मास्क द्वारा इसे दर्शाते हैं:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>क्यों?</b>\n\nधरती पर क्यों हम सबनेट बनाते हैं? सबनेटिंग का उपयोग नेटवर्क को खंडित करने और उस नेटवर्क के भीतर ट्रैफिक को नियंत्रित करने के लिए किया जाता है। इसलिए एक सबनेट पर एक होस्ट एक दूसरे सबनेट पर एक होस्ट से संवाद नहीं कर सकता। \n\nलेकिन एक मिनट रुकिए, अगर मैं अन्य होस्टों से जैसे yahoo.com से कनेक्ट करना चाहता हूं? तो आपको सबनेट्स को एक साथ कनेक्ट करने की आवश्यकता है। सबनेट्स को कनेक्ट करने के लिए आपको बस उन होस्टों को खोजना होगा जो एक से अधिक सबनेट से कनेक्ट हैं। उदाहरण के लिए, अगर मेरा होस्ट 192.168.1.129 एक स्थानीय नेटवर्क 192.168.1.129/24 से कनेक्ट है, तो वह उस नेटवर्क पर किसी भी होस्ट तक पहुंच सकता है। इंटरनेट के बाकी होस्टों तक पहुंचने के लिए, इसे राउटर के माध्यम से संवाद करने की आवश्यकता है। पारंपरिक रूप से, ज्यादातर सबनेट मास्क 255.255.255.0 के साथ नेटवर्क में राउटर सामान्यत: पता 1 पर होता है, इसलिए 192.168.1.1। अब उस राउटर के पास एक पोर्ट होगा जो इसे दूसरे सबनेट से जोड़ता है (रूटिंग कोर्स में अधिक है)। कुछ आईपी पते (निजी नेटवर्क) इंटरनेट को दिखाई नहीं देते हैं, और हमारे पास इस तरह की चीजें हैं जैसे एनएटी (इसके बारे में बाद में)।",
          "quizAnswer": "सही",
          "quizQuestion": "सही या गलत, एक सबनेट में एक सबनेट मास्क और नेटवर्क प्रिफिक्स होता है।",
          "slug": "subnets",
          "title": "सबनेट्स"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 3,
          "lessonContent": "ठीक है, हमें पता है कि सबनेट मास्क को हल करने के लिए महत्वपूर्ण है। हमारे सबनेट पर हमें कितने होस्ट हो सकते हैं, यह जानना जरूरी है। तो उसका मतलब क्या होगा? \n\nचलो मान लो कि मेरे पास एक आईपी पता है <b>192.168.1.0</b> और एक सबनेट मास्क है <b>255.255.255.0</b>, अब चलो इन नंबरों को बाइनरी रूप में लाइन अप करते हैं। अब तक इन मानों को डेसिमल से बाइनरी में बदलने के लिए ऑनलाइन कैलकुलेटर का उपयोग करें।\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nआईपी पते को हमारे सबनेट मास्क द्वारा मास्क किया जाता है, जब आप 1 देखते हैं, तो यह मास्क किया जाता है और हम ऐसा करने की कोशिश नहीं करते। तो हमें केवल 00000000 क्षेत्र से होस्ट करने की संभावना है। ध्यान दें कि बाइनरी रूप में 11111111 255 के बराबर होता है, हम 0 को भी एक होस्ट संख्या के रूप में गणना करते हैं, इसलिए 256 संभावित विकल्प हैं। हालांकि, यह दिख सकता है कि हमें 256 संभावित विकल्प हैं, लेकिन हम वास्तव में 2 होस्ट कम कर देते हैं क्योंकि हमें प्रसारण पते और सबनेट पते की गणना करनी होती है, जिससे हमें हमारे सबनेट पर 254 संभावित होस्ट बचते हैं। तो हम जानते हैं कि हमें आईपी पतों के साथ होस्ट हो सकते हैं जिनका पता है 192.168.1.1 - 192.168.1.254।",
          "quizAnswer": "11111111",
          "quizQuestion": "255 का बाइनरी समकक्ष क्या है?",
          "slug": "subnetmath",
          "title": "सबनेट गणित"
        },
        {
          "exercise": "अपने आईपी पते और सबनेट मास्क को देखें और देखें कि आपके सबनेट पर कितने होस्ट हो सकते हैं।",
          "id": 4,
          "lessonContent": "मुझे इस खंड को जोड़ने की नफरत है, वास्तविक दुनिया में आपको सबनेट गणित को हाथ से करने की संभावना नहीं है, हालांकि यदि आप इस पर साक्षात्कार देने जा रहे हैं, तो आपको सबनेटिंग के लिए बाइनरी रूप में परिवर्तित करना और वापस करना कैसे करना है, इसका पता होना चाहिए। भाग्यशाली रूप से कुछ अंकगणित धोखे हैं जिन्हें आप याद कर सकते हैं। \n\nपहले अपनी आधार-2 गणनाएँ याद करें, बस इसे करें:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>दशमलव से बाइनरी चार्ट</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nइस चार्ट के नीचे दी गई बहुत सारी वजहें हैं, यदि आप जानने की इच्छुक हैं कि यह कैसे काम करता है, तो ऑनलाइन बहुत सारे संसाधन हैं।\n\nठीक है, ये याद हैं? चलो तेजी से एक दशमलव से बाइनरी परिवर्तन करें:\n\n<b>192.168.23.43 को बाइनरी में परिवर्तित करें</b>\n\nध्यान रखें: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nहम पहले ऑक्टेट को बाइनरी में परिवर्तित करने के लिए चलेंगे और आप समझेंगे कि बाकी कैसे काम करता है।\n\n<ol>\n<li>क्या आप 192 - 128 कर सकते हैं? हां, तो पहला बिट 1 है</li>\n<li>192 - 128 = 64, चार्ट में अगला संख्या 64 है, क्या आप 64 - 64 कर सकते हैं? हां, तो दूसरा बिट 1 है</li>\n<li>हमें घटाने के लिए संख्याओं की कमी हो गई है, इसलिए हमारा 192 का बाइनरी रूप 11000000 है</li>\n</ol>\n\n<b>बाइनरी 11000000 को दशमलव में परिवर्तित करें</b>\n\nबाइनरी से दशमलव परिवर्तन के लिए आप उन संख्याओं को जो 1 है उनको जोड़ते हैं, इसलिए:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "123 का बाइनरी परिवर्तन क्या है?",
          "slug": "subnettingcheats",
          "title": "सबनेटिंग धोखा"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "CIDR (क्लासलेस इंटर-डोमेन रूटिंग) एक सबनेट मास्क को एक और संक्षिप्त तरीके में प्रस्तुत करने के लिए प्रयोग किया जाता है। आप CIDR नोटेशन में सबनेट्स देख सकते हैं, जहाँ एक सबनेट जैसे 10.42.3.0/255.255.255.0 को 10.42.3.0/24 के रूप में लिखा गया है जो केवल इसका मतलब है कि यह सबनेट प्रिफिक्स और सबनेट मास्क दोनों को शामिल करता है।\n\nध्यान रखें कि एक आईपी पता 4 बाइट या 32 बिट से बना होता है, CIDR नेटवर्क प्रिफिक्स के रूप में कितने बिट का उपयोग किया जाता है इसे दर्शाता है। इसलिए 123.12.24.0/23 का मतलब है कि पहले 23 बिट का उपयोग किया गया है। अच्छा यह क्या मतलब है? इसमें कितने होस्ट्स हैं?\n\nएक सरल ट्रिक है कि आईपी पते के कुल बिट (32) से CIDR पते (23) को घटा देना, ताकि 9 बिट बच जाएं, 2^9 = 512, लेकिन हमें 2 पते हटाने होंगे (सबनेट पता और ब्रॉडकास्ट पता) तो हमारे पास 510 उपयोगी होस्ट्स हैं।",
          "quizAnswer": "",
          "quizQuestion": "कोई प्रश्न नहीं, आगे बढ़ें!",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 6,
          "lessonContent": "हमने पहले ही NAT (नेटवर्क पता अनुवाद) के बारे में बात की थी लेकिन इस पर ध्यान नहीं दिया, जब हम अपने नेटवर्क पर काम कर रहे होते हैं, क्या यह मतलब है कि इंटरनेट हमारा आईपी पता देख सकता है? बिल्कुल नहीं।\n\nNAT एक ऐसी उपकरण को बनाता है जैसे हमारा राउटर इंटरनेट और निजी नेटवर्क के बीच एक मध्यस्थ के रूप में काम करे। इसलिए केवल एक एकल, अद्वितीय आईपी पता की आवश्यकता होती है जो पूरे समूह के कंप्यूटरों को प्रतिनिधित्व करने के लिए है।\n\nNAT को एक बड़े कार्यालय में एक सहायक के रूप में सोचें, अगर कोई आपसे संपर्क करना चाहता है, तो उन्हें केवल पूरे कार्यालय के नंबर का पता होता है, फिर सहायक को आपका एक्सटेंशन नंबर ढूंढना होगा और कॉल आपको फॉरवर्ड करना होगा।\n\n<b>यह कैसे काम करता है?</b>\n \nएक सरल मामला इस तरह दिख सकता है:\n\n<ol>\n<li>पैटी www.google.com से कनेक्ट करना चाहती है, इसलिए उसकी मशीन इस अनुरोध को राउटर के माध्यम से भेजती है</li>\n<li>राउटर उस अनुरोध को लेता है और google.com के साथ अपना कनेक्शन खोलता है, फिर जब यह कनेक्शन बन जाता है, तो वह पैटी का अनुरोध भेजता है</li>\n<li>राउटर पैटी और www.google.com के बीच मध्यस्थ है। Google पैटी के बारे में नहीं जानता है बल्कि उसके लिए केवल राउटर दिखाई देता है।</li>\n</ol>\n\nNAT और पैकेट रूटिंग सामान्य रूप से काफी बुरी हो सकती है, लेकिन हम विशेषताओं में नहीं जाएंगे।",
          "quizAnswer": "NAT",
          "quizQuestion": "इंटरनेट को एक एकल निजी पता प्रतिष्ठित करने के लिए क्या उपयोग किया जाता है?",
          "slug": "natnetworkaddresstranslation",
          "title": "NAT"
        },
        {
          "exercise": "यह देखने के लिए जांच करें कि आपके पास एक IPv6 पता सूचीबद्ध है।",
          "id": 7,
          "lessonContent": "हमने यहाँ-वहाँ IPv6 शब्द सुना है, लेकिन यह क्या है? इंटरनेट से जुड़ने वाले प्रत्येक उपकरण को अपना आईपी पता मिलता है, जो कि एक सीमित संख्या है जिसे हम इस डिजिटल युग में जल्द ही पहुंच रहे हैं। IPv6 को इंटरनेट से अधिक होस्ट को कनेक्ट करने की अनुमति देने के लिए बनाया गया था, यह अधिक आईपी सुधारों के साथ आता है हालांकि, इसका अपनान बहुत धीमा है। यह IPv4 को बदलने के लिए नहीं है, वे एक-दूसरे का पूरक होने के लिए हैं। दो आईपी प्रोटोकॉल बहुत समान हैं और यदि आपको IPv4 पता है तो आप IPv6 को समझेंगे, मुख्य अंतर पते लिखने के तरीके में है। यहाँ एक साधारित IPv6 पता कैसे दिखता है:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "किस आईपी पते का उपयोग किया जाता है ताकि इंटरनेट से जुड़ सकने वाले होस्टों की संख्या बढ़ाई जा सके?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "सबनेटिंग"
    },
    {
      "description": "नेटवर्कों के बीच पैकेट कैसे रूट किए जाते हैं, इसे सीखें!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "इस सबक के लिए कोई व्यायाम नहीं है।",
          "id": 1,
          "lessonContent": "हमने पहले भी इस शब्द 'राउटर' का उपयोग किया है, आशा है कि आप जानते होंगे कि यह क्या है, क्योंकि शायद आपके घर में एक होगा। एक राउटर नेटवर्क पर मशीनों को एक-दूसरे के साथ संचार करने की सुविधा प्रदान करता है साथ ही अन्य नेटवर्कों के साथ। एक सामान्य राउटर पर आपके पास एलएएन पोर्ट्स होंगे, जो आपकी मशीनों को एक ही स्थानीय क्षेत्रीय नेटवर्क से कनेक्ट करने की अनुमति देते हैं और आपके पास इंटरनेट अपलिंक पोर्ट होता है जो आपको इंटरनेट से कनेक्ट करता है, कभी-कभी आप इस पोर्ट को डब्ल्यूएएन के रूप में लेबल किया देखेंगे, क्योंकि यह आपको एक व्यापक नेटवर्क से कनेक्ट कर रहा है। हम किसी भी प्रकार की नेटवर्किंग गतिविधि करते हैं, तो यह राउटर के माध्यम से जाना पड़ता है। राउटर तय करता है कि हमारे नेटवर्क पैकेट कहाँ जाएं और कौन से आएं। यह हमारे पैकेट को एक से अधिक नेटवर्कों के बीच मार्गदर्शन करता है ताकि इसके स्रोत होस्ट से लक्ष्य होस्ट तक पहुंच सके। \n\n<b>राउटर कैसे काम करता है?</b>\n\nरूटिंग को मेल वितरण के रूप में सोचें, हमें एक पता है जिसे हम एक पत्र भेजना चाहते हैं, जब हम इसे डाकघर को भेजते हैं, वे पत्र प्राप्त करते हैं और देखते हैं, ओह यह कैलिफोर्निया जा रहा है, मैं इसे कैलिफोर्निया जाने वाले ट्रक पर रख दूंगा (मुझे सच में नहीं पता कि डाक सिस्टम कैसे काम करता है)। फिर पत्र सैन फ्रांसिस्को भेजा जाता है, सैन फ्रांसिस्को के अंदर विभिन्न ज़िप कोड होते हैं, और फिर उन ज़िप कोड में छोटे पता कोड होते हैं, जब तक आखिरकार कोई व्यक्ति आपके पते पर पत्र पहुंचा सकता है। दूसरी ओर, अगर आप पहले से ही सैन फ्रांसिस्को में रहते हैं और उसी ज़िप कोड में हैं, तो डाक वितरक शायद बिना किसी और को सौंपे बिना यह जान जाएगा कि पत्र को कहाँ भेजना है। \n\nजब हम पैकेट रूट करते हैं, तो वे समान पता \"रूट\" का उपयोग करते हैं, जैसे कि नेटवर्क ए को पहुंचने के लिए, इन पैकेट्स को नेटवर्क बी में भेजें। जब हमारे पास उसके लिए एक रूट सेट नहीं होता है, तो हमारे पैकेट्स का उपयोग किया जाएगा। ये रूट एक रूटिंग टेबल पर सेट होते हैं जिसका हमारे सिस्टम को नेटवर्कों के बीच नेविगेट करने के लिए उपयोग किया जाता है।\n\n<b>हॉप्स</b>\n\nजब पैकेट्स नेटवर्कों के बीच चलते हैं, तो वे हॉप्स में यात्रा करते हैं, एक हॉप वह दूरी है जिसे हम अंदाज़ से मापते हैं जिसे पैकेट को स्रोत से लक्ष्य तक पहुंचने के लिए यात्रा करनी पड़ती है। मान लीजिए मेरे पास होस्ट ए से होस्ट बी को जोड़ने वाले दो राउटर हैं, इसलिए हम कहते हैं कि होस्ट ए और होस्ट बी के बीच दो हॉप्स हैं। प्रत्येक हॉप एक इंटरमीडिएट डिवाइस है जैसे कि राउटर जिन्हें हमें पार करना होता है।\n\n<b>स्विचिंग, रूटिंग और फ्लडिंग के बीच मूल अंतर समझना</b>\nपैकेट स्विचिंग मूल रूप से डेटा प्राप्त करना, प्रसंस्करण करना और लक्ष्य उपकरण तक फॉरवर्ड करना है।\nरूटिंग एक रूटिंग टेबल बनाने की प्रक्रिया है, ताकि हम स्विचिंग बेहतर कर सकें।\nरूटिंग से पहले, फ्लडिंग का उपयोग किया जाता था। अगर एक राउटर को यह पता नहीं है कि पैकेट को किस तरह भेजना है तो हर आने वाले पैकेट को उसे आयातित लिंक के अलावा सभी आउटगोइंग लिंक के माध्यम से भेज दिया जाता था।",
          "quizAnswer": "हॉप्स",
          "quizQuestion": "पैकेट किस दूरी को मापते हैं?",
          "slug": "whatisarouter",
          "title": "राउटर क्या है?"
        },
        {
          "exercise": "अपनी रूटिंग तालिका देखें और देखें कि आपके पैकेट कहां जा सकते हैं।",
          "id": 2,
          "lessonContent": "अपनी मशीन की रूटिंग तालिका देखें:\n\n<pre>\npete@icebox:~$ sudo route -n\nकर्नेल आईपी रूटिंग तालिका\nगंतव्य     गेटवे         जेनमास्क         फ्लैग्स मेट्रिक रेफ    यूज इंटरफेस\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>गंतव्य</b>\n\nपहले फील्ड में, हमारे पास 192.168.224.0 का गंतव्य आईपी पता है, यह कहता है कि जो कोई भी पैकेट इस नेटवर्क को जाने की कोशिश करता है, वह मेरे इथरनेट केबल (eth0) के माध्यम से बाहर जाता है। अगर मैं 192.168.224.5 होता और 192.168.224.7 तक पहुंचना चाहता, तो मैं सीधे नेटवर्क इंटरफेस eth0 का उपयोग करता।\n\nध्यान दें कि हमारे पास <b>0.0.0.0</b> के पते हैं यह यह दर्शाता है कि कोई पता निर्दिष्ट नहीं है या यह अज्ञात है। इसलिए यदि मैं उदाहरण के लिए, आईपी पता 151.123.43.6 पर पैकेट भेजना चाहता, हमारी रूटिंग तालिका नहीं जानता कि वह कहां जाता है, इसलिए यह 0.0.0.0 के रूप में दर्शाता है और फिर हमारा पैकेट गेटवे पर मार्गिक होता है।\n\n<b>गेटवे</b>\n\nअगर हम एक ऐसे पैकेट को भेज रहे हैं जो समान नेटवर्क पर नहीं है, तो यह गेटवे पते पर भेजा जाएगा। जिसे एक दूसरे नेटवर्क के लिए गेटवे के रूप में सही नाम दिया गया है।\n\n<b>जेनमास्क</b>\n\nयह सबनेट मास्क है, जिसका उपयोग किया जाता है कि कौन से आईपी पते किस गंतव्य से मेल खाते हैं।\n\n<b>फ्लैग्स</b>\n\n<ul>\n<li>UG - नेटवर्क ऊपर है और एक गेटवे है</li>\n<li>U - नेटवर्क ऊपर है</li>\n</ul>\n\n<b>इंटरफेस</b>\n\nयह वह इंटरफेस है जिससे हमारा पैकेट बाहर जाएगा, आम तौर पर आपके सिस्टम पर पहला इथरनेट उपकरण के लिए खड़ा होता है।",
          "quizAnswer": "गेटवे",
          "quizQuestion": "हमारी रूटिंग तालिका नहीं जानती है तो पैकेट किसे रूट किया जाता है?",
          "slug": "रूटिंग तालिका",
          "title": "रूटिंग तालिका"
        },
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं।",
          "id": 3,
          "lessonContent": "<b>चलो देखते हैं कि एक पैकेट अपने स्थानीय नेटवर्क के भीतर कैसे यात्रा करता है</b>\n\n<ol>\n<li>पहले स्थानीय मशीन गंतव्य IP पते की तुलना करेगी ताकि यह देख सके कि क्या यह एक ही सबनेट में है यह अपनी सबनेट मास्क देखकर।</li>\n<li>पैकेट भेजे जाते हैं तो उन्हें एक स्रोत MAC पता, गंतव्य MAC पता, स्रोत IP पता और गंतव्य IP पता होना चाहिए, इस समय हमें गंतव्य MAC पता नहीं पता है।</li>\n<li>गंतव्य होस्ट तक पहुंचने के लिए, हम ARP का उपयोग करते हैं ताकि स्थानीय नेटवर्क पर गंतव्य होस्ट के MAC पता प्राप्त करने के लिए एक अनुरोध प्रसारित कर सकें।</li>\n<li>अब पैकेट सफलतापूर्वक भेजा जा सकता है!</li>\n</ol>\n\n<b>चलो देखते हैं कि एक पैकेट अपने नेटवर्क के बाहर कैसे यात्रा करता है</b>\n\n<ol>\n<li>पहले स्थानीय मशीन गंतव्य IP पता की तुलना करेगी, क्योंकि यह हमारे नेटवर्क के बाहर है, इसलिए यह गंतव्य होस्ट का MAC पता नहीं देखता। और हम ARP का उपयोग नहीं कर सकते क्योंकि ARP अनुरोध स्थानीय रूप से कनेक्टेड होस्ट्स को प्रसारित करता है।</li>\n<li>इसलिए हमारा पैकेट अब रूटिंग टेबल पर देखता है, यह गंतव्य IP का पता नहीं जानता है, इसलिए यह इसे डिफ़ॉल्ट गेटवे (एक और राउटर) पर भेजता है। तो अब हमारे पैकेट में हमारा स्रोत IP, गंतव्य IP और स्रोत MAC होता है, हालांकि हमें एक गंतव्य MAC नहीं है। ध्यान रखें MAC पते केवल एक ही नेटवर्क के माध्यम से पहुंचे जाते हैं। तो यह क्या करता है? यह डिफ़ॉल्ट गेटवे के MAC पता प्राप्त करने के लिए ARP अनुरोध भेजता है।</li>\n<li>राउटर पैकेट को देखता है और गंतव्य MAC पता सत्यापित करता है, लेकिन यह अंतिम गंतव्य IP पता नहीं है, इसलिए यह पैकेट को आगे बढ़ाने के लिए एक और IP पते की ओर देखता है जो पैकेट को उसके गंतव्य तक आगे बढ़ाने में मदद कर सकता है। हर बार पैकेट चलता है, पुराने स्रोत और गंतव्य MAC पते को हटाता है और पैकेट को नए स्रोत और गंतव्य MAC पतों के साथ अपडेट करता है।</li>\n<li>एक बार पैकेट को वही नेटवर्क आगे भेजा जाता है, हम अंतिम गंतव्य MAC पता प्राप्त करने के लिए ARP का उपयोग करते हैं</li>\n<li>इस प्रक्रिया के दौरान, हमारा पैकेट स्रोत या गंतव्य IP पता नहीं बदलता।</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "एक IP पते के MAC पता कैसे पाया जाता है?",
          "slug": "pathofapacket",
          "title": "पैकेट का मार्ग"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं।",
          "id": 4,
          "lessonContent": "नेटवर्क पर हर डिवाइस के लिए रूटिंग टेबल पर मैन्युअल रूप से रूट कॉन्फ़िगर करना एक पीड़ा होगी, इसलिए हम उसके बजाय वहाँ रूटिंग प्रोटोकॉल का उपयोग करते हैं। रूटिंग प्रोटोकॉल उन्हें नेटवर्क परिवर्तनों के साथ अनुकूलित करने में मदद करते हैं, यह विभिन्न रूटों के बारे में सीखता है, उन्हें रूटिंग टेबल में बनाता है और फिर हमारे पैकेट्स को उस तरह से रूट करता है। प्राथमिक रूटिंग प्रोटोकॉल प्रकार हैं, दूरी सूचक प्रोटोकॉल और लिंक स्थिति प्रोटोकॉल।\n\n<b>समाप्ति</b>\n\nप्रोटोकॉल के बारे में हम बात करने से पहले, हमें रूटिंग में इस्तेमाल होने वाले एक शब्द के बारे में जानना चाहिए जिसे समाप्ति कहा जाता है। जब रूटिंग प्रोटोकॉल का उपयोग किया जाता है, राउटर अन्य राउटरों के साथ संचार करते हैं ताकि नेटवर्क के बारे में जानकारी एकत्र करें और आपस में जानकारी आदान-प्रदान करें। जब वे एकमत होते हैं कि नेटवर्क कैसा दिखना चाहिए, हर रूटिंग टेबल पूरे नेटवर्क की पूरी टोपोलॉजी को मानचित्रित करता है, इस प्रकार \"समाप्ति\" होती है। जब नेटवर्क टोपोलॉजी में कुछ होता है, तो समाप्ति अस्थायी रूप से टूट जाएगी जब तक सभी राउटर इस परिवर्तन के बारे में जागरूक नहीं हो जाते हैं।",
          "quizAnswer": "समाप्ति",
          "quizQuestion": "जब सभी रूटिंग टेबल नेटवर्क टोपोलॉजी को जानते हैं, तो उसे क्या कहा जाता है?",
          "slug": "रूटिंगप्रोटोकॉल",
          "title": "रूटिंग प्रोटोकॉल"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "दूरी सूचक प्रोटोकॉल नेटवर्क के रास्ते का निर्धारण करते हैं जिसमें एक पैकेट नेटवर्क के अंदर हॉप काउंट का उपयोग करता है। यदि नेटवर्क A 3 हॉप दूर था और नेटवर्क B नेटवर्क A के पास था, तो हम मानते हैं कि यह 4 हॉप दूर होना चाहिए। दूरी सूचक प्रोटोकॉल में, अगला रूट उसी होगा जिसमें सबसे कम हॉप्स होंगे।\n\nदूरी सूचक प्रोटोकॉल छोटे नेटवर्कों के लिए बहुत अच्छे होते हैं, जब नेटवर्क बड़ा होता है तो राउटर्स का मिलाप होने में अधिक समय लगता है क्योंकि यह समय-समय पर पूरे रूटिंग टेबल को हर राउटर को भेजता है। दूरी सूचक प्रोटोकॉल का एक और नुकसान यह है कि यह प्रदर्शनशीलता है, यह हॉप्स में ज्यादा करीबी रूट चुनता है, लेकिन यह हमेशा सबसे अधिक कुशल रूट नहीं चुनता है।\n\nदूरी सूचक प्रोटोकॉल में से एक सामान्य प्रोटोकॉल RIP (रूटिंग सूचना प्रोटोकॉल) है, यह हर 30 सेकंड में रूटिंग टेबल को नेटवर्क के हर राउटर को प्रसारित करता है। एक बड़े नेटवर्क के लिए, इसे कुछ गंभीर शक्ति की आवश्यकता हो सकती है, इस कारण RIP अपनी हॉप काउंट को 15 तक सीमित करता है।",
          "quizAnswer": "असत्य",
          "quizQuestion": "सत्य या असत्य, दूरी सूचक प्रोटोकॉल उस रूट का उपयोग करते हैं जिसमें सबसे कम बैंडविड्थ हो?",
          "slug": "दूरीसूचकप्रोटोकॉल",
          "title": "दूरी सूचक प्रोटोकॉल"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं।",
          "id": 6,
          "lessonContent": "लिंक स्थिति प्रोटोकॉल बड़े पैमाने पर नेटवर्क के लिए बढ़िया हैं, वे दूरी वेक्टर प्रोटोकॉल की तुलना में अधिक जटिल हैं, हालांकि उनकी एक बड़ी फायदा यह है कि वे तेजी से संगत हो सकते हैं, यह इसलिए है क्योंकि रूटिंग टेबल को समय-समय पर पूरी तरह से नहीं भेजते, वे केवल पड़ोसी रूटों को अपडेट करते हैं। वे सबसे कम समय में सबसे छोटा मार्ग पहले की गणना करने के लिए एक अलग एल्गोरिदम का उपयोग करते हैं और एक ग्राफ के रूप में अपने नेटवर्क टोपोलॉजी को निर्माण करते हैं जिससे दिखाया जा सकता है कि कौन-कौन से राउटर अन्य राउटरों से कनेक्टेड हैं।\n\nएक सामान्य लिंक स्थिति प्रोटोकॉल OSPF (ओपन शॉर्टेस्ट पाथ फर्स्ट) में से एक है, यह केवल रूटिंग टेबल को अपडेट करता है अगर नेटवर्क में कोई परिवर्तन हुआ है। इसमें हॉप सीमा नहीं है।",
          "quizAnswer": "OSPF",
          "quizQuestion": "सबसे सामान्य लिंक स्थिति प्रोटोकॉल क्या है?",
          "slug": "linkstateprotocols",
          "title": "लिंक स्थिति प्रोटोकॉल"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं।",
          "id": 7,
          "lessonContent": "हम चर्चा करेंगे आखिरी महत्वपूर्ण प्रोटोकॉल बीजीपी की, बीजीपी मौजूदा रूप से इंटरनेट को कैसे चलाता है। यह ऑटोनोमस सिस्टम्स के बीच में रूटिंग सूचना को एकत्रित और विनिमय करने के लिए उपयोग किया जाता है। ऑटोनोमस सिस्टम को एक इंटरनेट सेवा प्रदाता, एक कंपनी, विश्वविद्यालय, किसी भी संगठन आदि के रूप में सोचें। बिना बीजीपी के, इन सिस्टम्स को पता नहीं होगा कि एक-दूसरे से कैसे बात करना है, वे बस अलग-अलग हो जाएंगे। इन ऑटोनोमस सिस्टम्स के भीतर रूटिंग की बजाय, बीजीपी उनके बीच रूट करता है।\n\nमान लीजिए आप अपने होम नेटवर्क पर हैं और मैं स्टारबक्स से काम कर रहा हूं, मुझे आपसे संवाद करने की इच्छा है, तो मैं एक ईमेल भेजता हूं और नेटवर्क पैकेट स्टारबक्स के नेटवर्क के माध्यम से यात्रा करता है, वहां घूमता है और स्टारबक्स के नेटवर्क में रूटिंग टेबल में जाता है जब तक यह अंततः स्टारबक्स नेटवर्क के सीमा पर पहुंचता है और बॉर्डर गेटवे राउटर को पार करता है। इस राउटर में मेरे पैकेट को स्टारबक्स नेटवर्क छोड़ने और अन्य नेटवर्कों को चलने के लिए सूचना होती है।",
          "quizAnswer": "बीजीपी",
          "quizQuestion": "कौन सा प्रोटोकॉल मुख्य रूप से इंटरनेट काम करता है?",
          "slug": "bgpbordergatewayprotocol",
          "title": "बॉर्डर गेटवे प्रोटोकॉल"
        }
      ],
      "slug": "रूटिंग",
      "title": "रूटिंग"
    },
    {
      "description": "Linux उपकरणों का उपयोग करके नेटवर्क कॉन्फ़िगरेशन के बारे में जानें!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "अपने नेटवर्क इंटरफेस की स्थिति को ऊपर या नीचे बदलने की कोशिश करें और देखें क्या होता है।\n\nक्या आप अपने नेटवर्क इंटरफेस को इफकॉन्फ़िग और आईपी कमांड्स के साथ बदल सकते हैं?",
          "id": 1,
          "lessonContent": "नेटवर्क इंटरफेस कर्नल को सॉफ़्टवेयर साइड ऑफ नेटवर्किंग को हार्डवेयर साइड से कैसे जोड़ता है। हमने पहले से ही इसका एक उदाहरण देख लिया है:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> द इफकॉन्फ़िग कमांड</b>\n\n<b>इफकॉन्फ़िग</b> टूल हमें हमारे नेटवर्क इंटरफेस कॉन्फ़िगर करने की अनुमति देता है, अगर हमारे पास कोई नेटवर्क इंटरफेस सेट नहीं है, तो कर्नल के डिवाइस ड्राइवर्स और नेटवर्क एक दूसरे से कैसे बात करेंगे यह पता नहीं चलेगा। इफकॉन्फ़िग बूटअप पर चलता है और हमारे इंटरफेस को कॉन्फ़िगर करता है कॉन्फ़िग फ़ाइलों के माध्यम से, लेकिन हम इन्हें मैन्युअली भी संशोधित कर सकते हैं। इफकॉन्फ़िग का आउटपुट इंटरफेस का नाम बाएं ओर दाएं ओर विस्तृत जानकारी दिखाता है। आप सबसे अधिक आम तौर पर इंटरफेस नाम देखेंगे eth0 (मशीन में पहला ईथरनेट कार्ड), wlan0 (वायरलेस इंटरफेस), lo (लूपबैक इंटरफेस)। लूपबैक इंटरफेस का उपयोग अपने कंप्यूटर को प्रतिनिधित करने के लिए किया जाता है, यह आपको खुद से लूप कर देता है। यह डीबगिंग या स्थानीय रूप से चल रहे सर्वरों से कनेक्ट करने के लिए अच्छा है।\n\nइंटरफेस की स्थिति, ऊपर या नीचे हो सकती है, जैसा कि आप अनुमान लगा सकते हैं अगर आप चाहते थे कि आप किसी इंटरफेस को \"बंद\" करना चाहते हैं तो आप इसे नीचे सेट कर सकते हैं। इफकॉन्फ़िग के आउटपुट में आपको सबसे अधिक देखने के लिए फ़ील्ड होंगे HWaddr (इंटरफेस का एमएसी पता), इंटरनेट पता (आईपीवी4 पता) और इंटरनेट6 (आईपीवी6 पता)। बेशक आप देख सकते हैं कि सबनेट मास्क और ब्रॉडकास्ट पता भी हैं। आप इंटरफेस जानकारी को /इट्स/नेटवर्क/इंटरफेसेस पर भी देख सकते हैं।\n\n<b>एक इंटरफेस बनाने और उसे ऊपर लाने के लिए</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nयह इथ0 इंटरफेस को एक आईपी पता और नेटमास्क सौंपता है और उसे ऊपर भी कर देता है।\n\n<b>इंटरफेस को ऊपर या नीचे लाने के लिए</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> द आईपी कमांड </b>\n\n<b>आईपी</b> कमांड भी हमें सिस्टम के नेटवर्किंग स्टैक को संशोधित करने की अनुमति देता है। आपके उपयोग करने के वितरण पर निर्भर करता है कि आपको अपने नेटवर्क सेटिंग्स को संशोधित करने का पसंदीदा तरीका हो सकता है।\n\nयहाँ कुछ इसके उपयोग के उदाहरण हैं:\n\n<b>सभी इंटरफेसेस के लिए इंटरफेस जानकारी दिखाने के लिए </b>\n<pre>\n$ ip link show\n</pre>\n\n<b>एक इंटरफेस के सांख्यिकी दिखाने के लिए</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>इंटरफेसेस को आवंटित किए गए आईपी पते दिखाने के लिए</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>इंटरफेस को ऊपर और नीचे लाने के लिए</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>एक आईपी पता को इंटरफेस में जोड़ने के लिए</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "हमारे नेटवर्क इंटरफेस कॉन्फ़िगर करने के लिए कमांड क्या है?",
          "slug": "नेटवर्कइंटरफेस",
          "title": "नेटवर्क इंटरफेस"
        },
        {
          "exercise": "इस सबक के लिए कोई अभ्यास नहीं है लेकिन आप यहाँ चर्चित कमांड्स पर और अधिक जानकारी पढ़ सकते हैं\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "हमने पहले ही रूट कमांड के साथ हमारे रूटिंग टेबल को देखने की चर्चा की है, यदि आप रूट को जोड़ना या हटाना चाहते हैं तो आप ऐसा मैन्युअल रूप से कर सकते हैं।\n\n<b>नया रूट जोड़ें</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>रूट हटाएं</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nआप इन परिवर्तनों को <b>ip</b> कमांड के साथ भी कर सकते हैं:\n\n<b>रूट जोड़ने के लिए</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>रूट हटाने के लिए</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\nया\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "हटाएं",
          "quizQuestion": "रूट हटाने के लिए कमांड फ्लैग क्या है?",
          "slug": "रूट",
          "title": "रूट"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 3,
          "lessonContent": "हमने पहले DHCP पर चर्चा की है और आमतौर पर आपको अपने IP पते, सबनेट मास्क, आदि को स्थिर रूप से सेट करने की आवश्यकता कभी नहीं होगी। इसके बजाय आप DHCP का उपयोग करेंगे! dhclient बूट पर शुरू होता है और dhclient.conf फ़ाइल से नेटवर्क इंटरफेस की सूची प्राप्त करता है। प्रत्येक इंटरफेस को सूचीबद्ध करने के लिए यह DHCP प्रोटोकॉल का उपयोग करने की कोशिश करता है।\n\ndhclient.leases फ़ाइल में, dhclient पुनरारंभों के बीच लीज़ की एक सूची का पता रखता है, dhclient.conf पढ़ने के बाद, dhclient.leases फ़ाइल को पढ़ा जाता है ताकि यह जान सके कि वह किस किस लीज़ को पहले से ही नियत कर चुका है।\n\n<b>एक ताज़ा IP प्राप्त करने के लिए</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "डीएचसीपी क्लाइंट",
          "quizQuestion": "कौन IP पते का नियत करने का प्रयास करता है डीएचसीपी प्रोटोकॉल के साथ?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 4,
          "lessonContent": "बेशक, अगर आप चाहते हैं कि आपके सिस्टम का नेटवर्किंग स्वत: चालू और चल रहा हो, तो उसके लिए पहले से कुछ है। अधिकांश वितरण NetworkManager डेमन का उपयोग करते हैं ताकि वे अपने नेटवर्क को स्वत: से कॉन्फ़िगर कर सकें। \n\nआपको ध्यान देना चाहिए कि यदि आप GUI का उपयोग कर रहे हैं तो अपने डेस्कटॉप टास्कबार पर कहीं एक एप्लेट के रूप में NetworkManager को देखेंगे। जैसा कि आप देख सकते हैं, यह आपके नेटवर्क के हार्डवेयर और कनेक्शन सूचना का प्रबंधन करता है। उदाहरण के लिए, स्टार्टअप पर, NetworkManager नेटवर्क हार्डवेयर सूचना इकट्ठा करेगा, वायरलेस, वायर्ड आदि कनेक्शन्स के लिए खोजेगा और फिर इसे सक्रिय करेगा।\n\nNetworkManager के साथ बातचीत करने के लिए भी कमांड-लाइन टूल हैं:\n\n<b>nm-tool</b>\n\nnm-टूल NetworkManager की स्थिति और इसके डिवाइस की रिपोर्ट करता है\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nState: connected (global)\n\n- Device: eth0  [Wired connection 1] -------------------------------------------\n  Type:              Wired\n  Driver:            pcnet32\n  State:             connected\n  Default:           yes\n  HW Address:        12:3D:45:56:7D:CC\n\n  Capabilities:\n    Carrier Detect:  yes\n\n  Wired Properties\n    Carrier:         on\n\n  IPv4 Settings:\n    Address:         192.168.22.1\n    Prefix:          24 (255.255.255.0)\n    Gateway:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nnmcli कमांड आपको NetworkManager को नियंत्रित और संशोधित करने की अनुमति देता है, अधिक विवरण के लिए मैनपेज देखें।",
          "quizAnswer": "nm-tool",
          "quizQuestion": "नेटवर्क प्रबंधक सूचना देखने के लिए कौन सी कमांड है?",
          "slug": "नेटवर्कमैनेजर",
          "title": "नेटवर्क प्रबंधक"
        },
        {
          "exercise": "नेटवर्क पर कुछ करने से पहले अपने ARP कैश में क्या होता है, इसे देखें।",
          "id": 5,
          "lessonContent": "ARP के साथ MAC पता खोजते समय याद रखें, यह पहले हमारे सिस्टम पर स्थानीय भंडारित ARP कैश की जांच करता है, आप वास्तव में इस कैश को देख सकते हैं:\n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nARP कैश वास्तव में जब एक मशीन बूट करती है, तो खाली होता है, यह पैकेट अन्य होस्ट को भेजे जाने पर भरा जाता है। यदि हम एक ऐसे गंतव्य को पैकेट भेजते हैं जो ARP कैश में नहीं है, तो निम्नलिखित होता है:\n\n<ol>\n<li>स्रोत होस्ट आरपी अनुरोध पैकेट के साथ इथरनेट फ्रेम बनाता है</li>\n<li>स्रोत होस्ट इस फ्रेम को पूरे नेटवर्क में ब्रॉडकास्ट करता है</li>\n<li>अगर नेटवर्क पर किसी होस्ट को सही MAC पता पता है, तो वह एक जवाब पैकेट और फ्रेम भेजेगा जिसमें MAC पता होगा</li>\n<li>स्रोत होस्ट IP से MAC पता मैपिंग को ARP कैश में जोड़ता है और फिर पैकेट भेजने के साथ आगे बढ़ता है</li>\n</ol>\n\nआप अपने ARP कैश को ip कमांड के माध्यम से भी देख सकते हैं:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "अपने ARP कैश को देखने के लिए आप कौन सा कमांड उपयोग कर सकते हैं?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "नेटवर्क कॉन्फ़िग",
      "title": "नेटवर्क कॉन्फ़िगरेशन"
    },
    {
      "description": "मामूली नेटवर्किंग उपकरणों के बारे में सीखें जो आपको समस्याओं का निदान करने और सुलझाने में मदद कर सकते हैं!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 1,
          "lessonContent": "इंटरनेट कंट्रोल संदेश प्रोटोकॉल (ICMP) TCP/IP प्रोटोकॉल सुइट का हिस्सा है, इसका उपयोग अपडेट और त्रुटि संदेश भेजने के लिए किया जाता है और यह नेटवर्क मुद्दों को डिबग करने के लिए एक अत्यंत उपयोगी प्रोटोकॉल है जैसे कि एक विफल पैकेट वितरण।\n\nप्रत्येक ICMP संदेश में एक प्रकार, कोड और चेकसम फ़ील्ड होता है। प्रकार फ़ील्ड ICMP संदेश का प्रकार होता है, कोड एक उप-प्रकार है और संदेश के बारे में अधिक जानकारी देता है और चेकसम संदेश की पूर्णता में किसी भी समस्या का पता लगाने के लिए उपयोग किया जाता है।\n\nचलिए कुछ सामान्य ICMP प्रकारों पर ध्यान देते हैं:\n\n<ul>\n<li>प्रकार 0 - इको प्रतिवाद</li>\n<li>प्रकार 3 - गंतव्य अप्राप्य</li>\n<li>प्रकार 8 - इको अनुरोध</li>\n<li>प्रकार 11 - समय समाप्त</li>\n</ul>\n\nजब एक पैकेट गंतव्य तक नहीं पहुंच सकता है, तो प्रकार 3 ICMP संदेश उत्पन्न होता है, प्रकार 3 के भीतर 16 कोड मान हैं जो और विस्तार से बयान करेंगे कि गंतव्य तक पहुंच क्यों नहीं सकता है:\n\n<ul>\n<li>कोड 0 - नेटवर्क अप्राप्य</li>\n<li>कोड 1 - होस्ट अप्राप्य</li>\netc..etc..\n</ul>\n\nये संदेश हमें कुछ नेटवर्क समस्या सुलझाने के उपकरणों का उपयोग करते समय अधिक समझ में आएँगे।",
          "quizAnswer": "8",
          "quizQuestion": "इको अनुरोध के लिए ICMP प्रकार क्या है?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "एक वेबसाइट पर पिंग करें और जो आप प्राप्त करते हैं, उसे देखें।",
          "id": 2,
          "lessonContent": "सबसे सरल नेटवर्किंग टूलों में से एक <b>पिंग</b>, यह होस्ट तक पैकेट पहुंच पा रहा है या नहीं यह जांचने के लिए उपयोग किया जाता है। यह गंतव्य होस्ट को ICMP इको अनुरोध (प्रकार 8) पैकेट भेजकर काम करता है और एक ICMP इको उत्तर (प्रकार 0) के लिए प्रतीक्षा करता है। पिंग सफल होता है जब एक होस्ट निर्देशित होस्ट से अनुरोध पैकेट भेजता है और लक्षित से एक प्रतिक्रिया प्राप्त करता है। चलिए एक उदाहरण देखते हैं: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) bytes of data.\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nइस उदाहरण में, हम www.google.com तक पहुंच सकते हैं या नहीं यह जांचने के लिए पिंग का उपयोग कर रहे हैं। -c ध्वज (गणना) का उपयोग गणना पूरी होने के बाद इको अनुरोध पैकेट भेजना बंद करने के लिए किया जाता है। \n\nपहला हिस्सा कहता है कि हम 64-बाइट पैकेट भेज रहे हैं 74.125.239.112 (google.com) और बाकी हमें यात्रा का विवरण दिखाते हैं। डिफ़ॉल्ट रूप से यह प्रति सेकंड एक पैकेट भेजता है।\n\n<b>icmp_seq</b>\n\nicmp_seq फ़ील्ड का उपयोग भेजे गए पैकेटों के क्रम संख्या दिखाने के लिए किया जाता है, इसलिए इस मामले में, मैंने 3 पैकेट भेजे और हम देख सकते हैं कि 3 पैकेट वापस आए। यदि आप पिंग करते हैं और आपको कुछ क्रम संख्याएँ गायब मिलती हैं, तो इसका अर्थ है कि कुछ कनेक्टिविटी समस्या हो रही है और आपके सभी पैकेट नहीं जा रहे हैं। यदि क्रम संख्या अव्यवस्थित है, तो आपका कनेक्शन शायद बहुत धीमा है क्योंकि आपके पैकेट डिफ़ॉल्ट एक सेकंड से अधिक हो रहे हैं। \n\n<b>ttl</b>\n\nटाइम टू लिव (ttl) फ़ील्ड एक हॉप काउंटर के रूप में उपयोग किया जाता है, जैसे ही आप हॉप करते हैं, यह गिनती को एक से कम कर देता है और एक बार हॉप काउंटर 0 तक पहुंच जाता है, हमारा पैकेट मर जाता है। यह पैकेट को एक जीवनकाल देने के लिए है, हम नहीं चाहते हैं कि हमारे पैकेट सदैव घूमते रहें।\n\n<b>time</b>\n\nयह राउंडट्रिप समय है जो आपको इको अनुरोध पैकेट भेजने से उत्तर प्राप्त होने में लिया गया।",
          "quizAnswer": "मिलीसेकंड",
          "quizQuestion": "राउंडट्रिप समय की मात्रक क्या है?",
          "slug": "पिंग",
          "title": "पिंग"
        },
        {
          "exercise": "अपनी मशीन पर ट्रेसराउट कमांड चलाएं और उत्पादन देखें।",
          "id": 3,
          "lessonContent": "ट्रेसराउट कमांड का उपयोग पैकेट कैसे रूट किए जा रहे हैं देखने के लिए किया जाता है। यह पैकेट भेजकर काम करता है जिसमें बढ़ते TTL मान होते हैं, 1 से शुरू होते हैं। इसलिए पहला राउटर पैकेट प्राप्त करता है, और यह TTL मान को एक से कम कर देता है, इस प्रकार पैकेट को ड्रॉप कर देता है। राउटर हमें एक ICMP समय सीमा समाप्त हुआ संदेश भेजता है। और फिर अगला पैकेट TTL 2 का होता है, इसलिए यह पहले राउटर को पार कर जाता है, लेकिन जब यह दूसरे राउटर तक पहुंचता है तो TTL 0 होता है और यह एक और ICMP समय सीमा समाप्त हुआ संदेश वापस करता है। ट्रेसराउट इस प्रकार काम करता है क्योंकि जैसे ही यह पैकेट भेजता है और ड्रॉप करता है, यह पैकेट जो रूट करता है उसकी सूची बनाता है, जब तक यह अंतिम लक्ष्य तक पहुंचता है और एक ICMP इको उत्तर संदेश प्राप्त करता है। \n\nयहाँ एक छोटा सा ट्रेसराउट स्निपेट है: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute to google.com (216.58.216.174), 30 hops max, 60 byte packets                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nप्रत्येक पंक्ति मेरे और मेरे लक्ष्य के बीच एक राउटर या मशीन है। यह लक्ष्य का नाम और इसका आईपी पता दिखाता है और आखिरी तीन स्तंभ एक पैकेट के लिए उस राउटर तक पहुंचने का राउंड-ट्रिप समय का संबंध दिखाते हैं। डिफ़ॉल्ट रूप से, हम मार्ग पर तीन पैकेट भेजते हैं।",
          "quizAnswer": "टीटीएल",
          "quizQuestion": "नेटवर्क के रूट करते समय क्या एक से कम किया जाता है?",
          "slug": "ट्रेसराउट",
          "title": "ट्रेसराउट"
        },
        {
          "exercise": "नेटस्टैट के मैनपेज देखें और उसमें उपलब्ध सभी विशेषताएँ सीखें।",
          "id": 4,
          "lessonContent": "<b>वेल नोउन पोर्ट्स</b>\n\nहमने अपनी मशीन के माध्यम से पोर्ट के माध्यम से डेटा प्रेषण पर चर्चा की है, चलो कुछ वेल नोउन पोर्ट्स देखते हैं।\n\nआप <b>/etc/services</b> फ़ाइल देखकर वेल-नोउन पोर्ट्स की सूची प्राप्त कर सकते हैं:\n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..आदि..\n</pre>\n\nपहला स्तंभ सेवा का नाम है, फिर पोर्ट नंबर और परिवहन परत प्रोटोकॉल है।\n\n<b>नेटस्टैट</b>\n\nआपके नेटवर्क के बारे में विस्तृत जानकारी प्राप्त करने के लिए एक अत्यंत उपयोगी उपकरण है <b>नेटस्टैट</b>। नेटस्टैट विभिन्न नेटवर्क संबंधित जानकारी जैसे नेटवर्क कनेक्शन, रूटिंग टेबल, नेटवर्क इंटरफेस के बारे में जानकारी दिखाता है, यह नेटवर्किंग उपकरणों का स्विस आर्मी चाकू है। हम अधिकांश रूप से एक विशेषता पर ध्यान केंद्रित करेंगे जिसका नेटस्टैट के पास है और वह है नेटवर्क कनेक्शन की स्थिति। जब हम एक उदाहरण देखने से पहले, चलो सॉकेट्स और पोर्ट्स के बारे में बात करते हैं। एक सॉकेट एक इंटरफेस है जो कार्यक्रमों को डेटा भेजने और प्राप्त करने की अनुमति देता है जबकि एक पोर्ट का उपयोग इसकी पहचान करने के लिए किया जाता है कि कौन सी अनुप्रयोग डेटा भेजेगा या प्राप्त करेगा। सॉकेट पता आईपी पता और पोर्ट का संयोजन है। हर होस्ट और गंतव्य के बीच कनेक्शन के लिए एक अद्वितीय सॉकेट की आवश्यकता है। उदाहरण के लिए, HTTP एक सेवा है जो पोर्ट 80 पर चलती है, हालांकि हमारे पास कई HTTP कनेक्शन हो सकते हैं और प्रत्येक कनेक्शन को बनाए रखने के लिए प्रत्येक कनेक्शन के लिए एक सॉकेट बनाया जाता है।\n\n<pre>\npete@icebox:~$ netstat -at\nसक्रिय इंटरनेट कनेक्शन (सर्वर और स्थापित)\nProto Recv-Q Send-Q Local Address           Foreign Address         State      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nनेटस्टैट -a कमांड नेटवर्क कनेक्शन के लिए सुनने और सुनाने वाले सॉकेट्स दिखाता है, -t फ्लैग केवल tcp कनेक्शन दिखाता है।\n\nस्तंभ निम्नलिखित हैं बाएं से दाएं:\n\n<ul>\n<li>Proto: प्रोटोकॉल का उपयोग, TCP या UDP।</li>\n<li>Recv-Q: प्राप्त करने के लिए कतारबद्ध डेटा</li>\n<li>Send-Q: भेजने के लिए कतारबद्ध डेटा</li>\n<li>Local Address: स्थानीय जुड़े होस्ट</li>\n<li>Foreign Address: दूरस्थ जुड़े होस्ट</li>\n<li>State: सॉकेट की स्थिति</li>\n</ul>\n\nसॉकेट स्थितियों की सूची के लिए मैनपेज देखें, लेकिन यहाँ कुछ हैं:\n\n<ul>\n<li>सुन रहा है: सॉकेट आउटगोइंग कनेक्शन के लिए सुन रहा है, याद रखें जब हम एक TCP कनेक्शन बनाते हैं तो हमारे गंतव्य को हमें सुनने के लिए होना चाहिए पहले हम कनेक्ट कर सकते हैं।</li>\n<li>SYN_SENT: सॉकेट सक्रिय रूप से कनेक्शन स्थापित करने का प्रयास कर रहा है।</li>\n<li>स्थापित: सॉकेट में स्थापित कनेक्शन है</li>\n<li>CLOSE_WAIT: दूरस्थ होस्ट बंद हो गया है और हम सॉकेट को बंद होने का इंतजार कर रहे हैं</li>\n<li>TIME_WAIT: सॉकेट बंद करने के बाद नेटवर्क में अब भी पैकेट्स को हैंडल करने के लिए इंतजार कर रहा है</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "HTTPS के लिए कौन सा पोर्ट उपयोग किया जाता है?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "वायरशार्क टूल डाउनलोड और इंस्टॉल करें और इंटरफेस के साथ खेलें।",
          "id": 5,
          "lessonContent": "पैकेट विश्लेषण का विषय एक पूरे कोर्स को भर सकता है और इस पर कई किताबें लिखी गई हैं। हालांकि, आज हम केवल मूल बातें सीखेंगे। दो बहुत ही लोकप्रिय पैकेट विश्लेषक हैं, वायरशार्क और tcpdump। ये उपकरण आपके नेटवर्क इंटरफेस को स्कैन करते हैं, पैकेट गतिविधि को कैप्चर करते हैं, पैकेजों को विश्लेषित करते हैं और हमें दिखाने के लिए जानकारी उत्पन्न करते हैं। ये हमें नेटवर्क विश्लेषण के विस्तृत अंश में जाने की अनुमति देते हैं और लो लेवल की चीजों में जाने की अनुमति देते हैं। हम tcpdump का उपयोग करेंगे क्योंकि इसमें एक सरल इंटरफेस है, हालांकि अगर आप अपने टूलबेल्ट के लिए पैकेट विश्लेषण करना चाहें तो मैं वायरशार्क की ओर देखने की सिफारिश करूँगा।\n\n<b>tcpdump को इंस्टॉल करें</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>इंटरफेस पर पैकेट डेटा कैप्चर करें</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 3, length 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 3, length 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 4, length 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 4, length 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 5, length 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 5, length 64\n11:28:30.674953 ARP, Request who-has 172.254.1.0 tell ThePickleParty.lan, length 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, length 306\n</pre>\n\nजब आप पैकेट कैप्चर चलाते हैं तो आपको बहुत कुछ होते हुए देखने को मिलेगा, यह उम्मीद की जा सकती है कि पिछली ओर बहुत सारी नेटवर्क गतिविधि हो रही है। मेरे ऊपर के उदाहरण में, मैंने केवल अपने कैप्चर का एक छोटा सा टुकड़ा लिया है विशेष रूप से जब मैंने व्व्व.गूगल.कॉम पर पिंग करने का निर्णय लिया।\n\n<b>आउटपुट को समझना</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n</pre>\n\n<ul>\n<li>पहला फ़ील्ड नेटवर्क गतिविधि का टाइमस्टैम्प है</li>\n<li>आईपी, इसमें प्रोटोकॉल जानकारी होती है</li>\n<li>अगले, आप स्रोत और गंतव्य पता देखेंगे: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, यह TCP पैकेट की शुरुआती और समाप्ति क्रमांक है</li>\n<li>लंबाई, बाइट में लंबाई</li>\n</ul>\n\nहमारे tcpdump आउटपुट से देखें, हम www.google.com पर एक ICMP इको अनुरोध पैकेट भेज रहे हैं और उसका जवाब प्राप्त कर रहे हैं! यह भी ध्यान दें कि विभिन्न पैकेट्स विभिन्न जानकारी उत्पन्न करेंगे, उनके बारे में जानने के लिए मैनपेज का संदर्भ देखें।\n\n<b>tcpdump आउटपुट को फ़ाइल में लिखना</b>\n\n<pre>\n$ sudo tcpdump -w /कोई/फ़ाइल\n</pre>\n\nकुछ अंतिम विचार: हमने पैकेट विश्लेषण के विषय की सतह ही छू ली है। आप देख सकते हैं कि आप कितना देख सकते हैं और हमने हेक्स और एएससी आउटपुट के साथ और गहराई से जाने के बारे में अभी तक नहीं छूआ है। पैकेट विश्लेषकों के बारे में और अधिक सीखने के लिए बहुत सारे संसाधन ऑनलाइन हैं और मैं आपको उन्हें खोजने की प्रेरणा देता हूँ!",
          "quizAnswer": "-i",
          "quizQuestion": "tcpdump के साथ एक विशिष्ट इंटरफेस को कैप्चर करने के लिए झंडा क्या है?",
          "slug": "packetanalysis",
          "title": "पैकेट विश्लेषण"
        }
      ],
      "slug": "नेटवर्कसमस्यासुलझाना",
      "title": "समस्या सुलझाना"
    },
    {
      "description": "DNS के बारे में सब कुछ और भी जो आप जानना चाहते थे।",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं है।",
          "id": 1,
          "lessonContent": "यह सोचें कि अगर हर बार जब आप Google पर खोज करना चाहते हैं तो आपको www.google.com की बजाय http://192.78.12.4 टाइप करना पड़ता। अच्छा, DNS (\"डोमेन नाम प्रणाली\") के बिना ऐसा ही होता। निचले स्तर के नेटवर्किंग केवल मूल आईपी पता को पहचानने के लिए समझता है। DNS हमें मनुष्यों को वेबसाइटों और होस्ट का नाम याद रखने की अनुमति देता है बिना किसी आईपी पते के। यह इंटरनेट के लिए एक संपर्क सूची की तरह है। अगर आप किसी का नाम जानते हैं लेकिन उनका फोन नंबर नहीं जानते, तो आप बस अपने संपर्क सूची में देख सकते हैं।\n\nDNS मौलिक रूप से एक वितरित होस्टनाम से आईपी पतियों का डेटाबेस है, हम अपने डेटाबेस का प्रबंधन करते हैं ताकि लोग हमारी साइट/डोमेन तक पहुंच सकें, और कहीं और कोई दूसरा व्यक्ति अपने डेटाबेस का प्रबंधन कर रहा है ताकि दूसरे लोग उनके डोमेन तक पहुंच सकें। फिर ये डोमेन एक दूसरे से बात कर सकते हैं और इंटरनेट की एक विशाल संपर्क सूची बना सकते हैं।\n\nइस पाठ्यक्रम में, हम DNS के कुछ मूल तत्वों पर चर्चा करेंगे, लेकिन ध्यान दें कि DNS एक व्यापक विषय है और अगर आप वास्तव में इसके साथ गहराई से जानना चाहते हैं, तो आपको कुछ अतिरिक्त अनुसंधान करने की आवश्यकता होगी।",
          "quizAnswer": "गलत",
          "quizQuestion": "सही या गलत, DNS हमें होस्टनाम के लिए MAC पते खोजने में मदद करता है?",
          "slug": "whatisdns",
          "title": "DNS क्या है?"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 2,
          "lessonContent": "इंटरनेट का DNS डेटाबेस साइट्स और संगठनों पर निर्भर करता है जो उस डेटाबेस का हिस्सा प्रदान करते हैं। उसे करने के लिए, उन्हें चाहिए:\n\n<b>नाम सर्वर</b>\n\nहम DNS को \"नाम सर्वर\" के माध्यम से सेटअप करते हैं, नाम सर्वर हमारी DNS सेटिंग्स और कॉन्फ़िगरेशन लोड करते हैं और क्लाइंट्स या अन्य सर्वरों से किसी भी प्रश्न का उत्तर देते हैं जो जानना चाहते हैं कि \"गूगल कौन है?\"। यदि नाम सर्वर उस प्रश्न का उत्तर नहीं जानता है, तो वह अन्य नाम सर्वरों को अनुरोध को दूसरे नाम सर्वरों पर पुनर्निर्देशित करेगा। नाम सर्वर \"आधिकारिक\" हो सकते हैं, जिसका अर्थ है कि वे वास्तविक DNS रिकॉर्ड्स को धारण करते हैं जिनकी आप खोज रहे हैं, या \"पुनरावृत्तिक\" हो सकते हैं जिसका अर्थ है कि वे अन्य सर्वरों से पूछेंगे और वे सर्वर अन्य सर्वरों से पूछेंगे जब तक वे एक आधिकारिक सर्वर नहीं मिल जाते जिसमें DNS रिकॉर्ड्स होते हैं। पुनरावृत्तिक सर्वरों में हमें चाहिए जानकारी को कैश किया जा सकता है बजाय एक आधिकारिक सर्वर तक पहुंचने की।\n\n<b>ज़ोन फ़ाइल</b>\n\nनाम सर्वर के अंदर कुछ ज़ोन फ़ाइल्स रहती हैं। ज़ोन फ़ाइल्स वहाँ जानकारी को कैसे रखती हैं जो डोमेन के बारे में है या जिसे वह नहीं जानता है कैसे पहुंचा जाए।\n\n<b>संसाधन रिकॉर्ड्स</b>\n\nएक ज़ोन फ़ाइल संसाधन रिकॉर्ड्स के एंट्री से बनी होती है। प्रत्येक पंक्ति एक रिकॉर्ड है और होस्ट्स, नेम सर्वर्स, अन्य संसाधनों आदि के बारे में जानकारी शामिल है। फ़ील्ड निम्नलिखित होते हैं:\n\n<ul>\n<li>रिकॉर्ड नाम</li>\n<li>TTL - रिकॉर्ड को हम कितने समय तक छोड़ देंगे और एक नया प्राप्त करेंगे, DNS में TTL को समय द्वारा दर्शाया जाता है, इसलिए रिकॉर्ड्स का एक घंटे का TTL हो सकता है। हम इसे इसलिए करते हैं क्योंकि इंटरनेट लगातार बदल रहा है, एक मिनट में एक होस्ट को X आईपी पते से मैप किया जा सकता है फिर अगले में Y आईपी पता हो सकता है</li>\n<li>क्लास - रिकॉर्ड जानकारी का नेमस्पेस, इंटरनेट के लिए सबसे आम IN का उपयोग किया जाता है</li>\n<li>प्रकार - रिकॉर्ड डेटा में संग्रहित जानकारी का प्रकार। हम रिकॉर्ड प्रकारों में नहीं जाएंगे, लेकिन आपने सामान्य रूप से देखे होंगे जैसे A आईपी पते के लिए, MX या मेल एक्सचेंजर आदि।</li>\n<li>डेटा - यह फ़ील्ड एक आईपी पता या कुछ और जो रिकॉर्ड प्रकार पर निर्भर करता है, उसमें शामिल हो सकता है।</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "मेल एक्सचेंजर्स के लिए कौन सा संसाधन रिकॉर्ड प्रकार उपयोग किया जाता है?",
          "slug": "dnscomponents",
          "title": "DNS Components"
        },
        {
          "exercise": "इस सबक के लिए कोई व्यायाम नहीं है।",
          "id": 3,
          "lessonContent": "चलो एक उदाहरण देखते हैं कि आपका होस्ट DNS के साथ एक डोमेन (catzontheinterwebz.com) को कैसे खोजता है। मौलिक रूप से, हम नीचे की ओर जाते हैं जब तक हम उस डोमेन के बारे में जानकारी रखने वाले DNS सर्वर तक नहीं पहुंच जाते।\n\n<b>स्थानीय DNS सर्वर</b>\n\nसबसे पहले हमारा होस्ट पूछता है, \"catzontheinterwebz.com कहाँ है?\", हमारा स्थानीय DNS सर्वर नहीं जानता है इसलिए वह ऊपर से शुरू होकर रूट सर्वरों से पूछने जाता है। ध्यान रखें कि हमारा होस्ट catzontheinterwebz.com को सीधे खोजने के लिए ये अनुरोध नहीं कर रहा है, अधिकांश उपयोगकर्ता अपने आईएसपी के द्वारा प्रदान किए गए एक रिकर्सिव DNS सर्वर से बात करते हैं और उस सर्वर को फिर catzontheinterwebz.com की स्थान खोजने के लिए काम मिलता है।\n\n<b>रूट सर्वर</b>\n\nइंटरनेट के लिए 13 रूट सर्वर हैं, वे दुनिया भर में मिरर और वितरित हैं ताकि वे इंटरनेट के DNS अनुरोधों को संभाल सकें, इसलिए वास्तव में सैकड़ों सर्वर हैं जो काम कर रहे हैं, वे विभिन्न संगठनों द्वारा नियंत्रित हैं और उनमें टॉप-लेवल डोमेन के बारे में जानकारी है। टॉप-लेवल डोमेन वे हैं जिन्हें आप .org, .com, .net, आदि पतों के रूप में जानते हैं। इसलिए रूट सर्वर को नहीं पता है कि catzontheinterwebz.com कहाँ है, इसलिए वह हमें उस आईपी पते पर .com टॉप-लेवल डोमेन DNS सर्वर से पूछने के लिए कहता है।\n\n<b>टॉप-लेवल डोमेन</b>\n\nअब हम उस नाम सर्वर को एक और अनुरोध भेजते हैं जो \".com\" पतों के बारे में जानकारी रखता है और पूछते हैं कि क्या उसे पता है कि catzontheinterwebz.com कहाँ है? TLD के पास catzontheinterwebz.com नहीं है, लेकिन उसे catzontheinterwebz.com के लिए नाम सर्वर के लिए एक रिकॉर्ड दिखाई देता है। इसलिए वह हमें इस नाम सर्वर का आईपी पता देता है और हमें वहाँ देखने के लिए कहता है।\n\n<b>अधिकारिक DNS सर्वर</b>\n\nअब हम उस DNS सर्वर को अंतिम अनुरोध भेजते हैं जिसके पास हमें चाहिए रिकॉर्ड है। नाम सर्वर देखता है कि उसके पास catzontheinterwebz.com के लिए एक ज़ोन फ़ाइल है और इस होस्ट के लिए 'www' के लिए एक संसाधन रिकॉर्ड है। फिर वह हमें इस होस्ट का आईपी पता देता है और हम अंततः इंटरनेट पर कुछ बिल्लियों को देख सकते हैं।",
          "quizAnswer": "TLD",
          "quizQuestion": ".com, .net, .org, आदि पतों के नाम सर्वरों के लिए शब्दक्षेप क्या है?",
          "slug": "dnsprocess",
          "title": "DNS प्रक्रिया"
        },
        {
          "exercise": "इस पाठ के लिए कोई व्यायाम नहीं है।",
          "id": 4,
          "lessonContent": "<p>हमारी मशीन वास्तव में DNS को क्वेरी करने से पहले, पहले हमारी मशीनों पर स्थानीय रूप से देखती है। </p><br><p><b>/etc/hosts</b></p><p>/etc/hosts फ़ाइल में कुछ होस्टनाम को आईपी पतों के मैपिंग होती है। फ़ील्ड्स बहुत ही स्वयंसमझी हैं, एक आईपी पते के लिए एक होस्टनाम है और फिर होस्ट के लिए कोई उपनाम है। </p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>आप इस फ़ाइल में डिफ़ॉल्ट रूप से अपना localhost पता देखेंगे। आप /etc/hosts.deny या /etc/hosts.allow फ़ाइलें संशोधित करके होस्ट्स तक पहुंच का प्रबंधन कर सकते हैं। हालांकि, यदि आप सुरक्षा संवेदनशील हैं, तो यह वास्तव में उस तरीके का नहीं है और आपको अपने फ़ायरवॉल नियमों को संशोधित करना चाहिए। </p><p>चलिए /etc/hosts का एक मजेदार उदाहरण देखते हैं। फ़ाइल को संशोधित करें और नीचे एक लाइन जोड़ें:</p><pre>123.45.6.7  www.google.com</pre><p>फ़ाइल को सहेजें और अब www.google.com पर जाएं। क्या समस्याएँ हैं? अच्छा वह क्योंकि हमने अभी बिल्कुल गलत आईपी पते को www.google.com से मैप कर दिया है। हमारे होस्ट्स पहले स्थानीय रूप से आईपी पते की मैपिंग के लिए देखते हैं, वह कभी भी google.com को खोजने के लिए DNS तक नहीं पहुंचता। </p><p><b>/etc/resolv.conf</b></p><p>पारंपरिक रूप से, हमने DNS नेम सर्वर्स को अधिक दक्ष खोज के लिए /etc/resolv.conf फ़ाइल का उपयोग किया है, हालांकि DNS में की गई सुधारों के साथ यह फ़ाइल अक्सर अप्रासंगिक होती है, वास्तव में, आप मेरे नीचे उदाहरण में देख सकते हैं कि /etc/resolv.conf मैन्युअल रूप से प्रबंधित नहीं है। DNS नेम सर्वर मैपिंग प्रबंधित करने के लिए अपने वितरण विशिष्ट सेटिंग्स का संदर्भ दें।</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "हमारी मशीनों पर होस्टनाम को आईपी पतों में मैप करने के लिए कौन सी फ़ाइल का उपयोग किया जाता है?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "इस पाठ के लिए कोई अभ्यास नहीं।",
          "id": 5,
          "lessonContent": "हम एक DNS सर्वर सेटअप के माध्यम से नहीं जाएंगे, क्योंकि यह काफी लंबा ट्यूटोरियल होगा। इसके बजाय, यहां लिनक्स के साथ उपयोग करने के लिए प्रसिद्ध DNS सर्वरों की एक तुलना सूची है।\n\n<b>BIND</b>\n\nइंटरनेट पर सबसे लोकप्रिय DNS सर्वर, यह लिनक्स वितरण के साथ उपयोग किया जाने वाला मानक है। यह मूल रूप से कैलिफोर्निया विश्वविद्यालय में विकसित किया गया था, इसलिए इसका नाम BIND (बर्कले इंटरनेट नेम डोमेन) है। यदि आप पूर्ण विशेषता और लचीलाई की आवश्यकता है, तो BIND के साथ गलत नहीं जा सकते।\n\n<b>DNSmasq</b>\n\nBIND से काफी हल्का है और अधिक कॉन्फ़िगर करना आसान है। यदि आप सरलता चाहते हैं और BIND के सभी घंटों और सीटियों की आवश्यकता नहीं है, तो DNSmasq का उपयोग करें। यह आपको DHCP और DNS सेटअप करने के लिए सभी उपकरण प्रदान करता है, एक छोटे नेटवर्क के लिए सिफारिश की जाती है।\n\n<b>PowerDNS</b>\n\nपूर्ण विशेषता और BIND के समान, यह आपको विकल्पों के साथ थोड़ी और लचीलाई प्रदान करता है। यह MySQL, PostgreSQL आदि जैसे कई डेटाबेस से जानकारी पढ़ता है, जिससे प्रशासन को आसान बनाया जा सकता है। बस इसलिए कि BIND हमारे काम का तरीका रहा है, इसका यह मतलब नहीं है कि यह ऐसा ही रहना चाहिए।\n\nयह पूरी सूची नहीं है, लेकिन यह आपको एक विचार देना चाहिए कि अगर आप अपना खुद का DNS सर्वर सेटअप कर रहे हैं तो कहाँ देखना चाहिए।",
          "quizAnswer": "BIND",
          "quizQuestion": "लिनक्स के लिए डी फैक्टो DNS सर्वर क्या है?",
          "slug": "dnssetup",
          "title": "DNS सेटअप"
        },
        {
          "exercise": "dig के मैनपेज पर पढ़ाई करें।",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\n\"नाम सर्वर लुकअप\" टूल रिसोर्स रिकॉर्ड के बारे में जानकारी प्राप्त करने के लिए नाम सर्वरों का प्रश्न करने के लिए प्रयोग किया जाता है। चलो देखते हैं कि google.com के नाम सर्वर कहाँ है:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nNon-authoritative answer:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (डोमेन इनफार्मेशन ग्रोपर) DNS नाम सर्वरों के बारे में जानकारी प्राप्त करने के लिए एक शक्तिशाली टूल है, यह nslookup से अधिक लचीला है और DNS समस्याओं के खोजने के लिए बहुत अच्छा है।\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; QUESTION SECTION:\n;www.google.com.                        IN      A\n\n;; ANSWER SECTION:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Query time: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; WHEN: Sun Feb 07 10:14:00 PST 2016\n;; MSG SIZE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "DNS नाम सर्वरों के बारे में विस्तृत जानकारी प्राप्त करने के लिए कौन सा टूल प्रयोग किया जाता है?",
          "slug": "dnstools",
          "title": "DNS टूल्स"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "सामग्री",
      "exerciseAndQuiz": "अभ्यास और क्विज़"
    },
    "exerciseBox": {
      "exercise": "अभ्यास"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Linux के विश्व में पहले कदम रखने में कितनी सहायता की है, उसके लिए एक नया जीवन LinuxJourney के लिए।",
      "title": "Linux की शक्ति को अनलॉक करें"
    },
    "navbar": {
      "home": "होम",
      "language": "भाषा",
      "lessons": "पाठ्यक्रम",
      "resources": "साधन",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "अध्यायों पर वापस जाएं",
      "checkAnswer": "जवाब जांचें",
      "correctAnswer": "सही उत्तर: ",
      "nextLesson": "अगला पाठ",
      "placeholderAnswer": "यहाँ अपना उत्तर लिखें",
      "quiz": "क्विज़",
      "showCorrectAnswer": "सही उत्तर दिखाएं"
    },
    "resources": {
      "data": [
        {
          "description": "शुरुआत के लिए एक कदम-से-कदम मार्गदर्शिका जो टर्मिनल का इतिहास और मूल कमांडों की समझ कराती है",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "आधिकारिक Ubuntu ट्यूटोरियल"
        },
        {
          "description": "टर्मिनल काम करने का स्पष्ट अवलोकन, कमांड चलाने और फाइल सिस्टम में नेविगेट करने के लिए।",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "सबसे अधिक सिफारिश की गई पुस्तकों में से एक!",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "कैसे Linux काम करता है"
        },
        {
          "description": "प्रत्येक सिसएडमिन के लिए अत्यंत व्यापक पुस्तक।",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "UNIX और Linux सिस्टम प्रशासन हैंडबुक"
        },
        {
          "description": "शैल स्क्रिप्टिंग के लिए महान व्यापक मार्गदर्शिका।",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Linux कमांड बाइबिल"
        },
        {
          "description": "गंभीर Linux उपयोगकर्ताओं के लिए, कर्नेल प्रोग्रामिंग में शुरुआत के लिए महान।",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "The Linux Programming Interface: एक Linux और UNIX सिस्टम"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "अपने Linux ज्ञान को गहराई देने के लिए चुने गए पुस्तकें, ट्यूटोरियल और उपकरण खोजें।",
        "title": "साधन"
      },
      "title": "साधन"
    }
  }
}