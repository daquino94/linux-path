{
  "chapters": [
    {
      "description": "Qu'est-ce que Linux ? Commencez par choisir une distribution et l'installer.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Lecture supplémentaire:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "Hey rookie! Alors vous avez décidé de plonger dans ce merveilleux monde connu sous le nom de Linux ? Eh bien, vous feriez mieux de vous attacher, car cela va être un long et difficile chemin. Je m'appelle Penguin Pete et je suis là pour vous guider dans ce voyage. Commençons par un peu d'histoire sur Linux. \n\nPour comprendre comment Linux est né, revenons au début, en 1969, lorsque Ken Thompson et Dennis Ritchie des laboratoires Bell ont développé le système d'exploitation UNIX. Il a ensuite été réécrit en C pour le rendre plus portable et est finalement devenu un système d'exploitation largement utilisé. \n\nUne décennie plus tard, Richard Stallman a commencé à travailler sur le projet GNU (GNU n'est pas UNIX), le noyau GNU appelé Hurd, qui malheureusement n'a jamais été achevé. La licence publique générale GNU (GPL), une licence de logiciel libre, a également été créée à la suite de cela.\n\nLe noyau est la pièce la plus importante du système d'exploitation. Il permet au matériel de communiquer avec le logiciel. Il fait également beaucoup d'autres choses, mais nous creuserons cela dans un cours différent. Pour l'instant, sachez simplement que le noyau contrôle à peu près tout ce qui se passe sur votre système. \n\nPendant ce temps, d'autres efforts tels que BSD, MINIX, etc. ont été développés pour être des systèmes de type UNIX. Cependant, une chose que tous ces systèmes de type UNIX avaient en commun était le manque d'un noyau unifié. \n\nPuis, en 1991, un jeune homme nommé Linus Torvalds a commencé à développer ce que nous connaissons aujourd'hui sous le nom de noyau Linux.",
          "quizAnswer": "Linus Torvalds",
          "quizQuestion": "Qui a développé le noyau Linux ?",
          "slug": "histoirelinux",
          "title": "Histoire"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 2,
          "lessonContent": "Dans la leçon précédente, nous avons appris sur le noyau Linux qui alimente des millions d'appareils chaque jour. Avant de continuer, il est important de noter que le terme Linux est en réalité assez trompeur, car il fait référence au noyau Linux. Cependant, de nombreuses distributions utilisent le noyau Linux et sont donc communément connues sous le nom de systèmes d'exploitation Linux. \n\nUn système Linux est divisé en trois parties principales :\n\n<ul>\n<li>Matériel - Cela inclut tout le matériel sur lequel votre système fonctionne ainsi que la mémoire, le CPU, les disques, etc.</li>\n<li>Noyau Linux - Comme nous l'avons discuté précédemment, le noyau est le cœur du système d'exploitation. Il gère le matériel et lui indique comment interagir avec le système.</li>\n<li>Espace Utilisateur - C'est ici que les utilisateurs comme vous interagiront directement avec le système.</li>\n</ul>\n\nLa première étape que nous devrons suivre est d'installer Linux sur votre machine. Vous avez de nombreuses options parmi lesquelles choisir et ce cours vous aidera à vous informer et à vous lancer dans le choix d'une distribution Linux. \n\nIl existe de nombreuses distributions Linux parmi lesquelles choisir, nous passerons en revue les options les plus populaires.",
          "quizAnswer": "",
          "quizQuestion": "Aucune question, passez à la suite !",
          "slug": "choisirunedistributionlinux",
          "title": "Choisir une distribution Linux"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation de Debian comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Aperçu</b>\nDebian est un système d'exploitation composé entièrement de logiciels libres et open-source. Il est largement connu et est en développement depuis plus de 20 ans. Il existe trois branches que vous pouvez utiliser, Stable, Testing et Unstable. \n\nStable est une branche globalement bonne à utiliser. Testing et Unstable sont des versions en continu. Cela signifie que tout changement incrémentiel dans ces branches finira par devenir Stable. Par exemple, si vous vouliez passer de Windows 8 à Windows 10, vous devrez effectuer une installation complète de Windows 10. Cependant, en étant sur la version Testing, vous recevrez automatiquement des mises à jour jusqu'à ce qu'elle devienne la prochaine version du système d'exploitation sans avoir à effectuer une installation complète. \n\n<b>Gestion des paquets</b>\nDebian utilise également des outils de gestion des paquets Debian. Chaque distribution Linux installe et gère les paquets différemment et utilise des outils de gestion des paquets différents. Nous approfondirons ce sujet dans un prochain cours. \n\n<b>Configurabilité</b>\nDebian peut ne pas recevoir les dernières mises à jour, mais il est extrêmement stable. Si vous voulez un bon système d'exploitation \"de base\", celui-ci est fait pour vous.\n\n<b>Utilisations</b>\nDebian est un excellent système d'exploitation pour n'importe quelle plateforme.",
          "quizAnswer": "En continu",
          "quizQuestion": "Quel type de version les branches Testing et Unstable ont-elles ?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation de RHEL comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Aperçu</b>\nRed Hat Enterprise Linux, communément appelé RHEL, est développé par Red Hat. RHEL a des règles strictes pour restreindre la redistribution gratuite bien qu'il fournisse toujours le code source gratuitement.\n\n<b>Gestion des packages</b>\nRHEL utilise un gestionnaire de packages différent de Debian, le gestionnaire de packages RPM, que nous apprendrons également par la suite.\n\n<b>Configurabilité</b>\nLes systèmes d'exploitation basés sur RHEL différeront légèrement des systèmes d'exploitation basés sur Debian, notamment en ce qui concerne la gestion des packages. Si vous décidez d'opter pour RHEL, il est probablement préférable de savoir que vous allez travailler avec.\n\n<b>Utilisations</b>\nComme son nom l'indique, il est principalement utilisé en entreprise, donc si vous avez besoin d'un système d'exploitation serveur solide, celui-ci serait un bon choix.",
          "quizAnswer": "RPM",
          "quizQuestion": "Quel gestionnaire de packages utilise RHEL ?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Si vous êtes intéressé par Ubuntu comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Vue d'ensemble</b>\nUne des distributions Linux les plus populaires pour les machines personnelles est Ubuntu. Ubuntu publie également son propre gestionnaire d'environnement de bureau Unity par défaut. \n\n<b>Gestion des paquets</b>\nUbuntu est un système d'exploitation basé sur Debian développé par Canonical. Il utilise donc un système de gestion de paquets Debian de base.\n\n<b>Configurabilité</b>\nUbuntu est un excellent choix pour un débutant qui souhaite se lancer dans Linux. Ubuntu offre une facilité d'utilisation et une excellente expérience d'interface utilisateur qui ont conduit à son adoption généralisée. Il est largement utilisé et pris en charge et ressemble le plus à d'autres systèmes d'exploitation tels que OSX et Windows en termes d'utilisabilité.\n\n<b>Utilisations</b>\nIdéal pour n'importe quelle plateforme, bureau, ordinateur portable et serveur.",
          "quizAnswer": "Debian",
          "quizQuestion": "Sur quel système d'exploitation Ubuntu est-il basé ?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation de Fedora comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Présentation</b>\nSoutenu par Red Hat, le projet Fedora est piloté par la communauté et contient des logiciels open source et gratuits. Red Hat Enterprise Linux dérive de Fedora, donc pensez à Fedora comme un système d'exploitation RHEL en amont. Finalement, RHEL recevra des mises à jour de Fedora après des tests approfondis et un contrôle qualité. Pensez à Fedora comme un équivalent d'Ubuntu qui utilise un backend Red Hat au lieu de Debian.\n\n<b>Gestion des paquets</b>\nUtilise le gestionnaire de paquets Red Hat.\n\n<b>Configurabilité</b>\nSi vous souhaitez utiliser un système d'exploitation basé sur Red Hat, c'est une version conviviale.\n\n<b>Utilisations</b>\nFedora est excellent si vous voulez un système d'exploitation basé sur Red Hat sans l'étiquette de prix. Recommandé pour les ordinateurs de bureau et les ordinateurs portables.",
          "quizAnswer": "Fedora",
          "quizQuestion": "De quoi RHEL est-il dérivé ?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Si vous êtes intéressé à avoir Linux Mint comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Aperçu</b>\nLinux Mint est basé sur Ubuntu. Il utilise les dépôts de logiciels d'Ubuntu, de sorte que les mêmes packages sont disponibles sur les deux distributions. Linux Mint est préféré par d'autres par rapport à Ubuntu car il ne contient pas certains des logiciels propriétaires inclus dans Ubuntu, tels que Unity.\n\n<b>Gestion des paquets</b>\nÉtant donné que Linux Mint est basé sur Ubuntu, il utilise le gestionnaire de paquets Debian.\n\n<b>Configurabilité</b>\nUne excellente interface utilisateur, idéale pour les débutants et moins encombrée qu'Ubuntu. Dans ce cours, j'utiliserai Linux Mint, mais toute autre distribution peut être utilisée.\n\n<b>Utilisations</b>\nIdéal pour les ordinateurs de bureau et les ordinateurs portables.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "Sur quoi Linux Mint est-il basé ?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation de Gentoo comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Vue d'ensemble</b>\nGentoo offre une flexibilité ridicule avec le système d'exploitation à un prix. Il est conçu pour les utilisateurs avancés qui n'ont pas peur de mettre les mains dans le cambouis du système.\n\n<b>Gestion des paquets</b>\nGentoo utilise sa propre gestion des paquets, Portage. La gestion des paquets Portage est très modulaire et facile à entretenir, ce qui joue un grand rôle dans la grande flexibilité de l'ensemble du système d'exploitation.\n\n<b>Configurabilité</b>\nSi vous débutez avec Linux et que vous souhaitez emprunter un chemin plus difficile, je choisirais Gentoo ou Arch Linux comme distribution.\n\n<b>Utilisations</b>\nIdéal pour les ordinateurs de bureau et les ordinateurs portables.",
          "quizAnswer": "Portage",
          "quizQuestion": "Quel système de gestion des paquets utilise Gentoo ?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation d'Arch comme système d'exploitation, rendez-vous dans la section d'installation et essayez-le : <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Vue d'ensemble</b>\nArch est une distribution Linux légère et flexible entièrement pilotée par la communauté. Similaire à Debian, Arch utilise un modèle de publication continue, de sorte que les mises à jour progressives finissent par devenir la version stable. Vous devez vraiment mettre les mains dans le cambouis pour comprendre le système et ses fonctions, mais en retour, vous obtenez un contrôle complet et total de votre système.\n\n<b>Gestion des paquets</b>\nIl utilise son propre gestionnaire de paquets, Pacman, pour installer, mettre à jour et gérer les paquets.\n\n<b>Configurabilité</b>\nSi vous voulez un système d'exploitation léger et vraiment comprendre Linux, utilisez Arch ! Il y a une courbe d'apprentissage, mais pour les utilisateurs de Linux chevronnés, c'est un excellent choix.\n\n<b>Utilisations</b>\nIdéal pour les ordinateurs de bureau et les ordinateurs portables. Si vous avez également un petit appareil tel qu'un Raspberry Pi et avez besoin d'y installer un système d'exploitation léger, vous ne pouvez pas vous tromper avec Arch.",
          "quizAnswer": "Pacman",
          "quizQuestion": "Quel gestionnaire de paquets utilise Arch Linux ?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Si vous êtes intéressé par l'utilisation de openSUSE comme système d'exploitation, rendez-vous sur la page de téléchargement et essayez-le : <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Vue d'ensemble</b>\nopenSUSE Linux est créé par le projet openSUSE. Une communauté qui promeut l'utilisation de Linux partout, travaillant ensemble de manière ouverte, transparente et amicale dans le cadre de la communauté mondiale des logiciels libres et open source. openSUSE est la deuxième distribution Linux encore en activité la plus ancienne et partage le système de base avec les produits primés SUSE Linux Enterprise de SUSE.\n\n<b>Gestion des paquets</b>\nUtilise le gestionnaire de paquets RPM.\n\n<b>Configurabilité</b>\nopenSUSE est un excellent choix pour un nouvel utilisateur de Linux. Il offre une application d'installation/administration graphique facile à utiliser (<a href=\"http://yast.github.io/\">YaST</a>) et un système de base bien rangé, facile à bricoler. openSUSE inclut tout ce dont vous avez besoin pour profiter d'Internet sans souci de virus/logiciels espions et pour exprimer votre créativité, que ce soit avec vos photos, vidéos, musique ou code.\n\n<b>Utilisations</b>\nopenSUSE Leap est tout à fait capable d'être utilisé sur un PC de bureau et un ordinateur portable.",
          "quizAnswer": "yast",
          "quizQuestion": "Quel est le nom de l'outil d'administration/installation d'openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Démarrage"
    },
    {
      "description": "Apprenez les fondamentaux de la ligne de commande, la navigation des fichiers, des répertoires et plus encore.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Essayez d'autres commandes Linux et voyez ce qu'elles affichent:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "Le monde est votre huître, ou plutôt la coquille est votre huître. Qu'est-ce que la coquille? La coquille est essentiellement un programme qui prend vos commandes du clavier et les envoie au système d'exploitation pour les exécuter. Si vous avez déjà utilisé une interface graphique, vous avez probablement vu des programmes tels que \"Terminal\" ou \"Console\", ce ne sont que des programmes qui lancent une coquille pour vous. Tout au long de ce cours, nous allons découvrir les merveilles de la coquille. \n\nDans ce cours, nous utiliserons le programme de coquille bash (Bourne Again shell), presque toutes les distributions Linux utiliseront par défaut la coquille bash. Il existe d'autres coquilles disponibles telles que ksh, zsh, tsch, mais nous n'aborderons aucune d'entre elles. \n\nPlongeons directement! Selon la distribution, votre invite de coquille pourrait changer, mais pour la plupart, elle devrait suivre le format suivant:\n<pre>nom_utilisateur@nom_hôte:répertoire_courant\npete@icebox:/home/pete $</pre>\n\nRemarquez le $ à la fin de l'invite? Différentes coquilles auront des invites différentes, dans notre cas le $ est pour un utilisateur normal utilisant Bash, Bourne ou Korn shell, vous n'ajoutez pas le symbole d'invite lorsque vous tapez la commande, sachez simplement qu'il est là.\n\nCommençons par une commande simple, echo. La commande echo imprime simplement les arguments textuels à l'écran.\n\n<pre>$ echo Bonjour le monde</pre>",
          "quizAnswer": "Bonjour le monde",
          "quizQuestion": "Que devrait afficher à l'écran lorsque vous tapez echo Bonjour le monde?",
          "slug": "lacoquille",
          "title": "La coquille"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 2,
          "lessonContent": "Tout dans Linux est un fichier. Au fur et à mesure que vous explorez plus en profondeur Linux, vous comprendrez cela, mais pour l'instant gardez-le simplement à l'esprit. Chaque fichier est organisé dans une arborescence de répertoires hiérarchique. Le premier répertoire dans le système de fichiers est judicieusement nommé le 'répertoire racine'. Le répertoire racine contient de nombreux dossiers et fichiers, dans lesquels vous pouvez stocker d'autres dossiers et fichiers, et ainsi de suite. Voici un exemple de ce à quoi ressemble l'arborescence des répertoires : \n\n<pre>/\n|-- bin\n|   |-- fichier1\n|   |-- fichier2\n|-- etc\n|   |-- fichier3\n|   `-- répertoire1\n|       |-- fichier4\n|       `-- fichier5\n|-- home\n|-- var\n</pre>\n\nLes emplacements de ces fichiers et répertoires sont appelés 'chemins'. Si vous aviez un dossier nommé 'home' qui contenait un dossier à l'intérieur nommé 'pete' et un autre dossier dans ce dossier nommé 'Films', ce chemin ressemblerait à ceci : '/home/pete/Films'. Assez simple, n'est-ce pas ?\n\nNaviguer dans le système de fichiers, tout comme naviguer dans la vie réelle, est plus facile si vous savez où vous êtes et où vous allez. Pour voir où vous êtes, vous pouvez utiliser la commande 'pwd'. Cette commande signifie “print working directory” et elle vous montre dans quel répertoire vous vous trouvez. Notez que le chemin provient du répertoire racine.\n\n<pre>$ pwd</pre>\n\nOù êtes-vous ? Où suis-je ? Essayez.",
          "quizAnswer": "pwd",
          "quizQuestion": "Comment puis-je savoir dans quel répertoire vous vous trouvez actuellement ?",
          "slug": "commandepwdafficherlerépertoiredetravail",
          "title": "pwd (Afficher le répertoire de travail)"
        },
        {
          "exercise": "<ol>\n<li>Exécutez la commande cd sans aucun indicateur, où vous emmène-t-elle ?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Maintenant que vous savez où vous vous trouvez, voyons si nous pouvons nous déplacer un peu dans le système de fichiers. N'oubliez pas que nous devrons naviguer en utilisant des chemins. Il existe deux façons différentes de spécifier un chemin, avec des chemins absolus et relatifs. \n\n<ul>\n<li>Chemin absolu : Il s'agit du chemin à partir du répertoire racine. Le répertoire racine est le chef. Le répertoire racine est communément représenté par un slash. Chaque fois que votre chemin commence par /, cela signifie que vous partez du répertoire racine. Par exemple, /home/pete/Desktop.</li>\n\n<li>Chemin relatif : Il s'agit du chemin à partir de l'endroit où vous vous trouvez actuellement dans le système de fichiers. Si j'étais dans l'emplacement /home/pete/Documents et que je voulais accéder à un répertoire à l'intérieur de Documents appelé taxes, je n'ai pas à spécifier tout le chemin à partir de la racine comme /home/pete/Documents/taxes, je peux simplement aller à taxes/ à la place.</li>\n</ul>\n\nMaintenant que vous savez comment fonctionnent les chemins, nous avons juste besoin de quelque chose pour nous aider à changer de répertoire. Heureusement, nous avons cd ou « changer de répertoire » pour le faire. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nMaintenant, j'ai changé l'emplacement de mon répertoire en /home/pete/Pictures.\n\nMaintenant, à partir de ce répertoire, j'ai un dossier à l'intérieur appelé Hawaii, je peux naviguer vers ce dossier avec :\n\n<pre>$ cd Hawaii</pre>\n\nRemarquez comment j'ai simplement utilisé le nom du dossier ? C'est parce que j'étais déjà dans /home/pete/Pictures.\n\nIl peut être assez fatigant de naviguer tout le temps avec des chemins absolus et relatifs, heureusement, il existe quelques raccourcis pour vous aider. \n\n<ul>\n<li>. (répertoire actuel). Il s'agit du répertoire dans lequel vous vous trouvez actuellement. </li>\n<li>.. (répertoire précédent). Vous emmène dans le répertoire au-dessus de votre actuel.</li>\n<li>~ (répertoire personnel). Ce répertoire est par défaut votre « répertoire personnel ». Par exemple, /home/pete.</li>\n<li>- (répertoire précédent). Cela vous ramènera au répertoire précédent où vous étiez juste avant.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nEssayez-les !",
          "quizAnswer": "cd ..",
          "quizQuestion": "Si vous êtes dans /home/pete/Pictures et que vous voulez aller à /home/pete, quel est un bon raccourci à utiliser ?",
          "slug": "changedirectorycdcommand",
          "title": "cd (Changer de répertoire)"
        },
        {
          "exercise": "Exécutez ls avec différents drapeaux et observez la sortie que vous recevez.",
          "id": 4,
          "lessonContent": "Maintenant que nous savons comment nous déplacer dans le système, comment pouvons-nous savoir ce qui est disponible pour nous ? Pour l'instant, c'est comme si nous nous déplacions dans l'obscurité. Eh bien, nous pouvons utiliser la merveilleuse commande ls pour lister le contenu des répertoires. La commande ls listera les répertoires et fichiers du répertoire actuel par défaut, cependant vous pouvez spécifier le chemin que vous souhaitez lister.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls est un outil assez utile, il vous montre également des informations détaillées sur les fichiers et répertoires que vous regardez.\n\nNotez également que tous les fichiers d'un répertoire ne seront pas visibles. Les noms de fichiers commençant par . sont cachés, vous pouvez cependant les voir avec la commande ls en passant le drapeau -a (a pour tous).\n\n<pre>$ ls -a</pre>\n\nIl y a aussi un autre drapeau ls utile, -l pour long, cela affiche une liste détaillée des fichiers dans un format long. Cela vous montrera des informations détaillées, en commençant par la gauche : les permissions du fichier, le nombre de liens, le nom du propriétaire, le groupe propriétaire, la taille du fichier, l'horodatage de la dernière modification et le nom du fichier/répertoire.\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nLes commandes ont des choses appelées drapeaux (ou arguments ou options, comme vous voulez l'appeler) pour ajouter plus de fonctionnalités. Voyez comment nous avons ajouté -a et -l, eh bien vous pouvez les ajouter tous les deux ensemble avec -la. L'ordre des drapeaux détermine dans quel ordre cela se fait, la plupart du temps cela n'a pas vraiment d'importance, donc vous pouvez également faire ls -al et cela fonctionnerait toujours.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "Quelle commande utiliseriez-vous pour voir les fichiers cachés ?",
          "slug": "listdirectorieslscommand",
          "title": "ls (Lister les répertoires)"
        },
        {
          "exercise": "<ol>\n<li>Créez un nouveau fichier</li>\n<li>Notez l'horodatage</li>\n<li>Touchez le fichier et vérifiez à nouveau l'horodatage</li>\n</ol>",
          "id": 5,
          "lessonContent": "Apprenons comment créer des fichiers. Une façon très simple est d'utiliser la commande touch. Touch vous permet de créer de nouveaux fichiers vides.\n\n<pre>$ touch mysuperduperfile</pre>\n\nEt voilà, un nouveau fichier ! \n\nTouch est également utilisé pour modifier les horodatages des fichiers et répertoires existants. Essayez, faites un ls -l sur un fichier et notez l'horodatage, puis touchez ce fichier et l'horodatage sera mis à jour. \n\nIl existe de nombreuses autres façons de créer des fichiers qui impliquent d'autres choses comme la redirection et les éditeurs de texte, mais nous aborderons cela dans le cours de Manipulation de texte.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "Comment créez-vous un fichier appelé myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Exécutez la commande file sur quelques répertoires et fichiers différents et notez la sortie.",
          "id": 6,
          "lessonContent": "Dans la leçon précédente, nous avons appris sur touch, revenons-y un instant. Avez-vous remarqué que le nom du fichier ne respectait pas les normes de nommage standard comme vous l'avez probablement vu avec d'autres systèmes d'exploitation comme Windows ? Normalement, vous vous attendriez à un fichier appelé banane.jpeg et vous vous attendriez à un fichier image JPEG. \n\nSous Linux, les noms de fichiers ne sont pas obligés de représenter le contenu du fichier. Vous pouvez créer un fichier appelé drole.gif qui n'est pas réellement un GIF. \n\nPour savoir de quel type de fichier il s'agit, vous pouvez utiliser la commande file. Elle vous montrera une description du contenu du fichier.\n\n<pre>$ file banane.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour trouver le type de fichier d'un fichier ?",
          "slug": "commandefichier",
          "title": "fichier"
        },
        {
          "exercise": "Exécutez la commande chat sur différents fichiers et répertoires. Ensuite, essayez de concaténer plusieurs fichiers.",
          "id": 7,
          "lessonContent": "Nous avons presque terminé de naviguer dans les fichiers, mais avant tout, apprenons comment lire un fichier. Une commande simple à utiliser est la commande chat, abréviation de concaténer, elle affiche non seulement le contenu du fichier mais peut également combiner plusieurs fichiers et vous montrer leur sortie. \n\n<pre>$ chat fichierchien fichieroiseau</pre>\n\nCe n'est pas idéal pour visualiser de gros fichiers et cela n'est destiné qu'à un contenu court. Il existe de nombreux autres outils que nous utilisons pour visualiser de plus grands fichiers texte que nous discuterons dans la prochaine leçon.",
          "quizAnswer": "chat",
          "quizQuestion": "Quel est un bon moyen de voir le contenu d'un fichier?",
          "slug": "commande-chat",
          "title": "chat"
        },
        {
          "exercise": "Exécutez less sur un fichier, puis naviguez dans le fichier. Essayez de rechercher un mot spécifique. Naviguez rapidement vers le début ou la fin du fichier.",
          "id": 8,
          "lessonContent": "Si vous consultez des fichiers texte plus grands qu'une simple sortie, less est plus. (Il existe en fait une commande appelée more qui fait quelque chose de similaire, donc c'est ironique.) Le texte est affiché de manière paginée, vous pouvez donc naviguer à travers un fichier texte page par page. \n\nAllez-y et regardez le contenu d'un fichier avec less. Une fois dans la commande less, vous pouvez réellement utiliser d'autres commandes clavier pour naviguer dans le fichier. \n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nUtilisez la commande suivante pour naviguer dans less: \n\n<ul>\n<li>q - Utilisé pour quitter less et revenir à votre shell.</li>\n<li>Page précédente, Page suivante, Haut et Bas - Naviguez à l'aide des touches fléchées et des touches de page.</li>\n<li>g - Se déplace au début du fichier texte.</li>\n<li>G - Se déplace à la fin du fichier texte.</li>\n<li>/recherche - Vous pouvez rechercher un texte spécifique à l'intérieur du document texte. Préfixez les mots que vous souhaitez rechercher avec /</li>\n<li>h - Si vous avez besoin d'un peu d'aide sur la manière d'utiliser less pendant que vous êtes dans less, utilisez help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "Comment quittez-vous une commande less?",
          "slug": "commandeless",
          "title": "less"
        },
        {
          "exercise": "Naviguez dans l'historique de vos commandes précédentes avec les touches Haut et Bas. Jouez avec la recherche inversée ctrl-R.",
          "id": 9,
          "lessonContent": "Dans votre shell, il y a un historique des commandes que vous avez précédemment saisies, vous pouvez effectivement parcourir ces commandes. C'est assez utile lorsque vous voulez trouver et exécuter une commande que vous avez utilisée précédemment sans la retaper.\n\n<pre>$ history</pre>\n\nVous voulez exécuter la même commande que celle que vous avez faite précédemment, appuyez simplement sur la flèche vers le haut.\n\nVous voulez exécuter la commande précédente sans la retaper ? Utilisez !!. Si vous avez tapé cat fichier1 et que vous voulez l'exécuter à nouveau, vous pouvez simplement taper !! et cela exécutera la dernière commande que vous avez exécutée.\n\nUn autre raccourci d'historique est ctrl-R, c'est la commande de recherche inversée, si vous appuyez sur ctrl-R et que vous commencez à taper des parties de la commande que vous voulez, il vous montrera des correspondances et vous pourrez simplement naviguer à travers elles en appuyant à nouveau sur la touche ctrl-R. Une fois que vous avez trouvé la commande que vous voulez utiliser à nouveau, appuyez simplement sur la touche Entrée.\n\nNotre terminal est un peu encombré, n'est-ce pas ? Faisons un peu de nettoyage, utilisez la commande clear pour nettoyer votre affichage.\n\n<pre>$ clear</pre>\n\nCela a l'air mieux, n'est-ce pas ?\n\nPendant que nous parlons de choses utiles, l'une des fonctionnalités les plus utiles dans n'importe quel environnement en ligne de commande est l'auto-complétion. Si vous commencez à taper le début d'une commande, d'un fichier, d'un répertoire, etc. et appuyez sur la touche Tab, cela complétera automatiquement en fonction de ce qu'il trouve dans le répertoire que vous recherchez tant que vous n'avez pas d'autres fichiers qui commencent par ces lettres. Par exemple, si vous essayiez d'exécuter la commande chrome, vous pouvez taper chr et appuyer sur Tab et cela complétera automatiquement chrome.",
          "quizAnswer": "clear",
          "quizQuestion": "Quelle est la commande pour effacer le terminal ?",
          "slug": "commandehistorique",
          "title": "historique"
        },
        {
          "exercise": "Copiez quelques fichiers, faites attention de ne pas écraser quelque chose d'important.",
          "id": 10,
          "lessonContent": "Commençons par faire des copies de ces fichiers. Tout comme copier et coller des fichiers dans d'autres systèmes d'exploitation, le shell nous offre un moyen encore plus simple de le faire. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile est le fichier que vous souhaitez copier et /home/pete/Documents/cooldocs est l'endroit où vous copiez le fichier.\n\nVous pouvez copier plusieurs fichiers et répertoires ainsi que utiliser des caractères génériques. Un caractère générique est un caractère qui peut être substitué pour une sélection basée sur un motif, vous offrant ainsi plus de flexibilité dans les recherches. Vous pouvez utiliser des caractères génériques dans chaque commande pour plus de flexibilité.\n\n<ul>\n<li>* le caractère générique des caractères génériques, il est utilisé pour représenter tous les caractères simples ou toute chaîne.</li>\n<li>? utilisé pour représenter un caractère</li>\n<li>[] utilisé pour représenter n'importe quel caractère dans les crochets</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nCela copiera tous les fichiers avec l'extension .jpg de votre répertoire actuel dans le répertoire Pictures.\n\nUne commande utile est d'utiliser le drapeau -r, cela copiera de manière récursive les fichiers et répertoires à l'intérieur d'un répertoire. \n\nEssayez de faire un cp sur un répertoire qui contient quelques fichiers vers votre répertoire Documents. Ça n'a pas fonctionné, n'est-ce pas ? Eh bien, c'est parce que vous devrez également copier les fichiers et répertoires à l'intérieur avec la commande -r.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nUne chose à noter, si vous copiez un fichier dans un répertoire qui a le même nom de fichier, le fichier sera écrasé par ce que vous copiez. Ce n'est pas bon si vous avez un fichier que vous ne voulez pas écraser accidentellement. Vous pouvez utiliser le drapeau -i (interactif) pour vous demander avant d'écraser un fichier. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Quel drapeau devez-vous spécifier pour copier un répertoire ?",
          "slug": "copycpcommand",
          "title": "cp (Copier)"
        },
        {
          "exercise": "Renommez un fichier, puis déplacez ce fichier vers un répertoire différent.",
          "id": 11,
          "lessonContent": "Utilisé pour déplacer des fichiers et les renommer. Assez similaire à la commande cp en termes de drapeaux et de fonctionnalités. \n\nVous pouvez renommer des fichiers comme ceci :\n\n<pre>$ mv ancienfichier nouveaufichier</pre>\n\nOu vous pouvez réellement déplacer un fichier vers un répertoire différent : \n\n<pre>$ mv fichier2 /home/pete/Documents</pre>\n\nEt déplacer plusieurs fichiers :\n\n<pre>$ mv fichier_1 fichier_2 /undossierquelconque</pre>\n\nVous pouvez également renommer des répertoires :\n\n<pre>$ mv répertoire1 répertoire2</pre>\n\nComme cp, si vous déplacez un fichier ou un répertoire, cela écrasera tout élément dans le même répertoire. Vous pouvez donc utiliser le drapeau -i pour vous avertir avant d'écraser quoi que ce soit.\n\n<pre>mv -i répertoire1 répertoire2</pre>\n\nDisons que vous vouliez effectivement déplacer un fichier pour écraser l'ancien. Vous pouvez également sauvegarder ce fichier et il renommera simplement l'ancienne version avec un ~. \n\n<pre>$ mv -b répertoire1 répertoire2</pre>",
          "quizAnswer": "mv chat chien",
          "quizQuestion": "Comment renommez-vous un fichier appelé chat en chien?",
          "slug": "commandedemvmv",
          "title": "mv (Déplacer)"
        },
        {
          "exercise": "Créez quelques répertoires et déplacez quelques fichiers dans ce répertoire.",
          "id": 12,
          "lessonContent": "Nous aurons besoin de répertoires pour stocker tous ces fichiers sur lesquels nous avons travaillé. La commande mkdir (Make Directory) est utile à cet effet, elle créera un répertoire s'il n'existe pas déjà. Vous pouvez même créer plusieurs répertoires en même temps.\n\n<pre>$ mkdir books paintings</pre>\n\nVous pouvez également créer des sous-répertoires en même temps avec le drapeau -p (parent).\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "Quelle commande est utilisée pour créer un répertoire?",
          "slug": "creerunrepertoirecommandemkdir",
          "title": "mkdir (Créer un répertoire)"
        },
        {
          "exercise": "<ol>\n<li>Créez un fichier appelé -file (n'oubliez pas le tiret !).</li>\n<li>Supprimez ce fichier.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Maintenant je pense que nous avons trop de fichiers, supprimons-en quelques-uns. Pour supprimer des fichiers, vous pouvez utiliser la commande rm. La commande rm (remove) est utilisée pour supprimer des fichiers et des répertoires. \n\n<pre>$ rm file1</pre>\n\nSoyez prudent lorsque vous utilisez rm, il n'y a pas de corbeille magique dans laquelle vous pouvez récupérer les fichiers supprimés. Une fois qu'ils sont partis, ils sont partis pour de bon, alors faites attention. \n\nHeureusement, certaines mesures de sécurité ont été mises en place, de sorte que Monsieur Tout-le-Monde ne puisse pas simplement supprimer un tas de fichiers importants. Les fichiers en écriture protégée vous demanderont confirmation avant de les supprimer. Si un répertoire est en écriture protégée, il ne sera pas non plus facilement supprimé. \n\nMaintenant, si cela ne vous dérange pas, vous pouvez absolument supprimer un tas de fichiers. \n\n<pre>$ rm -f file1</pre>\n\nL'option -f ou force indique à rm de supprimer tous les fichiers, qu'ils soient protégés en écriture ou non, sans demander l'avis de l'utilisateur (tant que vous avez les autorisations appropriées).\n\n<pre>$ rm -i file</pre>\n\nEn ajoutant le drapeau -i comme beaucoup des autres commandes, vous obtiendrez une invite pour savoir si vous voulez réellement supprimer les fichiers ou répertoires. \n\n<pre>$ rm -r répertoire</pre>\n\nVous ne pouvez pas simplement supprimer un répertoire par défaut, vous devrez ajouter le drapeau -r (récursif) pour supprimer tous les fichiers et sous-répertoires qu'il pourrait contenir.\n\nVous pouvez supprimer un répertoire avec la commande rmdir.\n\n<pre>$ rmdir répertoire</pre>",
          "quizAnswer": "",
          "quizQuestion": "Comment supprimer un fichier appelé myfile?",
          "slug": "removermcommand",
          "title": "rm (Supprimer)"
        },
        {
          "exercise": "<ol>\n<li>Trouvez un fichier à partir du répertoire racine qui contient le mot net.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Avec tous ces fichiers que nous avons sur le système, cela peut devenir un peu chaotique d'essayer de trouver un spécifique. Eh bien, il y a une commande que nous pouvons utiliser pour cela, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nAvec find, vous devrez spécifier le répertoire dans lequel vous effectuerez la recherche, ce que vous recherchez, dans ce cas, nous essayons de trouver un fichier nommé puppies.jpg. \n\nVous pouvez spécifier le type de fichier que vous essayez de trouver. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nVous pouvez voir que j'ai défini le type de fichier que je cherche comme (d) pour répertoire et je recherche toujours par le nom de MyFolder. \n\nUne chose intéressante à noter est que find ne s'arrête pas au répertoire que vous recherchez, il regardera également à l'intérieur de tous les sous-répertoires que ce répertoire pourrait avoir.",
          "quizAnswer": "-name",
          "quizQuestion": "Quelle option dois-je spécifier pour find si je veux rechercher par nom?",
          "slug": "commandetrouver",
          "title": "trouver"
        },
        {
          "exercise": "Exécutez l'aide sur la commande echo, la commande logout et la commande pwd.",
          "id": 15,
          "lessonContent": "Linux dispose de quelques excellents outils intégrés pour vous aider à apprendre comment utiliser une commande ou vérifier les options disponibles pour une commande. Un outil, aide, est une commande bash intégrée qui fournit de l'aide pour d'autres commandes bash (echo, logout, pwd, etc).\n\n<pre>$ help echo</pre>\n\nCela vous donnera une description et les options que vous pouvez utiliser lorsque vous souhaitez exécuter echo. Pour d'autres programmes exécutables, il est d'usage d'avoir une option appelée --help ou quelque chose de similaire. \n\n<pre>$ echo --help</pre>\n\nTous les développeurs qui distribuent des exécutables ne se conformeront pas à cette norme, mais c'est probablement votre meilleure chance de trouver de l'aide sur un programme.",
          "quizAnswer": "aide",
          "quizQuestion": "Comment obtenir rapidement de l'aide en ligne de commande pour les commandes bash intégrées ?",
          "slug": "commandeaide",
          "title": "aide"
        },
        {
          "exercise": "Exécutez la commande man sur la commande ls.",
          "id": 16,
          "lessonContent": "Gee, j'aimerais que certains de ces programmes aient un manuel pour que nous puissions voir plus d'informations à leur sujet. Eh bien, heureusement ils en ont un ! Appelées pages de manuel, vous pouvez voir les manuels d'une commande avec la commande man. \n\n<pre>$ man ls</pre>\n\nLes pages de manuel sont des manuels qui sont par défaut intégrés dans la plupart des systèmes d'exploitation Linux. Elles fournissent de la documentation sur les commandes et d'autres aspects du système. \n\nEssayez-le sur quelques commandes pour obtenir plus d'informations à leur sujet.",
          "quizAnswer": "man",
          "quizQuestion": "Comment voir les manuels d'une commande ?",
          "slug": "commandeman",
          "title": "homme"
        },
        {
          "exercise": "Exécutez la commande whatis sur la commande less.",
          "id": 17,
          "lessonContent": "Whew, we’ve learned quite a bit of commands so far, if you are ever feeling doubtful about what a command does, you can use the whatis command. The whatis command provides a brief description of command line programs. \n\n<pre>$ whatis cat</pre>\n\nThe description gets sourced from the manual page of each command. If you ran whatis cat, you’d see there is a small blurb with a short description.",
          "quizAnswer": "whatis",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour voir une petite description d'une commande?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "Créez quelques alias puis supprimez-les.",
          "id": 18,
          "lessonContent": "Parfois, taper des commandes peut devenir vraiment répétitif, ou si vous devez taper une longue commande plusieurs fois, il est préférable d'avoir un alias que vous pouvez utiliser pour cela. Pour créer un alias pour une commande, vous spécifiez simplement un nom d'alias et le définissez sur la commande. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nMaintenant, au lieu de taper ls -la, vous pouvez taper foobar et il exécutera cette commande, assez cool. Gardez à l'esprit que cette commande ne sauvegardera pas votre alias après le redémarrage, vous devrez donc ajouter un alias permanent dans :\n\n<pre>~/.bashrc</pre>\n\nou des fichiers similaires si vous souhaitez le conserver après le redémarrage.\n\nVous pouvez supprimer des alias avec la commande unalias : \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "Quelle commande est utilisée pour créer un alias?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Sortez du shell et voyez ce qui se passe. Assurez-vous de ne plus avoir besoin de travailler dans ce shell.",
          "id": 19,
          "lessonContent": "Eh bien, vous avez vraiment bien réussi à passer les bases. Nous avons à peine effleuré le sujet, maintenant que vous avez appris à marcher à quatre pattes, dans le prochain ensemble de cours, je vais vous apprendre à marcher. \n\nPour l'instant, vous pouvez vous féliciter et faire une pause. Pour sortir du shell, vous pouvez utiliser la commande exit\n\n<pre>$ exit</pre>\n\nOu la commande logout:\n\n<pre>$ logout</pre>\n\nOu si vous travaillez dans une interface utilisateur en ligne de commande, vous pouvez simplement fermer le terminal, à bientôt dans le prochain cours!",
          "quizAnswer": "exit",
          "quizQuestion": "Comment pouvez-vous sortir du shell?",
          "slug": "exitcommand",
          "title": "exit"
        }
      ],
      "slug": "commandline",
      "title": "Ligne de commande"
    },
    {
      "description": "Apprenez la manipulation de texte de base et la navigation.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Essayez quelques commandes : \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Bonjour le monde > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "À ce stade, nous sommes devenus familiers avec de nombreuses commandes et leur sortie, ce qui nous amène à notre prochain sujet : les flux d'E/S (entrée/sortie). Exécutons la commande suivante et discutons de son fonctionnement. \n\n<pre>$ echo Bonjour le monde > peanuts.txt</pre>\n\nQue s'est-il passé ? Eh bien, vérifiez le répertoire où vous avez exécuté cette commande et vous devriez voir un fichier appelé peanuts.txt, regardez à l'intérieur de ce fichier et vous devriez voir le texte Bonjour le monde. Beaucoup de choses viennent de se produire en une seule commande, alors décomposons cela. \n\nCommençons par décomposer la première partie : \n\n<pre>$ echo Bonjour le monde</pre>\n\nNous savons que cela affiche Bonjour le monde à l'écran, mais comment ? Les processus utilisent des flux d'E/S pour recevoir une entrée et renvoyer une sortie. Par défaut, la commande echo prend l'entrée (entrée standard ou stdin) du clavier et renvoie la sortie (sortie standard ou stdout) à l'écran. C'est pourquoi lorsque vous tapez echo Bonjour le monde dans votre shell, vous obtenez Bonjour le monde à l'écran. Cependant, la redirection d'E/S nous permet de modifier ce comportement par défaut, nous offrant ainsi une plus grande flexibilité de fichiers. \n\nPassons à la partie suivante de la commande : \n\n<pre> > </pre>\n\nLe > est un opérateur de redirection qui nous permet de modifier l'endroit où va la sortie standard. Il nous permet d'envoyer la sortie de echo Bonjour le monde vers un fichier au lieu de l'écran. Si le fichier n'existe pas déjà, il le créera pour nous. Cependant, s'il existe, il l'écrasera (vous pouvez ajouter un indicateur shell pour éviter cela en fonction du shell que vous utilisez).\n\nEt voilà comment fonctionne essentiellement la redirection stdout !\n\nImaginons maintenant que je ne veuille pas écraser mon peanuts.txt, heureusement, il existe également un opérateur de redirection pour cela, >> : \n\n<pre>$ echo Bonjour le monde >> peanuts.txt</pre>\n\nCela ajoutera Bonjour le monde à la fin du fichier peanuts.txt, s'il n'existe pas déjà, il le créera pour nous comme il l'a fait avec l'opérateur de redirection > !",
          "quizAnswer": ">>",
          "quizQuestion": "Quel opérateur de redirection utilisez-vous pour ajouter une sortie à un fichier ?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Essayez quelques commandes:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "Dans notre leçon précédente, nous avons appris que nous avons différents flux stdout que nous pouvons utiliser, tels qu'un fichier ou l'écran. Eh bien, il existe également différents flux d'entrée standard (stdin) que nous pouvons utiliser. Nous savons que nous avons stdin à partir de périphériques comme le clavier, mais nous pouvons également utiliser des fichiers, la sortie d'autres processus et le terminal, voyons un exemple. \n\nUtilisons le fichier peanuts.txt de la leçon précédente pour cet exemple, rappelez-vous qu'il contenait le texte Bonjour le monde. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nTout comme nous avions <b>&gt;</b> pour la redirection stdout, nous pouvons utiliser <b>&lt;</b> pour la redirection stdin. \n\nNormalement dans la commande cat, vous envoyez un fichier et ce fichier devient stdin, dans ce cas, nous avons redirigé peanuts.txt pour être notre stdin. Ensuite, la sortie de cat peanuts.txt qui serait Bonjour le monde est redirigée vers un autre fichier appelé banana.txt.",
          "quizAnswer": "<",
          "quizQuestion": "Quel opérateur utilisez-vous pour rediriger stdin?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Entrée standard)"
        },
        {
          "exercise": "Que fait la commande suivante ? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Essayons quelque chose de légèrement différent maintenant, essayons de lister le contenu d'un répertoire qui n'existe pas sur votre système et redirigeons à nouveau la sortie vers le fichier peanuts.txt.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nCe que vous devriez voir est : \n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nMaintenant, vous vous demandez probablement, ce message n'aurait-il pas dû être envoyé au fichier ? Il y a en fait un autre flux d'E/S en jeu ici appelé erreur standard (stderr). Par défaut, stderr envoie sa sortie également à l'écran, c'est un flux complètement différent de stdout. Vous devrez donc rediriger sa sortie d'une manière différente. \n\nMalheureusement, le redirigeur n'est pas aussi simple qu'utiliser <b>&lt;</b> ou <b>&gt;</b> mais c'est assez proche. Nous devrons utiliser des descripteurs de fichiers. Un descripteur de fichier est un nombre non négatif utilisé pour accéder à un fichier ou un flux. Nous approfondirons ce sujet plus tard, mais pour l'instant sachez que le descripteur de fichier pour stdin, stdout et stderr est respectivement 0, 1 et 2. \n\nDonc maintenant si nous voulons rediriger notre stderr vers le fichier, nous pouvons faire ceci : \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nVous devriez voir uniquement les messages stderr dans peanuts.txt. \n\nEt si je voulais voir à la fois stderr et stdout dans le fichier peanuts.txt ? C'est possible de le faire avec des descripteurs de fichiers également : \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nCela envoie les résultats de ls /fake/directory vers le fichier peanuts.txt et redirige ensuite stderr vers stdout via 2>&1. L'ordre des opérations ici est important, 2>&1 envoie stderr vers là où stdout pointe. Dans ce cas, stdout pointe vers un fichier, donc 2>&1 envoie également stderr vers un fichier. Donc si vous ouvrez ce fichier peanuts.txt, vous devriez voir à la fois stderr et stdout. Dans notre cas, la commande ci-dessus n'affiche que stderr.\n\nIl y a un moyen plus court de rediriger à la fois stdout et stderr vers un fichier : \n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nEt si je ne veux aucun de ces messages et que je veux me débarrasser complètement des messages stderr ? Eh bien, vous pouvez également rediriger la sortie vers un fichier spécial appelé /dev/null et il supprimera toute entrée.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "Quel est le redirigeur pour stderr ?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Standard Error)"
        },
        {
          "exercise": "Essayez les commandes suivantes : \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Entrons maintenant dans la plomberie, en quelque sorte. Essayons une commande : \n\n<pre>$ ls -la /etc</pre>\n\nVous devriez voir une liste très longue d'éléments, c'est un peu difficile à lire en fait. Au lieu de rediriger cette sortie vers un fichier, ne serait-il pas agréable de pouvoir simplement voir la sortie dans une autre commande comme less ? Eh bien, c'est possible !\n\n<pre>$ ls -la /etc | less </pre>\n\nL'opérateur de tuyauterie |, représenté par une barre verticale, nous permet de récupérer la sortie standard d'une commande et de la passer en entrée standard à un autre processus. Dans ce cas, nous avons pris la sortie standard de ls -la /etc et l'avons ensuite <i>tuyauté</i> vers la commande less. La commande de tuyauterie est extrêmement utile et nous continuerons à l'utiliser pour l'éternité. \n\nEt si je voulais écrire la sortie de ma commande vers deux flux différents ? C'est possible avec la commande tee : \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nVous devriez voir la sortie de ls sur votre écran et si vous ouvrez le fichier peanuts.txt, vous devriez voir les mêmes informations !",
          "quizAnswer": "|",
          "quizQuestion": "Quelle touche représente l'opérateur de tuyauterie ?",
          "slug": "pipeteeredirect",
          "title": "tuyau et té"
        },
        {
          "exercise": "Que donne la sortie suivante ? Pourquoi ?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Exécutez la commande suivante : \n\n<pre>$ echo $HOME</pre>\n\nVous devriez voir le chemin de votre répertoire personnel, le mien ressemble à /home/pete. \n\nEt cette commande ? \n\n<pre>$ echo $USER </pre>\n\nVous devriez voir votre nom d'utilisateur !\n\nD'où proviennent ces informations ? Elles proviennent de vos variables d'environnement. Vous pouvez les afficher en tapant\n\n<pre>$ env </pre>\n\nCela affiche une grande quantité d'informations sur les variables d'environnement que vous avez actuellement définies. Ces variables contiennent des informations utiles que l'interpréteur de commandes et d'autres processus peuvent utiliser.\n\nVoici un court exemple :\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nUne variable particulièrement importante est la variable PATH. Vous pouvez accéder à ces variables en ajoutant un $ devant le nom de la variable comme ceci :\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nCela renvoie une liste de chemins séparés par un deux-points que votre système recherche lorsqu'il exécute une commande. Disons que vous téléchargez manuellement et installez un package depuis internet et le placez dans un répertoire non standard et que vous souhaitez exécuter cette commande, vous tapez $ coolcommand et l'invite affiche commande introuvable. Eh bien, c'est étrange, vous regardez le binaire dans un dossier et vous savez qu'il existe. Ce qui se passe, c'est que la variable $PATH ne vérifie pas ce répertoire pour ce binaire, donc elle génère une erreur. \n\nDisons que vous aviez des tonnes de binaires que vous vouliez exécuter à partir de ce répertoire, vous pouvez simplement modifier la variable PATH pour inclure ce répertoire dans votre variable d'environnement PATH.",
          "quizAnswer": "env",
          "quizQuestion": "Comment visualisez-vous vos variables d'environnement ?",
          "slug": "envenvironment",
          "title": "env (Environnement)"
        },
        {
          "exercise": "Que fait la commande suivante ? Pourquoi ?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Nous allons apprendre quelques commandes utiles que vous pouvez utiliser pour traiter du texte. Avant de commencer, créons un fichier avec lequel nous allons travailler. Copiez et collez la commande suivante, une fois que vous l'aurez fait, ajoutez une TABULATION entre lazy et dog (maintenez Ctrl-v + TAB enfoncés).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nLa première commande que nous allons apprendre est la commande cut. Elle extrait des portions de texte d'un fichier. \n\nPour extraire des contenus par une liste de caractères : \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nCela affiche le 5e caractère de chaque ligne du fichier. Dans ce cas, il s'agit de \"q\", notez que l'espace compte également comme un caractère. \n\nPour extraire les contenus par un champ, nous devrons apporter une petite modification : \n\n<pre>$ cut -f 2 sample.txt</pre>\n\nLe drapeau -f ou champ découpe le texte en fonction des champs, par défaut il utilise les TABULATIONS comme délimiteurs, donc tout ce qui est séparé par une TABULATION est considéré comme un champ. Vous devriez voir \"dog\" comme sortie.\n\nVous pouvez combiner le drapeau champ avec le drapeau délimiteur pour extraire les contenus par un délimiteur personnalisé : \n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nCela changera le délimiteur TABULATION en délimiteur \";\" et comme nous coupons le premier champ, le résultat devrait être \"The quick brown\".",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "Quelle commande utiliseriez-vous pour obtenir le premier caractère de chaque ligne dans un fichier ?",
          "slug": "commandecut",
          "title": "couper"
        },
        {
          "exercise": "Essayez de coller plusieurs fichiers ensemble, que se passe-t-il ?",
          "id": 7,
          "lessonContent": "La commande coller est similaire à la commande cat, elle fusionne les lignes ensemble dans un fichier. Créons un nouveau fichier avec le contenu suivant : \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nCombinons maintenant toutes ces lignes en une seule ligne : \n\n<pre>$ coller -s sample2.txt</pre>\n\nLe délimiteur par défaut pour coller est la TABulation, donc maintenant il y a une seule ligne avec des TABs séparant chaque mot.\n\nChangeons ce délimiteur (-d) pour quelque chose de plus lisible : \n\n<pre>$ coller -d ' ' -s sample2.txt</pre>\n\nMaintenant tout devrait être sur une ligne délimitée par des espaces.",
          "quizAnswer": "-s",
          "quizQuestion": "Quel drapeau utilisez-vous avec coller pour mettre tout sur une seule ligne ?",
          "slug": "commandecoller",
          "title": "coller"
        },
        {
          "exercise": "Que fait la commande suivante et pourquoi ? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Supposons que nous ayons un fichier très long, en fait nous en avons plusieurs parmi lesquels choisir, allez-y et tapez cat /var/log/syslog. Vous devriez voir des pages et des pages de texte. Et si je voulais juste voir les premières lignes de ce fichier texte ? Eh bien, nous pouvons le faire avec la commande head, par défaut, la commande head vous montrera les 10 premières lignes d'un fichier.\n\n<pre>$ head /var/log/syslog</pre>\n\nVous pouvez également modifier le nombre de lignes selon votre choix, disons que je veux voir les 15 premières lignes à la place. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nLe drapeau -n signifie le nombre de lignes.",
          "quizAnswer": "-n",
          "quizQuestion": "Quel drapeau utiliseriez-vous pour changer le nombre de lignes que vous souhaitez afficher pour la commande head ?",
          "slug": "commandetête",
          "title": "tête"
        },
        {
          "exercise": "Consultez la page de manuel de la commande tail et lisez certaines des autres commandes que nous n'avons pas discutées. \n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Similaire à la commande head, la commande tail vous permet de voir les 10 dernières lignes d'un fichier par défaut.\n\n<pre>$ tail /var/log/syslog</pre>\n\nEn plus de head, vous pouvez changer le nombre de lignes que vous souhaitez voir.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nUne autre excellente option que vous pouvez utiliser est le drapeau -f (suivre), cela suivra le fichier à mesure qu'il grandit. Essayez et voyez ce qui se passe. \n\n<pre>$ tail -f /var/log/syslog</pre> \n\nVotre fichier syslog changera continuellement pendant que vous interagissez avec votre système et en utilisant tail -f, vous pouvez voir tout ce qui est ajouté à ce fichier.",
          "quizAnswer": "-f",
          "quizQuestion": "Quel est le drapeau utilisé pour suivre un fichier dans tail?",
          "slug": "commandetail",
          "title": "queue"
        },
        {
          "exercise": "Que se passe-t-il si vous tapez simplement expand sans entrée de fichier ?",
          "id": 10,
          "lessonContent": "Dans notre leçon sur la commande cut, nous avions notre fichier sample.txt qui contenait une tabulation. Normalement, les TABs montreraient généralement une différence notable, mais certains fichiers texte ne le montrent pas assez bien. Avoir des TABs dans un fichier texte peut ne pas correspondre à l'espacement souhaité. Pour changer vos TABs en espaces, utilisez la commande expand. \n\n<pre>$ expand sample.txt</pre>\n\nLa commande ci-dessus affichera une sortie avec chaque TAB converti en un groupe d'espaces. Pour enregistrer cette sortie dans un fichier, utilisez une redirection de sortie comme ci-dessous. \n\n<pre>$ expand sample.txt > result.txt</pre>\n\nContrairement à expand, nous pouvons convertir chaque groupe d'espaces en un TAB avec la commande unexpand : \n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "Quelle commande est utilisée pour convertir les TABs en espaces ?",
          "slug": "commandeexpandunexpand",
          "title": "expand and unexpand"
        },
        {
          "exercise": "Joindre deux fichiers avec un nombre différent de lignes dans chaque fichier, que se passe-t-il ?",
          "id": 11,
          "lessonContent": "La commande join vous permet de joindre plusieurs fichiers ensemble par un champ commun : \n\nDisons que j'avais deux fichiers que je voulais joindre ensemble :\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\nVoyez comment mes fichiers ont été joints ensemble ? Ils sont joints ensemble par défaut par le premier champ et les champs doivent être identiques, s'ils ne le sont pas, vous pouvez les trier, donc dans ce cas, les fichiers sont joints via 1, 2, 3. \n\nComment joindriez-vous les fichiers suivants ? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nPour joindre ce fichier, vous devez spécifier les champs que vous joignez, dans ce cas, nous voulons le champ 2 sur file1.txt et le champ 1 sur file2.txt, donc la commande ressemblerait à ceci :\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 fait référence à file1.txt et -2 fait référence à file2.txt. Plutôt sympa. Vous pouvez également diviser un fichier en différents fichiers avec la commande split : \n\n<pre>$ split somefile</pre>\n\nCela le divisera en différents fichiers, par défaut, ils seront divisés une fois qu'ils atteignent une limite de 1000 lignes. Les fichiers sont nommés x** par défaut.",
          "quizAnswer": "join chat chien vache",
          "quizQuestion": "Quelle commande utiliseriez-vous pour joindre les fichiers nommés chat chien vache ?",
          "slug": "commandejoindivise",
          "title": "joindre et diviser"
        },
        {
          "exercise": "Le véritable pouvoir du tri réside dans sa capacité à être combiné avec d'autres commandes, essayez la commande suivante et voyez ce qui se passe?\n\n<pre>$ ls /etc | trier -rn</pre>",
          "id": 12,
          "lessonContent": "La commande de tri est utile pour trier des lignes.\n\n<pre>\nfile1.txt\ndog\ncow\ncat\nelephant\nbird\n\n$ trier file1.txt\nbird\ncat\ncow\ndog\nelephant\n</pre>\n\nVous pouvez également effectuer un tri inverse : \n\n<pre>$ trier -r file1.txt\nelephant\ndog\ncow\ncat\nbird\n</pre>\n\nEt aussi trier par valeur numérique : \n\n<pre>$ trier -n file1.txt\nbird\ncat\ncow\nelephant\ndog\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Quel drapeau utilisez-vous pour effectuer un tri inverse?",
          "slug": "commandetrier",
          "title": "tri"
        },
        {
          "exercise": "Essayez la commande suivante, que se passe-t-il ? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "La commande tr (traduire) vous permet de traduire un ensemble de caractères en un autre ensemble de caractères. Essayons un exemple de traduction de tous les caractères en minuscules en caractères majuscules. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nComme vous pouvez le voir, nous avons transformé les plages de a-z en A-Z et tout le texte que nous tapons en minuscules est converti en majuscules.",
          "quizAnswer": "tr",
          "quizQuestion": "Quelle commande est utilisée pour traduire des caractères ?",
          "slug": "trtranslatecommand",
          "title": "tr (Traduire)"
        },
        {
          "exercise": "Quel résultat obtiendriez-vous si vous essayiez uniq -uc?",
          "id": 14,
          "lessonContent": "La commande uniq (unique) est un autre outil utile pour l'analyse de texte.\n\nDisons que vous aviez un fichier avec beaucoup de doublons:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nEt que vous vouliez supprimer les doublons, eh bien vous pouvez utiliser la commande uniq:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nObtenons le décompte du nombre d'occurrences d'une ligne:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nObtenons simplement les valeurs uniques:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nObtenons simplement les valeurs en double:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Remarque</b> : uniq ne détecte pas les lignes en double sauf si elles sont adjacentes. Par exemple:\n\nDisons que vous aviez un fichier avec des doublons qui ne sont pas adjacents:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nLe résultat retourné par uniq contiendra toutes les entrées contrairement au tout premier exemple.\n\nPour surmonter cette limitation de uniq, nous pouvons utiliser la commande sort en combinaison avec uniq:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "Quelle commande utiliseriez-vous pour supprimer les doublons dans un fichier?",
          "slug": "uniquniquecommand",
          "title": "uniq (Unique)"
        },
        {
          "exercise": "Comment obtiendriez-vous le nombre total de lignes en utilisant la commande nl sur un fichier sans parcourir l'intégralité de la sortie ? Astuce : Utilisez certaines des autres commandes apprises dans ce cours.",
          "id": 15,
          "lessonContent": "La commande wc (word count) affiche le nombre total de mots dans un fichier. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nElle affiche respectivement le nombre de lignes, le nombre de mots et le nombre d'octets.\n\nPour voir uniquement le décompte d'un champ spécifique, utilisez respectivement -l, -w ou -c. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nUne autre commande que vous pouvez utiliser pour vérifier le nombre de lignes dans un fichier est la commande nl (number lines). \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "Quelle commande utiliseriez-vous pour obtenir le nombre total de mots dans un fichier et juste les mots ?",
          "slug": "nlwccommand",
          "title": "wc and nl"
        },
        {
          "exercise": "Vous avez peut-être entendu parler de egrep ou fgrep, ces appels grep obsolètes ont depuis été remplacés par grep -E et grep -F. Lisez la page de manuel de grep pour en savoir plus.",
          "id": 16,
          "lessonContent": "La commande grep est probablement la commande de traitement de texte la plus courante que vous utiliserez. Elle vous permet de rechercher des caractères dans des fichiers qui correspondent à un certain motif. Et si vous vouliez savoir si un fichier existe dans un certain répertoire ou si vous vouliez voir si une chaîne de caractères était présente dans un fichier ? Vous ne fouilleriez certainement pas chaque ligne de texte, vous utiliseriez grep !\n\nPrenons notre fichier sample.txt comme exemple : \n\n<pre>$ grep renard sample.txt</pre>\n\nVous devriez voir que grep a trouvé renard dans le fichier sample.txt. \n\nVous pouvez également rechercher des motifs insensibles à la casse avec le drapeau -i : \n\n<pre>$ grep -i unautremotif unfichier</pre>\n\nPour être encore plus flexible avec grep, vous pouvez le combiner avec d'autres commandes avec |.\n\n<pre>$ env | grep -i Utilisateur</pre>\n\nComme vous pouvez le constater, grep est assez polyvalent. Vous pouvez même utiliser des expressions régulières dans votre motif : \n\n<pre>$ ls /uncertainrep | grep '.txt$'</pre>\n\nDevrait renvoyer tous les fichiers se terminant par .txt dans uncertainrep.",
          "quizAnswer": "grep",
          "quizQuestion": "Quelle commande utilisez-vous pour trouver un certain motif ?",
          "slug": "commandegrep",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Naviguez dans le texte comme un singe araignée Linux avec vim et emacs.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Essayez de combiner des expressions régulières avec grep et recherchez à travers certains fichiers.\n\n<pre>\ngrep [expression régulière ici] [fichier]",
          "id": 1,
          "lessonContent": "Les expressions régulières sont un outil puissant pour effectuer une sélection basée sur des motifs. Elles utilisent des notations spéciales similaires à celles que nous avons déjà rencontrées, telles que le joker *. \n\nNous passerons en revue quelques-unes des expressions régulières les plus courantes, qui sont presque universelles avec n'importe quel langage de programmation.\n\nNous utiliserons cette phrase comme notre chaîne de test:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. Début d'une ligne avec ^</b>\n\n<pre>\n<b>^</b>by\ncorrespondrait à la ligne \"by the seashore\"\n</pre>\n\n<b>2. Fin d'une ligne avec $</b>\n\n<pre>\nseashore<b>$</b>\ncorrespondrait à la ligne \"by the seashore\"\n</pre>\n\n<b>3. Correspondance avec n'importe quel caractère unique avec .</b>\n\n<pre>\nb<b>.</b>\ncorrespondrait à by\n</pre>\n\n<b>4. Notation entre crochets avec [] et ()</b>\n\nCela peut être un peu délicat, les crochets nous permettent de spécifier les caractères trouvés à l'intérieur des crochets. \n\n<pre>\nd<b>[iou]</b>g\ncorrespondrait à: dig, dog, dug\n</pre>\n\nLa balise d'ancrage précédente ^ lorsqu'elle est utilisée dans un crochet signifie tout sauf les caractères à l'intérieur du crochet. \n\n<pre>\nd<b>[^i]</b>g\ncorrespondrait à: dog et dug mais pas dig\n</pre>\n\nLes crochets peuvent également utiliser des plages pour augmenter le nombre de caractères que vous souhaitez utiliser. \n\n<pre>\nd<b>[a-c]</b>g\ncorrespondra à des motifs comme dag, dbg et dcg\n</pre>\n\nAttention cependant, car les crochets sont sensibles à la casse:\n\n<pre>\nd<b>[A-C]</b>g\ncorrespondra à dAg, dBg et dCg mais pas dag, dbg et dcg\n</pre>\n\nEt voilà quelques expressions régulières de base.",
          "quizAnswer": ".",
          "quizQuestion": "Quelle expression régulière utiliseriez-vous pour correspondre à un seul caractère?",
          "slug": "expressionsregulieresregex",
          "title": "expressions régulières (Regular Expressions)"
        },
        {
          "exercise": "Faites un petit tour de vim et emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Si vous réunissez quelques utilisateurs Linux convaincus dans une pièce et leur demandez quel est le meilleur éditeur de texte à utiliser, vous entendrez une discussion sans fin sur la divinité de vim ou emacs. N'essayez même pas de mentionner l'utilisation d'un éditeur GUI si vous tenez à votre vie. \n\nVim et emacs sont des éditeurs de texte populaires installés par défaut sur la plupart des distributions Linux et ils ont tous deux leurs avantages et leurs inconvénients. Si vous voulez vous déplacer dans votre système comme un ninja, vous devrez choisir l'un de ces éditeurs de texte à utiliser. Ils sont essentiellement des éditeurs de code, de traitement de texte et pratiquement tout-en-un.",
          "quizAnswer": "",
          "quizQuestion": "Aucune question, passez votre chemin !",
          "slug": "texteditorsvimoremacs",
          "title": "Éditeurs de texte"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 3,
          "lessonContent": "Vim signifie vi (Amélioré) tout comme son nom l'indique, il s'agit d'une version améliorée de la commande de l'éditeur de texte vi.\n\nIl est super léger, ouvrir et éditer un fichier avec vim est rapide et facile. Il est également presque toujours disponible, si vous démarrez une distribution Linux aléatoire, il y a de fortes chances que vim soit installé par défaut. \n\nPour lancer vim, il suffit de taper : <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "Pas de questions, passez à la suite !",
          "slug": "vimtexteditor",
          "title": "Vim (Vi Improved)"
        },
        {
          "exercise": "Jouez avec la touche de recherche, ouvrez un fichier texte dans vim avec : vim [fichier texte] et commencez à rechercher !",
          "id": 4,
          "lessonContent": "Pour rechercher une expression, il suffit de taper la touche / puis votre résultat de recherche lorsque vous êtes dans une session vim. Une fois que vous appuyez sur Entrée, vous pouvez appuyer sur \"n\" pour aller vers l'avant ou \"N\" pour aller vers l'arrière dans vos résultats de recherche.\n\n<pre>\nMon joli fichier est très joli.\n\n/pretty\n\ntrouvera les mots jolis dans le fichier texte.\n</pre>\n\n\nLa commande de recherche ? recherchera le fichier texte en arrière, donc dans l'exemple précédent, le dernier joli apparaîtrait en premier. \n<pre>\nMon joli fichier est très joli.\n\n?pretty\n\ntrouvera les mots jolis dans le fichier texte.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Quelle touche est utilisée pour rechercher dans vim ?",
          "slug": "vimsearchpatterns",
          "title": "Motifs de recherche Vim"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Maintenant, vous pouvez remarquer que la souris n'est pas du tout utilisée ici. Pour naviguer dans un document texte dans vim, utilisez les touches suivantes: \n\n<ul>\n<li>h ou la flèche gauche - vous déplacera d'un caractère vers la gauche</li>\n<li>k ou la flèche vers le haut - vous déplacera d'une ligne vers le haut</li>\n<li>j ou la flèche vers le bas - vous déplacera d'une ligne vers le bas</li>\n<li>l ou la flèche droite - vous déplacera d'un caractère vers la droite</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "Quelle lettre est utilisée pour descendre?",
          "slug": "vimnavigation",
          "title": "Navigation Vim"
        },
        {
          "exercise": "Jouez avec l'entrée et la sortie du mode insertion.",
          "id": 6,
          "lessonContent": "<p>Vous avez peut-être remarqué que si vous essayez de taper quelque chose, vous ne pourriez pas. C'est parce que vous êtes en mode commande. Cela peut être assez déroutant surtout si vous voulez simplement ouvrir un fichier et saisir du texte. Le mode commande est utilisé lorsque vous saisissez des commandes comme h, j, k, l, etc. Pour insérer du texte, vous devrez d'abord passer en mode insertion.</p><p></p><ul><br><li>i - insérer du texte avant le curseur</li><br><li>O - insérer du texte sur la ligne précédente</li><br><li>o - insérer du texte sur la ligne suivante</li><br><li>a - ajouter du texte après le curseur</li><br><li>A - ajouter du texte à la fin de la ligne</li><br></ul><p></p><p>Remarquez comment lorsque vous tapez l'un de ces modes d'insertion, vous verrez que vim est passé en mode insertion en bas de l'invite de commande. Pour quitter le mode insertion et revenir en mode commande, appuyez simplement sur la touche Échap.</p>",
          "quizAnswer": "i",
          "quizQuestion": "Quelle touche est utilisée pour insérer du texte avant le curseur?",
          "slug": "viminsertingappendingtext",
          "title": "Ajout de texte Vim"
        },
        {
          "exercise": "Je sais que cette leçon a ajouté quelques bizarreries, ouvrez un éditeur de texte et jouez avec cela.",
          "id": 7,
          "lessonContent": "Maintenant que nous avons quelques lignes écrites, éditons un peu plus et supprimons quelques éléments inutiles.<br><p></p><ul><br><li>x - utilisé pour couper le texte sélectionné, également utilisé pour supprimer des caractères</li><br><li>dd - utilisé pour supprimer la ligne actuelle</li><br><li>y - copier ou copier ce qui est sélectionné</li><br><li>yy - copier ou copier la ligne actuelle</li><br><li>p - coller le texte copié avant le curseur</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "Quel caractère est utilisé pour supprimer une ligne entière?",
          "slug": "vimediting",
          "title": "Édition Vim"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 8,
          "lessonContent": "Maintenant que vous avez terminé votre édition, il est temps d'enregistrer et de quitter Vim : \n\n<ul>\n<li>:w - écrit ou enregistre le fichier</li>\n<li>:q - quitte Vim</li>\n<li>:wq - écrit puis quitte</li>\n<li>:q! - quitte Vim sans enregistrer le fichier</li>\n<li>ZZ - équivalent de :wq, mais un caractère plus rapide</li>\n\n<li>u - annule votre dernière action</li>\n<li>Ctrl-r - refait votre dernière action</li>\n</ul>\n\nVous pourriez penser que ZZ n'est pas nécessaire, mais vous finirez par remarquer que vos doigts ont tendance à préférer cela plutôt que :wq.\n\nOuf, c'était beaucoup d'informations à assimiler sur Vim. Maintenant que vous connaissez quelques commandes de base et la navigation, vous pouvez commencer à éditer des fichiers texte. Il existe de nombreuses autres options que vous pouvez utiliser dans Vim pour améliorer votre maîtrise de cet éditeur de texte, consultez le guide en ligne de Vim pour en savoir plus.",
          "quizAnswer": ":q!",
          "quizQuestion": "Comment quitter Vim sans enregistrer ?",
          "slug": "vimsavingandexiting",
          "title": "Enregistrer et quitter Vim"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 9,
          "lessonContent": "Emacs est destiné aux utilisateurs qui recherchent un éditeur de texte extrêmement puissant, ce qui est peut-être un euphémisme car vous vivez essentiellement dans emacs. Vous pouvez effectuer toutes vos modifications de code, manipulations de fichiers, etc. tout en restant dans emacs. Il est un peu plus lent à charger et la courbe d'apprentissage est un peu plus raide que vim, mais si vous recherchez un éditeur puissant et extrêmement extensible, celui-ci est fait pour vous. Quand je dis extensible, je veux littéralement dire que vous pouvez écrire des scripts pour emacs qui étendent sa fonctionnalité.\n\nPour démarrer emacs, il suffit d'utiliser :\n\n<pre>emacs</pre>\n\nVous devriez être accueilli par le tampon d'accueil par défaut.\n\nLes tampons dans emacs sont l'endroit où réside votre texte. Ainsi, si vous ouvrez un fichier, un tampon est utilisé pour stocker le contenu de ce fichier. Vous pouvez avoir plusieurs tampons ouverts en même temps et vous pouvez facilement passer de l'un à l'autre.",
          "quizAnswer": "",
          "quizQuestion": "Pas de questions, passez à la suite !",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Jouez avec l'ouverture de fichiers et l'enregistrement de fichiers.",
          "id": 10,
          "lessonContent": "Dans beaucoup (si ce n'est pas tous) de la documentation d'Emacs, vous verrez la syntaxe C-[lettre]. Cela signifie simplement appuyer sur Ctrl-lettre, mais à des fins de raccourci, nous appellerons Ctrl avec C. Si vous voyez une syntaxe telle que M-[lettre], cela signifie utiliser la touche Meta, le plus souvent la touche Alt.\n\n<b>Enregistrer des fichiers</b>\n\n<pre>\nC-x C-s - Enregistrer un fichier\nC-x C-w - Enregistrer le fichier sous\nC-x s - Tout enregistrer\n</pre>\n\nLes options d'enregistrement de fichiers vous demanderont si vous souhaitez enregistrer chaque fichier.\n\n<b>Ouvrir un fichier</b>\n\n<pre>\nC-x C-f\n</pre>\n\nCela vous demandera de taper un nom de fichier à ouvrir. Si vous n'avez pas de fichier qui existe déjà, il créera un nouveau fichier. Vous pouvez également charger un répertoire.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "Quelle commande est utilisée pour ouvrir un fichier?",
          "slug": "emacsmanipulatefiles",
          "title": "Manipuler les fichiers dans Emacs"
        },
        {
          "exercise": "Jouez avec les buffers.",
          "id": 11,
          "lessonContent": "Pour vous déplacer dans les buffers (ou les fichiers que vous visitez), utilisez les commandes suivantes :\n\n<b>Changer de buffer</b>\n\n<pre>\nC-x b - changer de buffer\nC-x flèche droite - parcourir les buffers vers la droite\nC-x flèche gauche - parcourir les buffers vers la gauche\n</pre>\n\n<b>Fermer le buffer</b>\n\n<pre>C-x k</pre>\n\n<b>Diviser le buffer actuel</b>\n\n<pre>C-x 2</pre>\n\nCela vous permet de voir plusieurs buffers sur un seul écran. Pour vous déplacer entre ces buffers, utilisez : C-x o\n\n<b>Définir un seul buffer comme écran actuel</b>\n\n<pre>C-x 1</pre>\n\nSi vous avez déjà utilisé un multiplexeur de terminal comme screen et tmux, les commandes de buffer vous sembleront très familières.",
          "quizAnswer": "C-x k",
          "quizQuestion": "Comment fermez-vous un buffer ?",
          "slug": "navigationdanslesbuffersemacs",
          "title": "Navigation dans les buffers Emacs"
        },
        {
          "exercise": "Jouez avec la navigation dans le texte.",
          "id": 12,
          "lessonContent": "<b>Navigation dans le texte</b>\n\n<pre>\nC-flèche haut : monter d'un paragraphe\nC-flèche bas : descendre d'un paragraphe\nC-flèche gauche : déplacer d'un mot vers la gauche\nC-flèche droite : déplacer d'un mot vers la droite\nM-> : aller à la fin du tampon\n</pre>\n\nAvec la navigation dans le texte, vos boutons de texte habituels fonctionnent comme ils le devraient, début, fin, page précédente, page suivante et les touches de direction, etc.\n\n<b>Couper et Coller</b>\n\nPour couper (tuer) ou coller (yank) dans Emacs, vous devrez d'abord être capable de sélectionner du texte. Pour sélectionner du texte, déplacez votre curseur là où vous voulez couper ou coller et appuyez sur <pre>touche C-espace</pre>, puis vous pouvez utiliser les touches de navigation pour sélectionner le texte souhaité. Maintenant, vous pouvez couper et coller comme suit :\n\n<pre>\nC-w : couper\nC-y : coller\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "Comment aller à la fin du tampon?",
          "slug": "emacsediting",
          "title": "Édition Emacs"
        },
        {
          "exercise": "Visitez le site Emacs pour en apprendre davantage sur les commandes. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Pour fermer Emacs</b>\n\n<pre>C-x C-c</pre>\n\nSi vous avez des buffers ouverts, il vous demandera de les enregistrer avant de quitter Emacs.\n\n<b>Confus ?</b>\n\n<pre>C-h C-h : menu d'aide</pre>\n\n<b>Annuler</b>\n\n<pre>C-x u</pre>\n\nComme vous pouvez le constater, Emacs a plus de composants en mouvement, donc la courbe d'apprentissage est un peu plus raide. En revanche, vous obtenez un éditeur de texte très puissant.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "Comment accédez-vous au menu d'aide ?",
          "slug": "emacsexitingandhelp",
          "title": "Quitter et Aide d'Emacs"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Text-Fu Avancé"
    },
    {
      "description": "Apprenez-en davantage sur les rôles et la gestion des utilisateurs.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 1,
          "lessonContent": "Dans n'importe quel système d'exploitation traditionnel, il y a des utilisateurs et des groupes. Ils existent uniquement pour l'accès et les autorisations. Lors de l'exécution d'un processus, il s'exécutera en tant que propriétaire de ce processus, que ce soit Jane ou Bob. L'accès aux fichiers et la propriété dépendent également des autorisations. Vous ne voudriez pas que Jane voie les documents de Bob et vice versa. \n\nChaque utilisateur a son propre répertoire personnel où ses fichiers spécifiques à l'utilisateur sont stockés, cela se trouve généralement dans /home/nom_utilisateur, mais peut varier selon les distributions. \n\nLe système utilise des identifiants d'utilisateur (UID) pour gérer les utilisateurs, les noms d'utilisateur sont la manière conviviale d'associer les utilisateurs à une identification, mais le système identifie les utilisateurs par leur UID. Le système utilise également des groupes pour gérer les autorisations, les groupes ne sont que des ensembles d'utilisateurs avec des autorisations définies par ce groupe, ils sont identifiés par le système avec leur identifiant de groupe (GID).\n\nSous Linux, vous aurez des utilisateurs en plus des humains normaux qui utilisent le système. Parfois, ces utilisateurs sont des démons système qui exécutent continuellement des processus pour maintenir le bon fonctionnement du système. L'un des utilisateurs les plus importants est root ou superutilisateur, root est l'utilisateur le plus puissant du système, root peut accéder à n'importe quel fichier et démarrer et arrêter n'importe quel processus. Pour cette raison, il peut être dangereux d'opérer en tant que root tout le temps, vous pourriez potentiellement supprimer des fichiers critiques du système. Heureusement, si un accès root est nécessaire et qu'un utilisateur a un accès root, il peut exécuter une commande en tant que root avec la commande sudo. La commande sudo (superutilisateur faire) est utilisée pour exécuter une commande avec un accès root, nous approfondirons davantage sur la manière dont un utilisateur obtient un accès root dans une leçon ultérieure.\n\nAllez-y et essayez de visualiser un fichier protégé comme /etc/shadow:\n\n<pre>$ cat /etc/shadow</pre>\n\nRemarquez comment vous obtenez une erreur de permission refusée, regardez les autorisations avec: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nNous n'avons pas encore abordé les autorisations, mais ce qui se passe ici, c'est que root est le propriétaire du fichier et vous aurez besoin d'un accès root ou de faire partie du groupe shadow pour lire le contenu. Maintenant exécutez la commande avec sudo:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nMaintenant vous pourrez voir le contenu du fichier!",
          "quizAnswer": "sudo",
          "quizQuestion": "Quelle commande utilisez-vous pour exécuter en tant que root?",
          "slug": "utilisateursetgroupes",
          "title": "Utilisateurs et Groupes"
        },
        {
          "exercise": "Ouvrez le fichier /etc/sudoers et voyez quelles permissions de superutilisateur ont les autres utilisateurs sur la machine.",
          "id": 2,
          "lessonContent": "Nous avons examiné une façon d'obtenir un accès superutilisateur en utilisant la commande sudo. Vous pouvez également exécuter des commandes en tant que superutilisateur avec la commande su. Cette commande va \"substituer les utilisateurs\" et ouvrir un shell root si aucun nom d'utilisateur n'est spécifié. Vous pouvez utiliser cette commande pour vous substituer à n'importe quel utilisateur tant que vous connaissez le mot de passe. \n\n<pre>$ su</pre>\n\nIl y a quelques inconvénients à utiliser cette méthode : il est beaucoup plus facile de commettre une erreur critique en exécutant tout en tant que root, vous n'aurez pas de traces des commandes que vous utilisez pour modifier les configurations système, etc. En gros, si vous avez besoin d'exécuter des commandes en tant que superutilisateur, contentez-vous de sudo.\n\nMaintenant que vous savez quelles commandes exécuter en tant que superutilisateur, la question est de savoir comment savoir qui a accès pour le faire ? Le système ne permet pas à chaque Joe Schmoe d'exécuter des commandes en tant que superutilisateur, alors comment le sait-il ? Il existe un fichier appelé le fichier /etc/sudoers, ce fichier répertorie les utilisateurs qui peuvent exécuter sudo. Vous pouvez modifier ce fichier avec la commande <b>visudo</b>.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "Quel fichier montre les utilisateurs ayant accès à sudo ?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Regardez votre fichier /etc/passwd, examinez certains des utilisateurs et notez les accès qu'ils ont.",
          "id": 3,
          "lessonContent": "Rappelez-vous que les noms d'utilisateur ne sont pas vraiment des identifications pour les utilisateurs. Le système utilise un identifiant d'utilisateur (UID) pour identifier un utilisateur. Pour savoir quels utilisateurs sont associés à quel ID, regardez le fichier /etc/passwd. \n\n<pre>$ cat /etc/passwd</pre>\n\nCe fichier vous montre une liste d'utilisateurs et des informations détaillées à leur sujet. Par exemple, la première ligne de ce fichier ressemble probablement à ceci :\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nChaque ligne affiche les informations de l'utilisateur pour un utilisateur, le plus souvent vous verrez l'utilisateur root en première ligne. Il y a de nombreux champs séparés par des deux-points qui vous donnent des informations supplémentaires sur l'utilisateur, regardons-les tous :\n\n<ol>\n<li>Nom d'utilisateur</li>\n<li>Mot de passe de l'utilisateur - le mot de passe n'est pas vraiment stocké dans ce fichier, il est généralement stocké dans le fichier /etc/shadow. Nous en discuterons davantage dans la prochaine leçon sur /etc/shadow, mais pour l'instant, sachez qu'il contient des mots de passe d'utilisateurs cryptés. Vous pouvez voir de nombreux symboles différents dans ce champ, si vous voyez un \"x\" cela signifie que le mot de passe est stocké dans le fichier /etc/shadow, un \"*\" signifie que l'utilisateur n'a pas accès à la connexion et s'il y a un champ vide cela signifie que l'utilisateur n'a pas de mot de passe.</li>\n<li>L'identifiant de l'utilisateur - comme vous pouvez le voir, root a l'UID de 0</li>\n<li>L'identifiant du groupe</li>\n<li>Champ GECOS - Il est utilisé pour laisser généralement des commentaires sur l'utilisateur ou le compte tels que leur vrai nom ou numéro de téléphone, il est délimité par des virgules.</li>\n<li>Répertoire personnel de l'utilisateur</li>\n<li>Shell de l'utilisateur - vous verrez probablement beaucoup d'utilisateurs utilisant bash par défaut pour leur shell</li>\n</ol>\n\nNormalement, sur une page de configuration d'utilisateur, vous vous attendriez à voir uniquement des utilisateurs humains. Cependant, vous remarquerez que /etc/passwd contient d'autres utilisateurs. Rappelez-vous que les utilisateurs ne sont vraiment présents sur le système que pour exécuter des processus avec des autorisations différentes. Parfois, nous voulons exécuter des processus avec des autorisations prédéterminées. Par exemple, l'utilisateur daemon est utilisé pour les processus de démon.\n\nIl convient également de noter que vous pouvez éditer le fichier /etc/passwd manuellement si vous souhaitez ajouter des utilisateurs et modifier des informations avec l'outil <b>vipw</b>, cependant il est préférable de laisser de telles tâches aux outils que nous discuterons dans une leçon ultérieure tels que useradd et userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Si un utilisateur n'a pas accès à la connexion, comment cela est-il indiqué dans /etc/passwd ?",
          "slug": "fichieretcpasswd",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Jetez un œil au fichier /etc/shadow",
          "id": 4,
          "lessonContent": "Le fichier /etc/shadow est utilisé pour stocker des informations sur l'authentification de l'utilisateur. Il nécessite des permissions de lecture superutilisateur. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nVous remarquerez qu'il ressemble beaucoup au contenu de /etc/passwd, cependant dans le champ du mot de passe, vous verrez un mot de passe crypté. Les champs sont séparés par des deux-points comme suit :\n\n<ol>\n<li>Nom d'utilisateur</li>\n<li>Mot de passe crypté</li>\n<li>Date du dernier changement de mot de passe - exprimée en nombre de jours depuis le 1er janvier 1970. Si c'est 0, cela signifie que l'utilisateur doit changer son mot de passe la prochaine fois qu'il se connecte</li>\n<li>Âge minimum du mot de passe - Nombre de jours qu'un utilisateur devra attendre avant de pouvoir changer à nouveau son mot de passe</li>\n<li>Âge maximum du mot de passe - Nombre maximum de jours avant qu'un utilisateur ne doive changer son mot de passe</li>\n<li>Période d'avertissement du mot de passe - Nombre de jours avant qu'un mot de passe n'expire</li>\n<li>Période d'inactivité du mot de passe - Nombre de jours après l'expiration d'un mot de passe pour permettre la connexion avec le mot de passe</li>\n<li>Date d'expiration du compte - date à laquelle l'utilisateur ne pourra plus se connecter</li>\n<li>Champ réservé pour une utilisation future</li>\n</ol>\n\nDans la plupart des distributions actuelles, l'authentification de l'utilisateur ne repose pas uniquement sur le fichier /etc/shadow, il existe d'autres mécanismes en place tels que PAM (Pluggable Authentication Modules) qui remplacent l'authentification.",
          "quizAnswer": "",
          "quizQuestion": "Pas de questions, passez à la suite !",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Exécutez la commande <b>groups</b>. Que voyez-vous ?",
          "id": 5,
          "lessonContent": "Un autre fichier utilisé dans la gestion des utilisateurs est le fichier /etc/group. Ce fichier permet de définir différents groupes avec des permissions différentes. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nTrès similaire au champ /etc/password, les champs /etc/group sont les suivants :\n\n<ol>\n<li>Nom du groupe</li>\n<li>Mot de passe du groupe - il n'est pas nécessaire de définir un mot de passe de groupe, l'utilisation d'un privilège élevé comme sudo est standard. Un \"*\" sera mis en place comme valeur par défaut.</li>\n<li>ID du groupe (GID)</li>\n<li>Liste des utilisateurs - vous pouvez spécifier manuellement les utilisateurs que vous souhaitez dans un groupe spécifique</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "Quel est le GID de root ?",
          "slug": "fichieretcgroup",
          "title": "/etc/group"
        },
        {
          "exercise": "Créez un nouvel utilisateur, puis changez son mot de passe et connectez-vous en tant que nouvel utilisateur.",
          "id": 6,
          "lessonContent": "La plupart des environnements d'entreprise utilisent des systèmes de gestion pour gérer les utilisateurs, les comptes et les mots de passe. Cependant, sur un ordinateur individuel, il existe des commandes utiles à exécuter pour gérer les utilisateurs.\n\n<b>Ajout d'utilisateurs</b>\n\nVous pouvez utiliser la commande adduser ou useradd. La commande adduser contient des fonctionnalités plus utiles telles que la création d'un répertoire personnel et plus encore. Il existe des fichiers de configuration pour l'ajout de nouveaux utilisateurs qui peuvent être personnalisés en fonction de ce que vous souhaitez allouer à un utilisateur par défaut. \n\n<pre>$ sudo useradd bob</pre>\n\nVous verrez que la commande ci-dessus crée une entrée dans /etc/passwd pour bob, configure des groupes par défaut et ajoute une entrée au fichier /etc/shadow.\n\n<b>Suppression d'utilisateurs</b>\n\nPour supprimer un utilisateur, vous pouvez utiliser la commande userdel.\n\n<pre>$ sudo userdel bob</pre>\n\nCela fait essentiellement de son mieux pour annuler les modifications de fichier effectuées par useradd.\n\n<b>Changement de mots de passe</b>\n\n<pre>$ passwd bob</pre>\n\nCela vous permettra de changer le mot de passe de vous-même ou d'un autre utilisateur (si vous êtes root).",
          "quizAnswer": "passwd",
          "quizQuestion": "Quelle commande est utilisée pour changer un mot de passe?",
          "slug": "outilsdegestiondesutilisateurs",
          "title": "Outils de gestion des utilisateurs"
        }
      ],
      "slug": "usermanagement",
      "title": "Gestion des utilisateurs"
    },
    {
      "description": "Apprenez les niveaux de permission et la modification des permissions.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Utilisez la commande ls -l sur plusieurs fichiers et récitez leurs permissions, utilisateur et groupe.",
          "id": 1,
          "lessonContent": "Comme nous l'avons appris précédemment, les fichiers ont différentes permissions ou modes de fichier. Regardons un exemple:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nIl y a quatre parties dans les permissions d'un fichier. La première partie est le type de fichier, qui est indiqué par le premier caractère des permissions, dans notre cas puisque nous regardons un répertoire, il affiche <b>d</b> pour le type de fichier. Le plus souvent, vous verrez un <b>-</b> pour un fichier régulier. \n\nLes trois parties suivantes du mode de fichier sont les permissions réelles. Les permissions sont regroupées par 3 bits chacune. Les 3 premiers bits sont les permissions de l'utilisateur, puis les permissions de groupe et enfin les permissions des autres. J'ai ajouté le trait vertical pour faciliter la différenciation.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nChaque caractère représente une permission différente: \n<ul>\n<li>r: lisible</li>\n<li>w: inscriptible</li>\n<li>x: exécutable (essentiellement un programme exécutable)</li>\n<li>-: vide</li>\n</ul>\n\nAinsi, dans l'exemple ci-dessus, nous voyons que l'utilisateur pete a les permissions de lecture, écriture et exécution sur le fichier. Le groupe penguins a les permissions de lecture et d'exécution. Et enfin, les autres utilisateurs (tout le monde) ont les permissions de lecture et d'exécution.",
          "quizAnswer": "x",
          "quizQuestion": "Quel bit de permission est utilisé pour l'exécution?",
          "slug": "permissionsdefichier",
          "title": "Permissions de fichier"
        },
        {
          "exercise": "Changez les autorisations de quelques fichiers texte de base et observez les bits changer lorsque vous faites un ls -l.",
          "id": 2,
          "lessonContent": "Changer les autorisations peut facilement être fait avec la commande <b>chmod</b>. \n\nTout d'abord, choisissez quel ensemble d'autorisations vous souhaitez modifier, utilisateur, groupe ou autre. Vous pouvez ajouter ou supprimer des autorisations avec un <b>+</b> ou un <b>-</b>, regardons quelques exemples.\n\n<b>Ajouter un bit d'autorisation sur un fichier</b>\n<pre>$ chmod u+x myfile</pre>\n\nLa commande ci-dessus se lit comme suit : changer l'autorisation sur myfile en ajoutant un bit d'autorisation d'exécution sur l'ensemble utilisateur. Maintenant, l'utilisateur a l'autorisation d'exécution sur ce fichier !\n\n<b>Supprimer un bit d'autorisation sur un fichier</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>Ajouter plusieurs bits d'autorisation sur un fichier</b>\n<pre>$ chmod ug+w</pre>\n\nIl existe une autre façon de modifier les autorisations en utilisant un format numérique. Cette méthode vous permet de modifier les autorisations en une seule fois. Au lieu d'utiliser r, w ou x pour représenter les autorisations, vous utiliserez une représentation numérique pour un ensemble d'autorisations unique. Donc, pas besoin de spécifier le groupe avec g ou l'utilisateur avec u.\n\nLes représentations numériques sont les suivantes :\n\n<ul>\n<li>4 : autorisation de lecture</li>\n<li>2 : autorisation d'écriture</li>\n<li>1 : autorisation d'exécution</li>\n</ul>\n\nRegardons un exemple : \n\n<pre>$ chmod 755 myfile</pre>\n\nPouvez-vous deviner quelles autorisations nous donnons à ce fichier ? Décortiquons cela, donc maintenant 755 couvre les autorisations pour tous les ensembles. Le premier chiffre (7) représente les autorisations de l'utilisateur, le deuxième chiffre (5) représente les autorisations du groupe et le dernier 5 représente les autorisations des autres. \n\nAttendez une minute, 7 et 5 ne figuraient pas dans la liste ci-dessus, d'où viennent ces chiffres ? Rappelez-vous que nous combinons maintenant toutes les autorisations en un seul chiffre, donc vous devrez faire intervenir un peu de mathématiques.\n\n7 = 4 + 2 + 1, donc 7 sont les autorisations de l'utilisateur et il a les autorisations de lecture, d'écriture et d'exécution\n\n5 = 4 + 1, le groupe a les autorisations de lecture et d'exécution\n\n5 = 4 + 1, et tous les autres utilisateurs ont les autorisations de lecture et d'exécution\n\nÀ noter : ce n'est pas une bonne idée de modifier les autorisations de manière inconsidérée, vous pourriez potentiellement exposer un fichier sensible à tout le monde pour le modifier, cependant de nombreuses fois vous voulez légitimement modifier les autorisations, prenez simplement des précautions lors de l'utilisation de la commande chmod.",
          "quizAnswer": "4",
          "quizQuestion": "Quel nombre représente l'autorisation de lecture lors de l'utilisation du format numérique ?",
          "slug": "modificationdesautorisations",
          "title": "Modification des autorisations"
        },
        {
          "exercise": "Modifier le groupe et l'utilisateur de certains fichiers de test. Ensuite, jetez un œil aux autorisations avec ls -l.",
          "id": 3,
          "lessonContent": "En plus de modifier les autorisations sur les fichiers, vous pouvez également modifier le groupe et la propriété de l'utilisateur du fichier également. \n\n<b>Modifier la propriété de l'utilisateur</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nCette commande définira le propriétaire de myfile sur patty.\n\n<b>Modifier la propriété du groupe</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nCette commande définira le groupe de myfile sur whales.\n\n<b>Modifier à la fois la propriété de l'utilisateur et du groupe en même temps</b>\nSi vous ajoutez deux-points et le nom du groupe après l'utilisateur, vous pouvez définir à la fois l'utilisateur et le groupe en même temps.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "Quelle commande utilisez-vous pour changer la propriété de l'utilisateur?",
          "slug": "permissionsdepropriete",
          "title": "Permissions de propriété"
        },
        {
          "exercise": "<ol>\n<li>Créez un nouveau fichier, puis notez ses permissions.</li>\n<li>Modifiez l'umask, puis créez un autre nouveau fichier.</li>\n<li>Vérifiez à nouveau les permissions sur le nouveau fichier, que vous attendez-vous à voir ?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Chaque fichier créé est accompagné d'un ensemble de permissions par défaut. Si vous souhaitez modifier cet ensemble de permissions par défaut, vous pouvez le faire avec la commande umask. Cette commande utilise l'ensemble de permissions en 3 bits que nous voyons dans les permissions numériques. \n\nAu lieu d'ajouter ces permissions, umask les supprime. \n\n<pre>$ umask 021</pre>\n\nDans l'exemple ci-dessus, nous indiquons que nous voulons que les permissions par défaut des nouveaux fichiers permettent aux utilisateurs d'accéder à tout, mais pour les groupes, nous voulons leur retirer leur permission d'écriture et pour les autres, nous voulons leur retirer leur permission d'exécution. L'umask par défaut sur la plupart des distributions est 022, ce qui signifie un accès utilisateur complet, mais pas d'accès en écriture pour les groupes et les autres utilisateurs.\n\nLorsque vous exécutez la commande umask, elle attribuera cet ensemble de permissions par défaut à tout nouveau fichier que vous créez. Cependant, si vous souhaitez le conserver, vous devrez modifier votre fichier de démarrage (.profile), mais nous en discuterons dans une leçon ultérieure.",
          "quizAnswer": "umask",
          "quizQuestion": "Quelle commande est utilisée pour modifier les permissions de fichier par défaut ?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Examinez en détail les permissions pour /etc/passwd, remarquez-vous quelque chose d'autre ? Les fichiers avec le SUID activé sont également facilement reconnaissables.",
          "id": 5,
          "lessonContent": "Il existe de nombreux cas où les utilisateurs normaux ont besoin d'un accès élevé pour effectuer des tâches. L'administrateur système ne peut pas toujours être là pour entrer un mot de passe root à chaque fois qu'un utilisateur a besoin d'accéder à un fichier protégé, c'est pourquoi il existe des bits de permission spéciaux pour permettre ce comportement. L'identifiant utilisateur défini (SUID) permet à un utilisateur d'exécuter un programme en tant que propriétaire du fichier du programme plutôt qu'en tant qu'eux-mêmes.\n\nPrenons un exemple : \n\nDisons que je veux changer mon mot de passe, simple non ? J'utilise simplement la commande passwd :\n\n<pre>$ passwd</pre>\n\nQue fait la commande passwd ? Elle modifie quelques fichiers, mais surtout elle modifie le fichier /etc/shadow. Regardons ce fichier un instant : \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nAttendez une minute, ce fichier est possédé par root ? Comment est-il possible que nous puissions modifier un fichier possédé par root ? \n\nRegardons un autre ensemble de permissions, cette fois de la commande que nous avons exécutée : \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nVous remarquerez un nouveau bit de permission ici <b>s</b>. Ce bit de permission est le SUID, lorsqu'un fichier a ce bit de permission défini, il permet aux utilisateurs qui ont lancé le programme d'obtenir les permissions du propriétaire du fichier ainsi que les permissions d'exécution, dans ce cas root. Fondamentalement, pendant que l'utilisateur exécute la commande passwd, il s'exécute en tant que root.\n\nC'est pourquoi nous pouvons accéder à un fichier protégé comme /etc/shadow lorsque nous exécutons la commande passwd. Maintenant, si vous supprimez ce bit, vous verrez que vous ne pourrez pas modifier /etc/shadow et donc changer votre mot de passe. \n\n<b>Modification du SUID</b>\n\nTout comme les permissions régulières, il existe deux façons de modifier les permissions SUID. \n\n<i>Méthode symbolique :</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Méthode numérique :</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nComme vous pouvez le voir, le SUID est indiqué par un 4 et préfixé à l'ensemble de permissions. Vous pouvez voir le SUID indiqué par un <b>S</b> majuscule, cela signifie qu'il fait toujours la même chose, mais n'a pas les permissions d'exécution.",
          "quizAnswer": "4",
          "quizQuestion": "Quel numéro représente le SUID ?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 6,
          "lessonContent": "Similaire au bit de permission de l'identifiant utilisateur défini, il existe un bit de permission d'identifiant de groupe défini (SGID). Ce bit permet à un programme de s'exécuter comme s'il était membre de ce groupe. \n\nRegardons un exemple : \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nNous pouvons maintenant voir que le bit de permission est dans l'ensemble de permissions du groupe. \n\n<b>Modification de SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nLa représentation numérique pour SGID est 2.",
          "quizAnswer": "2",
          "quizQuestion": "Quel nombre représente le SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Nous n'avons pas encore discuté des processus, nous pouvons quand même jeter un œil à ce changement en temps réel : \n\n<ol>\n<li>Ouvrez une première fenêtre de terminal et exécutez la commande : <b>watch -n 1 \"ps aux | grep passwd\"</b>. Cela surveillera le processus passwd.</li>\n<li>Ouvrez une deuxième fenêtre de terminal et exécutez : <b>passwd</b></li>\n<li>Regardez la première fenêtre de terminal, vous verrez un processus apparaître pour passwd. La première colonne dans le tableau des processus est l'identifiant d'utilisateur effectif, et c'est l'utilisateur root !</li>\n</ol>",
          "id": 7,
          "lessonContent": "Passons un peu aux permissions de processus, souvenez-vous quand je vous ai dit que lorsque vous exécutez la commande passwd avec le bit de permission SUID activé, vous exécutez le programme en tant que root ? C'est vrai, mais est-ce que cela signifie que puisque vous êtes temporairement root, vous pouvez modifier les mots de passe des autres utilisateurs ? Non, heureusement non !\n\nCela est dû aux nombreux UIDs que Linux implémente. Il y a trois UIDs associés à chaque processus :\n\nLorsque vous lancez un processus, il s'exécute avec les mêmes permissions que l'utilisateur ou le groupe qui l'a lancé, c'est ce qu'on appelle un <b>identifiant d'utilisateur effectif</b>. Cet UID est utilisé pour accorder des droits d'accès à un processus. Donc naturellement, si Bob a lancé la commande touch, le processus s'exécuterait comme lui et tous les fichiers qu'il crée seraient sous sa propriété.\n\nIl y a un autre UID, appelé <b>identifiant d'utilisateur réel</b>, qui est l'ID de l'utilisateur qui a lancé le processus. Ceux-ci sont utilisés pour retrouver l'utilisateur qui a lancé le processus.\n\nUn dernier UID est l'<b>identifiant d'utilisateur sauvegardé</b>, qui permet à un processus de basculer entre l'UID effectif et l'UID réel, vice versa. C'est utile car nous ne voulons pas que notre processus s'exécute avec des privilèges élevés tout le temps, il est juste bon de les utiliser à des moments spécifiques.\n\nMaintenant, mettons tout cela ensemble en regardant à nouveau la commande passwd.\n\nLorsque vous exécutez la commande passwd, votre UID effectif est votre ID utilisateur, disons que c'est 500 pour l'instant. Oh, mais attendez, rappelez-vous que la commande passwd a la permission SUID activée. Donc lorsque vous l'exécutez, votre UID effectif est maintenant 0 (0 est l'UID de root). Maintenant ce programme peut accéder aux fichiers en tant que root.\n\nDisons que vous avez un petit goût du pouvoir et que vous voulez modifier le mot de passe de Sally, Sally a un UID de 600. Eh bien, vous serez malchanceux, heureusement le processus a également votre UID réel dans ce cas 500. Il sait que votre UID est 500 et donc vous ne pouvez pas modifier le mot de passe de l'UID 600. (Cela est bien sûr contourné si vous êtes un superutilisateur sur une machine et que vous pouvez tout contrôler et changer).\n\nDepuis que vous avez exécuté passwd, il démarrera le processus en utilisant votre UID réel, et il sauvegardera l'UID du propriétaire du fichier (UID effectif), vous pouvez donc basculer entre les deux. Pas besoin de modifier tous les fichiers avec un accès root s'il n'est pas nécessaire.\n\nLa plupart du temps, l'UID réel et l'UID effectif sont les mêmes, mais dans des cas tels que la commande passwd, ils changeront.",
          "quizAnswer": "effectif",
          "quizQuestion": "Quel UID décide des accès à accorder ?",
          "slug": "permissionsdeprocessus",
          "title": "Permissions de processus"
        },
        {
          "exercise": "Quels autres fichiers et répertoires pensez-vous avoir un bit collant activé ?",
          "id": 8,
          "lessonContent": "Un dernier bit de permission spécial dont je veux parler est le bit collant. \n\nCe bit de permission \"colle un fichier/répertoire\", cela signifie que seul le propriétaire ou l'utilisateur root peut supprimer ou modifier le fichier. Cela est très utile pour les répertoires partagés. Jetez un œil à l'exemple ci-dessous :\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nVous verrez un bit de permission spécial à la fin ici <b>t</b>, cela signifie que tout le monde peut ajouter des fichiers, écrire des fichiers, modifier des fichiers dans le répertoire /tmp, mais seul root peut supprimer le répertoire /tmp. \n\n<b>Modifier le bit collant</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nLa représentation numérique du bit collant est <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "Quel symbole représente le bit collant ?",
          "slug": "stickybit",
          "title": "Le bit collant"
        }
      ],
      "slug": "permissions",
      "title": "Permissions"
    },
    {
      "description": "Apprenez-en davantage sur les processus en cours sur le système.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Utilisez la commande ps avec différents indicateurs et voyez comment la sortie change.",
          "id": 1,
          "lessonContent": "Les processus sont les programmes qui s'exécutent sur votre machine. Ils sont gérés par le noyau et chaque processus a un identifiant associé appelé <b>identifiant de processus (PID).</b> Ce PID est attribué dans l'ordre de création des processus. \n\nAllez-y et exécutez la commande ps pour voir la liste des processus en cours d'exécution :\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nCela vous montre un aperçu rapide des processus actuels :\n\n<ul>\n<li>PID: Identifiant de processus</li>\n<li>TTY: Terminal de contrôle associé au processus (nous en parlerons en détail plus tard)</li>\n<li>STAT: Code d'état du processus</li>\n<li>TIME: Temps total d'utilisation du processeur</li>\n<li>CMD: Nom de l'exécutable/commande</li>\n</ul>\n\nSi vous regardez la page de manuel de ps, vous verrez qu'il existe de nombreuses options de commande que vous pouvez passer, elles varieront en fonction des options que vous souhaitez utiliser - BSD, GNU ou Unix. À mon avis, le style BSD est plus populaire à utiliser, donc nous allons opter pour celui-ci. Si vous êtes curieux de connaître la différence entre les styles, il s'agit du nombre de tirets que vous utilisez et des indicateurs.\n\n<pre>$ ps aux</pre>\n\nLe <b>a</b> affiche tous les processus en cours d'exécution, y compris ceux exécutés par d'autres utilisateurs. Le <b>u</b> affiche plus de détails sur les processus. Enfin, le <b>x</b> répertorie tous les processus qui n'ont pas de terminal associé, ces programmes afficheront un ? dans le champ TTY, ils sont les plus courants dans les processus de démon qui se lancent lors du démarrage du système.\n\nVous remarquerez que vous voyez maintenant beaucoup plus de champs, pas besoin de tous les mémoriser, dans un cours ultérieur sur les processus avancés, nous passerons en revue certains d'entre eux à nouveau :\n\n<ul>\n<li>USER: L'utilisateur effectif (celui dont nous utilisons l'accès)</li>\n<li>PID: Identifiant de processus</li>\n<li>%CPU: Temps CPU utilisé divisé par le temps d'exécution du processus</li>\n<li>%MEM: Ratio de la taille de l'ensemble résident du processus par rapport à la mémoire physique de la machine</li>\n<li>VSZ: Utilisation de la mémoire virtuelle de l'ensemble du processus</li>\n<li>RSS: Taille de l'ensemble résident, la mémoire physique non échangée qu'une tâche a utilisée</li>\n<li>TTY: Terminal de contrôle associé au processus</li>\n<li>STAT: Code d'état du processus</li>\n<li>START: Heure de démarrage du processus</li>\n<li>TIME: Temps total d'utilisation du processeur</li>\n<li>COMMAND: Nom de l'exécutable/commande</li>\n</ul>\n\nLa commande ps peut être un peu difficile à lire, pour l'instant les champs sur lesquels nous nous concentrerons le plus sont PID, STAT et COMMAND. \n\nUne autre commande très utile est la commande <b>top</b>, top vous donne des informations en temps réel sur les processus en cours d'exécution sur votre système au lieu d'un instantané. Par défaut, vous obtiendrez un rafraîchissement toutes les 10 secondes. Top est un outil extrêmement utile pour voir quels processus consomment beaucoup de vos ressources. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "Quel indicateur ps est utilisé pour afficher des informations détaillées sur les processus?",
          "slug": "surveiller-processus-commande-ps",
          "title": "ps (Processus)"
        },
        {
          "exercise": "Regardez votre sortie ps et listez toutes les valeurs TTY uniques.",
          "id": 2,
          "lessonContent": "Nous avons discuté de la présence d'un champ TTY dans la sortie ps. Le TTY est le terminal qui a exécuté la commande.\n\nIl existe deux types de terminaux, les <b>périphériques de terminal</b> réguliers et les <b>périphériques de pseudo-terminal</b>. Un périphérique de terminal régulier est un périphérique terminal natif dans lequel vous pouvez saisir du texte et envoyer des sorties à votre système, cela ressemble à l'application de terminal que vous avez lancée pour accéder à votre shell, mais ce n'est pas la même chose. \n\nNous allons passer à l'action pour que vous puissiez voir cela, tapez Ctrl-Alt-F1 pour accéder à TTY1 (la première console virtuelle), vous remarquerez que vous n'avez rien d'autre que le terminal, pas de graphiques, etc. Cela est considéré comme un périphérique de terminal régulier, vous pouvez en sortir avec Ctrl-Alt-F7. \n\nUn pseudo-terminal est ce dans quoi vous avez l'habitude de travailler, ils émulent des terminaux avec la fenêtre de terminal shell et sont indiqués par PTS. Si vous regardez à nouveau ps, vous verrez votre processus shell sous pts/*. \n\nBon, revenons maintenant au contrôle du terminal, les processus sont généralement liés à un terminal de contrôle. Par exemple, si vous exécutez un programme dans votre fenêtre de shell comme find et que vous fermez la fenêtre, votre processus disparaîtra également. \n\nIl existe des processus tels que les processus démon, qui sont des processus spéciaux essentiels au bon fonctionnement du système. Ils démarrent souvent au démarrage du système et sont généralement arrêtés lorsque le système est éteint. Ils s'exécutent en arrière-plan et comme nous ne voulons pas que ces processus spéciaux soient arrêtés, ils ne sont pas liés à un terminal de contrôle. Dans la sortie ps, le TTY est indiqué par un <b>?</b> ce qui signifie qu'il n'a pas de terminal de contrôle.",
          "quizAnswer": "?",
          "quizQuestion": "Quelle valeur est donnée pour un processus qui n'a pas de terminal de contrôle?",
          "slug": "controllingterminal",
          "title": "Contrôle du terminal"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Avant d'aborder des applications plus pratiques des processus, nous devons d'abord comprendre ce qu'ils sont et comment ils fonctionnent. Cette partie peut être déroutante car nous entrons dans les détails techniques, n'hésitez donc pas à revenir sur cette leçon si vous ne souhaitez pas en apprendre davantage pour le moment. \n\nUn processus, comme nous l'avons dit précédemment, est un programme en cours d'exécution sur le système, plus précisément c'est le système qui alloue de la mémoire, du CPU, des E/S pour faire fonctionner le programme. Un processus est une instance d'un programme en cours d'exécution, ouvrez donc 3 fenêtres de terminal, dans deux fenêtres, exécutez la commande <b>cat</b> sans passer d'options (le processus cat restera ouvert en tant que processus car il attend stdin). Maintenant, dans la troisième fenêtre, exécutez : <b>ps aux | grep cat</b>. Vous verrez qu'il y a deux processus pour cat, même s'ils appellent le même programme.\n\nLe noyau est responsable des processus, lorsque nous exécutons un programme, le noyau charge le code du programme en mémoire, détermine et alloue des ressources, puis surveille chaque processus, il sait : \n\n<ul>\n<li>L'état du processus</li>\n<li>Les ressources utilisées et reçues par le processus</li>\n<li>Le propriétaire du processus</li>\n<li>La gestion des signaux (nous en parlerons plus tard)</li>\n<li>Et fondamentalement tout le reste</li>\n</ul>\n\nTous les processus essaient de profiter de cette douce part de ressources, c'est le rôle du noyau de s'assurer que les processus reçoivent la bonne quantité de ressources en fonction de leurs besoins. Lorsqu'un processus se termine, les ressources qu'il a utilisées sont libérées pour d'autres processus.",
          "quizAnswer": "noyau",
          "quizQuestion": "Quel élément gère et contrôle les processus ?",
          "slug": "detailsduprocessus",
          "title": "Détails du processus"
        },
        {
          "exercise": "Jetez un œil à vos processus en cours d'exécution, pouvez-vous voir quels autres processus ont des parents ?",
          "id": 4,
          "lessonContent": "Encore une fois, cette leçon et la suivante sont purement informatives pour vous permettre de voir ce qui se passe en coulisses, n'hésitez pas à y revenir une fois que vous aurez travaillé un peu plus avec les processus.\n\nLorsqu'un nouveau processus est créé, un processus existant se clone essentiellement en utilisant quelque chose appelé l'appel système fork (les appels système seront discutés bien plus tard). L'appel système fork crée un processus enfant presque identique, ce processus enfant prend un nouvel identifiant de processus (PID) et le processus original devient son processus parent et a quelque chose appelé un identifiant de processus parent <b>PPID</b>. Ensuite, le processus enfant peut soit continuer à utiliser le même programme que son parent utilisait auparavant, soit plus souvent utiliser l'appel système execve pour lancer un nouveau programme. Cet appel système détruit la gestion de la mémoire que le noyau avait mise en place pour ce processus et en met en place de nouvelles pour le nouveau programme. \n\nNous pouvons voir cela en action :\n\n<pre>$ ps l</pre>\n\nL'option l nous donne un format \"long\" ou une vue encore plus détaillée de nos processus en cours d'exécution. Vous verrez une colonne étiquetée <b>PPID</b>, c'est l'identifiant du parent. Maintenant, regardez votre terminal, vous verrez un processus en cours d'exécution qui est votre shell, donc sur mon système j'ai un processus bash en cours d'exécution. Rappelez-vous lorsque vous avez exécuté la commande ps l, vous l'avez exécutée à partir du processus qui exécutait bash. Maintenant, vous verrez que le <b>PID</b> du shell bash est le <b>PPID</b> de la commande <b>ps l</b>.\n\nDonc, si chaque processus doit avoir un parent et qu'ils ne sont que des forks les uns des autres, il doit y avoir une mère de tous les processus, n'est-ce pas ? Vous avez raison, lorsque le système démarre, le noyau crée un processus appelé <b>init</b>, il a un PID de 1. Le processus init ne peut pas être terminé à moins que le système ne s'arrête. Il s'exécute avec des privilèges root et exécute de nombreux processus qui maintiennent le système en marche. Nous examinerons de plus près init dans le cours de démarrage du système, pour l'instant sachez simplement que c'est le processus qui engendre tous les autres processus.",
          "quizAnswer": "fork",
          "quizQuestion": "Quel appel système crée un nouveau processus ?",
          "slug": "creationdeprocessus",
          "title": "Création de processus"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Maintenant que nous savons ce qui se passe lorsqu'un processus est créé, que se passe-t-il lorsque nous n'en avons plus besoin ? Soyez prévenus, parfois Linux peut devenir un peu sombre...\n\nUn processus peut se terminer en utilisant l'appel système _exit, ce qui libérera les ressources que le processus utilisait pour une réaffectation réelle. Ainsi, lorsqu'un processus est prêt à se terminer, il informe le noyau de la raison de sa terminaison avec quelque chose appelé un statut de terminaison. Le plus souvent, un statut de 0 signifie que le processus a réussi. Cependant, ce n'est pas suffisant pour terminer complètement un processus. Le processus parent doit reconnaître la terminaison du processus enfant en utilisant l'appel système wait et ce que cela fait, c'est qu'il vérifie le statut de terminaison du processus enfant. Je sais que c'est macabre d'y penser, mais l'appel wait est une nécessité, après tout, quel parent ne voudrait pas savoir comment son enfant est mort ?\n\nIl y a une autre façon de terminer un processus et cela implique l'utilisation de signaux, que nous discuterons bientôt.\n\n<b>Processus Orphelins</b>\n\nLorsqu'un processus parent meurt avant un processus enfant, le noyau sait qu'il ne recevra pas d'appel wait, il transforme donc ces processus en \"orphelins\" et les place sous la responsabilité de init (rappelez-vous la mère de tous les processus). Init effectuera finalement l'appel système wait pour ces orphelins afin qu'ils puissent mourir. \n\n<b>Processus Zombie</b>\n\nQue se passe-t-il lorsqu'un enfant se termine et que le processus parent n'a pas encore appelé wait ? Nous voulons quand même pouvoir voir comment un processus enfant s'est terminé, donc même si le processus enfant est terminé, le noyau transforme le processus enfant en un processus zombie. Les ressources utilisées par le processus enfant sont toujours libérées pour d'autres processus, cependant il y a toujours une entrée dans la table des processus pour ce zombie. Les processus zombies ne peuvent pas non plus être tués, car ils sont techniquement \"morts\", donc vous ne pouvez pas utiliser de signaux pour les tuer. Finalement, si le processus parent appelle l'appel système wait, le zombie disparaîtra, c'est ce qu'on appelle \"reaping\". Si le parent ne fait pas d'appel wait, init adoptera le zombie et effectuera automatiquement un wait et supprimera le zombie. Avoir trop de processus zombies peut être préjudiciable, car ils occupent de l'espace dans la table des processus, s'il est plein, cela empêchera d'autres processus de s'exécuter.",
          "quizAnswer": "0",
          "quizQuestion": "Quel est le statut de terminaison le plus courant pour un processus réussi ?",
          "slug": "terminaisonprocessus",
          "title": "Terminaison de processus"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 6,
          "lessonContent": "Un signal est une notification à un processus qu'il s'est passé quelque chose.\n\n<b>Pourquoi avons-nous des signaux</b>\n\nCe sont des interruptions logicielles et ils ont de nombreuses utilisations :\n\n<ul>\n<li>Un utilisateur peut taper l'un des caractères spéciaux du terminal (Ctrl-C) ou (Ctrl-Z) pour tuer, interrompre ou suspendre des processus</li>\n<li>Des problèmes matériels peuvent survenir et le noyau veut en informer le processus</li>\n<li>Des problèmes logiciels peuvent survenir et le noyau veut en informer le processus</li>\n<li>Ils sont essentiellement des moyens par lesquels les processus peuvent communiquer</li>\n</ul>\n\n<b>Processus de signal</b>\n\nLorsqu'un signal est généré par un événement, il est ensuite livré à un processus, il est considéré dans un état en attente jusqu'à ce qu'il soit livré. Lorsque le processus est exécuté, le signal sera livré. Cependant, les processus ont des masques de signaux et ils peuvent définir la livraison du signal pour être bloquée si spécifié. Lorsqu'un signal est livré, un processus peut faire une multitude de choses : \n\n<ul>\n<li>Ignorer le signal</li>\n<li>\"Attraper\" le signal et exécuter une routine de gestion spécifique</li>\n<li>Le processus peut être terminé, contrairement à l'appel système de sortie normal</li>\n<li>Bloquer le signal, en fonction du masque de signal</li>\n</ul>\n\n<b>Signaux courants</b>\n\nChaque signal est défini par des entiers avec des noms symboliques qui sont sous la forme de SIGxxx. Certains des signaux les plus courants sont : \n\n<ul>\n<li>SIGHUP ou HUP ou 1 : Raccrochage</li>\n<li>SIGINT ou INT ou 2 : Interruption</li>\n<li>SIGKILL ou KILL ou 9 : Tuer</li>\n<li>SIGSEGV ou SEGV ou 11 : Violation de segmentation</li>\n<li>SIGTERM ou TERM ou 15 : Terminaison logicielle</li>\n<li>SIGSTOP ou STOP : Arrêt</li>\n</ul>\n\nLes nombres peuvent varier avec les signaux, donc ils sont généralement désignés par leurs noms.\n\nCertains signaux sont inbloquables, un exemple est le signal SIGKILL. Le signal KILL détruit le processus.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "Quel signal est inbloquable?",
          "slug": "signauxprocessus",
          "title": "Signaux"
        },
        {
          "exercise": "Tuez certains processus en utilisant différents signaux.",
          "id": 7,
          "lessonContent": "Vous pouvez envoyer des signaux qui terminent des processus, une commande appropriée est nommée la commande kill. \n\n<pre>$ kill 12445</pre>\n\nLe 12445 est le PID du processus que vous souhaitez tuer. Par défaut, il envoie un signal TERM. Le signal SIGTERM est envoyé à un processus pour demander sa terminaison en lui permettant de libérer proprement ses ressources et de sauvegarder son état. \n\nVous pouvez également spécifier un signal avec la commande kill: \n\n<pre>$ kill -9 12445</pre>\n\nCela exécutera le signal SIGKILL et tuera le processus. \n\n<b>Différences entre SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nCes signaux semblent tous raisonnablement similaires, mais ils ont leurs différences. \n\n<ul>\n<li>SIGHUP - Raccrocher, envoyé à un processus lorsque le terminal de contrôle est fermé. Par exemple, si vous fermez une fenêtre de terminal dans laquelle un processus s'exécutait, vous recevriez un signal SIGHUP. Donc en gros, on vous a raccroché au nez</li>\n<li>SIGINT - Est un signal d'interruption, donc vous pouvez utiliser Ctrl-C et le système essaiera de tuer le processus en douceur</li>\n<li>SIGTERM - Tuer le processus, mais lui permettre de faire un peu de nettoyage d'abord</li>\n<li>SIGKILL - Tuer le processus, le tuer à la hache, ne fait aucun nettoyage</li>\n<li>SIGSTOP - Arrêter/suspendre un processus</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "Quel est le nom du signal pour la commande kill par défaut?",
          "slug": "tuerprocessus",
          "title": "tuer (Terminer)"
        },
        {
          "exercise": "Quels processus ne sont pas très gentils et pourquoi?",
          "id": 8,
          "lessonContent": "Lorsque vous exécutez plusieurs tâches sur votre ordinateur, comme Chrome, Microsoft Word ou Photoshop en même temps, il peut sembler que ces processus s'exécutent simultanément, mais ce n'est pas tout à fait vrai. \n\nLes processus utilisent le CPU pendant une petite période de temps appelée tranche de temps. Ensuite, ils font une pause pendant quelques millisecondes et un autre processus obtient une petite tranche de temps. Par défaut, la planification des processus se fait de manière circulaire. Chaque processus obtient suffisamment de tranches de temps jusqu'à ce qu'il ait terminé son traitement. Le noyau gère tous ces changements de processus et le fait plutôt bien la plupart du temps.\n\nLes processus ne sont pas en mesure de décider quand et combien de temps ils obtiennent du temps CPU, si tous les processus se comportaient normalement, ils obtiendraient chacun (à peu près) une quantité égale de temps CPU. Cependant, il existe un moyen d'influencer l'algorithme de planification des processus du noyau avec une valeur de gentillesse. La gentillesse est un nom assez étrange, mais ce qu'elle signifie, c'est que les processus ont un nombre pour déterminer leur priorité pour le CPU. Un nombre élevé signifie que le processus est gentil et a une priorité plus basse pour le CPU, et un nombre bas ou négatif signifie que le processus n'est pas très gentil et veut obtenir autant de CPU que possible. \n\n<pre>$ top</pre>\n\nVous pouvez voir une colonne pour NI en ce moment, c'est le niveau de gentillesse d'un processus.\n\nPour changer le niveau de gentillesse, vous pouvez utiliser les commandes nice et renice:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nLa commande nice est utilisée pour définir la priorité pour un nouveau processus. La commande renice est utilisée pour définir la priorité sur un processus existant. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "plus bas",
          "quizQuestion": "Si je veux qu'un processus obtienne plus de priorité CPU, dois-je utiliser un nombre nice plus bas ou plus élevé?",
          "slug": "gentillesseprocessus",
          "title": "gentillesse"
        },
        {
          "exercise": "Jetez un œil aux processus en cours d'exécution sur votre système et vérifiez leurs états de processus.",
          "id": 9,
          "lessonContent": "Jetons un coup d'œil à nouveau à la commande ps aux :\n\n<pre>$ ps aux</pre>\n\nDans la colonne STAT, vous verrez de nombreuses valeurs. Un processus Linux peut se trouver dans plusieurs états différents. Les codes d'état les plus courants que vous verrez sont décrits ci-dessous :\n\n<ul>\n<li>R : en cours d'exécution ou prêt à être exécuté, il attend simplement que le CPU le traite</li>\n<li>S : sommeil interruptible, en attente de l'achèvement d'un événement, comme une entrée depuis le terminal</li>\n<li>D : sommeil non interruptible, des processus qui ne peuvent pas être tués ou interrompus par un signal, généralement pour les arrêter, vous devez redémarrer ou résoudre le problème</li>\n<li>Z : Zombie, nous avons discuté dans une leçon précédente que les zombies sont des processus terminés qui attendent que leur statut soit collecté</li>\n<li>T : Arrêté, un processus qui a été suspendu/arrêté</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "Quel code STAT est utilisé pour représenter un sommeil non interruptible ?",
          "slug": "processstates",
          "title": "États des processus"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 10,
          "lessonContent": "Rappelez-vous que tout dans Linux est un fichier, même les processus. Les informations sur les processus sont stockées dans un système de fichiers spécial connu sous le nom de système de fichiers /proc.\n\n<pre>$ ls /proc</pre>\n\nVous devriez voir plusieurs valeurs ici, il y a des sous-répertoires pour chaque PID. Si vous avez regardé un PID dans la sortie ps, vous seriez en mesure de le trouver dans le répertoire /proc.\n\nAllez-y et entrez l'un des processus et regardez ce fichier :\n\n<pre>$ cat /proc/12345/status</pre>\n\nVous devriez voir des informations sur l'état du processus ainsi que des informations plus détaillées. Le répertoire /proc est la façon dont le noyau voit le système, donc il y a beaucoup plus d'informations ici que ce que vous verriez dans ps.",
          "quizAnswer": "/proc",
          "quizQuestion": "Quel système de fichiers stocke les informations sur les processus?",
          "slug": "systèmedefichiersproc",
          "title": "/ Système de fichiers proc"
        },
        {
          "exercise": "Déplacez quelques tâches entre l'arrière-plan et le premier plan",
          "id": 11,
          "lessonContent": "Imaginons que vous travaillez sur une seule fenêtre de terminal et que vous exécutez une commande qui prend une éternité. Vous ne pouvez pas interagir avec le shell tant qu'elle n'est pas terminée, cependant nous voulons continuer à travailler sur nos machines, donc nous avons besoin de garder ce shell ouvert. Heureusement, nous pouvons contrôler la façon dont nos processus s'exécutent avec les tâches : \n\n<b>Envoyer une tâche en arrière-plan</b>\n\nAjouter un esperluette (&) à la commande l'exécutera en arrière-plan afin que vous puissiez toujours utiliser votre shell. Voyons un exemple :\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Afficher toutes les tâches en arrière-plan</b>\n\nMaintenant vous pouvez voir les tâches que vous venez d'envoyer en arrière-plan.\n\n<pre>$ jobs\n\n[1]    En cours     sleep 1000 &\n[2]-   En cours     sleep 1001 &\n[3]+   En cours     sleep 1002 &\n\n</pre>\n\nCela vous montrera l'identifiant de la tâche dans la première colonne, puis le statut et la commande qui a été exécutée. Le <b>+</b> à côté de l'identifiant de la tâche signifie que c'est la tâche en arrière-plan la plus récente qui a démarré. La tâche avec le <b>-</b> est la deuxième commande la plus récente.\n\n<b>Envoyer une tâche en arrière-plan sur une tâche existante</b>\n\nSi vous avez déjà lancé une tâche et que vous voulez l'envoyer en arrière-plan, vous n'avez pas besoin de la terminer et de la redémarrer. Suspendez d'abord la tâche avec Ctrl-Z, puis exécutez la commande <b>bg</b> pour l'envoyer en arrière-plan.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Arrêté     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    En cours     sleep 1000 &\n[2]    En cours     sleep 1001 &\n[3]-   En cours     sleep 1002 &\n[4]+   En cours     sleep 1003 &\n</pre>\n\n<b>Déplacer une tâche de l'arrière-plan au premier plan</b>\n\nPour ramener une tâche de l'arrière-plan, spécifiez simplement l'identifiant de la tâche que vous voulez. Si vous exécutez fg sans options, cela ramènera la tâche en arrière-plan la plus récente (la tâche avec le signe + à côté d'elle)\n\n<pre>$ fg %1</pre>\n\n<b>Arrêter les tâches en arrière-plan</b>\n\nTout comme pour déplacer des tâches de l'arrière-plan, vous pouvez utiliser la même forme pour arrêter les processus en utilisant leur identifiant de tâche.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "Quelle commande est utilisée pour lister les tâches en arrière-plan ?",
          "slug": "controledestaches",
          "title": "Contrôle des tâches"
        }
      ],
      "slug": "processes",
      "title": "Processus"
    },
    {
      "description": "Apprenez tout sur les outils de gestion de paquets dpkg, apt-get, rpm et yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 1,
          "lessonContent": "Votre système est composé de nombreux paquets tels que des navigateurs Internet, des éditeurs de texte, des lecteurs multimédias, etc. Ces paquets sont gérés via des gestionnaires de paquets, qui installent et maintiennent les logiciels sur votre système. Tous les paquets ne sont pas installés via des gestionnaires de paquets, cependant, vous pouvez souvent installer des paquets directement à partir de leur code source (nous y reviendrons bientôt). Cependant, la plupart du temps, vous utiliserez un gestionnaire de paquets pour installer des logiciels, la variété la plus courante de paquets étant Debian (.deb) et Red Hat (.rpm). Les paquets de style Debian sont utilisés dans des distributions telles que Debian, Ubuntu, LinuxMint, etc. Les paquets de style Red Hat sont présents dans Red Hat Enterprise Linux, Fedora, CentOS, etc.\n\nQuels sont les paquets? Vous pouvez les connaître sous le nom de Chrome, Photoshop, etc., mais ce qu'ils sont vraiment, ce sont simplement beaucoup et beaucoup de fichiers qui ont été compilés en un seul. Les personnes (ou parfois une seule personne) qui écrivent ce logiciel sont appelées <b>fournisseurs amont</b>, ils compilent leur code et rédigent comment l'installer. Ces fournisseurs amont travaillent à la sortie de nouveaux logiciels et à la mise à jour des logiciels existants. Lorsqu'ils sont prêts à le publier dans le monde, ils envoient leur paquet aux <b>mainteneurs de paquets</b>, qui se chargent de mettre ce logiciel entre les mains des utilisateurs. Ces mainteneurs de paquets examinent, gèrent et distribuent ce logiciel sous forme de paquets.",
          "quizAnswer": "",
          "quizQuestion": "Aucune question, passez à la suite !",
          "slug": "softwaredistribution",
          "title": "Distribution de logiciels"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 2,
          "lessonContent": "Comment les packages qui sont téléchargés sur internet se retrouvent-ils sur nos ordinateurs ? Allez-vous sur la page de téléchargement de chaque package que vous voulez et cliquez sur télécharger et installer ? Eh bien, en réalité, vous pouvez le faire, mais il y a quelque chose de mieux appelé dépôts de packages. Les dépôts sont simplement des emplacements de stockage central pour les packages. Il existe des tonnes de dépôts qui contiennent de nombreux packages et surtout ils se trouvent tous sur internet, pas de disques d'installation ridicules. Votre machine ne sait pas où chercher ces dépôts à moins que vous ne lui disiez explicitement où chercher.\n\nPar exemple, disons que je veux le logiciel WackyWidgets sur ma machine. Eh bien, WackyWidgets gère ses propres dépôts pour ses packages de widgets, à l'intérieur de ce dépôt se trouvent 10 packages, le package CoolWidget, le package SuperWidget, etc. WackyWidgets héberge ce dépôt à un lien source appelé : http://download.widgets/linux/deb/\n\nMaintenant, au lieu d'aller sur leur site web pour télécharger le package directement, vous pouvez dire à votre machine de trouver le logiciel WackyWidgets à partir du lien source.\n\nVotre distribution est déjà livrée avec des sources pré-approuvées pour obtenir des packages et c'est ainsi qu'elle installe tous les packages de base que vous voyez sur votre système. Sur un système Debian, ce fichier de sources est le fichier <b>/etc/apt/sources.list</b>. Votre machine saura chercher là-bas et vérifier les dépôts source que vous avez ajoutés.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Où se trouve le fichier de sources dans un système Debian ?",
          "slug": "depotsdepackages",
          "title": "Dépôts de packages"
        },
        {
          "exercise": "Familiarisez-vous avec la documentation de tar et examinez les autres options disponibles dans la page de manuel.",
          "id": 3,
          "lessonContent": "Avant de nous plonger dans l'installation de packages et les différents gestionnaires, nous devons discuter de l'archivage et de la compression de fichiers, car vous rencontrerez très probablement ces concepts lorsque vous chercherez des logiciels sur Internet. \n\nVous savez probablement déjà ce qu'est une archive de fichiers, vous avez très probablement rencontré des types de fichiers tels que .rar et .zip. Ce sont des archives de fichiers, elles contiennent de nombreux fichiers à l'intérieur, mais ils sont regroupés dans un seul fichier appelé archive.\n\n<b>Compression de fichiers avec gzip</b>\n\ngzip est un programme utilisé pour compresser des fichiers sous Linux, ils ont une extension .gz. \n\nPour compresser un fichier :\n<pre>$ gzip monsuperfichier</pre>\n\nPour décompresser le fichier :\n<pre>$ gunzip monsuperfichier.gz</pre>\n\n<b>Création d'archives avec tar</b>\nMalheureusement, gzip ne peut pas regrouper plusieurs fichiers dans une seule archive pour nous. Heureusement, nous avons le programme tar qui le peut. Lorsque vous créez une archive avec tar, elle aura une extension .tar. \n\n<pre>$ tar cvf monfichiertar.tar monsuperfichier1 monsuperfichier2</pre>\n\n<ul>\n<li>c - créer</li>\n<li>v - indique au programme d'être verbeux et de nous montrer ce qu'il fait</li>\n<li>f - le nom du fichier tar doit venir après cette option, si vous créez un fichier tar, vous devrez lui donner un nom</li>\n</ul>\n\n<b>Décompression d'archives avec tar</b>\n\nPour extraire le contenu d'un fichier tar, utilisez : \n\n<pre>$ tar xvf monfichiertar.tar</pre>\n\n<ul>\n<li>x - extraire</li>\n<li>v - indique au programme d'être verbeux et de nous montrer ce qu'il fait</li>\n<li>f - le fichier que vous souhaitez extraire</li>\n</ul>\n\n<b>Compression/décompression d'archives avec tar et gzip</b>\n\nVous verrez souvent un fichier tar compressé tel que : monarchivecompressee.tar.gz, il vous suffit de travailler de l'extérieur vers l'intérieur, donc d'abord supprimer la compression avec gunzip, puis vous pouvez décompresser le fichier tar. Ou vous pouvez également utiliser l'option <b>z</b> avec tar, qui lui dit simplement d'utiliser l'utilitaire gzip ou gunzip.\n\nCréer un fichier tar compressé :\n<pre>$ tar czf monfichier.tar.gz</pre>\n\nDécompresser et extraire : \n<pre>$ tar xzf fichier.tar</pre>\n\nSi vous avez besoin d'aide, rappelez-vous de ceci : e<b>X</b>traire tous les <b>Z</b> fichiers !\n\ntar est l'une de ces commandes si importantes et pourtant vous ne vous en souvenez jamais vraiment, xkcd pertinent : <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Autres Utilitaires</b>\n\nTout au long de votre parcours sur Linux, vous rencontrerez d'autres types d'archives et de compression tels que : bzip2, compress, zip, unzip, etc. Ils sont un peu moins courants, mais gardez à l'esprit que différents utilitaires nécessiteront des commandes différentes.",
          "quizAnswer": "c",
          "quizQuestion": "Quel drapeau tar est utilisé pour créer des archives?",
          "slug": "compressedarchivestar",
          "title": "tar and gzip"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 4,
          "lessonContent": "Les packages fonctionnent très rarement seuls, ils sont le plus souvent accompagnés de dépendances pour les aider à fonctionner. Par exemple, disons que nous avons un groupe de restaurants, ces restaurants proposent tous une cuisine différente, cependant ils se procurent tous leurs ingrédients auprès de la même ferme. Leur nourriture dépend des approvisionnements de la ferme, si la ferme arrêtait soudainement de fournir de la nourriture, alors les restaurants se retrouveraient dans un état assez critique. \n\nSous Linux, ces dépendances sont souvent d'autres packages ou des bibliothèques partagées. Les bibliothèques partagées sont des bibliothèques de code que d'autres programmes veulent utiliser et qu'ils ne veulent pas avoir à réécrire eux-mêmes. Pensez de nouveau au restaurant, combien de travail cela représenterait-il si chaque restaurant cultivait aussi sa propre nourriture ? Trop.\n\nNous approfondirons davantage les bibliothèques partagées dans le cours sur le système de fichiers, donc pour l'instant souvenez-vous simplement que les packages ont des dépendances pour les aider à fonctionner, que ces dépendances soient d'autres packages ou des bibliothèques ; si les dépendances ne sont pas présentes, le package finira dans un état cassé et la plupart du temps ne s'installera même pas.",
          "quizAnswer": "",
          "quizQuestion": "Pas de questions, passez à la suite !",
          "slug": "packagedependencies",
          "title": "Dépendances des packages"
        },
        {
          "exercise": "Trouvez un programme que vous souhaitez installer sur votre système comme Google Chrome et installez-le en utilisant l'une de ces commandes.",
          "id": 5,
          "lessonContent": "Bien que la plupart de ce cours concerne les systèmes de gestion de paquets (les Batman de la gestion de paquets), nous ne devons pas oublier les Robins. Bien qu'ils soient très utiles et fiables, ils ne viennent pas avec la superbe batmobile et la ceinture d'utilités.\n\nTout comme .exe est un fichier exécutable unique, il en va de même pour .deb et .rpm. Vous ne les verriez normalement pas si vous utilisez des dépôts de paquets, mais si vous téléchargez directement des paquets, vous les obtiendrez très probablement dans ces formats populaires. De toute évidence, ils sont propres à leurs distributions, .deb pour Debian et .rpm pour Red Hat.\n\nPour installer ces paquets directs, vous pouvez utiliser les commandes de gestion de paquets : rpm et dpkg. Ces outils sont utilisés pour installer des fichiers de paquets, cependant ils n'installeront pas les dépendances du paquet, donc si votre paquet avait 10 dépendances, vous devriez installer ces paquets séparément, puis leurs dépendances et ainsi de suite. Comme vous pouvez le voir, c'est l'une des raisons qui ont donné naissance aux systèmes de gestion complets dont nous discuterons plus tard.\n\nGardez à l'esprit qu'il y aura d'innombrables fois où vous aurez besoin d'installer, de consulter ou de vérifier un paquet avec l'un de ces outils, alors souvenez-vous de ces commandes. \n\n<b>Installer un paquet</b>\n\n<pre>\nDebian : $ dpkg -i some_deb_package.deb\nRPM : $ rpm -i some_rpm_package.rpm\n</pre>\n\nLe <b>i</b> signifie installer. Vous pouvez également utiliser le format plus long de --install. \n\n<b>Supprimer un paquet</b>\n\n<pre>\nDebian : $ dpkg -r some_deb_package.deb\nRPM : $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian : <b>r</b> pour supprimer\nRPM : <b>e</b> pour effacer\n\n<b>Lister les paquets installés</b>\n\n<pre>\nDebian : $ dpkg -l\nRPM : $ rpm -qa\n</pre>\n\nDebian : <b>l</b> pour lister\nRPM : <b>q</b> pour interroger et <b>a</b> pour tous",
          "quizAnswer": "dpkg",
          "quizQuestion": "Quel est l'outil de gestion de paquets pour les fichiers .deb ?",
          "slug": "packageinstalltools",
          "title": "rpm and dpkg"
        },
        {
          "exercise": "Exécutez chacune de ces commandes de paquet et observez la sortie que vous recevez.",
          "id": 6,
          "lessonContent": "Ah, les Batmans de la gestion des paquets, ces systèmes sont livrés avec tout ce qu'il faut pour rendre l'installation, la suppression et les modifications de paquets plus faciles, y compris l'installation des dépendances des paquets. Deux des systèmes de gestion les plus populaires sont <b>yum</b> et <b>apt</b>. Yum est exclusif à la famille Red Hat et apt est exclusif à la famille Debian.\n\n<b>Installer un paquet à partir d'un dépôt</b>\n\n<pre>\nDebian: $ apt install nom_du_paquet\nRPM: $ yum install nom_du_paquet\n</pre>\n\n<b>Supprimer un paquet</b>\n\n<pre>\nDebian: $ apt remove nom_du_paquet\nRPM: $ yum erase nom_du_paquet\n</pre>\n\n<b>Mise à jour des paquets pour un dépôt</b>\n\nIl est toujours préférable de mettre à jour vos dépôts de paquets pour qu'ils soient à jour avant d'installer et de mettre à jour un paquet. \n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Obtenir des informations sur un paquet installé</b>\n\n<pre>\nDebian: apt show nom_du_paquet\nRPM: yum info nom_du_paquet\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Quelle commande est utilisée pour afficher les informations sur un paquet dans un système Debian?",
          "slug": "systèmesdegestiondepaquets",
          "title": "yum et apt"
        },
        {
          "exercise": "Trouvez un programme en code source (à partir d'un site de confiance) et installez-le à partir de la source.",
          "id": 7,
          "lessonContent": "Souvent, vous rencontrerez un package obscur qui n'est disponible que sous forme de code source pur. Vous devrez utiliser quelques commandes pour compiler et installer ce package de code source sur votre système. \n\nTout d'abord, vous devrez avoir le logiciel pour installer les outils qui vous permettront de compiler le code source. \n\n<pre>$ sudo apt install build-essential</pre>\n\nUne fois cela fait, extrayez le contenu du fichier du package, très probablement un fichier .tar.gz. \n\n<pre>$ tar -xzvf package.tar.gz</pre>\n\nAvant de faire quoi que ce soit, consultez le fichier README ou INSTALL à l'intérieur du package. Parfois, il y aura des instructions d'installation spécifiques. \n\nEn fonction de la méthode de compilation utilisée par le développeur, vous devrez utiliser différentes commandes, telles que cmake ou autre chose.\n\nCependant, le plus souvent, vous verrez une compilation de base avec make, donc nous en discuterons :\n\nÀ l'intérieur du contenu du package se trouvera un script de configuration, ce script vérifie les dépendances sur votre système et s'il vous manque quelque chose, vous verrez une erreur et vous devrez corriger ces dépendances. \n\n<pre>$ ./configure</pre>\n\nLe <b>./</b> vous permet d'exécuter un script dans le répertoire actuel. \n\n<pre>$ make</pre>\n\nÀ l'intérieur du contenu du package, il y a un fichier appelé Makefile qui contient les règles de construction du logiciel. Lorsque vous exécutez la commande make, elle examine ce fichier pour construire le logiciel.\n\n<pre>$ sudo make install</pre>\n\nCette commande installe réellement le package, elle copiera les fichiers corrects aux emplacements corrects sur votre ordinateur.\n\nSi vous souhaitez désinstaller le package, utilisez :\n\n<pre>$ sudo make uninstall</pre>\n\nSoyez prudent lorsque vous utilisez make install, vous pourriez ne pas réaliser tout ce qui se passe en arrière-plan. Si vous décidez de supprimer ce package, vous pourriez ne pas réellement tout supprimer car vous n'avez pas réalisé ce qui a été ajouté à votre système. Oubliez tout ce que je viens de vous expliquer à propos de make install et utilisez plutôt la commande <b>checkinstall</b>. Cette commande créera un fichier .deb pour vous que vous pourrez facilement installer et désinstaller. \n\n<pre>$ sudo checkinstall</pre> \n\nCette commande va essentiellement \"make install\" et construire un package .deb et l'installer. Cela rendra plus facile la suppression du package plus tard.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "Que devriez-vous utiliser toujours à la place de make install ?",
          "slug": "compilerlecodesource",
          "title": "Compiler le code source"
        }
      ],
      "slug": "packages",
      "title": "Packages"
    },
    {
      "description": "Apprenez-en davantage sur les appareils Linux et comment ils interagissent avec le noyau et l'espace utilisateur.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Consultez le contenu du répertoire /dev, reconnaissez-vous des périphériques familiers?",
          "id": 1,
          "lessonContent": "Lorsque vous connectez un périphérique à votre machine, il a généralement besoin d'un pilote de périphérique pour fonctionner correctement. Vous pouvez interagir avec les pilotes de périphérique via des fichiers de périphérique ou des nœuds de périphérique, qui sont des fichiers spéciaux ressemblant à des fichiers réguliers. Comme ces fichiers de périphérique sont similaires à des fichiers réguliers, vous pouvez utiliser des programmes tels que ls, cat, etc. pour interagir avec eux. Ces fichiers de périphérique sont généralement stockés dans le répertoire /dev. Allez-y et faites un ls du répertoire /dev sur votre système, vous verrez un grand nombre de fichiers de périphérique qui sont sur votre système. \n\n<pre>$ ls /dev </pre>\n\nCertains de ces périphériques que vous avez déjà utilisés et avec lesquels vous avez interagi, comme /dev/null. Souvenez-vous que lorsque nous envoyons une sortie vers /dev/null, le noyau sait que ce périphérique prend toute notre entrée et la rejette simplement, donc rien n'est renvoyé.\n\nAutrefois, si vous vouliez ajouter un périphérique à votre système, vous ajoutiez le fichier de périphérique dans /dev et l'oubliiez probablement ensuite. Eh bien, répétez cela quelques fois et vous verrez où était le problème. Le répertoire /dev serait encombré de fichiers de périphérique statiques de périphériques que vous avez depuis longtemps mis à niveau, arrêté d'utiliser, etc. Les périphériques se voient également attribuer des fichiers de périphérique dans l'ordre où le noyau les trouve. Ainsi, si à chaque redémarrage de votre système, les périphériques pouvaient avoir des fichiers de périphérique différents en fonction de leur découverte.\n\nHeureusement, nous n'utilisons plus cette méthode, maintenant nous avons quelque chose que nous utilisons pour ajouter et supprimer dynamiquement les périphériques actuellement utilisés sur le système et nous en discuterons dans les prochaines leçons.",
          "quizAnswer": "/dev",
          "quizQuestion": "Où sont stockés les fichiers de périphérique sur le système?",
          "slug": "devdirectory",
          "title": "/dev répertoire"
        },
        {
          "exercise": "Regardez votre répertoire /dev et découvrez quels types de périphériques vous pouvez voir.",
          "id": 2,
          "lessonContent": "Avant de discuter de la gestion des périphériques, regardons en fait quelques périphériques.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nLes colonnes sont les suivantes de gauche à droite :\n\n<ul>\n<li>Permissions</li>\n<li>Propriétaire</li>\n<li>Groupe</li>\n<li>Numéro de périphérique majeur</li>\n<li>Numéro de périphérique mineur</li>\n<li>Horodatage</li>\n<li>Nom du périphérique</li>\n</ul>\n\nRappelez-vous que dans la commande ls, vous pouvez voir le type de fichier avec le premier bit de chaque ligne. Les fichiers de périphérique sont désignés comme suit : \n\n<ul>\n<li>c - caractère</li>\n<li>b - bloc</li>\n<li>p - tube</li>\n<li>s - socket</li>\n</ul>\n\n<b>Périphérique Caractère</b>\n\nCes périphériques transfèrent des données, mais un caractère à la fois. Vous verrez beaucoup de pseudo-périphériques (/dev/null) en tant que périphériques de caractères, ces périphériques ne sont pas vraiment connectés physiquement à la machine, mais ils permettent une plus grande fonctionnalité au système d'exploitation. \n\n<b>Périphérique Bloc</b>\n\nCes périphériques transfèrent des données, mais par blocs de taille fixe. Vous verrez le plus souvent des périphériques qui utilisent des blocs de données en tant que périphériques de bloc, tels que les disques durs, les systèmes de fichiers, etc. \n\n<b>Périphérique Tube</b>\n\nLes tubes nommés permettent à deux processus ou plus de communiquer entre eux, ils sont similaires aux périphériques de caractères, mais au lieu d'envoyer la sortie vers un périphérique, elle est envoyée à un autre processus. \n\n<b>Périphérique Socket</b>\n\nLes périphériques de socket facilitent la communication entre les processus, similaires aux périphériques de tube mais ils peuvent communiquer avec de nombreux processus à la fois. \n\n<b>Caractérisation du Périphérique</b>\n\nLes périphériques sont caractérisés en utilisant deux nombres, le <b>numéro de périphérique majeur</b> et le <b>numéro de périphérique mineur</b>. Vous pouvez voir ces nombres dans l'exemple ls ci-dessus, ils sont séparés par une virgule. Par exemple, disons qu'un périphérique avait les numéros de périphérique : <b>8, 0</b> :\n\nLe numéro de périphérique majeur représente le pilote de périphérique qui est utilisé, dans ce cas 8, qui est souvent le numéro majeur pour les périphériques de bloc sd. Le numéro mineur indique au noyau quel périphérique unique il s'agit dans cette classe de pilote, dans ce cas 0 est utilisé pour représenter le premier périphérique (a).",
          "quizAnswer": "c",
          "quizQuestion": "Quel est le symbole pour les périphériques de caractères dans la commande ls -l ?",
          "slug": "typesdeperipheriques",
          "title": "types de périphériques"
        },
        {
          "exercise": "Écrivez sur les périphériques pseudo et voyez ce qui se passe, faites attention de ne pas écrire sur vos disques à travers ces périphériques !",
          "id": 3,
          "lessonContent": "Voici les noms de périphériques les plus courants que vous rencontrerez : \n\n<b>Périphériques SCSI</b>\n\nSi vous avez un quelconque stockage de masse sur votre machine, il est probable qu'il utilise le protocole SCSI (prononcé \"scuzzy\"). SCSI signifie Small Computer System Interface, c'est un protocole utilisé pour permettre la communication entre les disques, imprimantes, scanners et autres périphériques avec votre système. Vous avez peut-être entendu parler de périphériques SCSI qui ne sont pas réellement utilisés dans les systèmes modernes, cependant nos systèmes Linux associent les disques SCSI avec les disques durs dans /dev. Ils sont représentés par un préfixe sd (disque SCSI) :\n\nFichiers de périphériques SCSI courants :\n\n<ul>\n<li>/dev/sda - Premier disque dur</li>\n<li>/dev/sdb - Deuxième disque dur</li>\n<li>/dev/sda3 - Troisième partition sur le premier disque dur</li>\n</ul>\n\n<b>Périphériques Pseudo</b>\n\nComme nous l'avons déjà discuté, les périphériques pseudo ne sont pas réellement connectés physiquement à votre système, les périphériques pseudo les plus courants sont les périphériques de caractères : \n\n<ul>\n<li>/dev/zero - accepte et rejette toutes les entrées, produit un flux continu de NULL (zéro) bytes</li>\n<li>/dev/null - accepte et rejette toutes les entrées, ne produit aucune sortie</li>\n<li>/dev/random - produit des nombres aléatoires</li>\n</ul>\n\n<b>Périphériques PATA</b>\n\nParfois, dans les anciens systèmes, vous pouvez voir des disques durs être désignés avec un préfixe hd : \n\n<ul>\n<li>/dev/hda - Premier disque dur</li>\n<li>/dev/hdd2 - Deuxième partition sur le 4ème disque dur</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "Quel serait communément le nom du périphérique pour la première partition sur le deuxième disque SCSI ?",
          "slug": "nomsdesperipheriques",
          "title": "Noms des périphériques"
        },
        {
          "exercise": "Consultez le contenu du répertoire /sys et voyez quels fichiers s'y trouvent.",
          "id": 4,
          "lessonContent": "Sysfs a été créé il y a longtemps pour mieux gérer les périphériques de notre système que le répertoire /dev n'arrivait pas à faire. Sysfs est un système de fichiers virtuel, le plus souvent monté sur le répertoire /sys. Il nous fournit des informations plus détaillées que ce que nous pourrions voir dans le répertoire /dev. Les deux répertoires /sys et /dev semblent être très similaires et le sont à certains égards, mais ils présentent des différences majeures. Fondamentalement, le répertoire /dev est simple, il permet à d'autres programmes d'accéder aux périphériques eux-mêmes, tandis que le système de fichiers /sys est utilisé pour afficher des informations et gérer le périphérique. \n\nLe système de fichiers /sys contient essentiellement toutes les informations sur tous les périphériques de votre système, telles que le fabricant et le modèle, où le périphérique est branché, l'état du périphérique, la hiérarchie des périphériques et plus encore. Les fichiers que vous voyez ici ne sont pas des nœuds de périphérique, vous n'interagissez donc pas vraiment avec les périphériques à partir du répertoire /sys, mais vous gérez les périphériques. \n\nJetez un œil au contenu du répertoire /sys:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "Quel répertoire est utilisé pour afficher des informations détaillées sur les périphériques?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Exécutez la commande udevadm donnée et examinez l'entrée.",
          "id": 5,
          "lessonContent": "À l'époque et même aujourd'hui si vous le souhaitez vraiment, vous créeriez des nœuds de périphérique en utilisant une commande telle que : \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nCette commande créera un nœud de périphérique /dev/sdb1 et le définira comme un périphérique de bloc (b) avec un numéro majeur de 8 et un numéro mineur de 3.\n\nPour supprimer un périphérique, vous supprimeriez simplement le fichier du périphérique dans le répertoire /dev. \n\nHeureusement, nous n'avons vraiment plus besoin de le faire grâce à udev. Le système udev crée et supprime dynamiquement les fichiers de périphérique pour nous en fonction de s'ils sont connectés ou non. Il y a un démon udevd qui fonctionne sur le système et qui écoute les messages du noyau concernant les périphériques connectés au système. Udevd analysera ces informations et les fera correspondre avec les règles spécifiées dans /etc/udev/rules.d, en fonction de ces règles, il créera très probablement des nœuds de périphérique et des liens symboliques pour les périphériques. Vous pouvez écrire vos propres règles udev, mais cela dépasse un peu le cadre de cette leçon. Heureusement, votre système est déjà livré avec de nombreuses règles udev, vous n'aurez donc probablement jamais besoin d'écrire les vôtres.\n\nVous pouvez également consulter la base de données udev et sysfs en utilisant la commande <b>udevadm</b>. Cet outil est très utile, mais parfois peut devenir très complexe, une commande simple pour afficher des informations pour un périphérique serait : \n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "Qu'est-ce qui ajoute et supprime dynamiquement des périphériques ?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Essayez chacune de ces commandes et observez la sortie que vous recevez.",
          "id": 6,
          "lessonContent": "Tout comme nous utiliserions la commande ls pour lister les fichiers et répertoires, nous pouvons utiliser des outils similaires qui listent des informations sur les périphériques.\n\n<b>Liste des périphériques USB</b>\n\n<pre>$ lsusb </pre>\n\n<b>Liste des périphériques PCI</b>\n\n<pre>$ lspci </pre>\n\n<b>Liste des périphériques SCSI</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "Quelle commande peut être utilisée pour afficher les périphériques USB?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Utilisez la commande dd pour sauvegarder votre disque et définir la sortie sur un fichier .img.",
          "id": 7,
          "lessonContent": "L'outil dd est super utile pour convertir et copier des données. Il lit l'entrée à partir d'un fichier ou d'un flux de données et l'écrit dans un fichier ou un flux de données. \n\nConsidérez la commande suivante: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nCette commande copie le contenu de backup.img vers /dev/sdb. Elle copiera les données par blocs de 1024 octets jusqu'à ce qu'il n'y ait plus de données à copier. \n\n<ul>\n<li>if=fichier - Fichier d'entrée, lire à partir d'un fichier au lieu de l'entrée standard</li>\n<li>of=fichier - Fichier de sortie, écrire dans un fichier au lieu de la sortie standard</li>\n<li>bs=octets - Taille du bloc, lit et écrit autant d'octets de données à la fois. Vous pouvez utiliser différentes tailles en indiquant la taille avec un k pour kilooctet, m pour mégaoctet, etc., donc 1024 octets équivaut à 1k</li>\n<li>count=nombre - Nombre de blocs à copier.</li>\n</ul>\n\nVous verrez certaines commandes dd qui utilisent l'option count, généralement avec dd si vous voulez copier un fichier qui fait 1 mégaoctet, vous voudrez généralement voir ce fichier comme 1 mégaoctet une fois la copie terminée. Disons que vous exécutez la commande suivante: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nNotre fichier backup.img fait 10M, cependant, dans cette commande, nous disons de copier 1M 2 fois, donc seuls 2M sont copiés, laissant nos données copiées incomplètes. Count peut être utile dans de nombreuses situations, mais si vous copiez simplement des données, vous pouvez généralement omettre count et même bs. Si vous voulez vraiment optimiser vos transferts de données, alors vous voudrez commencer à utiliser ces options.\n\ndd est extrêmement puissant, vous pouvez l'utiliser pour sauvegarder n'importe quoi, y compris des disques entiers, restaurer des images de disque, et plus encore. Faites attention, cet outil puissant peut avoir un prix si vous n'êtes pas sûr de ce que vous faites.",
          "quizAnswer": "bs",
          "quizQuestion": "Quelle est l'option dd pour la taille du bloc?",
          "slug": "commandedd",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Appareils"
    },
    {
      "description": "Apprenez-en davantage sur le système de fichiers Linux, les différents types de systèmes de fichiers, le partitionnement et plus encore.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Regardez à l'intérieur de votre répertoire /usr, quel type d'informations y sont stockées ?",
          "id": 1,
          "lessonContent": "À ce stade, vous êtes probablement bien familiarisé avec la structure des répertoires de votre système, sinon vous le serez bientôt. Les systèmes de fichiers peuvent varier en fonction de leur structure, mais pour la plupart, ils devraient se conformer à la norme de hiérarchie du système de fichiers. \n\nAllez-y et exécutez un <b>ls -l /</b> pour voir les répertoires répertoriés sous le répertoire racine, le vôtre peut être différent du mien, mais les répertoires devraient pour la plupart ressembler à ce qui suit :\n\n<ul>\n<li>/ - Le répertoire racine de toute la hiérarchie du système de fichiers, tout est niché sous ce répertoire.</li>\n<li>/bin - Programmes prêts à l'emploi essentiels (binaires), inclut les commandes les plus basiques telles que ls et cp.</li>\n<li>/boot - Contient les fichiers du chargeur de démarrage du noyau.</li>\n<li>/dev - Fichiers de périphériques.</li>\n<li>/etc - Répertoire de configuration système de base, ne devrait contenir que des fichiers de configuration et aucun binaire.</li>\n<li>/home - Répertoires personnels pour les utilisateurs, contient vos documents, fichiers, paramètres, etc.</li>\n<li>/lib - Contient des fichiers de bibliothèque que les binaires peuvent utiliser.</li>\n<li>/media - Utilisé comme point de montage pour les supports amovibles comme les clés USB.</li>\n<li>/mnt - Systèmes de fichiers temporairement montés.</li>\n<li>/opt - Paquets logiciels d'application optionnels.</li>\n<li>/proc - Informations sur les processus en cours d'exécution actuellement.</li>\n<li>/root - Le répertoire personnel de l'utilisateur root.</li>\n<li>/run - Informations sur le système en cours depuis le dernier démarrage.</li>\n<li>/sbin - Contient des binaires système essentiels, généralement exécutables uniquement par root.</li>\n<li>/srv - Données spécifiques au site qui sont servies par le système.</li>\n<li>/tmp - Stockage pour les fichiers temporaires.</li>\n<li>/usr - Malheureusement nommé, il ne contient le plus souvent pas de fichiers d'utilisateur au sens d'un dossier personnel. Cela est destiné aux logiciels et utilitaires installés par l'utilisateur, cependant cela ne signifie pas que vous ne pouvez pas ajouter de répertoires personnels à l'intérieur. À l'intérieur de ce répertoire se trouvent des sous-répertoires pour /usr/bin, /usr/local, etc.</li>\n<li>/var - Répertoire variable, il est utilisé pour les journaux système, le suivi des utilisateurs, les caches, etc. Fondamentalement, tout ce qui est sujet à des changements tout le temps.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "Dans quel répertoire sont stockés les journaux ?",
          "slug": "hiérarchiedusystèmedefichiers",
          "title": "Hiérarchie du système de fichiers"
        },
        {
          "exercise": "Faites un peu de recherche en ligne sur les autres types de systèmes de fichiers : ReiserFS, ZFS, JFS et d'autres que vous pouvez trouver.",
          "id": 2,
          "lessonContent": "Il existe de nombreuses implémentations de systèmes de fichiers disponibles. Certains sont plus rapides que d'autres, certains prennent en charge un stockage de capacité plus importante et d'autres ne fonctionnent que sur un stockage de capacité plus faible. Les différents systèmes de fichiers ont différentes façons d'organiser leurs données et nous allons détailler les types de systèmes de fichiers qui existent. Comme il existe de nombreuses implémentations différentes, les applications ont besoin d'une manière de gérer les différentes opérations. Il y a donc quelque chose appelé la couche d'abstraction du système de fichiers virtuel (VFS). C'est une couche entre les applications et les différents types de systèmes de fichiers, donc peu importe le système de fichiers que vous avez, vos applications pourront y travailler. \n\nVous pouvez avoir de nombreux systèmes de fichiers sur vos disques, en fonction de la façon dont ils sont partitionnés et nous passerons en revue cela dans une leçon à venir.\n\n<b>Journalisation</b>\n\nLa journalisation est activée par défaut sur la plupart des types de systèmes de fichiers, mais au cas où ce ne serait pas le cas, vous devriez savoir ce qu'elle fait. Disons que vous copiez un gros fichier et tout à coup vous perdez de l'électricité. Eh bien, si vous êtes sur un système de fichiers non journalisé, le fichier finirait corrompu et votre système de fichiers serait incohérent, puis lorsque vous redémarrez, votre système effectuerait une vérification du système de fichiers pour s'assurer que tout va bien. Cependant, les réparations pourraient prendre un certain temps en fonction de la taille de votre système de fichiers. \n\nMaintenant, si vous étiez sur un système journalisé, avant même que votre machine commence à copier le fichier, elle écrirait ce que vous allez faire dans un fichier journal (journal). Maintenant, lorsque vous copiez réellement le fichier, une fois qu'il est terminé, le journal marque cette tâche comme terminée. Le système de fichiers est toujours dans un état cohérent à cause de cela, il saura exactement où vous vous êtes arrêté si votre machine s'éteint brusquement. Cela réduit également le temps de démarrage car au lieu de vérifier l'intégralité du système de fichiers, il regarde simplement votre journal.\n\n<b>Types de systèmes de fichiers de bureau courants</b>\n\n<ul>\n<li>ext4 - Il s'agit de la version la plus récente des systèmes de fichiers natifs Linux. Il est compatible avec les anciennes versions ext2 et ext3. Il prend en charge les volumes de disque jusqu'à 1 exaoctet et les tailles de fichiers jusqu'à 16 téraoctets et bien plus encore. C'est le choix standard pour les systèmes de fichiers Linux.</li>\n<li>Btrfs - \"Better or Butter FS\", c'est un nouveau système de fichiers pour Linux qui est livré avec des instantanés, des sauvegardes progressives, une augmentation des performances et bien plus encore. Il est largement disponible, mais pas encore tout à fait stable et compatible.</li>\n<li>XFS - Système de fichiers de journalisation haute performance, idéal pour un système avec de gros fichiers comme un serveur multimédia.</li>\n<li>NTFS et FAT - Systèmes de fichiers Windows</li>\n<li>HFS+ - Système de fichiers Macintosh</li>\n</ul>\n\nConsultez quels systèmes de fichiers sont sur votre machine: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nLa commande <b>df</b> rapporte l'utilisation de l'espace disque du système de fichiers et d'autres détails sur votre disque, nous parlerons plus de cet outil plus tard.",
          "quizAnswer": "ext4",
          "quizQuestion": "Quel est le type de système de fichiers Linux courant ?",
          "slug": "types-de-systemes-de-fichiers",
          "title": "Types de systèmes de fichiers"
        },
        {
          "exercise": "Exécutez <b>parted -l</b> sur votre machine et évaluez vos résultats.",
          "id": 3,
          "lessonContent": "Les disques durs peuvent être subdivisés en partitions, créant essentiellement plusieurs périphériques de blocs. Pensez à des exemples tels que /dev/sda1 et /dev/sda2, /dev/sda est le disque entier, mais /dev/sda1 est la première partition sur ce disque. Les partitions sont extrêmement utiles pour séparer les données et si vous avez besoin d'un certain système de fichiers, vous pouvez facilement créer une partition au lieu de faire du disque entier un seul type de système de fichiers.\n\n<b>Table des partitions</b>\n\nChaque disque aura une table de partitions, cette table indique au système comment le disque est partitionné. Cette table vous indique où commencent et finissent les partitions, quelles partitions sont amorçables, quels secteurs du disque sont alloués à quelle partition, etc. Il existe deux principaux schémas de table de partitions utilisés, le Master Boot Record (MBR) et le GUID Partition Table (GPT).\n\n<b>Partition</b>\n\nLes disques sont composés de partitions qui nous aident à organiser nos données. Vous pouvez avoir plusieurs partitions sur un disque et elles ne peuvent pas se chevaucher. Si un espace n'est pas alloué à une partition, il est alors appelé espace libre. Les types de partitions dépendent de votre table de partitions. À l'intérieur d'une partition, vous pouvez avoir un système de fichiers ou dédier une partition à d'autres choses comme le swap (nous y reviendrons bientôt).\n\n<i>MBR</i>\n\n<ul>\n<li>Table de partition traditionnelle, était utilisée comme norme</li>\n<li>Peut avoir des partitions primaires, étendues et logiques</li>\n<li>Le MBR a une limite de quatre partitions primaires</li>\n<li>Des partitions supplémentaires peuvent être créées en transformant une partition primaire en partition étendue (il ne peut y avoir qu'une seule partition étendue sur un disque). Ensuite, à l'intérieur de la partition étendue, vous ajoutez des partitions logiques. Les partitions logiques sont utilisées comme n'importe quelle autre partition. Absurde, je sais.</li>\n<li>Prend en charge les disques jusqu'à 2 téraoctets</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>La table de partition GUID (GPT) devient la nouvelle norme pour le partitionnement des disques</li>\n<li>Ne possède qu'un seul type de partition et vous pouvez en créer beaucoup</li>\n<li>Chaque partition a un identifiant unique mondial (GUID)</li>\n<li>Utilisé principalement en conjonction avec le démarrage basé sur UEFI (nous verrons les détails dans un autre cours)</li>\n</ul>\n\n<b>Structure du système de fichiers</b>\n\nNous savons de notre leçon précédente qu'un système de fichiers est une collection organisée de fichiers et de répertoires. Dans sa forme la plus simple, il est composé d'une base de données pour gérer les fichiers et les fichiers eux-mêmes, cependant nous allons entrer dans un peu plus de détails.\n\n<ul>\n<li>Bloc de démarrage - Il est situé dans les premiers secteurs du système de fichiers, et il n'est pas vraiment utilisé par le système de fichiers. Il contient plutôt des informations utilisées pour démarrer le système d'exploitation. Seul un bloc de démarrage est nécessaire par le système d'exploitation. Si vous avez plusieurs partitions, elles auront des blocs de démarrage, mais beaucoup d'entre eux ne sont pas utilisés.</li>\n<li>Super bloc - Il s'agit d'un seul bloc qui vient après le bloc de démarrage, et il contient des informations sur le système de fichiers, telles que la taille de la table d'inodes, la taille des blocs logiques et la taille du système de fichiers.</li>\n<li>Table d'inodes - Pensez-y comme la base de données qui gère nos fichiers (nous avons une leçon entière sur les inodes, donc ne vous inquiétez pas). Chaque fichier ou répertoire a une entrée unique dans la table d'inodes et elle contient diverses informations sur le fichier.</li>\n<li>Blocs de données - Ce sont les données réelles des fichiers et des répertoires.</li>\n</ul>\n\nJetons un coup d'œil aux différentes tables de partitions. Ci-dessous se trouve un exemple de partition utilisant la table de partitionnement MBR (msdos). Vous pouvez voir les partitions primaires, étendues et logiques sur la machine.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModèle: Seagate (scsi)\nDisque /dev/sda: 21.5Go\nTaille des secteurs (logique/physique): 512o/512o\nTable de partitions: msdos\n\nNuméro  Début   Fin     Taille   Type      Système de fichiers     Drapeaux\n 1      1049ko  6860Mo  6859Mo  primaire   ext4                    amorçable\n 2      6861Mo  21.5Go  14.6Go  étendue\n 5      6861Mo  7380Mo  519Mo   logique   linux-swap(v1)\n 6      7381Mo  21.5Go  14.1Go  logique   xfs\n</pre>\n\n\nCet exemple est GPT, utilisant simplement un identifiant unique pour les partitions.\n\n<pre>\nModèle: Clé USB (scsi)\nDisque /dev/sdb: 4041Mo\nTaille des secteurs (logique/physique): 512o/512o\nTable de partitions: gpt\n\nNuméro  Début   Fin     Taille     Système de fichiers  Nom        Drapeaux\n 1      17.4ko  1000Mo  1000Mo                  first\n 2      1000Mo  4040Mo  3040Mo                  second\n</pre>",
          "quizAnswer": "étendue",
          "quizQuestion": "Quel type de partition est utilisé pour créer plus de 4 partitions dans le schéma de partitionnement MBR ?",
          "slug": "anatomiedundisque",
          "title": "Anatomie d'un disque"
        },
        {
          "exercise": "Partitionner une clé USB avec la moitié du disque en ext4 et l'autre moitié en espace libre.",
          "id": 4,
          "lessonContent": "Faisons des manipulations pratiques avec les systèmes de fichiers en travaillant sur le processus sur une clé USB. Si vous n'en avez pas, pas de soucis, vous pouvez quand même suivre ces prochaines leçons. \n\nTout d'abord, nous devrons partitionner notre disque. Il existe de nombreux outils disponibles pour cela : \n\n<ul>\n<li>fdisk - outil de partitionnement en ligne de commande de base, ne prend pas en charge GPT</li>\n<li>parted - c'est un outil en ligne de commande qui prend en charge le partitionnement MBR et GPT</li>\n<li>gparted - c'est la version graphique de parted</li>\n<li>gdisk - fdisk, mais ne prend en charge que GPT, pas MBR</li>\n</ul>\n\nUtilisons parted pour partitionner. Disons que je connecte le périphérique USB et que nous voyons que le nom du périphérique est /dev/sdb2. \n\n<b>Lancer parted</b>\n\n<pre>$ sudo parted</pre>\n\nVous serez entré dans l'outil parted, où vous pouvez exécuter des commandes pour partitionner votre périphérique. \n\n<b>Sélectionner le périphérique</b>\n\n<pre>sélectionner /dev/sdb2</pre>\n\nPour sélectionner le périphérique avec lequel vous travaillerez, sélectionnez-le par son nom de périphérique.\n\n<b>Afficher la table de partition actuelle</b>\n\n<pre>\n(parted) afficher                                                            \nModèle : Seagate (scsi)\nDisque /dev/sda : 21,5 Go\nTaille des secteurs (logique/physique) : 512 o/512 o\nTable de partitions : msdos\n\nNuméro  Début   Fin     Taille   Type      Système de fichiers     Drapeaux\n 1      1049ko  6860Mo  6859Mo  primaire   ext4            boot\n 2      6861Mo  21,5Go  14,6Go  étendue\n 5      6861Mo  7380Mo  519Mo   logique   linux-swap(v1)\n 6      7381Mo  21,5Go  14,1Go  logique   xfs\n</pre>\n\nIci, vous verrez les partitions disponibles sur le périphérique. Les points de <b>début</b> et de <b>fin</b> indiquent où les partitions occupent de l'espace sur le disque dur, vous voudrez trouver un bon emplacement de début et de fin pour vos partitions. \n\n<b>Partitionner le périphérique</b>\n\n<pre>mkpart primaire 123 4567</pre>\n\nChoisissez maintenant un point de départ et d'arrêt et créez la partition, vous devrez spécifier le type de partition en fonction de la table que vous avez utilisée. \n\n<b>Redimensionner une partition</b>\n\nVous pouvez également redimensionner une partition si vous n'avez plus d'espace. \n\n<pre>redimensionner 2 1245 3456</pre>\n\nSélectionnez le numéro de partition, puis les points de départ et d'arrêt où vous souhaitez le redimensionner. \n\nParted est un outil très puissant et vous devez être prudent lorsque vous partitionnez vos disques.",
          "quizAnswer": "mkpart",
          "quizQuestion": "Quelle est la commande parted pour créer une partition?",
          "slug": "partitionnementdedisque",
          "title": "Partitionnement de disque"
        },
        {
          "exercise": "Créez un système de fichiers ext4 sur la clé USB.",
          "id": 5,
          "lessonContent": "Maintenant que vous avez réellement partitionné un disque, créons un système de fichiers!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nAussi simple que cela! L'outil <b>mkfs</b> (make filesystem) nous permet de spécifier le type de système de fichiers que nous voulons et où nous le voulons. Vous ne voudrez créer un système de fichiers que sur un disque nouvellement partitionné ou si vous repartitionnez un ancien. Vous risquez fort de laisser votre système de fichiers dans un état corrompu si vous essayez d'en créer un par-dessus un existant.",
          "quizAnswer": "mkfs",
          "quizQuestion": "Quelle commande est utilisée pour créer un système de fichiers?",
          "slug": "creatingfilesystems",
          "title": "Création de systèmes de fichiers"
        },
        {
          "exercise": "Consultez la page de manuel pour mount et umount et voyez quelles autres options vous pouvez utiliser.",
          "id": 6,
          "lessonContent": "Avant de pouvoir afficher le contenu de votre système de fichiers, vous devrez le monter. Pour cela, j'aurai besoin de l'emplacement du périphérique, du type de système de fichiers et d'un point de montage, le point de montage est un répertoire sur le système où le système de fichiers va être attaché. Donc, nous voulons essentiellement monter notre périphérique sur un point de montage. \n\nCréez d'abord le point de montage, dans notre cas <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nAussi simple que cela ! Maintenant, lorsque nous allons dans /mydrive, nous pouvons voir le contenu de notre système de fichiers, le <b>-t</b> spécifie le type de système de fichiers, puis nous avons l'emplacement du périphérique, puis le point de montage. \n\nPour démonter un périphérique d'un point de montage : \n\n<pre>$ sudo umount /mydrive \nou \n$ sudo umount /dev/sdb2</pre>\n\nRappelez-vous que le noyau nomme les périphériques dans l'ordre où il les trouve. Que se passe-t-il si le nom de notre périphérique change pour une raison quelconque après l'avoir monté ? Eh bien, heureusement, vous pouvez utiliser l'identifiant unique universel (UUID) d'un périphérique à la place d'un nom.\n\nPour voir les UUID sur votre système pour les périphériques de bloc :\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nNous pouvons voir les noms de nos périphériques, leurs types de systèmes de fichiers correspondants et leurs UUID. Maintenant, lorsque nous voulons monter quelque chose, nous pouvons utiliser :\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nLa plupart du temps, vous n'aurez pas besoin de monter des périphériques via leurs UUID, il est beaucoup plus facile d'utiliser le nom du périphérique et souvent le système d'exploitation saura monter des périphériques courants comme les clés USB. Si vous devez monter automatiquement un système de fichiers au démarrage, par exemple si vous avez ajouté un disque dur secondaire, vous voudrez utiliser l'UUID et nous verrons cela dans la prochaine leçon.",
          "quizAnswer": "mount",
          "quizQuestion": "Quelle commande est utilisée pour attacher un système de fichiers ?",
          "slug": "montagedémontagesystèmesdefichiers",
          "title": "monter et démonter"
        },
        {
          "exercise": "Ajoutez le lecteur USB sur lequel nous avons travaillé en tant qu'entrée dans /etc/fstab, lorsque vous redémarrez, vous devriez toujours le voir monté.",
          "id": 7,
          "lessonContent": "Lorsque nous voulons monter automatiquement des systèmes de fichiers au démarrage, nous pouvons les ajouter à un fichier appelé /etc/fstab (prononcé \"eff es tab\" et non \"eff stab\") abréviation de table de systèmes de fichiers. Ce fichier contient une liste permanente des systèmes de fichiers montés.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nChaque ligne représente un système de fichiers, les champs sont : \n\n<ul>\n<li>UUID - Identifiant du périphérique</li>\n<li>Point de montage - Répertoire où le système de fichiers est monté</li>\n<li>Type de système de fichiers</li>\n<li>Options - autres options de montage, voir la page de manuel pour plus de détails</li>\n<li>Dump - utilisé par l'utilitaire de sauvegarde pour décider quand effectuer une sauvegarde, vous devriez simplement le laisser par défaut à 0</li>\n<li>Pass - Utilisé par fsck pour décider de l'ordre dans lequel les systèmes de fichiers doivent être vérifiés, si la valeur est 0, il ne sera pas vérifié</li>\n</ul>\n\nPour ajouter une entrée, modifiez directement le fichier /etc/fstab en utilisant la syntaxe d'entrée ci-dessus. Faites attention lorsque vous modifiez ce fichier, vous pourriez potentiellement vous compliquer un peu la vie si vous faites une erreur.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "Quel fichier est utilisé pour définir comment les systèmes de fichiers doivent être montés ?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Partitionner l'espace libre dans la clé USB pour l'espace swap.",
          "id": 8,
          "lessonContent": "Dans notre exemple précédent, je vous ai montré comment voir votre table de partitions, revenons sur cet exemple, plus précisément cette ligne :\n\n<pre>\nNumber  Start   End     Size    Type      File system     Flags\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n</pre>\n\nQu'est-ce que cette partition swap ? Eh bien, le swap est ce que nous utilisons pour allouer de la mémoire virtuelle à notre système. Si vous manquez de mémoire, le système utilise cette partition pour \"échanger\" des morceaux de mémoire de processus inactifs vers le disque, afin que vous ne soyez pas encombré de mémoire.\n\n<b>Utiliser une partition pour l'espace swap</b>\n\nDisons que nous voulions définir notre partition /dev/sdb2 pour être utilisée comme espace swap. \n\n<ol>\n<li>Assurez-vous d'abord de ne rien avoir sur la partition</li>\n<li>Exécutez : mkswap /dev/sdb2 pour initialiser les zones de swap</li>\n<li>Exécutez : swapon /dev/sdb2 cela activera le périphérique de swap</li>\n<li>Si vous souhaitez que la partition swap persiste au démarrage, vous devez ajouter une entrée dans le fichier /etc/fstab. sw est le type de système de fichiers que vous utiliserez.</li>\n<li>Pour supprimer le swap : swapoff /dev/sdb2</li>\n</ol>\n\nEn général, vous devriez allouer environ le double de l'espace swap par rapport à la mémoire que vous avez. Mais les systèmes modernes d'aujourd'hui sont généralement assez puissants et ont suffisamment de RAM telle quelle.",
          "quizAnswer": "swapon",
          "quizQuestion": "Quelle est la commande pour activer l'espace swap sur un périphérique ?",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "Regardez votre utilisation du disque et l'espace libre avec à la fois du et df.",
          "id": 9,
          "lessonContent": "Il existe quelques outils que vous pouvez utiliser pour voir l'utilisation de vos disques : \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocs    Utilisé Disponible Utilisation Monté sur\n/dev/sda1       6,2G  2,3G  3,6G  40% /\n</pre>\n\nLa commande df vous montre l'utilisation de vos systèmes de fichiers actuellement montés. Le drapeau -h vous donne un format lisible par l'homme. Vous pouvez voir quel est le périphérique, et combien de capacité est utilisée et disponible. \n\nDisons que votre disque se remplit et que vous voulez savoir quels fichiers ou répertoires occupent cet espace, pour cela vous pouvez utiliser la commande <b>du</b>. \n\n<pre>$ du -h</pre>\n\nCela vous montre l'utilisation du disque du répertoire courant dans lequel vous vous trouvez, vous pouvez jeter un œil au répertoire racine avec <b>du -h /</b> mais cela peut devenir un peu encombré.\n\nCes deux commandes sont si similaires en syntaxe qu'il peut être difficile de se rappeler laquelle utiliser, pour vérifier combien de votre <b>disque</b> est <b>libre</b> utilisez df. Pour vérifier l'<b>utilisation du disque</b>, utilisez du.",
          "quizAnswer": "df",
          "quizQuestion": "Quelle commande est utilisée pour afficher combien d'espace est libre sur votre disque ?",
          "slug": "utilisation-du-disque",
          "title": "Utilisation du disque"
        },
        {
          "exercise": "Consultez la page de manuel de fsck pour voir ce qu'il peut faire d'autre.",
          "id": 10,
          "lessonContent": "Parfois, notre système de fichiers n'est pas toujours dans la meilleure condition, si nous subissons une coupure brutale, nos données peuvent devenir corrompues. Il revient au système de tenter de nous remettre dans un état de fonctionnement (bien que nous puissions certainement essayer nous-mêmes).\n\nLa commande <b>fsck</b> (filesystem check) est utilisée pour vérifier la cohérence d'un système de fichiers et peut même essayer de le réparer pour nous. Habituellement, lorsque vous démarrez un disque, fsck s'exécute avant que votre disque ne soit monté pour s'assurer que tout va bien. Parfois cependant, votre disque est tellement endommagé que vous devrez le faire manuellement. Cependant, assurez-vous de le faire lorsque vous êtes dans un disque de secours ou quelque part où vous pouvez accéder à votre système de fichiers sans qu'il soit monté.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "Quelle commande est utilisée pour vérifier l'intégrité d'un système de fichiers?",
          "slug": "reparationdusystemedefichiers",
          "title": "Réparation du système de fichiers"
        },
        {
          "exercise": "Observer quelques numéros d'inode pour différents fichiers, lesquels sont généralement créés en premier ?",
          "id": 11,
          "lessonContent": "Souvenez-vous comment notre système de fichiers est composé de tous nos fichiers réels et d'une base de données qui gère ces fichiers ? La base de données est connue sous le nom de table d'inodes. \n\n<b>Qu'est-ce qu'un inode ?</b>\n\nUn inode (index node) est une entrée dans cette table et il y en a un pour chaque fichier. Il décrit tout sur le fichier, tel que :\n\n<ul>\n<li>Type de fichier - fichier régulier, répertoire, périphérique de caractères, etc.</li>\n<li>Propriétaire</li>\n<li>Groupe</li>\n<li>Autorisations d'accès</li>\n<li>Horodatages - mtime (heure de la dernière modification du fichier), ctime (heure de la dernière modification d'attribut), atime (heure du dernier accès)</li>\n<li>Nombre de liens durs vers le fichier</li>\n<li>Taille du fichier</li>\n<li>Nombre de blocs alloués au fichier</li>\n<li>Pointeurs vers les blocs de données du fichier - le plus important !</li>\n</ul>\n\nFondamentalement, les inodes stockent tout sur le fichier, sauf le nom de fichier et le fichier lui-même !\n\n<b>Quand les inodes sont-ils créés ?</b>\n\nLorsqu'un système de fichiers est créé, de l'espace pour les inodes est également alloué. Il existe des algorithmes qui interviennent pour déterminer combien d'espace inode vous avez besoin en fonction du volume du disque et plus encore. Vous avez probablement à un moment de votre vie vu des erreurs pour des problèmes d'espace disque insuffisant. Eh bien, la même chose peut se produire pour les inodes également (bien que moins courant), vous pouvez manquer d'inodes et donc être incapable de créer plus de fichiers. Rappelez-vous que le stockage des données dépend à la fois des données et de la base de données (inodes). \n\nPour voir combien d'inodes il reste sur votre système, utilisez la commande <b>df -i</b>\n\n<b>Informations sur les inodes</b>\n\nLes inodes sont identifiés par des numéros, lorsqu'un fichier est créé, il se voit attribuer un numéro d'inode, le numéro est attribué dans l'ordre séquentiel. Cependant, vous pouvez parfois remarquer que lorsque vous créez un nouveau fichier, il reçoit un numéro d'inode inférieur à d'autres, cela est dû au fait que une fois que des inodes sont supprimés, ils peuvent être réutilisés par d'autres fichiers. Pour voir les numéros d'inode, exécutez <b>ls -li</b>:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 janv. 20 20:13 Bureau\n141 drwxr-xr-x 2 pete pete 6 janv. 20 20:01 Documents\n</pre>\n\nLe premier champ de cette commande liste le numéro d'inode.\n\nVous pouvez également voir des informations détaillées sur un fichier avec stat, cela vous donne des informations sur l'inode également.\n\n<pre>\npete@icebox:~$ stat ~/Bureau/\n  Fichier : ‘/home/pete/Bureau/’\n  Taille : 6               Blocs : 0          Bloc d'E/S : 4096   répertoire\nPériphérique : 806h/2054d      Inode : 140         Liens : 2\nAccès : (0755/drwxr-xr-x)  Uid : ( 1000/   pete)   Gid : ( 1000/   pete)\nAccès : 2016-01-20 20:13:50.647435982 -0800\nModif. : 2016-01-20 20:13:06.191675843 -0800\nChangement : 2016-01-20 20:13:06.191675843 -0800\n Création : -\n</pre>\n\n\n<b>Comment les inodes localisent-ils les fichiers ?</b>\n\nNous savons que nos données sont quelque part sur le disque, malheureusement elles n'ont probablement pas été stockées de manière séquentielle, nous devons donc utiliser des inodes. Les inodes pointent vers les blocs de données réels de vos fichiers. Dans un système de fichiers typique (tous ne fonctionnent pas de la même manière), chaque inode contient 15 pointeurs, les 12 premiers pointeurs pointent directement vers les blocs de données. Le 13e pointeur pointe vers un bloc contenant des pointeurs vers d'autres blocs, le 14e pointeur pointe vers un autre bloc imbriqué de pointeurs, et le 15e pointeur pointe encore une fois vers un autre bloc de pointeurs ! Confus, je sais ! La raison pour laquelle cela est fait de cette manière est de maintenir la structure de l'inode identique pour chaque inode, mais de pouvoir référencer des fichiers de tailles différentes. Si vous aviez un petit fichier, vous pourriez le trouver plus rapidement avec les 12 premiers pointeurs directs, les fichiers plus grands peuvent être trouvés avec les nids de pointeurs. De toute façon, la structure de l'inode est la même.",
          "quizAnswer": "df -i",
          "quizQuestion": "Comment voir combien d'inodes il reste sur votre système ?",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "Jouez avec la création de liens symboliques et de liens physiques, supprimez-en quelques-uns et voyez ce qui se passe.",
          "id": 12,
          "lessonContent": "Utilisons un exemple précédent d'informations d'inode : \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nVous avez peut-être remarqué que nous avons survolé le troisième champ dans la commande ls, ce champ est le compteur de liens. Le compteur de liens est le nombre total de liens physiques qu'un fichier possède, cela n'a pas de sens pour vous pour l'instant. Parlons donc d'abord des liens. \n\n<b>Liens symboliques</b>\n\nDans le système d'exploitation Windows, il existe des raccourcis, des raccourcis ne sont que des alias vers d'autres fichiers. Si vous faites quelque chose sur le fichier original, vous pourriez potentiellement casser le raccourci. Sous Linux, l'équivalent des raccourcis sont les liens symboliques (ou liens souples). Les liens symboliques nous permettent de lier à un autre fichier par son nom de fichier. Un autre type de liens trouvés sous Linux sont les liens physiques, ce sont en fait un autre fichier avec un lien vers un inode. Voyons ce que cela signifie en pratique en commençant par les liens symboliques.\n\n<pre>\npete@icebox:~/Desktop$ echo 'monfichier' > monfichier\npete@icebox:~/Desktop$ echo 'monfichier2' > monfichier2\npete@icebox:~/Desktop$ echo 'monfichier3' > monfichier3\n\npete@icebox:~/Desktop$ ln -s monfichier monfichierlien\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 monfichier\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 monfichier2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 monfichier3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 monfichierlien -> monfichier\n</pre>\n\nVous pouvez voir que j'ai créé un lien symbolique nommé monfichierlien qui pointe vers monfichier. Les liens symboliques sont indiqués par ->. Remarquez comment j'ai obtenu un nouveau numéro d'inode, les liens symboliques ne sont que des fichiers qui pointent vers des noms de fichiers. Lorsque vous modifiez un lien symbolique, le fichier est également modifié. Les numéros d'inode sont uniques aux systèmes de fichiers, vous ne pouvez pas avoir deux fois le même numéro d'inode dans un seul système de fichiers, ce qui signifie que vous ne pouvez pas référencer un fichier dans un autre système de fichiers par son numéro d'inode. Cependant, si vous utilisez des liens symboliques, ils n'utilisent pas les numéros d'inode, ils utilisent les noms de fichiers, donc ils peuvent être référencés à travers différents systèmes de fichiers. \n\n<b>Liens physiques</b>\n\nVoyons un exemple de lien physique :\n\n<pre>\npete@icebox:~/Desktop$ ln monfichier2 monlienphysique\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 monfichier\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 monfichier2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 monfichier3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 monfichierlien -> monfichier\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 monlienphysique\n</pre>\n\nUn lien physique crée simplement un autre fichier avec un lien vers le même inode. Ainsi, si je modifiais le contenu de monfichier2 ou de monlienphysique, le changement serait visible sur les deux, mais si je supprimais monfichier2, le fichier serait toujours accessible via monlienphysique. C'est là que notre compteur de liens dans la commande ls entre en jeu. Le compteur de liens est le nombre de liens physiques qu'un inode possède, lorsque vous supprimez un fichier, cela diminuera ce compteur de liens. L'inode n'est supprimé que lorsque tous les liens physiques vers l'inode ont été supprimés. Lorsque vous créez un fichier, son compteur de liens est de 1 car c'est le seul fichier qui pointe vers cet inode. Contrairement aux liens symboliques, les liens physiques ne s'étendent pas sur les systèmes de fichiers car les inodes sont uniques au système de fichiers. \n\n<b>Créer un lien symbolique</b>\n\n<pre>\n$ ln -s monfichier monlien</pre>\n\nPour créer un lien symbolique, vous utilisez la commande ln avec -s pour symbolique et vous spécifiez un fichier cible puis un nom de lien. \n\n<b>Créer un lien physique</b>\n\n<pre>\n$ ln unautrefichier unautrelien</pre>\n\nSimilaire à la création d'un lien symbolique, sauf que cette fois vous laissez de côté le -s.",
          "quizAnswer": "ln -s",
          "quizQuestion": "Quelle est la commande utilisée pour créer un lien symbolique?",
          "slug": "symlinks",
          "title": "liens symboliques"
        }
      ],
      "slug": "thesystemedefichiers",
      "title": "Le système de fichiers"
    },
    {
      "description": "Apprenez les étapes du processus de démarrage de Linux.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Redémarrez votre système et voyez si vous pouvez repérer chaque étape pendant le démarrage de votre machine.",
          "id": 1,
          "lessonContent": "Maintenant que nous avons une assez bonne compréhension de certains des composants importants de Linux, rassemblons-les en apprenant comment le système démarre. Lorsque vous allumez votre machine, elle effectue des choses intéressantes comme vous montrer l'écran de logo, afficher différents messages, puis à la fin, vous êtes invité à une fenêtre de connexion. Eh bien, il se passe en réalité beaucoup de choses entre le moment où vous appuyez sur le bouton d'alimentation et le moment où vous vous connectez, et nous en discuterons dans ce cours. \n\nLe processus de démarrage de Linux peut être décomposé en 4 étapes simples : \n\n<b>1. BIOS</b>\n\nLe BIOS (qui signifie \"Basic Input/Output System\") initialise le matériel et s'assure avec un test d'autocontrôle (POST) que tout le matériel est prêt à fonctionner. Le rôle principal du BIOS est de charger le chargeur d'amorçage.\n\n<b>2. Chargeur d'amorçage</b>\n\nLe chargeur d'amorçage charge le noyau en mémoire, puis démarre le noyau avec un ensemble de paramètres du noyau. Un des chargeurs d'amorçage les plus courants est GRUB, qui est une norme universelle pour Linux. \n\n<b>3. Noyau</b>\n\nLorsque le noyau est chargé, il initialise immédiatement les périphériques et la mémoire. Le rôle principal du noyau est de charger le processus d'initialisation. \n\n<b>4. Init</b>\n\nRappelez-vous que le processus d'initialisation est le premier processus qui démarre, init démarre et arrête les processus de service essentiels sur le système. Il existe trois implémentations majeures d'init dans les distributions Linux. Nous les survolerons brièvement, puis nous les approfondirons dans un autre cours.\n\nVoilà, l'explication (très) simple du processus de démarrage de Linux. Nous approfondirons ces étapes dans les prochaines leçons.",
          "quizAnswer": "init",
          "quizQuestion": "Quelle est la dernière étape du processus de démarrage de Linux ?",
          "slug": "vue-d-ensemble-du-processus-de-demarrage",
          "title": "Vue d'ensemble du processus de démarrage"
        },
        {
          "exercise": "Accédez au menu de votre BIOS et vérifiez si le démarrage UEFI est activé.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nLa première étape du processus de démarrage de Linux est le BIOS qui effectue des vérifications d'intégrité du système. Le BIOS est un micrologiciel qui se trouve le plus souvent dans les ordinateurs compatibles PC IBM, le type d'ordinateurs dominant aujourd'hui. Vous avez probablement utilisé le micrologiciel BIOS pour modifier l'ordre de démarrage de vos disques durs, vérifier l'heure système, l'adresse MAC de votre machine, etc. L'objectif principal du BIOS est de trouver le chargeur d'amorçage du système.\n\nUne fois que le BIOS a démarré le disque dur, il recherche le bloc de démarrage pour savoir comment démarrer le système. En fonction de la façon dont vous avez partitionné votre disque, il cherchera le secteur de démarrage principal (MBR) ou GPT. Le MBR se trouve dans le premier secteur du disque dur, les premiers 512 octets. Le MBR contient le code pour charger un autre programme quelque part sur le disque, ce programme charge ensuite notre chargeur d'amorçage.\n\nMaintenant, si vous avez partitionné votre disque avec GPT, l'emplacement du chargeur d'amorçage change un peu.\n\n<b>UEFI</b>\n\nIl existe une autre façon de démarrer votre système au lieu d'utiliser le BIOS, c'est avec UEFI (qui signifie \"Interface micrologicielle extensible unifiée\"). UEFI a été conçu pour être le successeur du BIOS, la plupart du matériel disponible aujourd'hui est livré avec le micrologiciel UEFI intégré. Les machines Macintosh utilisent le démarrage EFI depuis des années maintenant et Windows a pour la plupart déplacé tous leurs éléments vers le démarrage UEFI. Le format GPT était destiné à être utilisé avec l'EFI. Vous n'avez pas nécessairement besoin de l'EFI si vous démarrez un disque GPT. Le premier secteur d'un disque GPT est réservé à un \"MBR de protection\" pour permettre le démarrage sur une machine basée sur le BIOS.\n\nUEFI stocke toutes les informations de démarrage dans un fichier .efi. Ce fichier est stocké sur une partition spéciale appelée partition système EFI sur le matériel. À l'intérieur de cette partition, il contiendra le chargeur d'amorçage. UEFI apporte de nombreuses améliorations par rapport au micrologiciel BIOS traditionnel. Cependant, comme nous utilisons Linux, la majorité d'entre nous utilisons le BIOS. Donc, toutes ces leçons suivront cette prémisse.",
          "quizAnswer": "chargeur d'amorçage",
          "quizQuestion": "Que charge le BIOS?",
          "slug": "processusdedemarragebios",
          "title": "Processus de démarrage : BIOS"
        },
        {
          "exercise": "Si vous avez GRUB comme chargeur d'amorçage, accédez au menu GRUB avec 'e' et examinez les paramètres.",
          "id": 3,
          "lessonContent": "Les principales responsabilités du chargeur d'amorçage sont :\n\n<ul>\n<li>Démarrer dans un système d'exploitation, il peut également être utilisé pour démarrer vers des systèmes d'exploitation non-Linux</li>\n<li>Sélectionner un noyau à utiliser</li>\n<li>Spécifier les paramètres du noyau</li>\n</ul>\n\nLe chargeur d'amorçage le plus courant pour Linux est GRUB, vous l'utilisez très probablement sur votre système. Il existe de nombreux autres chargeurs d'amorçage que vous pouvez utiliser tels que LILO, efilinux, coreboot, SYSLINUX et d'autres. Cependant, nous travaillerons uniquement avec GRUB comme chargeur d'amorçage. \n\nNous savons donc que l'objectif principal du chargeur d'amorçage est de charger le noyau, mais où trouve-t-il le noyau ? Pour le trouver, nous devrons examiner nos paramètres du noyau. Les paramètres peuvent être trouvés en accédant au menu GRUB au démarrage en utilisant la touche 'e'. Si vous n'avez pas GRUB, pas de soucis, nous passerons en revue les paramètres de démarrage que vous verrez :\n\n<ul>\n<li>initrd - Spécifie l'emplacement du disque RAM initial (nous en parlerons davantage dans la prochaine leçon).</li>\n<li>BOOT_IMAGE - C'est là que se trouve l'image du noyau</li>\n<li>root - L'emplacement du système de fichiers racine, le noyau recherche à l'intérieur de cet emplacement pour trouver init. Il est souvent représenté par son UUID ou le nom du périphérique tel que /dev/sda1.</li>\n<li>ro - Ce paramètre est assez standard, il monte le système de fichiers en mode lecture seule.</li>\n<li>quiet - Cela est ajouté pour que vous ne voyiez pas les messages d'affichage qui se déroulent en arrière-plan pendant le démarrage.</li>\n<li>splash - Cela permet d'afficher l'écran de démarrage.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "Quel paramètre du noyau fait en sorte que vous ne voyiez pas les messages de démarrage ?",
          "slug": "processusdedemarragechargeur",
          "title": "Processus de démarrage : Chargeur d'amorçage"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 4,
          "lessonContent": "Maintenant que notre chargeur d'amorçage a transmis les paramètres nécessaires, voyons comment il démarre :\n\n<b>Initrd vs Initramfs</b>\n\nIl y a un peu un problème de poule et d'œuf lorsque nous parlons du démarrage du noyau. Le noyau gère le matériel de nos systèmes, cependant tous les pilotes ne sont pas disponibles pour le noyau lors du démarrage. Nous dépendons donc d'un système de fichiers racine temporaire qui contient uniquement les modules essentiels dont le noyau a besoin pour accéder au reste du matériel. Dans les anciennes versions de Linux, cette tâche était confiée à l'initrd (disque RAM initial). Le noyau montait l'initrd, obtenait les pilotes de démarrage nécessaires, puis lorsqu'il avait chargé tout ce dont il avait besoin, il remplaçait l'initrd par le véritable système de fichiers racine. De nos jours, nous avons quelque chose appelé l'initramfs, qui est un système de fichiers racine temporaire intégré au noyau lui-même pour charger tous les pilotes nécessaires pour le véritable système de fichiers racine, donc plus besoin de localiser le fichier initrd. \n\n<b>Montage du système de fichiers racine</b>\n\nMaintenant que le noyau a tous les modules dont il a besoin pour créer un périphérique racine et monter la partition racine. Avant d'aller plus loin cependant, la partition racine est en fait montée en mode lecture seule d'abord pour que fsck puisse s'exécuter en toute sécurité et vérifier l'intégrité du système. Ensuite, il remonte le système de fichiers racine en mode lecture-écriture. Ensuite, le noyau localise le programme init et l'exécute.",
          "quizAnswer": "initramfs",
          "quizQuestion": "Qu'est-ce qui est utilisé dans les systèmes modernes pour charger un système de fichiers racine temporaire ?",
          "slug": "processusdedemarragenoyau",
          "title": "Processus de démarrage : Noyau"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 5,
          "lessonContent": "Nous avons discuté de init dans les leçons précédentes et savons que c'est le premier processus qui démarre et lance tous les autres services essentiels sur notre système. Mais comment ?\n\nIl existe en fait trois implémentations majeures de init sous Linux : \n\n<b>System V init (sysv)</b>\n\nIl s'agit du système init traditionnel. Il démarre et arrête séquentiellement les processus, basés sur des scripts de démarrage. L'état de la machine est indiqué par des niveaux d'exécution, chaque niveau d'exécution démarre ou arrête une machine de manière différente. \n\n<b>Upstart</b>\n\nC'est l'init que vous trouverez sur les anciennes installations d'Ubuntu. Upstart utilise l'idée de tâches et d'événements et fonctionne en démarrant des tâches qui effectuent certaines actions en réponse à des événements. \n\n<b>Systemd</b>\n\nIl s'agit de la nouvelle norme pour init, il est orienté objectif. Fondamentalement, vous avez un objectif que vous voulez atteindre et systemd essaie de satisfaire les dépendances de l'objectif pour le compléter. \n\nNous avons un cours entier sur les systèmes Init où nous plongerons dans chacun de ces systèmes plus en détail.",
          "quizAnswer": "systemd",
          "quizQuestion": "Quelle est la norme la plus récente pour init ?",
          "slug": "processusdedemarrageinit",
          "title": "Processus de démarrage : Init"
        }
      ],
      "slug": "bootthesystem",
      "title": "Démarrer le système"
    },
    {
      "description": "La partie la plus importante du système Linux, apprenez comment il fonctionne et comment le configurer.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 1,
          "lessonContent": "Comme vous l'avez appris jusqu'à présent, le noyau est le cœur du système d'exploitation. Nous avons parlé des autres parties du système d'exploitation mais n'avons pas encore montré comment elles fonctionnent toutes ensemble. Le système d'exploitation Linux peut être organisé en trois niveaux d'abstraction différents.\n\nLe niveau le plus bas est le matériel, cela inclut notre CPU, la mémoire, les disques durs, les ports de réseau, etc. La couche physique qui effectivement calcule ce que notre machine fait.\n\nLe niveau suivant est le noyau, qui gère les processus et la mémoire, la communication avec les périphériques, les appels système, configure notre système de fichiers, etc. Le rôle du noyau est de communiquer avec le matériel pour s'assurer qu'il exécute ce que nous voulons que nos processus fassent. \n\nEt le niveau que vous connaissez est l'espace utilisateur, l'espace utilisateur inclut le shell, les programmes que vous exécutez, les graphiques, etc.\n\nDans ce cours, nous nous concentrerons sur le noyau et apprendrons ses subtilités.",
          "quizAnswer": "noyau",
          "quizQuestion": "Quel niveau du système d'exploitation gère les périphériques ?",
          "slug": "aperçunoyau",
          "title": "Aperçu du Noyau"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 2,
          "lessonContent": "Les prochaines leçons deviennent assez théoriques, donc si vous cherchez des choses pratiques, vous pouvez sauter et revenir plus tard.\n\nPourquoi avons-nous différentes couches d'abstraction pour l'espace utilisateur et le noyau ? Pourquoi ne pouvons-nous pas combiner les deux pouvoirs en une seule couche ? Eh bien, il y a une très bonne raison pour laquelle ces deux couches existent séparément. Elles fonctionnent toutes les deux dans des modes différents, le noyau fonctionne en mode noyau et l'espace utilisateur fonctionne en mode utilisateur. \n\nEn mode noyau, le noyau a un accès complet au matériel, il contrôle tout. En mode espace utilisateur, il y a une très petite quantité de mémoire et de CPU sécurisés auxquels vous êtes autorisé à accéder. Fondamentalement, lorsque nous voulons faire quelque chose qui implique du matériel, lire des données de nos disques, écrire des données sur nos disques, contrôler notre réseau, etc., tout cela se fait en mode noyau. Pourquoi est-ce nécessaire ? Imaginez si votre machine était infectée par des logiciels espions, vous ne voudriez pas qu'elle puisse avoir un accès direct au matériel de votre système. Elle pourrait accéder à toutes vos données, à votre webcam, etc. et ce n'est pas bon. \n\nCes différents modes sont appelés niveaux de privilège (bien nommés pour les niveaux de privilège que vous obtenez) et sont souvent décrits comme des anneaux de protection. Pour rendre cette image plus facile à comprendre, disons que vous découvrez que Britney Spears est en ville dans votre klerb local, elle est protégée par ses groupies, puis ses gardes du corps personnels, puis le videur à l'extérieur du klerb. Vous voulez obtenir son autographe (parce que pourquoi pas ?), mais vous ne pouvez pas l'atteindre car elle est fortement protégée. Les anneaux fonctionnent de la même manière, l'anneau le plus interne correspond au niveau de privilège le plus élevé. Il y a deux niveaux principaux ou modes dans une architecture d'ordinateur x86. L'anneau n°3 est le privilège dans lequel les applications en mode utilisateur s'exécutent, l'anneau n°0 est le privilège dans lequel le noyau s'exécute. L'anneau n°0 peut exécuter n'importe quelle instruction système et bénéficie d'une confiance totale. Maintenant que nous savons comment fonctionnent ces niveaux de privilège, comment pouvons-nous écrire quelque chose sur notre matériel ? Ne serons-nous pas toujours dans un mode différent du noyau ? \n\nLa réponse est avec les appels système, les appels système nous permettent d'exécuter une instruction privilégiée en mode noyau puis de revenir en mode utilisateur.",
          "quizAnswer": "0",
          "quizQuestion": "Quel numéro d'anneau a les privilèges les plus élevés ?",
          "slug": "niveauxprivilegekernel",
          "title": "Niveaux de privilège"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Vous vous souvenez de Britney dans la leçon précédente? Disons que nous voulons la voir et prendre un verre ensemble, comment passer de l'extérieur, parmi la foule de gens, à l'intérieur de son cercle le plus intime? Nous utiliserions des appels système. Les appels système sont comme des laissez-passer VIP qui vous conduisent à une porte dérobée secrète menant directement à Britney.\n\nLes appels système (syscall) fournissent aux processus de l'espace utilisateur un moyen de demander au noyau de faire quelque chose pour nous. Le noyau met à disposition certains services via l'API des appels système. Ces services nous permettent de lire ou d'écrire dans un fichier, de modifier l'utilisation de la mémoire, de modifier notre réseau, etc. Le nombre de services est fixe, donc vous ne pouvez pas ajouter des appels système au hasard, votre système a déjà une table des appels système existants et chaque appel système a un identifiant unique. \n\nJe ne rentrerai pas dans les détails des appels système, car cela nécessiterait que vous connaissiez un peu le langage C, mais l'essentiel est que lorsque vous appelez un programme comme ls, le code à l'intérieur de ce programme contient un wrapper d'appel système (donc pas encore l'appel système réel). À l'intérieur de ce wrapper, il invoque l'appel système qui exécutera un piège, ce piège sera ensuite intercepté par le gestionnaire d'appels système et fera référence à l'appel système dans la table des appels système. Disons que nous essayons d'appeler l'appel système stat(), il est identifié par un ID d'appel système et l'objectif de l'appel système stat() est de consulter le statut d'un fichier. Maintenant, rappelez-vous, vous exécutiez le programme ls en mode non privilégié. Donc maintenant, il voit que vous essayez de faire un appel système, il vous bascule alors en mode noyau, là il fait beaucoup de choses mais surtout il recherche votre numéro d'appel système, le trouve dans une table basée sur l'ID de l'appel système, puis exécute la fonction que vous vouliez exécuter. Une fois terminé, il reviendra en mode utilisateur et votre processus recevra un statut de retour s'il a réussi ou s'il a rencontré une erreur. Les rouages internes des appels système deviennent vraiment détaillés, je vous recommande de consulter des informations en ligne si vous voulez en savoir plus. \n\nVous pouvez en fait voir les appels système qu'un processus effectue avec la commande strace. La commande strace est utile pour déboguer comment un programme s'est exécuté. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "appel système",
          "quizQuestion": "Qu'est-ce qui est utilisé pour passer du mode utilisateur au mode noyau?",
          "slug": "appelssysteme",
          "title": "Appels Système"
        },
        {
          "exercise": "<ol>\n<li>Découvrez quelle version de noyau vous avez.</li>\n<li>Recherchez les différentes versions de noyaux disponibles</li>\n</ol>",
          "id": 4,
          "lessonContent": "Ok, maintenant que nous avons terminé avec toutes ces choses ennuyeuses, parlons de l'installation et de la modification réelle des noyaux. Vous pouvez installer plusieurs noyaux sur votre système, vous vous souvenez de notre leçon sur le processus de démarrage ? Dans notre menu GRUB, nous pouvons choisir quel noyau démarrer. \n\nPour voir quelle version de noyau vous avez sur votre système, utilisez la commande suivante :\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nLa commande uname affiche des informations système, la commande -r affichera toute la version de publication du noyau.\n\nVous pouvez installer le noyau Linux de différentes manières, vous pouvez télécharger le paquet source et le compiler à partir de la source ou l'installer à l'aide d'outils de gestion de paquets.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\net ensuite redémarrez simplement dans le noyau que vous avez installé. Simple non ? En quelque sorte, vous devrez également installer d'autres paquets Linux tels que les en-têtes Linux, linux-image-generic, etc.). Vous pouvez également spécifier le numéro de version, donc la commande ci-dessus peut ressembler à ceci, <b>sudo apt install 3.19.0-43-generic</b>\n\nAlternativement, si vous voulez simplement la version de noyau mise à jour, utilisez simplement dist-upgrade, cela effectue des mises à jour de tous les paquets sur votre système :\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nIl existe de nombreuses versions de noyaux différentes, certaines sont utilisées comme LTS (support à long terme), d'autres sont les dernières et les meilleures, la compatibilité peut être très différente entre les versions de noyau, vous voudrez peut-être essayer différents noyaux.",
          "quizAnswer": "uname -r",
          "quizQuestion": "Comment voir la version du noyau de votre système ?",
          "slug": "installation-du-noyau",
          "title": "Installation du Noyau"
        },
        {
          "exercise": "Allez dans votre répertoire /boot et voyez quels fichiers s'y trouvent.",
          "id": 5,
          "lessonContent": "Que se passe-t-il lorsque vous installez un nouveau noyau ? Eh bien, cela ajoute en fait quelques fichiers à votre système, ces fichiers sont généralement ajoutés au répertoire /boot. \n\nVous verrez plusieurs fichiers pour différentes versions de noyau :\n\n<ul>\n<li>vmlinuz - c'est le noyau Linux réel</li>\n<li>initrd - comme nous l'avons déjà discuté, l'initrd est utilisé comme un système de fichiers temporaire, utilisé avant le chargement du noyau</li>\n<li>System.map - table de recherche symbolique</li>\n<li>config - paramètres de configuration du noyau, si vous compilez votre propre noyau, vous pouvez définir quels modules peuvent être chargés</li>\n</ul>\n\nSi votre répertoire /boot manque d'espace, vous pouvez toujours supprimer d'anciennes versions de ces fichiers ou simplement utiliser un gestionnaire de paquets, mais soyez prudent lors de la maintenance dans ce répertoire et ne supprimez pas accidentellement le noyau que vous utilisez.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "Comment s'appelle l'image du noyau dans /boot ?",
          "slug": "kernellocation",
          "title": "Emplacement du noyau"
        },
        {
          "exercise": "Déchargez votre module bluetooth avec modprobe et voyez ce qui se passe. Comment allez-vous résoudre cela ?",
          "id": 6,
          "lessonContent": "Disons que j'ai une voiture de sport, j'investis beaucoup de temps et d'argent dedans. J'ajoute un aileron, une attache, un porte-vélos et d'autres choses aléatoires. Ces composants ne modifient pas réellement la fonctionnalité de base de la voiture et je peux les retirer et les ajouter très facilement. Le noyau utilise le même concept avec les modules du noyau.\n\nLe noyau en lui-même est une pièce logicielle monolithique, lorsque nous voulons ajouter le support pour un nouveau type de clavier, nous n'écrivons pas ce code directement dans le code du noyau. Tout comme nous ne fusionnerions pas un porte-vélos à notre voiture (enfin, peut-être que certaines personnes le feraient). Les modules du noyau sont des morceaux de code qui peuvent être chargés et déchargés dans le noyau à la demande. Ils nous permettent d'étendre la fonctionnalité du noyau sans ajouter au code du noyau de base. Nous pouvons également ajouter des modules sans devoir redémarrer le système (dans la plupart des cas).\n\n<b>Visualiser une liste des modules actuellement chargés</b>\n\n<pre>$ lsmod</pre>\n\n<b>Charger un module</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe essaie de charger le module depuis <b>/lib/modules/(version du noyau)/kernel/drivers</b>. Les modules du noyau peuvent également avoir des dépendances, modprobe charge nos dépendances de module si elles ne sont pas déjà chargées.\n\n<b>Retirer un module</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Chargement au démarrage</b>\n\nVous pouvez également charger des modules lors du démarrage du système, au lieu de les charger temporairement avec modprobe (qui seront déchargés lorsque vous redémarrez). Modifiez simplement le répertoire <b>/etc/modprobe.d</b> et ajoutez-y un fichier de configuration comme ceci :\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\nUn exemple un peu excentrique, mais si vous aviez un module nommé peanut_butter et que vous vouliez ajouter un paramètre de noyau pour type=almond, vous pouvez le charger au démarrage en utilisant ce fichier de configuration. Notez également que les modules du noyau ont leurs propres paramètres de noyau, donc vous voudrez en apprendre davantage sur le module spécifiquement pour en savoir plus.\n\n<b>Ne pas charger au démarrage</b>\n\nVous pouvez également vous assurer qu'un module ne se charge pas au démarrage en ajoutant un fichier de configuration comme ceci :\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "Quelle commande est utilisée pour décharger un module ?",
          "slug": "modulesnoyau",
          "title": "Modules du Noyau"
        }
      ],
      "slug": "kernel",
      "title": "Noyau"
    },
    {
      "description": "Apprenez les différents systèmes d'initialisation, SysV, Upstart et systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Si vous utilisez System V, changez le niveau d'exécution par défaut de votre machine pour quelque chose d'autre et voyez ce qui se passe.",
          "id": 1,
          "lessonContent": "Le but principal de init est de démarrer et d'arrêter les processus essentiels du système. Il existe trois implémentations majeures de init dans Linux, System V, Upstart et systemd. Dans cette leçon, nous allons passer en revue la version la plus traditionnelle de init, System V init ou Sys V (prononcé 'System Five'). \n\nPour savoir si vous utilisez l'implémentation Sys V init, si vous avez un fichier /etc/inittab, vous utilisez probablement Sys V. \n\nSys V démarre et arrête les processus séquentiellement, donc disons que vous vouliez démarrer un service nommé foo-a, eh bien avant que foo-b puisse fonctionner, vous devez vous assurer que foo-a est déjà en cours d'exécution. Sys V le fait avec des scripts, ces scripts démarrer et arrêter des services pour nous, nous pouvons écrire nos propres scripts ou la plupart du temps utiliser ceux qui sont déjà intégrés dans le système d'exploitation et sont utilisés pour charger des services essentiels. \n\nLes avantages de l'utilisation de cette implémentation de init sont qu'il est relativement facile de résoudre les dépendances, car vous savez que foo-a vient avant foo-b, cependant les performances ne sont pas excellentes car généralement une seule chose démarre ou s'arrête à la fois. \n\nLors de l'utilisation de Sys V, l'état de la machine est défini par des niveaux d'exécution qui vont de 0 à 6. Ces modes différents varieront en fonction de la distribution, mais la plupart du temps ressembleront à ce qui suit: \n\n<ul>\n<li>0: Arrêt</li>\n<li>1: Mode utilisateur unique</li>\n<li>2: Mode multi-utilisateur sans réseau</li>\n<li>3: Mode multi-utilisateur avec réseau</li>\n<li>4: Inutilisé</li>\n<li>5: Mode multi-utilisateur avec réseau et interface graphique</li>\n<li>6: Redémarrage</li>\n</ul>\n\nLorsque votre système démarre, il vérifie dans quel niveau d'exécution vous vous trouvez et exécute les scripts situés à l'intérieur de cette configuration de niveau d'exécution. Les scripts sont situés dans <b>/etc/rc.d/rc[numéro du niveau d'exécution].d/</b> ou <b>/etc/init.d</b>. Les scripts commençant par S(démarrage) ou K(arrêt) s'exécuteront au démarrage et à l'arrêt, respectivement. Les chiffres à côté de ces caractères indiquent la séquence dans laquelle ils s'exécutent. \n\nPar exemple:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nNous voyons que lorsque nous passons au niveau d'exécution 0 ou mode d'arrêt, notre machine essaiera d'exécuter un script pour arrêter les services de mises à jour puis openvpn. Pour savoir dans quel niveau d'exécution votre machine démarre, vous pouvez voir le niveau d'exécution par défaut dans le fichier /etc/inittab. Vous pouvez également modifier votre niveau d'exécution par défaut dans ce fichier également. \n\nÀ noter, System V est progressivement remplacé, peut-être pas aujourd'hui, ni même dans les années à venir. Cependant, vous pouvez voir des niveaux d'exécution apparaître dans d'autres implémentations de init, principalement pour prendre en charge les services qui ne sont démarrés ou arrêtés qu'en utilisant des scripts d'initialisation System V.",
          "quizAnswer": "0",
          "quizQuestion": "Quel niveau d'exécution est généralement utilisé pour l'arrêt ?",
          "slug": "sysvoverview",
          "title": "Présentation de System V"
        },
        {
          "exercise": "Gérez quelques services et modifiez leurs états, que constatez-vous?",
          "id": 2,
          "lessonContent": "Il existe de nombreux outils en ligne de commande que vous pouvez utiliser pour gérer les services Sys V. \n\n<b>Liste des services</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Démarrer un service</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Arrêter un service</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Redémarrer un service</b>\n\n<pre>$ sudo service networking restart</pre>\n\nCes commandes ne sont pas spécifiques aux systèmes d'initialisation Sys V, vous pouvez également utiliser ces commandes pour gérer les services Upstart. Étant donné que Linux essaie de s'éloigner des scripts d'initialisation Sys V plus traditionnels, il existe encore des éléments en place pour faciliter cette transition.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Quelle est la commande pour arrêter un service nommé peanut avec Sys V?",
          "slug": "servicesysv",
          "title": "Service System V"
        },
        {
          "exercise": "Si vous utilisez Upstart, essayez de comprendre les configurations de tâches dans /etc/init.",
          "id": 3,
          "lessonContent": "Upstart a été développé par Canonical, il était donc l'implémentation init sur Ubuntu pendant un certain temps, cependant sur les installations modernes d'Ubuntu, systemd est maintenant utilisé. Upstart a été créé pour améliorer les problèmes de Sys V, tels que les processus de démarrage stricts, le blocage des tâches, etc. Le modèle piloté par les événements et les tâches d'Upstart lui permet de répondre aux événements au fur et à mesure qu'ils se produisent. \n\nPour savoir si vous utilisez Upstart, si vous avez un répertoire /usr/share/upstart, c'est un indicateur assez fiable. \n\nLes tâches sont les actions qu'Upstart effectue et les événements sont des messages reçus d'autres processus pour déclencher des tâches. Pour voir une liste des tâches et leur configuration:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nÀ l'intérieur de ces configurations de tâches, il y aura des informations sur la manière de démarrer les tâches et quand les démarrer.\n\nPar exemple, dans le fichier networking.conf, cela pourrait dire quelque chose d'aussi simple que:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nCela signifie qu'il démarrera la configuration du réseau sur les niveaux d'exécution 2, 3 ou 5 et arrêtera le réseau sur le niveau d'exécution 0. Il existe de nombreuses façons d'écrire le fichier de configuration et vous découvrirez cela en examinant les différentes configurations de tâches disponibles. \n\nLa façon dont Upstart fonctionne est la suivante: \n\n<ol>\n<li>Tout d'abord, il charge les configurations de tâches depuis /etc/init</li>\n<li>Une fois qu'un événement de démarrage se produit, il exécutera les tâches déclenchées par cet événement.</li>\n<li>Ces tâches créeront de nouveaux événements et ces événements déclencheront d'autres tâches</li>\n<li>Upstart continue à faire cela jusqu'à ce qu'il ait terminé toutes les tâches nécessaires</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Quelle est l'implémentation init utilisée par Ubuntu?",
          "slug": "upstartoverview",
          "title": "Présentation d'Upstart"
        },
        {
          "exercise": "Observez votre liste d'emplois Upstart, puis changez l'état de l'emploi avec l'une des commandes que nous avons apprises aujourd'hui. Que remarquez-vous ensuite?",
          "id": 4,
          "lessonContent": "Upstart peut déclencher de nombreux événements et emplois à exécuter, malheureusement il n'y a pas de moyen facile de voir d'où provient un événement ou un emploi, donc vous devrez fouiller dans les configurations d'emploi dans /etc/init. La plupart du temps, vous n'aurez jamais besoin de consulter les fichiers de configuration d'emploi Upstart, mais vous voudrez contrôler plus facilement certains emplois spécifiques. Il existe de nombreuses commandes utiles que vous pouvez utiliser dans un système Upstart. \n\n<b>Voir les emplois</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nVous verrez une liste d'emplois Upstart avec différents statuts qui leur sont appliqués. Sur chaque ligne, le nom de l'emploi est la première valeur et le deuxième champ (avant le /) est en fait l'objectif de l'emploi, la troisième valeur (après le /) est le statut actuel. Ainsi, nous voyons que notre emploi de shutdown veut finalement s'arrêter, mais il est actuellement dans un état d'attente. Le statut et les objectifs de l'emploi changeront lorsque vous démarrerez ou arrêterez des emplois. \n\n<b>Voir un emploi spécifique</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nNous n'entrerons pas dans les détails de la rédaction d'une configuration d'emploi Upstart, cependant nous savons déjà que les emplois sont arrêtés, démarrés et redémarrés dans ces configurations. Ces emplois émettent également des événements, donc ils peuvent démarrer d'autres emplois. Nous passerons en revue les commandes manuelles de l'opération Upstart, mais si vous êtes curieux, vous devriez approfondir les fichiers .conf.\n\n<b>Démarrer manuellement un emploi</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Arrêter manuellement un emploi</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Redémarrer manuellement un emploi</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Émettre manuellement un événement</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Comment redémarrer manuellement un emploi Upstart appelé peanuts?",
          "slug": "emplois-upstart",
          "title": "Emplois Upstart"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Systemd devient lentement la norme émergente pour l'initialisation. Si vous avez un répertoire /usr/lib/systemd, vous utilisez très probablement systemd.\n\nSystemd utilise des objectifs pour démarrer votre système. Fondamentalement, vous avez une cible que vous souhaitez atteindre et cette cible a également des dépendances que nous devons atteindre. Systemd est extrêmement flexible et robuste, il ne suit pas une séquence stricte pour démarrer les processus. Voici ce qui se passe pendant le démarrage typique de systemd:\n\n<ol>\n<li>Tout d'abord, systemd charge ses fichiers de configuration, généralement situés dans /etc/systemd/system ou /usr/lib/systemd/system</li>\n<li>Ensuite, il détermine son objectif de démarrage, qui est généralement default.target</li>\n<li>Systemd identifie les dépendances de la cible de démarrage et les active</l>\n</ol>\n\nSimilaire aux niveaux d'exécution de Sys V, systemd démarre dans différentes cibles:\n\n<ul>\n<li>poweroff.target - arrêt du système</li>\n<li>rescue.target - mode utilisateur unique</li>\n<li>multi-user.target - multi-utilisateur avec réseau</li>\n<li>graphical.target - multi-utilisateur avec réseau et interface graphique</li>\n<li>reboot.target - redémarrage</li>\n</ul>\n\nL'objectif de démarrage par défaut de default.target pointe généralement vers graphical.target. \n\nL'objet principal avec lequel systemd travaille est connu sous le nom d'unités. Systemd ne se contente pas d'arrêter et de démarrer des services, il peut monter des systèmes de fichiers, surveiller vos sockets réseau, etc. et en raison de cette robustesse, il a différents types d'unités sur lesquelles il opère. Les unités les plus courantes sont:\n\n<ul>\n<li>Unités de service - ce sont les services que nous avons démarrés et arrêtés, ces fichiers d'unités se terminent par .service</li>\n<li>Unités de montage - Ces unités montent des systèmes de fichiers, ces fichiers d'unités se terminent par .mount</li>\n<li>Unités de cible - Ces unités regroupent d'autres unités, les fichiers se terminent par .target</li>\n</ul>\n\nPar exemple, disons que nous démarrons dans notre default.target, eh bien cette cible regroupe l'unité networking.service, l'unité crond.service, etc., donc une fois que nous activons une seule unité, tout ce qui se trouve en dessous de cette unité est également activé.",
          "quizAnswer": "cible",
          "quizQuestion": "Quelle unité est utilisée pour regrouper d'autres unités?",
          "slug": "systemdoverview",
          "title": "Présentation de Systemd"
        },
        {
          "exercise": "Consultez les statuts des unités et démarrez et arrêtez quelques services. Que observez-vous ?",
          "id": 6,
          "lessonContent": "Nous n'entrerons pas dans les détails de l'écriture des fichiers unités systemd. Nous allons cependant passer en revue un bref aperçu d'un fichier unité et comment contrôler manuellement les unités. \n\nVoici un fichier unité de service de base : foobar.service\n\n<pre>\n[Unit]\nDescription=Mon Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nIl s'agit d'une cible de service simple, au début du fichier nous voyons une section pour [Unit], cela nous permet de donner une description à notre fichier unité ainsi que de contrôler l'ordre d'activation de l'unité. La partie suivante est la section [Service], ici nous pouvons démarrer, arrêter ou recharger un service. Et la section [Install] est utilisée pour les dépendances. Ce n'est que la partie émergée de l'iceberg pour écrire des fichiers systemd, donc je vous implore de vous renseigner sur le sujet si vous voulez en savoir plus. \n\nMaintenant, passons à quelques commandes que vous pouvez utiliser avec les unités systemd : \n\n<b>Lister les unités</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Afficher l'état d'une unité</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Démarrer un service</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Arrêter un service</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Redémarrer un service</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Activer une unité</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Désactiver une unité</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nEncore une fois, vous n'avez pas encore vu toute la profondeur de systemd, donc renseignez-vous si vous voulez en apprendre davantage.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "Quelle est la commande pour démarrer un service nommé peanut.service ?",
          "slug": "systemdgoals",
          "title": "Objectifs de Systemd"
        },
        {
          "exercise": "Que pensez-vous qu'il se passe avec init lorsque vous éteignez votre machine ?",
          "id": 7,
          "lessonContent": "Difficile à croire que nous n'avons pas encore discuté des moyens de contrôler l'état de votre système via la ligne de commande, mais en parlant de init, nous ne parlons pas seulement des modes qui nous permettent de démarrer notre système, mais aussi de ceux qui l'arrêtent.\n\nPour éteindre votre système :\n\n<pre>$ sudo shutdown -h now</pre>\n\nCela arrêtera le système (l'éteindra), vous devez également spécifier un moment où vous souhaitez que cela se produise. Vous pouvez ajouter un temps en minutes qui éteindra le système dans ce laps de temps.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nCela éteindra votre système dans deux minutes. Vous pouvez également redémarrer avec la commande shutdown :\n\n<pre>$ sudo shutdown -r now</pre>\n\nOu simplement utiliser la commande reboot :\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "Quelle est la commande pour éteindre votre système dans 4 minutes ?",
          "slug": "powerstates",
          "title": "États de puissance"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Apprenez la surveillance des ressources avec top, les moyennes de charge, iostat et plus encore!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Jouez avec la commande top et voyez quels processus utilisent le plus de ressources.",
          "id": 1,
          "lessonContent": "Dans ce cours, nous verrons comment lire et analyser l'utilisation des ressources sur votre système, cette leçon présente quelques excellents outils à utiliser lorsque vous avez besoin de suivre ce qu'un processus fait. \n\n<b>top</b>\n\nNous avons déjà discuté de top, mais nous allons approfondir les spécificités de ce qu'il affiche réellement. Rappelez-vous que top est l'outil que nous avons utilisé pour obtenir une vue en temps réel de l'utilisation du système par nos processus :\n\n<pre>\ntop - 18:06:26 up 6 jours,  4:07,  2 utilisateurs,  charge moyenne : 0.92, 0.62, 0.59\nTâches : 389 au total,   1 en cours d'exécution, 387 en attente,   0 arrêtées,   1 zombie\n%Cpu(s) :  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  32870888 au total, 27467976 utilisés,  5402912 libres,   518808 tampons\nKiB Swap : 33480700 au total,    39892 utilisés, 33440808 libres. 19454152 mémoire cache\n\n  PID UTILISATEUR      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMANDE                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nPassons en revue ce que signifie cette sortie, vous n'avez pas à mémoriser cela, mais revenez-y quand vous avez besoin d'une référence.\n\n<b>1ère ligne : Il s'agit des mêmes informations que vous verriez si vous exécutiez la commande uptime (à suivre)</b>\n\nLes champs sont de gauche à droite :\n<ol>\n<li>Heure actuelle</li>\n<li>Depuis combien de temps le système est en marche</li>\n<li>Combien d'utilisateurs sont actuellement connectés</li>\n<li>Charge moyenne du système (à suivre)</li>\n</ol>\n\n<b>2ème ligne : Tâches en cours d'exécution, en attente, arrêtées et zombies</b>\n\n<b>3ème ligne : Informations sur le CPU</b>\n\n<ol>\n<li>us : temps CPU utilisateur - Pourcentage de temps CPU passé à exécuter des processus utilisateurs non renicés.</li>\n<li>sy : temps CPU système - Pourcentage de temps CPU passé à exécuter le noyau et les processus du noyau</li>\n<li>ni : temps CPU agréable - Pourcentage de temps CPU passé à exécuter des processus renicés</li>\n<li>id : temps CPU inactif - Pourcentage de temps CPU passé inactif</li>\n<li>wa : attente E/S - Pourcentage de temps CPU passé en attente d'E/S. Si cette valeur est faible, le problème n'est probablement pas lié à l'E/S disque ou réseau</li> \n<li>hi : interruptions matérielles - Pourcentage de temps CPU passé à servir des interruptions matérielles</li>\n<li>si : interruptions logicielles - Pourcentage de temps CPU passé à servir des interruptions logicielles</li>\n<li>st : temps volé - Si vous exécutez des machines virtuelles, c'est le pourcentage de temps CPU qui vous a été volé pour d'autres tâches</li>\n</ol>\n\n<b>4ème et 5ème ligne : Utilisation de la mémoire et de l'échange</b>\n\n<b>Liste des processus actuellement en cours d'utilisation</b>\n\n<ol>\n<li>PID : Identifiant du processus</li>\n<li>UTILISATEUR : utilisateur propriétaire du processus</li>\n<li>PR : Priorité du processus</li>\n<li>NI : La valeur agréable</li>\n<li>VIRT : Mémoire virtuelle utilisée par le processus</li>\n<li>RES : Mémoire physique utilisée par le processus</li>\n<li>SHR : Mémoire partagée du processus</li>\n<li>S : Indique l'état du processus : S=sommeil, R=exécution, Z=zombie, D=non interruptible, T=arrêté</li>\n<li>%CPU - c'est le pourcentage de CPU utilisé par ce processus</li>\n<li>%MEM - pourcentage de RAM utilisé par ce processus</li>\n<li>TIME+ - temps total d'activité de ce processus</li>\n<li>COMMANDE - nom du processus</li>\n</ol>\n\nVous pouvez également spécifier un ID de processus si vous voulez simplement suivre certains processus :\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "Quelle commande affiche la même sortie que la première ligne dans top?",
          "slug": "suividesprocessustop",
          "title": "Suivi des processus : top"
        },
        {
          "exercise": "Lisez les pages de manuel de lsof et fuser, il y a beaucoup d'informations que nous n'avons pas couvertes qui vous permettent d'avoir une plus grande flexibilité avec ces outils.",
          "id": 2,
          "lessonContent": "Imaginons que vous ayez branché une clé USB et commencé à travailler sur des fichiers. Une fois que vous avez terminé, vous démontez le périphérique USB et vous obtenez une erreur \"Périphérique ou ressource occupé\". Comment trouver quels fichiers de la clé USB sont encore en cours d'utilisation ? Il existe en fait deux outils que vous pouvez utiliser pour cela : \n\n<b>lsof</b>\n\nRappelez-vous que les fichiers ne sont pas seulement des fichiers texte, des images, etc., ce sont toutes les ressources du système, disques, tubes, sockets réseau, périphériques, etc. Pour voir ce qui est utilisé par un processus, vous pouvez utiliser la commande lsof (abrégé de \"list open files\"), cela vous montrera une liste de tous les fichiers ouverts et leur processus associé. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nMaintenant je peux voir quels processus détiennent actuellement le fichier/périphérique ouvert. Dans notre exemple de clé USB, vous pouvez également arrêter ces processus pour pouvoir démonter ce fichu lecteur.\n\n<b>fuser</b>\n\nUne autre façon de suivre un processus est la commande fuser (abrégé de \"file user\"), cela vous montrera des informations sur le processus qui utilise le fichier ou l'utilisateur du fichier. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nNous pouvons voir quels processus utilisent actuellement notre répertoire /home/pete. Les outils lsof et fuser sont très similaires, familiarisez-vous avec ces outils et essayez de les utiliser la prochaine fois que vous avez besoin de suivre un fichier ou un processus.",
          "quizAnswer": "lsof",
          "quizQuestion": "Quelle commande est utilisée pour lister les fichiers ouverts et leurs informations de processus ?",
          "slug": "suiviprocessuslsoffuser",
          "title": "lsof et fuser"
        },
        {
          "exercise": "Exécutez la commande <b>ps m</b> et voyez quels processus en cours d'exécution sont multi-thread.",
          "id": 3,
          "lessonContent": "Vous avez peut-être entendu parler des termes de processus à un seul thread et multi-thread. Les threads sont très similaires aux processus, car ils sont utilisés pour exécuter le même programme, ils sont souvent appelés processus légers. Si un processus a un thread, il est à un seul thread et s'il a plus d'un thread, il est multi-thread. Cependant, tous les processus ont au moins un thread. \n\nLes processus fonctionnent avec leurs propres ressources système isolées, cependant les threads peuvent partager ces ressources entre eux facilement, ce qui facilite leur communication entre eux et parfois il est plus efficace d'avoir une application multi-thread plutôt qu'une application multi-processus.\n\nEn gros, disons que vous ouvrez LibreOffice Writer et Chrome, chacun est son propre processus séparé. Maintenant, vous entrez dans Writer et commencez à éditer du texte, lorsque vous éditez le texte, il est automatiquement enregistré. Ces deux processus parallèles \"légers\" d'enregistrement et d'édition sont des threads. \n\nPour voir les threads de processus, vous pouvez utiliser: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nLes processus sont indiqués avec chaque PID et en dessous se trouvent leurs threads (indiqués par un --). Vous pouvez donc voir que les processus ci-dessus sont tous à un seul thread.",
          "quizAnswer": "Vrai",
          "quizQuestion": "Vrai ou faux, tous les processus commencent à un seul thread.",
          "slug": "threadsdeprocessus",
          "title": "Threads de Processus"
        },
        {
          "exercise": "Vérifiez la charge moyenne de votre système et voyez ce qu'elle fait.",
          "id": 4,
          "lessonContent": "Passons en revue une commande utile, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 en marche depuis 1 jour,  5:59,  2 utilisateurs,  charge moyenne: 0.00, 0.02, 0.05\n</pre>\n\nNous avons parlé de l'uptime dans la première leçon de ce cours, mais nous n'avons pas abordé le champ de la charge moyenne. Les moyennes de charge sont un bon moyen de voir la charge CPU sur votre système. Ces chiffres représentent la charge CPU moyenne dans des intervalles de 1, 5 et 15 minutes. Que signifie la charge CPU, la charge CPU est le nombre moyen de processus qui attendent d'être exécutés par le CPU.\n\nDisons que vous avez un CPU monocœur, pensez à ce cœur comme une seule voie de circulation. S'il y a des embouteillages sur l'autoroute, cette voie sera très fréquentée et la circulation sera à 100% ou une charge de 1. Maintenant, la circulation est devenue si mauvaise qu'elle bloque l'autoroute et rend les routes normales deux fois plus fréquentées par les voitures, nous pouvons dire que votre charge est de 200% ou une charge de 2. Maintenant, disons que cela se dégage un peu et qu'il y a seulement la moitié des voitures sur la voie rapide, nous pouvons dire que la charge de la voie est de 0.5. Lorsque la circulation est inexistante et que nous pouvons rentrer chez nous plus rapidement, la charge devrait idéalement être très faible, comme à 2h du matin. Les voitures dans ce cas sont des processus et ces processus attendent simplement de sortir de l'autoroute et de rentrer chez eux.\n\nMaintenant, juste parce que vous avez une charge moyenne de 1 ne signifie pas que votre ordinateur rame. La plupart des machines modernes de nos jours ont plusieurs cœurs. Si vous aviez un processeur quadricœur (4 cœurs) et que votre charge moyenne est de 1, cela affecte vraiment seulement 25% de votre CPU. Pensez à chaque cœur comme une voie de circulation. Vous pouvez voir le nombre de cœurs que vous avez sur votre système avec <b>cat /proc/cpuinfo</b>.\n\nLors de l'observation de la charge moyenne, vous devez tenir compte du nombre de cœurs, si vous constatez que votre machine utilise toujours une charge supérieure à la moyenne, il pourrait y avoir un problème en cours.",
          "quizAnswer": "uptime",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour voir la charge moyenne?",
          "slug": "surveillanceduprocesseur",
          "title": "Surveillance du processeur"
        },
        {
          "exercise": "Utilisez iostat pour afficher l'utilisation de votre disque.",
          "id": 5,
          "lessonContent": "Nous pouvons également surveiller l'utilisation du processeur ainsi que surveiller l'utilisation du disque avec un outil pratique connu sous le nom de <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nLa première partie concerne les informations sur le CPU :\n\n<ul>\n<li>%user - Affiche le pourcentage d'utilisation du CPU qui s'est produit lors de l'exécution au niveau utilisateur (application)</li>\n<li>%nice - Affiche le pourcentage d'utilisation du CPU qui s'est produit lors de l'exécution au niveau utilisateur avec une priorité nice. Utilisation du CPU utilisateur avec des priorités nice</li>\n<li>%system - Affiche le pourcentage d'utilisation du CPU qui s'est produit lors de l'exécution au niveau système (noyau).</li>\n<li>%iowait - Affiche le pourcentage de temps pendant lequel le CPU ou les CPU étaient inactifs alors que le système avait une demande d'E/S disque en attente.</li>\n<li>%steal - Affiche le pourcentage de temps passé en attente involontaire par le CPU ou les CPU virtuels pendant que l'hyperviseur servait un autre processeur virtuel.</li>\n<li>%idle - Affiche le pourcentage de temps pendant lequel le CPU ou les CPU étaient inactifs et le système n'avait pas de demande d'E/S disque en attente.</li>\n</ul>\n\nLa deuxième partie concerne l'utilisation du disque :\n\n<ul>\n<li>tps - Indique le nombre de transferts par seconde qui ont été émis vers le périphérique. Un transfert est une demande d'E/S au périphérique. De multiples demandes logiques peuvent être combinées en une seule demande d'E/S au périphérique. Un transfert est de taille indéterminée.</li>\n<li>kB_read/s - Indique la quantité de données lues à partir du périphérique exprimée en kilooctets par seconde.</li>\n<li>kB_wrtn/s - Indique la quantité de données écrites sur le périphérique exprimée en kilooctets par seconde.</li>\n<li>kB_read - Le nombre total de kilooctets lus.</li>\n<li>kB_wrtn - Le nombre total de kilooctets écrits.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "Quelle commande peut être utilisée pour afficher l'utilisation de l'E/S et du CPU?",
          "slug": "iomonitoring",
          "title": "Surveillance E/S"
        },
        {
          "exercise": "Regardez votre utilisation de la mémoire avec vmstat.",
          "id": 6,
          "lessonContent": "En plus de la surveillance du processeur et de la surveillance des E/S, vous pouvez surveiller votre utilisation de la mémoire avec <b>vmstat</b>\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nLes champs sont les suivants:\n\n<b>procs</b>\n<ul>\n<li>r - Nombre de processus en cours d'exécution</li>\n<li>b - Nombre de processus en sommeil non interruptible</li>\n</ul>\n\n<b>mémoire</b>\n<ul>\n<li>swpd - Quantité de mémoire virtuelle utilisée</li>\n<li>free - Quantité de mémoire libre</li>\n<li>buff - Quantité de mémoire utilisée comme tampons</li>\n<li>cache - Quantité de mémoire utilisée comme cache</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Quantité de mémoire échangée depuis le disque</li>\n<li>so - Quantité de mémoire échangée vers le disque</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Quantité de blocs reçus depuis un périphérique de blocs</li>\n<li>bo - Quantité de blocs envoyés vers un périphérique de blocs</li>\n</ul>\n\n<b>système</b>\n<ul>\n<li>in - Nombre d'interruptions par seconde</li>\n<li>cs - Nombre de changements de contexte par seconde</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Temps passé en temps utilisateur</li>\n<li>sy - Temps passé en temps noyau</li>\n<li>id - Temps passé inactif</li>\n<li>wa - Temps passé en attente d'E/S</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "Quel outil est utilisé pour visualiser l'utilisation de la mémoire?",
          "slug": "surveillancememoire",
          "title": "Surveillance de la mémoire"
        },
        {
          "exercise": "Installez sar sur votre système et commencez à collecter et analyser l'utilisation des ressources de votre système.",
          "id": 7,
          "lessonContent": "Ces outils de surveillance sont bons pour examiner lorsque votre machine rencontre des problèmes, mais que faire des machines qui rencontrent des problèmes lorsque vous ne les regardez pas. Pour celles-ci, vous devrez utiliser un outil de surveillance continue, quelque chose qui collectera, rapportera et sauvegardera les informations sur l'activité de votre système. Dans cette leçon, nous passerons en revue un excellent outil à utiliser <b>sar</b>.\n\n<b>Installation de sar</b>\nSar est un outil utilisé pour effectuer une analyse historique de votre système, assurez-vous d'abord de l'avoir installé en installant le package sysstat <b>sudo apt install sysstat</b>.\n\n<b>Mise en place de la collecte de données</b>\nGénéralement, une fois que vous avez installé sysstat, votre système commencera automatiquement à collecter des données, si ce n'est pas le cas, vous pouvez l'activer en modifiant le champ ENABLED dans /etc/default/sysstat.\n\n<b>Utilisation de sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nCette commande affichera les détails depuis le début de la journée.\n\n<pre>$ sudo sar -r</pre>\n\nCela affichera les détails de l'utilisation de la mémoire depuis le début de la journée.\n\n<pre>$ sudo sar -P</pre>\n\nCela affichera les détails de l'utilisation du processeur. \n\nPour voir une vue d'un jour différent, vous pouvez accéder à /var/log/sysstat/saXX où XX est le jour que vous souhaitez voir. \n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "Quel est un bon outil à utiliser pour surveiller les ressources système?",
          "slug": "surveillancecontinue",
          "title": "Surveillance continue"
        },
        {
          "exercise": "Créez une tâche cron que vous voulez exécuter à un moment planifié.",
          "id": 8,
          "lessonContent": "Bien que nous ayons parlé de l'utilisation des ressources, je pense que ce serait un bon moment pour mentionner un outil pratique sous Linux qui est utilisé pour planifier des tâches en utilisant cron. Il s'agit d'un service qui exécute des programmes pour vous à l'heure que vous avez planifiée. C'est vraiment utile si vous avez un script que vous voulez exécuter une fois par jour et qui doit faire quelque chose pour vous. \n\nPar exemple, disons que j'ai un script situé dans /home/pete/scripts/change_wallpaper. J'utilise ce script chaque matin pour changer l'image que j'utilise comme fond d'écran, mais chaque matin je dois exécuter ce script manuellement. Au lieu de cela, je peux créer une tâche cron qui exécute mon script via cron. Je peux spécifier l'heure à laquelle je veux que cette tâche cron s'exécute et exécute mon script. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nLes champs sont les suivants de gauche à droite :\n<ul>\n<li>Minute - (0-59)</li>\n<li>Heure - (0-23)</li>\n<li>Jour du mois - (1-31)</li>\n<li>Mois - (1-12)</li>\n<li>Jour de la semaine - (0-7). 0 et 7 sont désignés comme dimanche</li>\n</ul>\n\nL'astérisque dans le champ signifie correspondre à chaque valeur. Ainsi, dans mon exemple ci-dessus, je veux que cela s'exécute tous les jours de chaque mois à 8h30.\n\nPour créer une tâche cron, il suffit de modifier le fichier crontab :\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "Quelle est la commande pour éditer vos tâches cron ?",
          "slug": "cronjobs",
          "title": "Tâches Cron"
        }
      ],
      "slug": "processutilization",
      "title": "Utilisation des processus"
    },
    {
      "description": "Apprenez à propos des journaux système et du répertoire /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Consultez votre fichier /var/log/syslog et voyez ce qui se passe d'autre sur votre machine.",
          "id": 1,
          "lessonContent": "Les services, le noyau, les démons, etc. de votre système font constamment quelque chose, ces données sont en fait envoyées pour être enregistrées sur votre système sous forme de journaux. Cela nous permet d'avoir un journal lisible par l'homme des événements qui se produisent sur notre système. Ces données sont généralement conservées dans le répertoire /var, le répertoire /var est l'endroit où nous conservons nos données variables, telles que les journaux !\n\nComment ces messages sont-ils même reçus sur votre système ? Il existe un service appelé syslog qui envoie ces informations au journal système. \n\nSyslog contient en fait de nombreux composants, l'un des plus importants est un démon en cours d'exécution appelé syslogd (les distributions Linux plus récentes utilisent rsyslogd), qui attend que des messages d'événements se produisent et filtre ceux dont il veut être informé, et en fonction de ce qu'il est censé faire avec ce message, il l'enverra à un fichier, à votre console ou ne fera rien avec.\n\nVous penseriez que ce journal système est l'endroit centralisé pour gérer les journaux, mais malheureusement ce n'est pas le cas. Vous verrez de nombreuses applications qui écrivent leurs propres règles de journalisation et génèrent différents fichiers journaux, cependant en général le format des journaux devrait inclure une horodatage et les détails de l'événement. \n\nVoici un exemple d'une ligne de syslog :\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nIci, nous pouvons voir qu'à Jan 27 07:41:32 notre service cron a exécuté la tâche cron.weekly. Vous pouvez consulter tous les messages d'événements collectés par syslog dans le fichier /var/log/syslog.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "Quel est le démon qui gère les journaux sur les nouveaux systèmes Linux ?",
          "slug": "journalisationsysteme",
          "title": "Journalisation du système"
        },
        {
          "exercise": "Consultez votre fichier de configuration /etc/rsyslog.d et voyez ce qui est également journalisé via le journal système.",
          "id": 2,
          "lessonContent": "Le service syslog gère et envoie des journaux vers le journal système. Rsyslog est une version avancée de syslog, la plupart des distributions Linux devraient utiliser cette nouvelle version. La sortie de tous les journaux collectés par le service syslog se trouve dans /var/log/syslog (chaque message sauf les messages d'authentification).\n\nPour savoir quels fichiers sont gérés par notre journal système, consultez les fichiers de configuration dans /etc/rsyslog.d:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nCes règles pour les fichiers journaux sont indiquées par le sélecteur dans la colonne de gauche et l'action dans la colonne de droite. L'action nous indique où envoyer les informations de journalisation, dans un fichier, une console, etc. Rappelez-vous que toutes les applications et services n'utilisent pas rsyslog pour gérer leurs journaux, donc si vous voulez savoir spécifiquement ce qui est journalisé, vous devrez regarder à l'intérieur de ce répertoire.\n\nVoyons en fait la journalisation en action, vous pouvez envoyer manuellement un journal avec la commande logger:\n\n<pre>\nlogger -s Bonjour\n</pre>\n\nMaintenant, regardez à l'intérieur de votre /var/log/syslog et vous devriez voir cette entrée dans vos journaux!",
          "quizAnswer": "logger",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour journaliser manuellement un message?",
          "slug": "syslog",
          "title": "D'abord quelques fichiers journaux standard. Journal par service."
        },
        {
          "exercise": "Regardez vos fichiers /var/log/messages et /var/log/syslog et voyez quelles sont les différences.",
          "id": 3,
          "lessonContent": "Il existe de nombreux fichiers journaux que vous pouvez consulter sur votre système, beaucoup d'entre eux importants se trouvent sous /var/log. Nous n'allons pas tous les passer en revue, mais nous discuterons de quelques-uns des principaux. \n\nIl existe deux fichiers journaux généraux que vous pouvez consulter pour avoir un aperçu de ce que fait votre système :\n\n<b>/var/log/messages</b>\n\nCe journal contient tous les messages non critiques et non de débogage, inclut les messages enregistrés lors du démarrage (dmesg), auth, cron, daemon, etc. Très utile pour avoir un aperçu du comportement de votre machine. \n\n<b>/var/log/syslog</b>\n\nCela enregistre tout sauf les messages d'authentification, c'est extrêmement utile pour déboguer les erreurs sur votre machine. \n\nCes deux journaux devraient suffire largement pour résoudre les problèmes de votre système. Cependant, si vous voulez simplement consulter un composant de journal spécifique, il existe également des journaux séparés pour cela.",
          "quizAnswer": "syslog",
          "quizQuestion": "Quel fichier journal enregistre tout sauf les messages d'authentification?",
          "slug": "journalisationgenerale",
          "title": "Journalisation générale"
        },
        {
          "exercise": "Regardez vos journaux dmesg et kern, quelles différences remarquez-vous ?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nAu démarrage, votre système enregistre des informations sur le tampon d'anneau du noyau. Cela nous montre des informations sur les pilotes matériels, les informations du noyau et l'état lors du démarrage, et plus encore. Ce fichier journal peut être trouvé à /var/log/dmesg et est réinitialisé à chaque démarrage, vous ne verrez peut-être pas d'utilité pour le moment, mais si vous rencontrez des problèmes lors du démarrage ou un problème matériel, dmesg est le meilleur endroit où regarder. Vous pouvez également afficher ce journal en utilisant la commande dmesg. \n\n<b>/var/log/kern.log</b>\nUn autre journal que vous pouvez utiliser pour afficher les informations du noyau est le fichier /var/log/kern.log, qui enregistre les informations et les événements du noyau sur votre système, il enregistre également la sortie de dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "Quelle commande peut être utilisée pour afficher les messages de démarrage du noyau ?",
          "slug": "journalisationnoyau",
          "title": "Journalisation du noyau"
        },
        {
          "exercise": "Effectuez quelques échecs de connexion puis une réussie, regardez votre /var/log/auth.log et voyez ce qui s'est passé.",
          "id": 5,
          "lessonContent": "La journalisation de l'authentification peut être très utile pour examiner si vous rencontrez des problèmes de connexion. \n\n<b>/var/log/auth.log</b>\n\nCela contient les journaux d'autorisation du système, tels que les connexions d'utilisateurs et la méthode d'authentification utilisée. \n\nExtrait d'exemple:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "Quel journal est utilisé pour l'authentification de l'utilisateur?",
          "slug": "journalisationauthentification",
          "title": "Journalisation de l'authentification"
        },
        {
          "exercise": "Consultez votre fichier de configuration logrotate et voyez comment il gère certains de vos journaux.",
          "id": 6,
          "lessonContent": "Les fichiers journaux génèrent beaucoup de données et les stockent sur vos disques durs, cependant il y a beaucoup de problèmes avec cela, pour la plupart nous voulons juste pouvoir voir les journaux les plus récents, nous voulons également gérer efficacement notre espace disque, alors comment faisons-nous tout cela? La réponse est avec logrotate. \n\nL'utilitaire logrotate gère les journaux pour nous. Il dispose d'un fichier de configuration qui nous permet de spécifier combien et quels journaux conserver, comment compresser nos journaux pour économiser de l'espace et plus encore. L'outil logrotate est généralement exécuté à partir de cron une fois par jour et les fichiers de configuration peuvent être trouvés dans /etc/logrotate.d. \n\nIl existe d'autres outils de rotation de journaux que vous pouvez utiliser pour gérer vos journaux, mais logrotate est le plus courant.",
          "quizAnswer": "logrotate",
          "quizQuestion": "Quel utilitaire est utilisé pour gérer les journaux?",
          "slug": "gestiondesfichiersjournaux",
          "title": "Gestion des fichiers journaux"
        }
      ],
      "slug": "journalisation",
      "title": "Journalisation"
    },
    {
      "description": "Apprenez le partage de réseau avec rsync, scp, nfs et plus encore.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Essayez de copier un fichier avec scp d'une machine à une autre.",
          "id": 1,
          "lessonContent": "Vous n'êtes généralement pas le seul ordinateur sur votre réseau, c'est particulièrement vrai si vous travaillez dans un environnement commercial. Lorsque nous voulons transférer des données d'une machine à une autre, il est parfois plus facile de connecter une clé USB et de les copier manuellement. Mais la plupart du temps, si vous travaillez avec des machines sur le même réseau, la manière de transférer des données est par le biais du partage de fichiers en réseau. \n\nDans ce cours, nous passerons en revue quelques méthodes différentes pour copier des données de et vers différentes machines sur votre réseau. Nous discuterons de quelques copies de fichiers simples, puis nous parlerons du montage de répertoires entiers sur votre machine qui agissent comme un lecteur séparé. \n\nUn outil simple de partage de fichiers est la commande <b>scp</b>. La commande scp signifie copie sécurisée, elle fonctionne exactement comme le fait la commande cp, mais vous permet de copier d'un hôte à un autre sur le même réseau. Elle fonctionne via ssh, donc toutes vos actions utilisent la même authentification et sécurité que ssh. \n\n<b>Pour copier un fichier de l'hôte local vers un hôte distant</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>Pour copier un fichier d'un hôte distant vers votre hôte local</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>Pour copier un répertoire de votre hôte local vers un hôte distant</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour copier des fichiers en toute sécurité d'un hôte à un autre?",
          "slug": "partagedefichiersenreseau",
          "title": "Présentation du partage de fichiers"
        },
        {
          "exercise": "Utilisez rsync pour synchroniser un répertoire avec un autre répertoire, assurez-vous de ne pas écraser un répertoire important !",
          "id": 2,
          "lessonContent": "Un autre outil utilisé pour copier des données entre différents hôtes est rsync (abréviation de synchronisation à distance). Rsync est très similaire à scp, mais il présente une différence majeure. Rsync utilise un algorithme spécial qui vérifie à l'avance s'il existe déjà des données que vous êtes en train de copier et ne copiera que les différences. Par exemple, imaginons que vous copiez un fichier et que votre réseau soit interrompu, arrêtant ainsi votre copie en cours. Au lieu de tout recopier depuis le début, rsync ne copiera que les parties qui n'ont pas été copiées. \n\nIl vérifie également l'intégrité d'un fichier que vous copiez avec des sommes de contrôle. Ces petites optimisations permettent une plus grande flexibilité de transfert de fichiers et rendent rsync idéal pour la synchronisation de répertoires à distance et localement, les sauvegardes de données, les transferts de données volumineux, etc.\n\nQuelques options couramment utilisées avec rsync :\n\n<ul>\n<li>v - affichage détaillé</li>\n<li>r - récursif dans les répertoires</li>\n<li>h - affichage lisible par l'homme</li>\n<li>z - compressé pour un transfert plus facile, idéal pour les connexions lentes</li>\n</ul>\n\n<b>Copier/synchroniser des fichiers sur le même hôte</b>\n\n<pre>$ rsync -zvr /mon/répertoire/local/un /mon/répertoire/local/deux</pre>\n\n<b>Copier/synchroniser des fichiers vers l'hôte local depuis un hôte distant</b>\n\n<pre>$ rsync /répertoire/local nom_utilisateur@hôte_distant.com:/répertoire/à_distance</pre>\n\n<b>Copier/synchroniser des fichiers vers un hôte distant depuis un hôte local</b>\n\n<pre>$ rsync nom_utilisateur@hôte_distant.com:/répertoire/à_distance /répertoire/local</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "Quelle commande serait utile pour les sauvegardes de données ?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "Essayez de configurer un SimpleHTTPServer !",
          "id": 3,
          "lessonContent": "Python dispose d'un outil très utile pour servir des fichiers via HTTP. C'est idéal si vous souhaitez simplement créer un partage réseau rapide auquel d'autres machines de votre réseau peuvent accéder. Pour cela, il vous suffit de vous rendre dans le répertoire que vous souhaitez partager et d'exécuter :\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nCela configure un serveur web de base auquel vous pouvez accéder via l'adresse localhost. Ainsi, récupérez l'adresse IP de la machine sur laquelle vous avez exécuté cette commande, puis sur une autre machine, accédez-y dans le navigateur avec : http://ADRESSE_IP:8000. Sur votre propre machine, vous pouvez voir les fichiers disponibles en tapant : http://localhost:8000 dans votre navigateur web.\n\nVous pouvez également faire cela avec node ou si vous utilisez Python 3, la syntaxe sera un peu différente.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Quel outil pouvez-vous utiliser pour créer un serveur http simple avec python ?",
          "slug": "simplehttpserver",
          "title": "Serveur HTTP Simple"
        },
        {
          "exercise": "Lisez la page de manuel de NFS pour en savoir plus.",
          "id": 4,
          "lessonContent": "Le partage de fichiers réseau le plus standard pour Linux est NFS (Network File System), NFS permet à un serveur de partager des répertoires et des fichiers avec un ou plusieurs clients sur le réseau. \n\nNous n'entrerons pas dans les détails de la création d'un serveur NFS car cela peut devenir complexe, cependant nous discuterons de la configuration des clients NFS.\n\n<b>Configuration du client NFS</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>Montage automatique</b>\n\nDisons que vous utilisez souvent le serveur NFS et que vous souhaitez le monter de manière permanente, normalement vous penseriez à modifier le fichier /etc/fstab, mais vous ne parviendrez pas toujours à vous connecter au serveur et cela peut poser des problèmes au démarrage. Au lieu de cela, ce que vous voulez faire, c'est configurer le montage automatique afin de pouvoir vous connecter au serveur NFS lorsque vous en avez besoin. Cela se fait avec l'outil <b>automount</b> ou dans les versions récentes de Linux <b>amd</b>. Lorsqu'un fichier est accédé dans un répertoire spécifié, automount recherchera le serveur distant et le montera automatiquement.",
          "quizAnswer": "automount",
          "quizQuestion": "Quel outil est utilisé pour gérer automatiquement les points de montage?",
          "slug": "partagedefichiersréseauenfs",
          "title": "NFS"
        },
        {
          "exercise": "Configurer un partage Samba, si vous n'en avez pas, ouvrez smb.conf et familiarisez-vous avec les options du fichier de configuration.",
          "id": 5,
          "lessonContent": "Aux débuts de l'informatique, il est devenu nécessaire pour les machines Windows de partager des fichiers avec des machines Linux, d'où la naissance du protocole Server Message Block (SMB). SMB était utilisé pour le partage de fichiers entre les systèmes d'exploitation Windows (Mac dispose également du partage de fichiers avec SMB) puis il a été nettoyé et optimisé sous la forme du protocole Common Internet File System (CIFS).\n\nSamba est ce que nous appelons les utilitaires Linux pour travailler avec CIFS sur Linux. En plus du partage de fichiers, vous pouvez également partager des ressources comme des imprimantes.\n\n<b>Créer un partage réseau avec Samba</b>\n\nPassons en revue les étapes de base pour créer un partage réseau auquel une machine Windows peut accéder :\n\n<b>Installer Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Configurer smb.conf</b>\n\nLe fichier de configuration de Samba se trouve à /etc/samba/smb.conf, ce fichier doit indiquer au système quels répertoires doivent être partagés, leurs autorisations d'accès et d'autres options. Le smb.conf par défaut contient déjà beaucoup de code commenté que vous pouvez utiliser comme exemple pour rédiger vos propres configurations.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Configurer un mot de passe pour Samba</b>\n\n<pre>$ sudo smbpasswd -a [nom_utilisateur]</pre>\n\n<b>Créer un répertoire partagé</b>\n\n<pre>$ mkdir /mon/répertoire/à/partager</pre>\n\n<b>Redémarrer le service Samba</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Accéder à un partage Samba via Windows</b>\n\nSous Windows, tapez simplement la connexion réseau dans l'invite d'exécution : \\\\HÔTE\\nom_partage.\n\n<b>Accéder à un partage Samba/Windows via Linux</b>\n\n<pre>$ smbclient //HÔTE/répertoire -U utilisateur</pre>\n\nLe package Samba inclut un outil en ligne de commande appelé <b>smbclient</b> que vous pouvez utiliser pour accéder à n'importe quel serveur Windows ou Samba. Une fois connecté au partage, vous pouvez naviguer et transférer des fichiers.\n\n<b>Attacher un partage Samba à votre système</b>\n\nAu lieu de transférer des fichiers un par un, vous pouvez simplement monter le partage réseau sur votre système.\n\n<pre>$ sudo mount -t cifs nom_serveur:répertoire point_de_montage -o utilisateur=nom_utilisateur,mot_de_passe=mdp</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Quel est le dernier protocole utilisé pour le transfert de fichiers entre Windows et Linux?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Partage de réseau"
    },
    {
      "description": "Apprenez les bases du réseau et le modèle TCP/IP.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 1,
          "lessonContent": "Jetons un coup d'œil à un réseau domestique typique, vous avez quelques composants différents. \n\n<ul>\n<li>FAI - Votre fournisseur de services Internet, la société à laquelle vous payez pour obtenir Internet à votre domicile.</li>\n<li>Routeur - Le routeur permet à chaque machine de votre réseau de se connecter à Internet. Dans la plupart des routeurs modernes, vous pouvez vous connecter via le sans fil ou un câble Ethernet.</li>\n<li>WAN - Réseau étendu, c'est ce que nous appelons le réseau qui englobe tout entre votre routeur et un réseau plus large tel qu'Internet.</li>\n<li>WLAN - Réseau local sans fil, c'est le réseau entre votre routeur et tous les appareils sans fil que vous pourriez avoir comme des ordinateurs portables.</li>\n<li>LAN - Réseau local, c'est le réseau entre votre routeur et tous les appareils câblés tels que les PC de bureau.</li>\n<li>Hôtes - Chaque machine sur un réseau est appelée un hôte.</li>\n</ul>\n\nLes données et les informations qui sont transmises à travers les réseaux sont appelées des paquets et à la fin de la section Nomade du Réseau, vous comprendrez en détail comment un paquet se déplace vers et depuis les hôtes.",
          "quizAnswer": "LAN",
          "quizQuestion": "Comment appelle-t-on le réseau local?",
          "slug": "basesreseau",
          "title": "Bases du réseau"
        },
        {
          "exercise": "En savoir plus sur le modèle OSI : <a href=\"https://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI\">https://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI</a>",
          "id": 2,
          "lessonContent": "Avant de pouvoir aborder des aspects pratiques du réseau, nous devons passer en revue quelques termes ennuyeux que vous avez probablement déjà entendus. Le modèle OSI (Open Systems Interconnection) est un modèle théorique de réseau. Ce modèle nous montre comment un paquet traverse un réseau en sept couches différentes. Je ne rentrerai pas dans les détails de ce modèle, car la plupart de ces cours de réseau se concentreront sur le modèle TCP/IP, mais il convient de mentionner qu'un tel modèle théorique de réseau existe et a en fait joué un grand rôle dans le modèle de réseau TCP/IP que nous utilisons aujourd'hui.",
          "quizAnswer": "OSI",
          "quizQuestion": "Quel est utilisé comme modèle théorique de réseau ?",
          "slug": "modeleosi",
          "title": "Modèle OSI"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Le modèle OSI a donné naissance à ce qui est finalement devenu le modèle TCP/IP et ce modèle est en fait sur lequel Internet est basé. C'est la mise en œuvre réelle du réseau. Le modèle TCP/IP utilise la suite de protocoles TCP/IP, que nous appelons simplement TCP/IP. Ces protocoles travaillent ensemble pour spécifier comment les données doivent être collectées, adressées, transmises et routées à travers un réseau. En utilisant le modèle TCP/IP, nous pouvons voir comment ces protocoles sont utilisés pour montrer le déroulement du voyage d'un paquet à travers le réseau.\n\n<b>Couche Application</b>\n\nLa couche supérieure du modèle TCP/IP. Elle détermine comment les programmes de votre ordinateur (comme votre navigateur web) interagissent avec les services de la couche transport pour visualiser les données qui sont envoyées ou reçues.\n\nCette couche utilise :\n<ul>\n<li>HTTP (Hypertext Transfer Protocol) - utilisé pour les pages web sur Internet.</li>\n<li>SMTP (Simple Mail Transfer Protocol) - transmission de courrier électronique (email)</li>\n</ul>\n\n<b>Couche Transport</b>\n\nComment les données seront transmises, inclut la vérification des ports corrects, l'intégrité des données, et essentiellement la livraison de nos paquets.\n\nCette couche utilise :\n<ul>\n<li>TCP (Transmission Control Protocol) - livraison fiable des données</li>\n<li>UDP (User Datagram Protocol) - livraison non fiable des données</li>\n</ul>\n\n<b>Couche Réseau</b>\n\nCette couche spécifie comment déplacer les paquets entre les hôtes et à travers les réseaux.\n\nCette couche utilise :\n<ul>\n<li>IP (Internet Protocol) - Aide à router les paquets d'une machine à une autre.</li>\n<li>ICMP (Internet Control Message Protocol) - Aide à nous dire ce qui se passe, comme les messages d'erreur et les informations de débogage.</li>\n</ul>\n\n<b>Couche Liaison</b>\n\nCette couche spécifie comment envoyer des données à travers un morceau de matériel physique. Comme les données qui voyagent à travers Ethernet, la fibre optique, etc.\n\nLes listes ci-dessus des protocoles utilisés par chaque couche ne sont pas exhaustives et vous rencontrerez de nombreux autres protocoles qui entrent en jeu.\n\nDans les leçons suivantes, nous plongerons dans chacune de ces couches et discuterons de la traversée de notre paquet à travers le réseau selon le modèle TCP/IP (il existe de nombreuses perspectives sur la manière dont un paquet voyage à travers les réseaux, nous n'en examinerons pas toutes, mais sachez qu'elles existent).",
          "quizAnswer": "Application",
          "quizQuestion": "Quelle est la couche supérieure du modèle TCP/IP?",
          "slug": "modele-tcpip",
          "title": "Modèle TCP/IP"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 4,
          "lessonContent": "Avant de voir comment un paquet se déplace à travers un réseau, nous devons nous familiariser avec certains termes. Lorsque vous envoyez une lettre, vous devez savoir à qui elle est destinée et d'où elle provient. Les paquets ont besoin des mêmes informations, nos hôtes et d'autres hôtes sont identifiés à l'aide d'adresses MAC (media access control) et d'adresses IP, pour faciliter les choses pour nous, les humains, nous utilisons des noms d'hôtes pour identifier un hôte.\n\n<b>Adresses MAC</b>\n\nUne adresse MAC est un identifiant unique utilisé comme adresse matérielle. Cette adresse ne changera jamais. Lorsque vous voulez accéder à Internet, votre machine doit avoir un périphérique appelé une carte réseau. Cet adaptateur réseau a sa propre adresse matérielle qui est utilisée pour identifier votre machine. Une adresse MAC pour un périphérique Ethernet ressemble à ceci 00:C4:B5:45:B2:43. Les adresses MAC sont attribuées aux adaptateurs réseau lors de leur fabrication. Chaque fabricant a un identifiant unique organisationnel (OUI) pour les identifier en tant que fabricant. Cet OUI est indiqué par les 3 premiers octets de l'adresse MAC. Par exemple, Dell a 00-14-22, donc un adaptateur réseau de Dell pourrait avoir une adresse MAC comme: 00-14-22-34-B2-C2. \n\n<b>Adresses IP</b>\n\nUne adresse IP est utilisée pour identifier un appareil sur un réseau, elles sont indépendantes du matériel et peuvent varier en syntaxe en fonction de l'utilisation d'IPv4 ou IPv6 (nous en parlerons plus tard). Pour l'instant, nous supposerons que vous utilisez IPv4, donc une adresse IP typique ressemblerait à ceci: 10.24.12.4. Les adresses IP sont utilisées du côté logiciel du réseau. Chaque fois qu'un système est connecté à Internet, il doit avoir une adresse IP. Elles peuvent également changer si votre réseau change et sont uniques à l'ensemble d'Internet (ce n'est pas toujours le cas une fois que nous en apprenons davantage sur NAT). \n\nN'oubliez pas qu'il faut à la fois du logiciel et du matériel pour déplacer des paquets à travers les réseaux, nous avons donc deux identifiants pour chacun, MAC (matériel) et IP (logiciel).\n\n<b>Noms d'hôtes</b>\n\nUne dernière façon d'identifier vos machines est à travers le nom d'hôte. Les noms d'hôtes prennent votre adresse IP et vous permettent de lier cette adresse à un nom lisible par un humain. Au lieu de se souvenir de 192.12.41.4, vous pouvez simplement vous souvenir de monhote.com.",
          "quizAnswer": "4",
          "quizQuestion": "Combien d'octets y a-t-il dans une adresse IPv4?",
          "slug": "adressageréseau",
          "title": "Adressage réseau"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Imaginons que je veuille envoyer un e-mail à Patty. Nous allons passer en revue chacune des couches TCP/IP pour voir cela en action. \n\nRappelez-vous que des paquets sont utilisés pour transmettre des données à travers les réseaux, un paquet se compose d'un en-tête et d'une charge utile. L'en-tête contient des informations sur l'endroit où le paquet va et d'où il vient. La charge utile est la donnée réelle qui est transférée. Alors que notre paquet traverse le réseau, chaque couche ajoute un peu d'information à l'en-tête du paquet. Gardez également à l'esprit que différentes couches utilisent un terme différent pour notre \"paquet\". Dans la couche transport, nous encapsulons essentiellement nos données dans un segment et dans la couche liaison, nous appelons cela une trame, mais sachez simplement que le terme paquet peut être utilisé pour désigner la même chose.\n\nNous commençons d'abord par la couche application. Lorsque nous envoyons notre e-mail via notre client de messagerie, la couche application encapsulera ces données. La couche application communique avec la couche transport via un port spécifié et à travers ce port, elle envoie ses données. Nous voulons envoyer un e-mail via le protocole de la couche application SMTP (protocole simple de transfert de courrier). Les données sont envoyées via notre protocole de transport qui ouvre une connexion vers ce port (le port 25 est utilisé pour SMTP), donc nous obtenons ces données envoyées via ce port et ces données sont envoyées à la couche transport pour être encapsulées en segments.",
          "quizAnswer": "Application",
          "quizQuestion": "Quelle couche est utilisée pour présenter les données du paquet dans un format convivial pour l'utilisateur?",
          "slug": "coucheapplication",
          "title": "Couche Application"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 6,
          "lessonContent": "La couche de transport nous aide à transférer nos données de manière lisible par les réseaux. Elle divise nos données en morceaux qui seront transportés et remis dans le bon ordre. Ces morceaux sont appelés segments. Les segments facilitent le transport des données à travers les réseaux. \n\n<b>Ports</b>\n\nMême si nous savons où nous envoyons nos données via des adresses IP, elles ne sont pas assez spécifiques pour envoyer nos données à des processus ou services spécifiques. Des services tels que HTTP utilisent un canal de communication via des ports. Si nous voulons envoyer des données de page web, nous devons les envoyer sur le port HTTP (port 80). En plus de former des segments, la couche de transport attachera également les ports source et destination au segment, de sorte que lorsque le destinataire reçoit le paquet final, il saura quel port utiliser. \n\n<b>UDP</b>\n\nIl existe deux protocoles de transport populaires, UDP et TCP. Nous discuterons brièvement de l'UDP et passerons la plupart de notre temps sur le TCP, car c'est celui le plus couramment utilisé.\n\nL'UDP n'est pas une méthode fiable de transport de données, en fait, il n'est pas vraiment important si vous recevez toutes vos données d'origine. Cela peut sembler terrible, mais il a ses utilisations, comme pour le streaming multimédia, il est acceptable de perdre quelques trames en retour pour obtenir vos données un peu plus rapidement. \n\n<b>TCP</b>\n\nTCP fournit une connexion fiable orientée vers un flux de données. TCP utilise des ports pour envoyer des données vers et depuis des hôtes. Une application ouvre une connexion d'un port sur son hôte à un autre port sur un hôte distant. Pour établir la connexion, nous utilisons le handshake TCP. \n\n<ul>\n<li>Le client (processus de connexion) envoie un segment SYN au serveur pour demander une connexion</li>\n<li>Le serveur envoie au client un segment SYN-ACK pour accuser réception de la demande de connexion du client</li>\n<li>Le client envoie un ACK au serveur pour accuser réception de la demande de connexion du serveur</li>\n</ul>\n\nUne fois cette connexion établie, les données peuvent être échangées via une connexion TCP. Les données sont envoyées sous forme de segments différents et sont suivies avec des numéros de séquence TCP pour qu'elles puissent être ordonnées dans le bon ordre lors de leur livraison. Dans notre exemple d'e-mail, la couche de transport attache le port de destination (25) au port source de l'hôte source.",
          "quizAnswer": "TCP",
          "quizQuestion": "Quel est un protocole de transport fiable?",
          "slug": "couchedetransport",
          "title": "Couche de transport"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 7,
          "lessonContent": "La couche Réseau détermine l'acheminement de nos paquets de notre hôte source à un hôte de destination. Heureusement, dans notre exemple, notre paquet ne voyage que dans le même réseau, mais Internet est composé de nombreux réseaux. Ces réseaux plus petits qui composent Internet sont appelés sous-réseaux. Tous les sous-réseaux sont connectés les uns aux autres d'une manière ou d'une autre, c'est pourquoi nous pouvons accéder à www.google.com même s'il est sur son propre réseau. Je ne rentrerai pas dans les détails car nous avons un cours entier dédié aux sous-réseaux, mais pour le moment, en ce qui concerne notre couche Réseau, sachez que les adresses IP définissent les règles pour se rendre dans différents sous-réseaux. \n\nDans la couche réseau, elle reçoit le segment provenant de la couche transport et encapsule ce segment dans un paquet IP, puis attache l'adresse IP de l'hôte source et l'adresse IP de l'hôte de destination à l'en-tête du paquet. À ce stade, notre paquet contient des informations sur sa destination et son origine. Maintenant, il envoie notre paquet à la couche matérielle physique.",
          "quizAnswer": "sous-réseaux",
          "quizQuestion": "Comment sont appelés les réseaux plus petits qui composent Internet?",
          "slug": "couche-reseau",
          "title": "Couche Réseau"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 8,
          "lessonContent": "Au bas du modèle TCP/IP se trouve la couche de liaison. Cette couche est la couche spécifique au matériel.\n\nDans la couche de liaison, notre paquet est encapsulé une fois de plus dans quelque chose appelé un cadre. L'en-tête du cadre attache les adresses MAC source et destination de nos hôtes, les sommes de contrôle et les séparateurs de paquets afin que le récepteur puisse savoir quand un paquet se termine. \n\nHeureusement, nous sommes sur le même réseau, donc notre paquet n'aura pas à parcourir une grande distance. Tout d'abord, la couche de liaison attache mon adresse MAC source à l'en-tête du cadre, mais elle doit également connaître l'adresse MAC de Patty. Comment le sait-elle et comment puis-je la trouver puisqu'elle n'est pas sur Internet ? Nous utilisons ARP !\n\n<b>ARP (protocole de résolution d'adresse)</b>\n\nARP trouve l'adresse MAC associée à une adresse IP. ARP est utilisé dans le même réseau. Si Patty n'était pas sur le même réseau, nous utiliserions un système de routage pour déterminer le prochain routeur qui recevrait le paquet et une fois que nous serions sur le même réseau, nous pourrions utiliser ARP. \n\nUne fois sur le même réseau, les systèmes utilisent d'abord la table de recherche ARP qui stocke des informations sur quelles adresses IP sont associées à quelles adresses MAC. Si la valeur n'est pas là, alors ARP est utilisé. Ensuite, le système enverra un message de diffusion sur le réseau en utilisant le protocole ARP pour savoir quel hôte possède l'IP 10.10.1.4. Un message de diffusion est un message spécial envoyé à tous les hôtes d'un réseau (nommé de manière appropriée pour l'envoi d'une diffusion). Toute machine avec l'adresse IP demandée répondra avec un paquet ARP contenant l'adresse IP et l'adresse MAC.\n\nMaintenant que nous avons toutes les données nécessaires, adresse IP et adresses MAC, notre couche de liaison transmet ce cadre via notre carte réseau, jusqu'au prochain appareil et trouve le réseau de Patty. Cette étape est un peu plus complexe que ce que je viens d'expliquer, mais nous discuterons de plus de détails dans le cours sur le routage.\n\nEt voilà un parcours de paquet simple (ou pas si simple) dans la couche TCP/IP. Gardez à l'esprit que les paquets ne voyagent pas de cette façon unidirectionnelle. Nous n'avons même pas encore atteint le réseau de Patty ! Lorsqu'on voyage à travers les réseaux, il faut passer par le modèle TCP/IP au moins deux fois avant que des données ne soient envoyées ou reçues. En réalité, l'aspect de ce paquet serait quelque chose comme ceci : \n\n<b>Parcours de paquet</b>\n\n<ol>\n<li>Pete envoie un email à Patty : ces données sont envoyées à la couche transport.</li>\n<li>La couche transport encapsule les données dans un en-tête TCP ou UDP pour former un segment, le segment attache les ports TCP ou UDP de destination et source, puis le segment est envoyé à la couche réseau.</li>\n<li>La couche réseau encapsule le segment TCP à l'intérieur d'un paquet IP, elle attache les adresses IP source et destination. Puis route le paquet vers la couche de liaison.</li>\n<li>Le paquet atteint ensuite le matériel physique de Pete et est encapsulé dans un cadre. Les adresses MAC source et destination sont ajoutées au cadre.</li>\n<li>Patty reçoit ce cadre de données via sa couche physique et vérifie chaque cadre pour l'intégrité des données, puis désencapsule le contenu du cadre et envoie le paquet IP à la couche réseau.</li>\n<li>La couche réseau lit le paquet pour trouver l'adresse IP source et destination qui était précédemment attachée. Elle vérifie si son IP est la même que l'IP de destination, ce qui est le cas ! Elle désencapsule le paquet et envoie le segment à la couche transport.</li>\n<li>La couche transport désencapsule les segments, vérifie les numéros de port TCP ou UDP et établit une connexion à la couche application en fonction de ces numéros de port.</li>\n<li>La couche application reçoit les données de la couche transport sur le port spécifié et les présente à Patty sous la forme du message email final</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Qu'est-ce qui est utilisé pour trouver l'adresse MAC sur le même réseau ?",
          "slug": "couche-de-lien",
          "title": "Couche de liaison"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 9,
          "lessonContent": "Un concept réseau important que nous n'avons pas encore abordé est le DHCP (Dynamic Host Configuration Protocol)\n\nLe DHCP attribue des adresses IP, des masques de sous-réseau et des passerelles à nos machines. Par exemple, disons que vous avez un téléphone portable et que vous voulez obtenir un numéro de téléphone pour commencer à parler aux gens. Vous devez appeler votre opérateur téléphonique et ils vous donneront un numéro. Tant que vous payez vos factures, vous pouvez continuer à utiliser votre téléphone. Le DHCP est l'opérateur téléphonique dans ce cas, il vous attribue une adresse IP afin que vous puissiez communiquer avec d'autres adresses IP. Vous avez également une adresse IP en location, celles-ci durent pendant une certaine période, puis seront renouvelées en fonction de vos paramètres de location. \n\nLe DHCP est excellent pour de nombreuses raisons, il permet à un administrateur réseau de ne pas se soucier de l'attribution des adresses IP et l'empêche également de configurer des adresses IP en double. Chaque réseau physique devrait avoir son propre serveur DHCP afin qu'un hôte puisse demander une adresse IP. Dans un environnement domestique classique, le routeur agit généralement en tant que serveur DHCP.\n\nLa manière dont le DHCP obtient toutes vos informations d'hôte dynamiques est la suivante :\n\n<ol>\n<li>DHCP DISCOVER - Ce message est diffusé pour rechercher un serveur DHCP.</li>\n<li>DHCP OFFER - Le serveur DHCP du réseau répond avec un message d'offre. L'offre contient un paquet avec le temps de bail DHCP, le masque de sous-réseau, l'adresse IP, etc.</li>\n<li>DHCP REQUEST - Le client envoie une autre diffusion pour informer tous les serveurs DHCP de l'offre qu'il a acceptée.</li>\n<li>DHCP ACK - L'accusé de réception est envoyé par le serveur.</li>\n</ol>\n\nLe DHCP devient plus complexe que cela, mais voilà l'essentiel.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "Quelles sont les étapes d'une demande DHCP?",
          "slug": "dhcpoverview",
          "title": "Présentation du DHCP"
        }
      ],
      "slug": "networkbasics",
      "title": "Fondamentaux du réseau"
    },
    {
      "description": "Apprenez les sous-réseaux et comment faire de l'arithmétique de sous-réseaux!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Trouvez votre adresse IP avec ifconfig.",
          "id": 1,
          "lessonContent": "Chaque hôte réseau a une adresse unique, et chaque adresse unique peut être utilisée pour localiser l'hôte dans le réseau. Ces adresses uniques sont connues sous le nom d'« adresses IP ». Une adresse IPv4 ressemble à ceci :\n\n<pre>204.23.124.23</pre>\n\nCette adresse contient en réalité deux parties : la partie réseau (qui identifie sur quel réseau elle se trouve) et la partie hôte (qui identifie l'hôte). Pour ce cours, nous discuterons principalement des adresses IPv4, que vous verrez couramment lorsque vous ferez référence aux 'adresses IP'.\n\nUne adresse IP est séparée en octets par les points. Il y a 4 octets dans une adresse IPv4. Si vous connaissez un peu l'informatique, vous saurez qu'un octet est composé de 8 bits, et vous saurez que 8 bits équivalent en réalité à 1 octet. Cela signifie qu'une adresse IPv4 a 4 octets. Nous utilisons fréquemment les bits lors de la manipulation des sous-réseaux et des adresses IP.\n\nVous pouvez voir votre adresse IP avec la commande 'ifconfig -a' :\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nComme vous pouvez le voir, mon adresse IPv4 est : 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "Combien d'octets y a-t-il dans une adresse IPv4 ?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Utilisez ifconfig pour afficher votre masque de sous-réseau.",
          "id": 2,
          "lessonContent": "Comment puis-je savoir si je suis sur le même réseau que Patty ? Eh bien, nous pouvons simplement regarder le sous-réseau, abrégé en sous-réseau. Un sous-réseau est un groupe d'hôtes avec des adresses IP qui se ressemblent d'une certaine manière. Ces hôtes sont généralement situés à proximité les uns des autres et vous pouvez facilement envoyer des données vers et depuis des hôtes sur le même sous-réseau. Pensez-y comme envoyer du courrier dans le même code postal, c'est beaucoup plus facile que d'envoyer du courrier à un autre État. \n\nPar exemple, tous les hôtes avec une adresse IP qui commence par 123.45.67 seraient sur le même sous-réseau. Mon hôte a une IP de 123.45.67.8 et celle de Patty a une IP de 123.45.67.9. Les chiffres communs sont mon préfixe réseau et les 8 et 9 sont nos hôtes, donc mon réseau est le même que celui de Patty. Un sous-réseau est divisé en un préfixe réseau, tel que 123.45.67.0 et un masque de sous-réseau.\n\n<b>Masques de sous-réseau</b>\n\nLes masques de sous-réseau déterminent quelle partie de votre adresse IP est la partie réseau et quelle partie est la partie hôte. \n\nUn masque de sous-réseau typique peut ressembler à ceci :\n\n<pre>255.255.255.0</pre>\n\nLa partie 255 est en fait notre masque. Pour rendre cela un peu plus facile à comprendre, rappelez-vous comment nous appelons chaque octet 8 bits ? En informatique, un bit est noté par un 0 ou un 1 sous forme binaire. Lorsque des nombres binaires sont utilisés, 1 signifie allumé et 0 signifie éteint. Alors que valent 8 0 ou 1 ?\n\nTapez dans Google \"calculatrice binaire en décimal\" et convertissez 11111111 en forme décimale. Qu'obtenez-vous ? 255 ! Ainsi, un octet va de 0 à 255. Donc, si nous avions un masque de sous-réseau de 255.255.255.0, et une adresse IP de 192.168.1.0, combien d'hôtes se trouvent sur ce sous-réseau ? Nous découvrirons la réponse à cela dans notre leçon de mathématiques sur les sous-réseaux.\n\nAussi, lorsque nous parlons de notre sous-réseau, nous le désignons généralement par le préfixe réseau suivi du masque de sous-réseau :\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>Pourquoi ?</b>\n\nPourquoi diable créons-nous des sous-réseaux ? Le sous-réseau est utilisé pour segmenter les réseaux et contrôler le flux de trafic à l'intérieur de ce réseau. Ainsi, un hôte sur un sous-réseau ne peut pas interagir avec un autre hôte sur un sous-réseau différent. \n\nMais attendez une minute, que se passe-t-il si je veux me connecter à d'autres hôtes comme yahoo.com ? Alors vous devez connecter des sous-réseaux ensemble. Pour connecter des sous-réseaux, vous devez simplement trouver les hôtes qui sont connectés à plus d'un sous-réseau. Par exemple, si mon hôte à 192.168.1.129 est connecté à un réseau local de 192.168.1.129/24, il peut atteindre tous les hôtes de ce réseau. Pour atteindre les hôtes sur le reste d'Internet, il doit communiquer à travers le routeur. Traditionnellement, sur la plupart des réseaux avec un masque de sous-réseau de 255.255.255.0, le routeur est généralement à l'adresse 1 du sous-réseau, donc 192.168.1.1. Ce routeur aura un port qui le connecte à un autre sous-réseau (plus dans le cours de routage). Certaines adresses IP (réseaux privés) ne sont pas visibles sur Internet, et nous avons des choses comme NAT en place (plus à ce sujet plus tard).",
          "quizAnswer": "Vrai",
          "quizQuestion": "Vrai ou faux, un sous-réseau se compose d'un masque de sous-réseau et d'un préfixe réseau.",
          "slug": "sous-reseaux",
          "title": "Sous-réseaux"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Ok, nous savons que les masques de sous-réseau sont importants pour déterminer combien d'hôtes nous pouvons avoir sur notre sous-réseau. Alors, combien d'hôtes cela pourrait-il être ? \n\nDisons que j'ai une adresse IP de <b>192.168.1.0</b> et un masque de sous-réseau de <b>255.255.255.0</b>, maintenant alignons ces nombres sous forme binaire. Pour l'instant, utilisez une calculatrice en ligne pour convertir ces valeurs de décimal en binaire.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nL'adresse IP est masquée par notre masque de sous-réseau, lorsque vous voyez un 1, il est masqué et nous faisons semblant de ne pas le voir. Donc, les seuls hôtes possibles que nous pouvons avoir sont de la région 00000000. Rappelez-vous que 11111111 en forme binaire équivaut à 255, nous comptons également 0 comme un numéro d'hôte, donc il y a 256 options possibles. Cependant, il peut sembler que nous avons 256 options possibles, mais en réalité, nous soustrayons 2 hôtes car nous devons tenir compte de l'adresse de diffusion et de l'adresse de sous-réseau, ce qui nous laisse avec 254 hôtes possibles sur notre sous-réseau. Donc, nous savons que nous pouvons avoir des hôtes avec des adresses IP allant de 192.168.1.1 à 192.168.1.254.",
          "quizAnswer": "11111111",
          "quizQuestion": "Quelle est l'équivalent binaire de 255 ?",
          "slug": "subnetmath",
          "title": "Calcul de sous-réseau"
        },
        {
          "exercise": "Regardez votre adresse IP et votre masque de sous-réseau et voyez combien d'hôtes vous pouvez avoir sur votre sous-réseau.",
          "id": 4,
          "lessonContent": "Je déteste devoir ajouter cette section, dans le monde réel, vous n'auriez probablement jamais à faire des calculs de sous-réseaux à la main, cependant si vous étiez interrogé à ce sujet, vous devriez savoir comment convertir en et à partir de la forme binaire pour le sous-réseau. Heureusement, il existe quelques astuces arithmétiques que vous pouvez mémoriser. \n\nCommencez par mémoriser vos calculs en base 2, faites-le simplement :\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Tableau de conversion Décimal en Binaire</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nIl y a de nombreuses raisons pour lesquelles le tableau suivant ressemble à ce qu'il est, si vous vous demandez comment cela fonctionne, il existe de nombreuses ressources en ligne.\n\nD'accord, vous les avez mémorisés ? Faisons une rapide conversion décimale en binaire :\n\n<b>Convertir 192.168.23.43 en Binaire</b>\n\nRappelez-vous : 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nMarchons à travers la conversion du premier octet en binaire et vous comprendrez comment le reste fonctionne.\n\n<ol>\n<li>Pouvez-vous soustraire 192 - 128 ? Oui, donc le premier bit est 1</li>\n<li>192 - 128 = 64, le prochain nombre dans le tableau est 64, pouvez-vous soustraire 64 - 64 ? Oui, donc le deuxième bit est 1</li>\n<li>Nous avons épuisé les nombres à soustraire, donc notre forme binaire de 192 est 11000000</li>\n</ol>\n\n<b>Convertir Binaire 11000000 en Décimal</b>\n\nPour la conversion binaire en décimal, vous ajoutez les nombres qui ont un 1, donc :\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "Quelle est la conversion binaire de 123?",
          "slug": "tricheriesousreseau",
          "title": "Tricheries de sous-réseau"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "CIDR (classless inter-domain routing) est utilisé pour représenter un masque de sous-réseau de manière plus compacte. Vous pouvez voir des sous-réseaux notés en notation CIDR, où un sous-réseau tel que 10.42.3.0/255.255.255.0 est écrit comme 10.42.3.0/24 ce qui signifie simplement qu'il inclut à la fois le préfixe du sous-réseau et le masque de sous-réseau.\n\nRappelez-vous qu'une adresse IP est composée de 4 octets ou 32 bits, CIDR indique la quantité de bits utilisés comme préfixe réseau. Ainsi, 123.12.24.0/23 signifie que les 23 premiers bits sont utilisés. Mais que cela signifie-t-il ? Combien d'hôtes cela représente-t-il ?\n\nUn truc simple est de soustraire le total des bits qu'une adresse IP peut avoir (32) de l'adresse CIDR (23), ce qui laisse 9 bits, 2^9 = 512, mais nous devons retirer 2 adresses (adresse de sous-réseau et adresse de diffusion) donc nous avons 510 hôtes utilisables.",
          "quizAnswer": "",
          "quizQuestion": "Aucune question, passez à la suite !",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 6,
          "lessonContent": "Nous avons déjà mentionné le NAT (traduction d'adresse réseau) auparavant mais sans y toucher. Lorsque nous travaillons sur notre réseau, est-ce que cela signifie que l'Internet peut voir notre adresse IP? Pas tout à fait.\n\nLe NAT fait en sorte qu'un appareil comme notre routeur agisse en tant qu'intermédiaire entre l'Internet et le réseau privé. Ainsi, seul une seule adresse IP unique est nécessaire pour représenter tout un groupe d'ordinateurs.\n\nPensez au NAT comme à une réceptionniste dans un grand bureau, si quelqu'un veut vous contacter, il ne connaît que le numéro de tout le bureau, la réceptionniste devra alors chercher votre numéro d'extension et transférer l'appel vers vous.\n\n<b>Comment ça marche?</b>\n\nUn cas simple ressemblerait à ceci:\n\n<ol>\n<li>Patty veut se connecter à www.google.com, donc son ordinateur envoie cette demande via le routeur</li>\n<li>Le routeur prend cette demande et ouvre sa propre connexion vers google.com, puis envoie la demande de Patty une fois la connexion établie</li>\n<li>Le routeur est l'intermédiaire entre Patty et www.google.com. Google ne sait rien de Patty, tout ce qu'il peut voir, c'est le routeur.</li>\n</ol>\n\nLe NAT et le routage de paquets en général peuvent devenir assez compliqués, mais nous n'entrerons pas dans les détails.",
          "quizAnswer": "NAT",
          "quizQuestion": "Qu'est-ce qui est utilisé pour représenter une seule adresse privée à l'Internet?",
          "slug": "natnetworkaddresstranslation",
          "title": "NAT"
        },
        {
          "exercise": "Vérifiez ifconfig pour voir si vous avez une adresse IPv6 répertoriée.",
          "id": 7,
          "lessonContent": "Nous avons entendu le terme IPv6 ici et là, mais qu'est-ce que c'est ? Chaque appareil qui se connecte à Internet obtient sa propre adresse IP, eh bien, il se trouve que c'est un nombre fini que nous approchons bientôt dans cette ère numérique. IPv6 a été créé pour nous permettre de connecter plus d'hôtes à Internet, il apporte plus d'améliorations IP cependant, son adoption est assez lente. Il n'est pas destiné à remplacer IPv4, ils sont censés se compléter. Les deux protocoles IP sont très similaires et si vous connaissez IPv4, vous comprendrez IPv6, la principale différence est la façon dont l'adresse est écrite. Voici à quoi ressemble une adresse IPv6 typique :\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "Quelle adresse IP est utilisée pour augmenter le nombre d'hôtes pouvant se connecter à Internet ?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Subnetting"
    },
    {
      "description": "Apprenez comment les paquets sont routés à travers les réseaux !",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 1,
          "lessonContent": "Nous avons déjà utilisé ce terme routeur auparavant, j'espère que vous savez ce que c'est, car vous en avez probablement un chez vous. Un routeur permet aux machines d'un réseau de communiquer entre elles ainsi qu'avec d'autres réseaux. Sur un routeur typique, vous aurez des ports LAN, qui permettent à vos machines de se connecter au même réseau local, et vous aurez également un port de liaison Internet qui vous connecte à Internet, parfois vous verrez ce port étiqueté comme WAN, car il vous connecte essentiellement à un réseau plus large. Lorsque nous effectuons une quelconque activité de mise en réseau, cela doit passer par le routeur. Le routeur décide où vont nos paquets réseau et lesquels entrent. Il route nos paquets entre plusieurs réseaux pour passer de l'hôte source à l'hôte de destination. \n\n<b>Comment fonctionne un routeur?</b>\n\nPensez au routage de la même manière que la livraison de courrier, nous avons une adresse à laquelle nous voulons envoyer une lettre, lorsque nous l'envoyons au bureau de poste, ils reçoivent la lettre et voient, oh, cela va en Californie, je vais la mettre dans le camion qui va en Californie (je n'ai honnêtement aucune idée de comment fonctionne le système postal). La lettre est ensuite envoyée à San Francisco, à l'intérieur de San Francisco, il y a différents codes postaux, et ensuite dans ces codes postaux, il y a de plus petits codes d'adresse, jusqu'à ce que quelqu'un puisse enfin livrer votre lettre à l'adresse souhaitée. En revanche, si vous habitiez déjà à San Francisco et dans le même code postal, le facteur saura probablement exactement où la lettre doit aller sans la remettre à quelqu'un d'autre. \n\nLorsque nous routons des paquets, ils utilisent des \"routes\" d'adresse similaires, par exemple pour accéder au réseau A, envoyer ces paquets au réseau B. Lorsque nous n'avons pas de route définie pour cela, nous avons une route par défaut que nos paquets utiliseront. Ces routes sont définies sur une table de routage que notre système utilise pour nous guider à travers les réseaux.\n\n<b>Sauts</b>\n\nÀ mesure que les paquets se déplacent à travers les réseaux, ils voyagent par sauts, un saut est la manière dont nous mesurons approximativement la distance que le paquet doit parcourir pour passer de la source à la destination. Disons que j'ai deux routeurs connectant l'hôte A à l'hôte B, donc nous disons qu'il y a deux sauts entre l'hôte A et l'hôte B. Chaque saut est un dispositif intermédiaire comme les routeurs que nous devons traverser.\n\n<b>Comprendre la différence fondamentale entre la commutation, le routage et le floodage?</b>\nLa COMMUTATION de paquets consiste essentiellement à recevoir, traiter et transmettre des données à l'appareil de destination.\nLe ROUTAGE est un processus de création de la table de routage, afin que nous puissions effectuer la COMMUTATION de manière plus efficace.\nAvant le routage, le FLOODAGE était utilisé. Si un routeur ne sait pas dans quelle direction envoyer un paquet, alors chaque paquet entrant est envoyé par chaque lien sortant sauf celui par lequel il est arrivé.",
          "quizAnswer": "sauts",
          "quizQuestion": "Comment les paquets mesurent-ils la distance?",
          "slug": "qu-est-ce-qu-un-routeur",
          "title": "Qu'est-ce qu'un routeur?"
        },
        {
          "exercise": "Regardez votre table de routage et voyez où vos paquets peuvent aller.",
          "id": 2,
          "lessonContent": "Regardez la table de routage de votre machine :\n\n<pre>\npete@icebox:~$ sudo route -n\nTable de routage IP du noyau\nDestination     Passerelle         Masque réseau         Drapeaux Métrique Réf    Utilisation Interface\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destination</b>\n\nDans le premier champ, nous avons une adresse IP de destination de 192.168.224.0, cela signifie que tout paquet essayant d'atteindre ce réseau passe par mon câble Ethernet (eth0). Si j'étais 192.168.224.5 et que je voulais atteindre 192.168.224.7, j'utiliserais simplement l'interface réseau eth0 directement. \n\nRemarquez que nous avons des adresses de <b>0.0.0.0</b>, cela signifie qu'aucune adresse n'est spécifiée ou qu'elle est inconnue. Donc, si par exemple, je voulais envoyer un paquet à l'adresse IP 151.123.43.6, notre table de routage ne sait pas où cela va, donc elle le note comme 0.0.0.0 et donc route notre paquet vers la passerelle.\n\n<b>Passerelle</b>\n\nSi nous envoyons un paquet qui n'est pas sur le même réseau, il sera envoyé à cette adresse de passerelle. Qui est judicieusement nommée comme étant une passerelle vers un autre réseau.\n\n<b>Masque réseau</b>\n\nC'est le masque de sous-réseau, utilisé pour déterminer quelles adresses IP correspondent à quelle destination. \n\n<b>Drapeaux</b>\n\n<ul>\n<li>UG - Le réseau est actif et est une passerelle</li>\n<li>U - Le réseau est actif</li>\n</ul>\n\n<b>Interface</b>\n\nC'est l'interface par laquelle notre paquet sortira, eth0 signifie généralement le premier périphérique Ethernet de votre système.",
          "quizAnswer": "Passerelle",
          "quizQuestion": "Où sont acheminés les paquets si notre table de routage ne sait pas?",
          "slug": "tablederoutage",
          "title": "Table de routage"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 3,
          "lessonContent": "<b>Regardons comment un paquet voyage au sein de son réseau local</b>\n\n<ol>\n<li>Tout d'abord, la machine locale comparera l'adresse IP de destination pour voir si elle se trouve dans le même sous-réseau en regardant son masque de sous-réseau.</li>\n<li>Lorsque les paquets sont envoyés, ils doivent avoir une adresse MAC source, une adresse MAC de destination, une adresse IP source et une adresse IP de destination, à ce stade, nous ne connaissons pas encore l'adresse MAC de destination.</li>\n<li>Pour atteindre l'hôte de destination, nous utilisons ARP pour diffuser une demande sur le réseau local afin de trouver l'adresse MAC de l'hôte de destination.</li>\n<li>Maintenant, le paquet peut être envoyé avec succès !</li>\n</ol>\n\n<b>Voyons comment un paquet voyage en dehors de son réseau</b>\n\n<ol>\n<li>Tout d'abord, la machine locale comparera l'adresse IP de destination, puisqu'elle est en dehors de notre réseau, elle ne voit pas l'adresse MAC de l'hôte de destination. Et nous ne pouvons pas utiliser ARP car la demande ARP est une diffusion aux hôtes connectés localement.</li>\n<li>Donc notre paquet regarde maintenant la table de routage, il ne connaît pas l'adresse de l'IP de destination, donc il l'envoie vers la passerelle par défaut (un autre routeur). Maintenant notre paquet contient notre IP source, l'IP de destination et l'adresse MAC source, cependant nous n'avons pas d'adresse MAC de destination. Rappelez-vous que les adresses MAC ne sont accessibles que via le même réseau. Que fait-il alors ? Il envoie une demande ARP pour obtenir l'adresse MAC de la passerelle par défaut.</li>\n<li>Le routeur examine le paquet et confirme l'adresse MAC de destination, mais ce n'est pas l'adresse IP de destination finale, donc il continue de regarder la table de routage pour transférer le paquet vers une autre adresse IP qui peut aider le paquet à avancer vers sa destination. À chaque déplacement du paquet, il supprime les anciennes adresses MAC source et de destination et met à jour le paquet avec les nouvelles adresses MAC source et de destination.</li>\n<li>Une fois que le paquet est transféré vers le même réseau, nous utilisons ARP pour trouver l'adresse MAC de destination finale.</li>\n<li>Pendant ce processus, notre paquet ne modifie pas l'adresse IP source ou de destination.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Comment trouvons-nous l'adresse MAC d'une adresse IP ?",
          "slug": "chemindunpaquet",
          "title": "Chemin d'un paquet"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 4,
          "lessonContent": "Il serait fastidieux de devoir configurer manuellement des routes sur une table de routage pour chaque appareil de votre réseau, c'est pourquoi nous utilisons ce que l'on appelle les protocoles de routage. Les protocoles de routage sont utilisés pour aider notre système à s'adapter aux changements du réseau, il apprend différentes routes, les construit dans la table de routage et ensuite route nos paquets de cette manière. Il existe deux types principaux de protocoles de routage, les protocoles de vecteur de distance et les protocoles d'état de liaison.\n\n<b>Convergence</b>\n\nAvant de parler des protocoles, nous devrions expliquer un terme utilisé dans le routage appelé convergence. Lors de l'utilisation de protocoles de routage, les routeurs communiquent avec d'autres routeurs pour collecter et échanger des informations sur le réseau. Lorsqu'ils sont d'accord sur l'apparence d'un réseau, chaque table de routage cartographie la topologie complète du réseau, ce qui permet de \"converger\". Lorsqu'un événement survient dans la topologie du réseau, la convergence se rompra temporairement jusqu'à ce que tous les routeurs soient conscients de ce changement.",
          "quizAnswer": "convergence",
          "quizQuestion": "Quel est le terme utilisé lorsque toutes les tables de routage connaissent la topologie du réseau?",
          "slug": "protocolesderoutage",
          "title": "Protocoles de routage"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Les protocoles de vecteur de distance déterminent le chemin d'autres réseaux en utilisant le nombre de sauts qu'un paquet effectue à travers le réseau. Si le réseau A était à 3 sauts et que le réseau B était à côté du réseau A, alors nous supposons qu'il doit être à 4 sauts. Dans les protocoles de vecteur de distance, la prochaine route serait celle avec le moins de sauts.\n\nLes protocoles de vecteur de distance sont excellents pour les petits réseaux, mais lorsque les réseaux commencent à se développer, il faut plus de temps aux routeurs pour converger car ils envoient périodiquement la table de routage entière à chaque routeur. Un autre inconvénient des protocoles de vecteur de distance est l'efficacité, ils choisissent des routes plus proches en termes de sauts, mais cela ne signifie pas toujours qu'ils choisissent la route la plus efficace.\n\nUn des protocoles de vecteur de distance courants est RIP (Routing Information Protocol), il diffuse la table de routage à chaque routeur du réseau toutes les 30 secondes. Pour un grand réseau, cela peut nécessiter beaucoup de ressources, c'est pourquoi RIP limite son nombre de sauts à 15.",
          "quizAnswer": "faux",
          "quizQuestion": "Vrai ou faux, les protocoles de distance utilisent la route avec le moins de bande passante ?",
          "slug": "protocolesdevecteurdedistance",
          "title": "Protocoles de vecteur de distance"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 6,
          "lessonContent": "Les protocoles d'état de liaison sont excellents pour les réseaux à grande échelle, ils sont plus complexes que les protocoles de vecteur de distance, cependant, un grand avantage est leur capacité à converger rapidement, cela est dû au fait qu'au lieu d'envoyer périodiquement toute la table de routage, ils envoient uniquement des mises à jour aux routes voisines. Ils utilisent un algorithme différent pour calculer le plus court chemin en premier et construire leur topologie réseau sous forme de graphe pour montrer quels routeurs sont connectés à d'autres routeurs.\n\nUn des protocoles d'état de liaison courants est OSPF (Open Shortest Path First), il met à jour les tables de routage uniquement s'il y a eu un changement dans le réseau. Il n'a pas de limite de saut.",
          "quizAnswer": "OSPF",
          "quizQuestion": "Quel est l'un des protocoles d'état de liaison les plus courants?",
          "slug": "protocolesetatdeliaison",
          "title": "Protocoles d'état de liaison"
        },
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 7,
          "lessonContent": "Le dernier protocole important que nous aborderons est BGP, BGP est essentiellement la façon dont fonctionne Internet. Il est utilisé pour collecter et échanger des informations de routage entre les systèmes autonomes. Pensez à un système autonome comme un fournisseur de services Internet, une entreprise, une université, une organisation, etc. Sans BGP, ces systèmes ne sauraient pas comment communiquer entre eux, ils resteraient cloisonnés. Au lieu de router à l'intérieur de ces systèmes autonomes, BGP route entre eux.\n\nDisons que vous êtes sur votre réseau domestique et que je travaille depuis Starbucks, je veux pouvoir communiquer avec vous, donc j'envoie un e-mail et le paquet réseau voyage à travers le réseau de Starbucks, il rebondit là-bas et passe à travers les tables de routage dans le réseau de Starbucks jusqu'à ce qu'il atteigne enfin un point à la frontière du réseau de Starbucks et le transmette à un routeur de passerelle frontalière. Ce routeur contient les informations pour que mon paquet quitte le réseau de Starbucks et traverse d'autres réseaux.",
          "quizAnswer": "BGP",
          "quizQuestion": "Quel protocole fait essentiellement fonctionner Internet?",
          "slug": "protocolepasserellefrontalierebgp",
          "title": "Protocole de passerelle frontalière"
        }
      ],
      "slug": "routing",
      "title": "Routage"
    },
    {
      "description": "Apprenez la configuration du réseau en utilisant des outils Linux!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Essayez de changer l'état de vos interfaces réseau en actif ou inactif et observez ce qui se passe.\n\nPouvez-vous changer l'état de vos interfaces réseau avec les commandes ifconfig et ip ?",
          "id": 1,
          "lessonContent": "Une interface réseau est comment le noyau relie le côté logiciel du réseau au côté matériel. Nous avons déjà vu un exemple de ceci : \n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> La commande ifconfig</b>\n\nL'outil <b>ifconfig</b> nous permet de configurer nos interfaces réseau. Si nous n'avons pas d'interfaces réseau configurées, les pilotes de périphériques du noyau et le réseau ne sauront pas comment communiquer entre eux. Ifconfig s'exécute au démarrage et configure nos interfaces via des fichiers de configuration, mais nous pouvons également les modifier manuellement. La sortie de ifconfig montre le nom de l'interface du côté gauche et le côté droit affiche des informations détaillées. Vous verrez le plus souvent des interfaces nommées eth0 (première carte Ethernet de la machine), wlan0 (interface sans fil), lo (interface de bouclage). L'interface de bouclage est utilisée pour représenter votre ordinateur, elle vous renvoie simplement à vous-même. C'est utile pour le débogage ou pour se connecter à des serveurs en local. \n\nL'état des interfaces peut être actif ou inactif, comme vous pouvez le deviner si vous voulez \"désactiver\" une interface, vous pouvez la mettre en bas. Les champs sur lesquels vous regarderez probablement le plus dans la sortie de ifconfig sont HWaddr (adresse MAC de l'interface), adresse inet (adresse IPv4) et inet6 (adresse IPv6). Bien sûr, vous pouvez voir que le masque de sous-réseau et l'adresse de diffusion sont également là. Vous pouvez également consulter les informations sur les interfaces dans /etc/network/interfaces.\n\n<b>Pour créer une interface et l'activer</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nCela attribue une adresse IP et un masque de réseau à l'interface eth0 et l'active également.\n\n<b>Pour activer ou désactiver une interface</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> La commande ip </b>\n\nLa commande <b>ip</b> nous permet également de manipuler la pile réseau d'un système. Selon la distribution que vous utilisez, il peut s'agir de la méthode préférée pour manipuler vos paramètres réseau. \n\nVoici quelques exemples de son utilisation :\n\n<b>Pour afficher les informations d'interface pour toutes les interfaces </b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Pour afficher les statistiques d'une interface</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>Pour afficher les adresses IP attribuées aux interfaces</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>Pour activer ou désactiver des interfaces</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Pour ajouter une adresse IP à une interface</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "Quelle est la commande pour configurer nos interfaces réseau ?",
          "slug": "interfacesreseau",
          "title": "Interfaces Réseau"
        },
        {
          "exercise": "Il n'y a pas d'exercices pour cette leçon, mais vous pouvez lire plus d'informations sur les commandes discutées ici dans les pages de manuel\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Nous avons déjà discuté de la visualisation de nos tables de routage avec la commande route, si vous souhaitez ajouter ou supprimer des routes, vous pouvez le faire manuellement.\n\n<b>Ajouter une nouvelle route</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Supprimer une route</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nVous pouvez également effectuer ces changements avec la commande <b>ip</b> :\n\n<b>Pour ajouter une route</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Pour supprimer une route</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\nou\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "Quel est le drapeau de commande pour supprimer une route?",
          "slug": "route",
          "title": "route"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Nous avons déjà discuté du protocole DHCP et la plupart du temps, vous n'aurez jamais besoin de définir statiquement vos adresses IP, masques de sous-réseau, etc. Au lieu de cela, vous utiliserez DHCP! Le dhclient démarre au démarrage et obtient une liste d'interfaces réseau à partir du fichier dhclient.conf. Pour chaque interface répertoriée, il tente de configurer l'interface en utilisant le protocole DHCP.\n\nDans le fichier dhclient.leases, dhclient garde une trace d'une liste de baux à travers les redémarrages du système. Après avoir lu dhclient.conf, le fichier dhclient.leases est lu pour lui indiquer quels baux il a déjà attribués. \n\n<b>Pour obtenir une nouvelle adresse IP</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "Quel élément tente d'assigner des adresses IP avec le protocole DHCP?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 4,
          "lessonContent": "Bien sûr, si vous souhaitez que le réseau de votre système soit opérationnel automatiquement, il existe déjà quelque chose en place pour cela. La plupart des distributions utilisent le démon NetworkManager pour configurer automatiquement leurs réseaux. \n\nVous remarquerez NetworkManager sous la forme d'un applet quelque part sur la barre des tâches de votre bureau si vous utilisez une interface graphique. Comme vous pouvez le constater, il gère le matériel réseau et les informations de connexion. Par exemple, au démarrage, NetworkManager recueillera des informations sur le matériel réseau, recherchera des connexions sans fil, filaires, etc. et les activera ensuite.\n\nIl existe également des outils en ligne de commande pour interagir avec NetworkManager :\n\n<b>nm-tool</b>\n\nnm-tools rapporte l'état de NetworkManager et de ses périphériques\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nÉtat : connecté (global)\n\n- Périphérique : eth0  [Connexion filaire 1] -------------------------------------------\n  Type :              Filaire\n  Pilote :            pcnet32\n  État :             connecté\n  Par défaut :           oui\n  Adresse matérielle :        12:3D:45:56:7D:CC\n\n  Capacités :\n    Détection du support :  oui\n\n  Propriétés filaires\n    Support :         activé\n\n  Paramètres IPv4 :\n    Adresse :         192.168.22.1\n    Préfixe :          24 (255.255.255.0)\n    Passerelle :         192.168.22.2\n\n    DNS :             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nLa commande nmcli vous permet de contrôler et de modifier NetworkManager, consultez le manuel pour plus de détails.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "Quelle est la commande pour afficher les informations de NetworkManager ?",
          "slug": "networkmanager",
          "title": "Gestionnaire de réseau"
        },
        {
          "exercise": "Observez ce qui se passe avec votre cache ARP lorsque vous redémarrez votre machine et que vous effectuez ensuite une action sur le réseau.",
          "id": 5,
          "lessonContent": "Souvenez-vous que lorsque nous recherchons une adresse MAC avec ARP, il vérifie d'abord le cache ARP stocké localement sur notre système, vous pouvez en fait afficher ce cache : \n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nLe cache ARP est en fait vide lorsqu'une machine démarre, il se remplit au fur et à mesure que des paquets sont envoyés à d'autres hôtes. Si nous envoyons un paquet à une destination qui n'est pas dans le cache ARP, les événements suivants se produisent :\n\n<ol>\n<li>L'hôte source crée le trame Ethernet avec un paquet de demande ARP</li>\n<li>L'hôte source diffuse cette trame sur l'ensemble du réseau</li>\n<li>Si l'un des hôtes sur le réseau connaît la bonne adresse MAC, il enverra un paquet de réponse et une trame contenant l'adresse MAC</li>\n<li>L'hôte source ajoute le mappage adresse IP - adresse MAC au cache ARP et procède ensuite à l'envoi du paquet</li>\n</ol>\n\nVous pouvez également afficher votre cache ARP via la commande ip :\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "Quelle commande pouvez-vous utiliser pour afficher votre cache ARP ?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Configuration du réseau"
    },
    {
      "description": "Apprenez à utiliser des outils de réseau courants pour vous aider à diagnostiquer et résoudre les problèmes !",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 1,
          "lessonContent": "Le protocole de messages de contrôle Internet (ICMP) fait partie de la suite de protocoles TCP/IP, il est utilisé pour envoyer des mises à jour et des messages d'erreur et est un protocole extrêmement utile utilisé pour le débogage des problèmes réseau tels qu'une livraison de paquets échouée.\n\nChaque message ICMP contient un champ type, code et checksum. Le champ type est le type de message ICMP, le code est un sous-type et décrit plus d'informations sur le message et le checksum est utilisé pour détecter tout problème d'intégrité du message.\n\nRegardons quelques types ICMP courants:\n\n<ul>\n<li>Type 0 - Réponse Echo</li>\n<li>Type 3 - Destination Inatteignable</li>\n<li>Type 8 - Requête Echo</li>\n<li>Type 11 - Temps écoulé</li>\n</ul>\n\nLorsqu'un paquet ne peut pas atteindre sa destination, un message ICMP de type 3 est généré, et à l'intérieur du type 3, il existe 16 valeurs de code qui décriront davantage pourquoi il ne peut pas atteindre la destination:\n\n<ul>\n<li>Code 0 - Réseau Inatteignable</li>\n<li>Code 1 - Hôte Inatteignable</li>\netc..etc..\n</ul>\n\nCes messages auront plus de sens lorsque nous utiliserons certains outils de dépannage réseau.",
          "quizAnswer": "8",
          "quizQuestion": "Quel est le type ICMP pour une requête echo?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Faites un ping sur un site web et examinez la sortie que vous recevez.",
          "id": 2,
          "lessonContent": "Un des outils de réseau les plus simples <b>ping</b>, il est utilisé pour tester si un paquet peut atteindre un hôte ou non. Il fonctionne en envoyant des paquets de demande de type ICMP echo (Type 8) vers l'hôte de destination et en attendant une réponse de type ICMP echo (Type 0). Le ping réussit lorsque l'hôte envoie le paquet de demande et reçoit une réponse de la cible. Regardons un exemple: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) octets de données.\n64 octets de nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 temps=29.0 ms\n64 octets de nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 temps=23.7 ms\n64 octets de nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 temps=15.1 ms\n</pre>\n\nDans cet exemple, nous utilisons ping pour vérifier si nous pouvons accéder à www.google.com. Le drapeau -c (compter) est utilisé pour arrêter l'envoi de paquets de demande echo une fois que le nombre spécifié a été atteint. \n\nLa première partie indique que nous envoyons des paquets de 64 octets à 74.125.239.112 (google.com) et le reste nous montre les détails du trajet. Par défaut, il envoie un paquet par seconde.\n\n<b>icmp_seq</b>\n\nLe champ icmp_seq est utilisé pour montrer le numéro de séquence des paquets envoyés, donc dans ce cas, j'ai envoyé 3 paquets et nous pouvons voir que les 3 paquets sont revenus. Si vous faites un ping et que vous constatez que certains numéros de séquence manquent, cela signifie qu'un problème de connectivité se produit et que tous vos paquets ne passent pas. Si le numéro de séquence est désordonné, votre connexion est probablement très lente car vos paquets dépassent la valeur par défaut d'une seconde. \n\n<b>ttl</b>\n\nLe champ Time To Live (ttl) est utilisé comme compteur de saut, à chaque saut, il décrémente le compteur de un et une fois que le compteur de saut atteint 0, notre paquet meurt. Cela est censé donner au paquet une durée de vie, nous ne voulons pas que nos paquets voyagent indéfiniment.\n\n<b>time</b>\n\nLe temps de trajet qu'il a fallu depuis l'envoi du paquet de demande echo jusqu'à la réception d'une réponse echo.",
          "quizAnswer": "ms",
          "quizQuestion": "Quelle est l'unité de mesure du temps de trajet?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Exécutez la commande traceroute sur votre machine et observez la sortie.",
          "id": 3,
          "lessonContent": "La commande traceroute est utilisée pour voir comment les paquets sont routés. Elle fonctionne en envoyant des paquets avec des valeurs de TTL croissantes, en commençant par 1. Ainsi, le premier routeur reçoit le paquet et décrémente la valeur de TTL de un, ce qui fait que le paquet est abandonné. Le routeur renvoie un message ICMP Time Exceeded vers nous. Ensuite, le paquet suivant reçoit un TTL de 2, ce qui lui permet de passer le premier routeur, mais lorsqu'il atteint le deuxième routeur, le TTL est de 0 et un autre message ICMP Time Exceeded est renvoyé. Traceroute fonctionne de cette manière car en envoyant et abandonnant des paquets, il construit une liste des routeurs que les paquets traversent, jusqu'à ce qu'il atteigne enfin sa destination et reçoive un message ICMP Echo Reply. \n\nVoici un petit extrait d'un traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute vers google.com (216.58.216.174), 30 sauts max, 60 octets de paquets                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nChaque ligne représente un routeur ou une machine qui se trouve entre moi et ma cible. Elle affiche le nom de la cible et son adresse IP, et les trois dernières colonnes correspondent au temps de trajet aller-retour d'un paquet pour atteindre ce routeur. Par défaut, nous envoyons trois paquets le long de l'itinéraire.",
          "quizAnswer": "ttl",
          "quizQuestion": "Qu'est-ce qui est décrémenté de un lors des sauts à travers le réseau?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Consultez la page de manuel de netstat et apprenez toutes les fonctionnalités qu'il offre.",
          "id": 4,
          "lessonContent": "<b>Ports Bien Connus</b>\n\nNous avons discuté de la transmission de données via les ports sur notre machine, regardons maintenant quelques ports bien connus.\n\nVous pouvez obtenir une liste des ports bien connus en regardant le fichier <b>/etc/services</b>: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..etc..\n</pre>\n\nLa première colonne est le nom du service, puis le numéro de port et le protocole de la couche de transport qu'il utilise.\n\n<b>netstat</b>\n\nUn outil extrêmement utile pour obtenir des informations détaillées sur votre réseau est <b>netstat</b>. Netstat affiche diverses informations liées au réseau telles que les connexions réseau, les tables de routage, les informations sur les interfaces réseau et plus encore, c'est le couteau suisse des outils de mise en réseau. Nous nous concentrerons principalement sur une fonctionnalité que netstat possède et c'est l'état des connexions réseau. Avant de regarder un exemple, parlons d'abord des sockets et des ports. Un socket est une interface qui permet aux programmes d'envoyer et de recevoir des données tandis qu'un port est utilisé pour identifier quelle application doit envoyer ou recevoir des données. L'adresse du socket est la combinaison de l'adresse IP et du port. Chaque connexion entre un hôte et une destination nécessite un socket unique. Par exemple, HTTP est un service qui s'exécute sur le port 80, cependant nous pouvons avoir de nombreuses connexions HTTP et pour maintenir chaque connexion, un socket est créé par connexion.\n\n<pre>\npete@icebox:~$ netstat -at\nConnexions Internet actives (serveurs et établies)\nProto Recv-Q Send-Q Adresse locale           Adresse distante         État      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nLa commande netstat -a affiche les sockets en écoute et non en écoute pour les connexions réseau, le drapeau -t affiche uniquement les connexions tcp. \n\nLes colonnes sont les suivantes de gauche à droite:\n\n<ul>\n<li>Proto: Protocole utilisé, TCP ou UDP.</li>\n<li>Recv-Q: Données en attente de réception</li>\n<li>Send-Q: Données en attente d'envoi</li>\n<li>Adresse locale: Hôte connecté localement</li>\n<li>Adresse distante: Hôte connecté à distance</li>\n<li>État: L'état du socket</li>\n</ul>\n\nConsultez la page de manuel pour une liste des états de socket, mais voici quelques-uns:\n\n<ul>\n<li>LISTENING: Le socket écoute les connexions entrantes, rappelez-vous que lorsque nous établissons une connexion TCP, notre destination doit nous écouter avant que nous puissions nous connecter.</li>\n<li>SYN_SENT: Le socket tente activement d'établir une connexion.</li>\n<li>ESTABLISHED: Le socket a une connexion établie</li>\n<li>CLOSE_WAIT: L'hôte distant s'est arrêté et nous attendons que le socket se ferme</li>\n<li>TIME_WAIT: Le socket attend après la fermeture pour traiter les paquets encore dans le réseau</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "Quel port est utilisé pour HTTPS?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Téléchargez et installez l'outil Wireshark et explorez l'interface.",
          "id": 5,
          "lessonContent": "Le sujet de l'analyse de paquets pourrait remplir tout un cours à lui seul et de nombreux livres ont été écrits uniquement sur l'analyse de paquets. Cependant, aujourd'hui nous allons simplement apprendre les bases. Il existe deux analyseurs de paquets extrêmement populaires, Wireshark et tcpdump. Ces outils analysent vos interfaces réseau, capturent l'activité des paquets, analysent les paquets et affichent les informations pour que nous puissions les voir. Ils nous permettent d'entrer dans les détails de l'analyse réseau et d'explorer les aspects les plus bas niveau. Nous utiliserons tcpdump car il a une interface plus simple, cependant si vous souhaitez vous lancer dans l'analyse de paquets, je vous recommande de vous intéresser à Wireshark.\n\n<b>Installer tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Capturer des données de paquets sur une interface</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: sortie verbeuse supprimée, utilisez -v ou -vv pour un décodage complet des protocoles\nécoute sur wlan0, type de liaison EN10MB (Ethernet), taille de capture 65535 octets\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: demande d'écho ICMP, id 1901, seq 2, longueur 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: réponse d'écho ICMP, id 1901, seq 2, longueur 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: demande d'écho ICMP, id 1901, seq 3, longueur 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: réponse d'écho ICMP, id 1901, seq 3, longueur 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: demande d'écho ICMP, id 1901, seq 4, longueur 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: réponse d'écho ICMP, id 1901, seq 4, longueur 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: demande d'écho ICMP, id 1901, seq 5, longueur 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: réponse d'écho ICMP, id 1901, seq 5, longueur 64\n11:28:30.674953 ARP, Demande qui a 172.254.1.0 dit ThePickleParty.lan, longueur 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, longueur 306\n</pre>\n\nVous remarquerez beaucoup de choses se produire lorsque vous lancez une capture de paquets, c'est normal car il y a beaucoup d'activité réseau en arrière-plan. Dans mon exemple ci-dessus, j'ai pris seulement un extrait de ma capture, spécifiquement au moment où j'ai décidé de faire un ping sur www.google.com. \n\n<b>Comprendre la sortie</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: demande d'écho ICMP, id 1901, seq 2, longueur 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: réponse d'écho ICMP, id 1901, seq 2, longueur 64\n</pre>\n\n<ul>\n<li>Le premier champ est un horodatage de l'activité réseau</li>\n<li>IP, contient les informations du protocole</li>\n<li>Ensuite, vous verrez l'adresse source et de destination : icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, il s'agit du numéro de séquence de début et de fin des paquets TCP</li>\n<li>longueur, longueur en octets</li>\n</ul>\n\nComme vous pouvez le voir dans notre sortie tcpdump, nous envoyons un paquet de demande d'écho ICMP à www.google.com et recevons en retour un paquet de réponse d'écho ICMP ! Notez également que différents paquets afficheront des informations différentes, consultez le manuel pour voir ce que sont ces informations.\n\n<b>Écrire la sortie de tcpdump dans un fichier</b>\n\n<pre>\n$ sudo tcpdump -w /some/file\n</pre>\n\n\nQuelques réflexions finales : nous avons seulement effleuré la surface du sujet de l'analyse de paquets. Il y a tellement de choses à explorer et nous n'avons même pas abordé l'approfondissement avec la sortie Hex et ASCII. Il existe de nombreuses ressources en ligne pour vous aider à en apprendre davantage sur les analyseurs de paquets et je vous encourage à les trouver !",
          "quizAnswer": "-i",
          "quizQuestion": "Quel est le drapeau pour capturer une interface spécifique avec tcpdump?",
          "slug": "analysepaquets",
          "title": "Analyse de paquets"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Dépannage"
    },
    {
      "description": "Tout ce que vous vouliez savoir sur le DNS, et plus encore.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "Pas d'exercices pour cette leçon.",
          "id": 1,
          "lessonContent": "Imaginez si chaque fois que vous vouliez faire une recherche sur Google, vous deviez taper http://192.78.12.4 au lieu de www.google.com. Eh bien, sans le DNS (\"Domain Name System\"), c'est exactement ce qui se passerait. Le réseau de bas niveau ne comprend que l'adresse IP brute pour identifier un hôte. Le DNS nous permet, à nous les humains, de suivre les sites web et les hôtes par leur nom au lieu d'une adresse IP. C'est comme une liste de contacts pour Internet. Si vous connaissez le nom de quelqu'un mais ne connaissez pas son numéro de téléphone, vous pouvez simplement le chercher dans votre liste de contacts.\n\nLe DNS est fondamentalement une base de données distribuée des noms d'hôtes et des adresses IP, nous gérons notre base de données pour que les gens sachent comment accéder à notre site/domaine, et quelque part d'autre une autre personne gère sa base de données pour que d'autres puissent accéder à son domaine. Ces domaines peuvent ensuite communiquer entre eux et construire une immense liste de contacts d'Internet.\n\nDans ce cours, nous passerons en revue quelques bases du DNS, mais sachez que le DNS est un sujet exhaustif et si vous voulez vraiment plonger dedans, vous devrez faire des recherches supplémentaires.",
          "quizAnswer": "faux",
          "quizQuestion": "Vrai ou faux, le DNS nous aide à trouver les adresses MAC des noms d'hôtes ?",
          "slug": "qu-est-ce-que-le-dns",
          "title": "Qu'est-ce que le DNS ?"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 2,
          "lessonContent": "La base de données DNS d'Internet repose sur des sites et des organisations fournissant une partie de cette base de données. Pour ce faire, ils ont besoin de :\n\n<b>Serveur de noms</b>\n\nNous configurons le DNS via des \"serveurs de noms\", les serveurs de noms chargent nos paramètres DNS et configurations et répondent aux questions des clients ou d'autres serveurs qui veulent savoir des choses comme \"Qui est google.com?\". Si le serveur de noms ne connaît pas la réponse à cette requête, il redirigera la demande vers d'autres serveurs de noms. Les serveurs de noms peuvent être \"autoritaires\", ce qui signifie qu'ils détiennent les enregistrements DNS réels que vous recherchez, ou \"récursifs\", ce qui signifie qu'ils poseraient des questions à d'autres serveurs et que ces serveurs poseraient des questions à d'autres serveurs jusqu'à ce qu'ils trouvent un serveur autoritaire contenant les enregistrements DNS. Les serveurs récursifs peuvent également avoir les informations que nous voulons mises en cache au lieu d'atteindre un serveur autoritaire.\n\n<b>Fichier de zone</b>\n\nÀ l'intérieur d'un serveur de noms se trouve quelque chose appelé fichiers de zone. Les fichiers de zone sont la façon dont le serveur de noms stocke des informations sur le domaine ou comment accéder au domaine s'il ne le sait pas.\n\n<b>Enregistrements de ressources</b>\n\nUn fichier de zone est composé d'entrées d'enregistrements de ressources. Chaque ligne est un enregistrement et contient des informations sur les hôtes, les serveurs de noms, d'autres ressources, etc. Les champs se composent de ce qui suit :\n\n<ul>\n<li>Nom de l'enregistrement</li>\n<li>TTL - Le temps après lequel nous jetons l'enregistrement et en obtenons un nouveau, en DNS, le TTL est indiqué par le temps, donc les enregistrements pourraient avoir un TTL d'une heure. La raison pour laquelle nous faisons cela est que l'Internet change constamment, une minute un hôte peut être associé à une adresse IP X puis la suivante à une adresse IP Y</li>\n<li>Classe - Espace de noms des informations d'enregistrement, le plus couramment utilisé est IN pour Internet</li>\n<li>Type - Type d'informations stockées dans les données d'enregistrement. Nous n'entrerons pas dans les types d'enregistrements, mais vous avez probablement vu des types courants comme A pour adresse, MX pour échangeur de courrier, etc.</li>\n<li>Données - Ce champ peut contenir une adresse IP s'il s'agit d'un enregistrement A ou autre chose en fonction du type d'enregistrement.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "Quel type d'enregistrement de ressources est utilisé pour les échangeurs de courrier?",
          "slug": "composantsdns",
          "title": "Composants DNS"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 3,
          "lessonContent": "Voyons un exemple de la façon dont votre hôte trouve un domaine (catzontheinterwebz.com) avec le DNS. Essentiellement, nous descendons jusqu'à atteindre le serveur DNS qui connaît ce domaine.\n\n<b>Serveur DNS Local</b>\n\nTout d'abord, notre hôte demande : \"Où se trouve catzontheinterwebz.com ?\", notre serveur DNS local ne sait pas, il remonte donc jusqu'au sommet de l'entonnoir pour interroger les serveurs racines. Gardez à l'esprit que notre hôte ne fait pas ces demandes pour trouver directement catzontheinterwebz.com, la plupart des utilisateurs parlent à un serveur DNS récursif fourni par leur FAI et ce serveur est ensuite chargé de trouver l'emplacement de catzontheinterwebz.com.\n\n<b>Serveurs Racines</b>\n\nIl y a 13 serveurs racines pour Internet, ils sont dupliqués et répartis dans le monde entier pour gérer les demandes DNS pour Internet, il y a donc vraiment des centaines de serveurs qui travaillent, ils sont contrôlés par différentes organisations et contiennent des informations sur les domaines de premier niveau. Les domaines de premier niveau sont ce que vous connaissez sous les adresses .org, .com, .net, etc. Donc, le serveur racine ne sait pas où se trouve catzontheinterwebz.com, il nous dit donc de demander au serveur DNS du domaine de premier niveau .com à une adresse IP qu'il nous donne. \n\n<b>Domaine de Premier Niveau</b>\n\nNous envoyons maintenant une autre demande au serveur de noms qui connaît les adresses \".com\" et lui demandons s'il sait où se trouve catzontheinterwebz.com ? Le domaine de premier niveau n'a pas catzontheinterwebz.com dans ses fichiers de zone, mais il voit un enregistrement pour le serveur de noms de catzontheinterwebz.com. Il nous donne donc l'adresse IP de ce serveur de noms et nous dit de regarder là-bas.\n\n<b>Serveur DNS Autoritaire</b>\n\nNous envoyons maintenant une demande finale au serveur DNS qui possède réellement l'enregistrement que nous voulons. Le serveur de noms voit qu'il a un fichier de zone pour catzontheinterwebz.com et qu'il y a un enregistrement de ressource pour 'www' pour cet hôte. Il nous donne ensuite l'adresse IP de cet hôte et nous pouvons enfin voir des chats sur Internet.",
          "quizAnswer": "DPN",
          "quizQuestion": "Quelle est l'abréviation des serveurs de noms où l'on trouve les adresses .com, .net, .org, etc. ?",
          "slug": "processus-dns",
          "title": "Processus DNS"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 4,
          "lessonContent": "<p>Avant que notre machine ne fasse réellement appel au DNS pour effectuer une requête, elle regarde d'abord localement sur nos machines. </p><br><p><b>/etc/hosts</b></p><p>Le fichier /etc/hosts contient des mappings de certains noms d'hôtes vers des adresses IP. Les champs sont assez explicites, il y en a un pour l'adresse IP, le nom d'hôte, puis tout alias pour l'hôte. </p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>Vous verrez généralement votre adresse localhost répertoriée par défaut dans ce fichier. Vous pouvez également gérer l'accès aux hôtes en modifiant les fichiers /etc/hosts.deny ou /etc/hosts.allow. Cependant, si vous êtes soucieux de la sécurité, ce n'est pas vraiment la bonne méthode et vous devriez plutôt modifier vos règles de pare-feu. </p><p>Voyons un exemple amusant de /etc/hosts. Modifiez le fichier et ajoutez une ligne pour :</p><pre>123.45.6.7  www.google.com</pre><p>Enregistrez le fichier et allez maintenant sur www.google.com. Vous rencontrez des problèmes, n'est-ce pas ? Eh bien, c'est parce que nous venons de mapper www.google.com vers une adresse IP complètement erronée. Comme nos hôtes recherchent d'abord localement les mappings d'adresses IP, ils n'atteignent jamais le DNS pour trouver google.com. </p><p><b>/etc/resolv.conf</b></p><p>Traditionnellement, nous avons utilisé un fichier appelé /etc/resolv.conf pour mapper les serveurs de noms DNS afin de réaliser des recherches plus efficaces, cependant, avec les améliorations apportées au DNS, ce fichier est souvent sans importance, en fait, vous pouvez voir dans mon exemple ci-dessous que /etc/resolv.conf n'est pas géré manuellement. Consultez les paramètres spécifiques à votre distribution pour gérer les mappings des serveurs de noms DNS.</p><pre>fichier conf(5) pour le résolveur glibc(3) généré par resolvconf(8)<br>#     NE PAS MODIFIER CE FICHIER MANUELLEMENT -- VOS MODIFICATIONS SERONT ÉCRASÉES<br>serveur de noms 127.0.1.1<br>recherche localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "Quel fichier est utilisé pour mapper les noms d'hôtes aux adresses IP sur nos machines ?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "Aucun exercice pour cette leçon.",
          "id": 5,
          "lessonContent": "Nous n'aborderons pas la mise en place d'un serveur DNS, car ce serait un tutoriel assez long. À la place, voici une liste de comparaison rapide des serveurs DNS populaires à utiliser avec Linux.\n\n<b>BIND</b>\n\nLe serveur DNS le plus populaire sur Internet, c'est la norme utilisée avec les distributions Linux. Il a été initialement développé à l'Université de Californie à Berkeley, d'où le nom BIND (Berkeley Internet Name Domain). Si vous avez besoin de puissance et de flexibilité complètes, vous ne pouvez pas vous tromper avec BIND.\n\n<b>DNSmasq</b>\n\nLéger et beaucoup plus facile à configurer que BIND. Si vous recherchez la simplicité et que vous n'avez pas besoin de toutes les fonctionnalités de BIND, utilisez DNSmasq. Il est livré avec tous les outils dont vous avez besoin pour configurer DHCP et DNS, recommandé pour un réseau plus petit.\n\n<b>PowerDNS</b>\n\nComplet et similaire à BIND, il vous offre un peu plus de flexibilité avec des options. Il lit des informations à partir de plusieurs bases de données telles que MySQL, PostgreSQL, etc. pour une administration plus facile. Juste parce que BIND a été la façon dont nous faisons les choses, cela ne signifie pas que cela doit rester ainsi.\n\nCe n'est pas une liste complète, mais cela devrait vous donner une idée d'où chercher si vous mettez en place votre propre serveur DNS.",
          "quizAnswer": "BIND",
          "quizQuestion": "Quel est le serveur DNS de facto pour Linux?",
          "slug": "configuration-dns",
          "title": "Configuration DNS"
        },
        {
          "exercise": "Consultez le manuel de dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nL'outil \"recherche de serveur de noms\" est utilisé pour interroger les serveurs de noms afin de trouver des informations sur les enregistrements de ressources. Trouvons où se trouve le serveur de noms pour google.com :\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nNon-authoritative answer:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (domain information groper) est un outil puissant pour obtenir des informations sur les serveurs de noms DNS, il est plus flexible que nslookup et idéal pour résoudre les problèmes DNS.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; QUESTION SECTION:\n;www.google.com.                        IN      A\n\n;; ANSWER SECTION:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Query time: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; WHEN: Sun Feb 07 10:14:00 PST 2016\n;; MSG SIZE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "Quel outil est utilisé pour obtenir des informations détaillées sur les serveurs de noms DNS ?",
          "slug": "dnstools",
          "title": "Outils DNS"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Contenu",
      "exerciseAndQuiz": "Exercice & quiz"
    },
    "exerciseBox": {
      "exercise": "Exercice"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Une nouvelle vie pour LinuxJourney, qui a aidé tant de personnes à faire leurs premiers pas dans le monde de Linux.",
      "title": "Débloquez la puissance de Linux"
    },
    "navbar": {
      "home": "Accueil",
      "language": "Langue",
      "lessons": "Leçons",
      "resources": "Ressources",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Retour aux chapitres",
      "checkAnswer": "Vérifier la réponse",
      "correctAnswer": "Réponse correcte : ",
      "nextLesson": "Leçon suivante",
      "placeholderAnswer": "Tapez votre réponse ici",
      "quiz": "Quiz",
      "showCorrectAnswer": "Afficher la réponse correcte"
    },
    "resources": {
      "data": [
        {
          "description": "Un guide étape par étape pour les débutants qui explique l'histoire du terminal et les commandes de base",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Tutoriel officiel d'Ubuntu"
        },
        {
          "description": "Un aperçu clair du fonctionnement du terminal, comment exécuter des commandes et naviguer dans le système de fichiers.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "Un des livres les plus recommandés !",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "How Linux Works"
        },
        {
          "description": "Livre extrêmement complet pour chaque SysAdmin.",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "UNIX and Linux System Administration Handbook"
        },
        {
          "description": "Excellent guide complet pour le scripting shell.",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Linux Command Bible"
        },
        {
          "description": "Pour les utilisateurs sérieux de Linux, excellent début dans la programmation du noyau.",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "The Linux Programming Interface: A Linux and UNIX System"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Découvrez des livres, tutoriels et outils sélectionnés pour approfondir vos connaissances en Linux.",
        "title": "Ressources"
      },
      "title": "Ressources"
    }
  }
}