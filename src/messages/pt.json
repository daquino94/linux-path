{
  "chapters": [
    {
      "description": "O que é o Linux? Comece escolhendo uma distribuição e fazendo a instalação.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Leitura adicional:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "Ei novato! Então você decidiu mergulhar neste maravilhoso mundo conhecido como Linux? Bem, é melhor se preparar, porque será um longo e árduo caminho. Meu nome é Pinguim Pete e estou aqui para guiá-lo nesta jornada. Vamos começar com um pouco de história sobre o Linux. \n\nPara aprender como o Linux surgiu, vamos voltar ao início, em 1969, quando Ken Thompson e Dennis Ritchie dos Laboratórios Bell desenvolveram o sistema operacional UNIX. Mais tarde, foi reescrito em C para torná-lo mais portátil e eventualmente tornou-se um sistema operacional amplamente utilizado. \n\nUma década depois, Richard Stallman começou a trabalhar no projeto GNU (GNU não é UNIX), o kernel GNU chamado Hurd, que infelizmente nunca foi concluído. A Licença Pública Geral GNU (GPL), uma licença de software livre, também foi criada como resultado disso.\n\nO kernel é a parte mais importante do sistema operacional. Ele permite que o hardware se comunique com o software. Ele também faz muitas outras coisas, mas vamos aprofundar isso em um curso diferente. Por enquanto, saiba que o kernel controla praticamente tudo o que acontece em seu sistema. \n\nDurante esse tempo, outros esforços como BSD, MINIX, etc foram desenvolvidos para serem sistemas semelhantes ao UNIX. No entanto, uma coisa que todos esses sistemas semelhantes ao UNIX tinham em comum era a falta de um kernel unificado. \n\nEntão, em 1991, um jovem chamado Linus Torvalds começou a desenvolver o que hoje conhecemos como o kernel Linux.",
          "quizAnswer": "Linus Torvalds",
          "quizQuestion": "Quem desenvolveu o kernel Linux?",
          "slug": "historiadolinux",
          "title": "História"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 2,
          "lessonContent": "Na lição anterior, aprendemos sobre o kernel do Linux que alimenta milhões de dispositivos por dia. Uma coisa antes de avançarmos, o termo Linux é na verdade um equívoco, pois na realidade se refere ao kernel do Linux. No entanto, muitas distribuições utilizam o kernel do Linux e, portanto, são comumente conhecidas como sistemas operacionais Linux. \n\nUm sistema Linux é dividido em três partes principais:\n\n<ul>\n<li>Hardware - Isso inclui todo o hardware em que seu sistema funciona, bem como memória, CPU, discos, etc.</li>\n<li>Kernel do Linux - Como discutimos acima, o kernel é o núcleo do sistema operacional. Ele gerencia o hardware e diz como interagir com o sistema.</li>\n<li>Espaço do Usuário - Aqui é onde os usuários, como você, interagirão diretamente com o sistema.</li>\n</ul>\n\nPortanto, o primeiro passo que precisaremos dar é instalar o Linux em sua máquina. Você tem muitas opções para escolher e este curso ajudará a informá-lo e começar a escolher uma distribuição Linux. \n\nExistem muitas distribuições Linux para escolher, vamos apenas revisar as opções mais populares.",
          "quizAnswer": "",
          "quizQuestion": "Sem perguntas, avance!",
          "slug": "escolhendo-uma-distribuicao-linux",
          "title": "Escolhendo uma Distribuição Linux"
        },
        {
          "exercise": "Se você estiver interessado em ter o Debian como seu sistema operacional, vá para a seção de instalação e experimente: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Visão Geral</b>\nDebian é um sistema operacional composto inteiramente por software livre e de código aberto. É amplamente conhecido e está em desenvolvimento há mais de 20 anos. Existem três branches que você pode usar, Estável, Teste e Instável. \n\nEstável é uma boa branch para se estar. Teste e Instável são lançamentos contínuos. Isso significa que quaisquer mudanças incrementais nesses branches eventualmente se tornarão Estável. Por exemplo, se você quisesse passar para a próxima atualização do Windows 8 para o Windows 10, teria que fazer uma instalação completa do Windows 10. No entanto, estando no lançamento de Teste, você receberá automaticamente atualizações até que se torne o próximo lançamento do sistema operacional sem ter que fazer uma instalação completa. \n\n<b>Gerenciamento de Pacotes</b>\nDebian também usa ferramentas de gerenciamento de pacotes Debian. Cada distribuição Linux instala e gerencia pacotes de maneira diferente e usa diferentes ferramentas de gerenciamento de pacotes. Falaremos mais sobre isso em um curso posterior. \n\n<b>Configurabilidade</b>\nDebian pode não receber as últimas atualizações, mas é extremamente estável. Se você deseja um bom sistema operacional \"core\", este é o ideal para você.\n\n<b>Usos</b>\nDebian é um ótimo sistema operacional para qualquer plataforma.",
          "quizAnswer": "Rolling",
          "quizQuestion": "Que tipo de lançamento o Teste e o Instável têm?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Se você está interessado em ter o RHEL como seu sistema operacional, vá para a seção de instalação e experimente: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Visão Geral</b>\nRed Hat Enterprise Linux comumente referido como RHEL é desenvolvido pela Red Hat. O RHEL possui regras rígidas para restringir a redistribuição gratuita, embora ainda forneça o código-fonte gratuitamente.\n\n<b>Gerenciamento de Pacotes</b>\nO RHEL utiliza um gerenciador de pacotes diferente do Debian, o gerenciador de pacotes RPM, que eventualmente aprenderemos também.\n\n<b>Configurabilidade</b>\nOs sistemas operacionais baseados em RHEL diferirão ligeiramente dos sistemas operacionais baseados em Debian, principalmente no gerenciamento de pacotes. Se você decidir usar o RHEL, é provavelmente melhor saber que estará trabalhando com ele.\n\n<b>Usos</b>\nComo o nome sugere, é principalmente usado em empresas, então se você precisa de um sistema operacional de servidor sólido, este seria uma boa opção.",
          "quizAnswer": "RPM",
          "quizQuestion": "Que gerenciador de pacotes o RHEL utiliza?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Se você está interessado em ter o Ubuntu como seu sistema operacional, vá para a seção de instalação e experimente: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Visão Geral</b>\nUma das distribuições Linux mais populares para máquinas pessoais é o Ubuntu. O Ubuntu também lança seu próprio gerenciador de ambiente de desktop Unity por padrão. \n\n<b>Gerenciamento de Pacotes</b>\nO Ubuntu é um sistema operacional baseado em Debian desenvolvido pela Canonical. Portanto, ele utiliza um sistema central de gerenciamento de pacotes Debian.\n\n<b>Configurabilidade</b>\nO Ubuntu é uma ótima escolha para um iniciante que deseja entrar no mundo do Linux. O Ubuntu oferece facilidade de uso e uma ótima experiência de interface de usuário que levou à sua ampla adoção. É amplamente utilizado e suportado e é mais semelhante a outros sistemas operacionais como OSX e Windows em termos de usabilidade.\n\n<b>Usos</b>\nÓtimo para qualquer plataforma, desktop, laptop e servidor.",
          "quizAnswer": "Debian",
          "quizQuestion": "Em qual sistema operacional o Ubuntu é baseado?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Se você estiver interessado em ter o Fedora como seu sistema operacional, vá para a seção de instalação e experimente: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Visão Geral</b>\nApoiado pela Red Hat, o Projeto Fedora é impulsionado pela comunidade e contém software livre e de código aberto. O Red Hat Enterprise Linux deriva do Fedora, então pense no Fedora como um sistema operacional RHEL upstream. Eventualmente, o RHEL receberá atualizações do Fedora após testes minuciosos e garantia de qualidade. Pense no Fedora como um equivalente ao Ubuntu que utiliza um backend da Red Hat em vez do Debian.\n\n<b>Gerenciamento de Pacotes</b>\nUtiliza o gerenciador de pacotes Red Hat.\n\n<b>Configurabilidade</b>\nSe você deseja usar um sistema operacional baseado na Red Hat, esta é uma versão amigável para o usuário.\n\n<b>Usos</b>\nO Fedora é ótimo se você deseja um sistema operacional baseado na Red Hat sem o preço. Recomendado para desktops e laptops.",
          "quizAnswer": "Fedora",
          "quizQuestion": "De que o RHEL deriva?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Se você está interessado em ter o Linux Mint como seu sistema operacional, vá para a seção de instalação e experimente: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Visão Geral</b>\nLinux Mint é baseado no Ubuntu. Ele utiliza os repositórios de software do Ubuntu, então os mesmos pacotes estão disponíveis em ambas as distribuições. Linux Mint é preferido por outros em relação ao Ubuntu porque não vem com alguns softwares proprietários que o Ubuntu inclui, como o Unity.\n\n<b>Gerenciamento de Pacotes</b>\nComo o Linux Mint é baseado no Ubuntu, ele utiliza o gerenciador de pacotes Debian.\n\n<b>Configurabilidade</b>\nÓtima interface de usuário, ótimo para iniciantes e menos inchado que o Ubuntu. Neste curso, estarei usando o Linux Mint, mas qualquer outra distribuição pode ser usada.\n\n<b>Usos</b>\nÓtimo para desktop e laptop.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "De que o Linux Mint é baseado?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Se você está interessado em ter o Gentoo como seu sistema operacional, vá para a seção de instalação e experimente: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Visão Geral</b>\nGentoo oferece uma flexibilidade ridícula com o sistema operacional a um preço. É feito para usuários avançados que não se importam em sujar as mãos com o sistema.\n\n<b>Gerenciamento de Pacotes</b>\nGentoo usa seu próprio gerenciador de pacotes, Portage. O gerenciamento de pacotes Portage é muito modular e fácil de manter, o que desempenha um grande papel na flexibilidade do sistema operacional como um todo.\n\n<b>Configurabilidade</b>\nSe você está começando com o Linux e quer seguir um caminho mais difícil, eu escolheria Gentoo ou Arch Linux como sua distribuição.\n\n<b>Usos</b>\nÓtimo para desktop e laptop.",
          "quizAnswer": "Portage",
          "quizQuestion": "Que sistema de gerenciamento de pacotes o Gentoo utiliza?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Se você está interessado em ter o Arch como seu sistema operacional, vá para a seção de instalação e experimente: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Visão Geral</b>\nArch é uma distribuição Linux leve e flexível conduzida 100% pela comunidade. Semelhante ao Debian, o Arch utiliza um modelo de lançamento contínuo, de modo que as atualizações incrementais eventualmente se tornam a versão Estável. Você realmente precisa colocar a mão na massa para entender o sistema e suas funções, mas em troca obtém controle completo e total do seu sistema.\n\n<b>Gerenciamento de Pacotes</b>\nEle utiliza seu próprio gerenciador de pacotes, Pacman, para instalar, atualizar e gerenciar pacotes. \n\n<b>Configurabilidade</b>\nSe você deseja um sistema operacional leve e realmente quer entender o Linux, use o Arch! Há uma curva de aprendizado, mas para os usuários avançados de Linux, esta é uma ótima escolha.\n\n<b>Usos</b>\nÓtimo para desktop e laptop. Se você também tem um dispositivo pequeno como um Raspberry Pi e precisa instalar um sistema operacional leve nele, você não pode errar com o Arch.",
          "quizAnswer": "Pacman",
          "quizQuestion": "Que gerenciador de pacotes o Arch Linux utiliza?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Se você está interessado em ter o openSUSE como seu sistema operacional, vá para a página de download e experimente: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Visão Geral</b>\nopenSUSE Linux é criado pelo Projeto openSUSE. Uma comunidade que promove o uso do Linux em todos os lugares, trabalhando juntos de forma aberta, transparente e amigável como parte da comunidade mundial de Software Livre e de Código Aberto. openSUSE é a segunda distribuição Linux mais antiga ainda em funcionamento e compartilha o sistema base com os premiados produtos SUSE Linux Enterprise da SUSE.\n\n<b>Gerenciamento de Pacotes</b>\nUtiliza o gerenciador de pacotes RPM.\n\n<b>Configurabilidade</b>\nopenSUSE é uma ótima escolha para um novo usuário de Linux. Oferece um instalador/administrador gráfico fácil de usar (<a href=\"http://yast.github.io/\">YaST</a>) e um sistema base organizado, fácil de mexer. openSUSE inclui tudo o que você precisa para desfrutar da Internet sem preocupações com vírus/spyware e para expressar sua criatividade, seja com suas fotos, vídeos, música ou código.\n\n<b>Usos</b>\nopenSUSE Leap é totalmente capaz de ser usado em um PC desktop e laptop.",
          "quizAnswer": "yast",
          "quizQuestion": "Qual é o nome da Ferramenta de Administração/Instalação do openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Começando"
    },
    {
      "description": "Aprenda os fundamentos da linha de comando, navegando por arquivos, diretórios e muito mais.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Tente alguns outros comandos Linux e veja o que eles exibem:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "O mundo é sua ostra, ou na verdade o shell é sua ostra. O que é o shell? O shell é basicamente um programa que recebe seus comandos do teclado e os envia para o sistema operacional executar. Se você já usou uma GUI, provavelmente já viu programas como 'Terminal' ou 'Console', esses são apenas programas que iniciam um shell para você. Ao longo de todo este curso, estaremos aprendendo sobre as maravilhas do shell. \n\nNeste curso, usaremos o programa shell bash (Bourne Again shell), quase todas as distribuições Linux usarão o bash por padrão. Existem outros shells disponíveis, como ksh, zsh, tsch, mas não vamos entrar em nenhum deles. \n\nVamos direto ao ponto! Dependendo da distribuição, seu prompt de shell pode mudar, mas em sua maioria deve seguir o seguinte formato:\n<pre>nome_de_usuário@nome_do_host:diretório_atual\npete@icebox:/home/pete $</pre>\n\nPercebeu o $ no final do prompt? Diferentes shells terão prompts diferentes, no nosso caso o $ é para um usuário normal usando Bash, Bourne ou Korn shell, você não adiciona o símbolo do prompt ao digitar o comando, apenas saiba que ele está lá.\n\nVamos começar com um comando simples, echo. O comando echo apenas imprime os argumentos de texto na tela.\n\n<pre>$ echo Olá Mundo</pre>",
          "quizAnswer": "Olá Mundo",
          "quizQuestion": "O que deve ser exibido na tela quando você digitar echo Olá Mundo?",
          "slug": "o-shell",
          "title": "O Shell"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 2,
          "lessonContent": "Tudo no Linux é um arquivo. Conforme você mergulha mais fundo no Linux, você vai entender isso, mas por enquanto apenas mantenha isso em mente. Cada arquivo é organizado dentro de uma árvore de diretórios hierárquica. O primeiro diretório no sistema de arquivos é adequadamente chamado de 'diretório raiz'. O diretório raiz tem muitas pastas e arquivos, nos quais você pode armazenar mais pastas e arquivos, e assim por diante. Aqui está um exemplo de como a árvore de diretórios se parece: \n\n<pre>/\n|-- bin\n|   |-- arquivo1\n|   |-- arquivo2\n|-- etc\n|   |-- arquivo3\n|   `-- diretório1\n|       |-- arquivo4\n|       `-- arquivo5\n|-- home\n|-- var\n</pre>\n\nAs localizações desses arquivos e diretórios são referidas como 'caminhos'. Se você tivesse uma pasta chamada 'home' que tivesse uma pasta dentro dela chamada 'pete' e outra pasta nessa pasta chamada 'Filmes', esse caminho se pareceria com isso: '/home/pete/Filmes'. Bastante simples, não é?\n\nNavegar no sistema de arquivos, assim como navegar na vida real, é mais fácil se você souber onde está e para onde está indo. Para ver onde você está, você pode usar o comando 'pwd'. Esse comando significa “print working directory” e mostra em qual diretório você está. Note que o caminho se origina do diretório raiz.\n\n<pre>$ pwd</pre>\n\nOnde você está? Onde estou? Experimente.",
          "quizAnswer": "pwd",
          "quizQuestion": "Como eu descubro em qual diretório você está atualmente?",
          "slug": "comandoprintworkingdirectorypwd",
          "title": "pwd (Print Working Directory)"
        },
        {
          "exercise": "<ol>\n<li>Execute o comando cd sem nenhuma flag, para onde ele te leva?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Agora que você sabe onde está, vamos ver se conseguimos nos mover um pouco pelo sistema de arquivos. Lembre-se de que precisaremos navegar usando caminhos. Existem duas maneiras diferentes de especificar um caminho, com caminhos absolutos e relativos. \n\n<ul>\n<li>Caminho absoluto: Este é o caminho a partir do diretório raiz. O diretório raiz é o chefe. O diretório raiz é comumente mostrado como uma barra. Toda vez que seu caminho começa com / significa que você está começando a partir do diretório raiz. Por exemplo, /home/pete/Desktop.</li>\n\n<li>Caminho relativo: Este é o caminho de onde você está atualmente no sistema de arquivos. Se eu estivesse na localização /home/pete/Documents e quisesse ir para um diretório dentro de Documents chamado taxes, não preciso especificar o caminho inteiro a partir da raiz como /home/pete/Documents/taxes, posso simplesmente ir para taxes/ em vez disso.</li>\n</ul>\n\nAgora que você sabe como os caminhos funcionam, precisamos de algo para nos ajudar a mudar para o diretório que queremos. Felizmente, temos cd ou \"change directory\" para fazer isso. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nAgora mudei minha localização de diretório para /home/pete/Pictures.\n\nAgora, a partir deste diretório, tenho uma pasta dentro chamada Hawaii, posso navegar para essa pasta com:\n\n<pre>$ cd Hawaii</pre>\n\nPerceba como eu apenas usei o nome da pasta? Isso porque eu já estava em /home/pete/Pictures.\n\nPode ser cansativo navegar com caminhos absolutos e relativos o tempo todo, felizmente existem alguns atalhos para ajudar você. \n\n<ul>\n<li>. (diretório atual). Este é o diretório em que você está atualmente. </li>\n<li>.. (diretório anterior). Leva você para o diretório acima do seu atual.</li>\n<li>~ (diretório home). Este diretório é o padrão para o seu \"diretório home\". Como /home/pete.</li>\n<li>- (diretório anterior). Isso o levará para o diretório anterior em que você estava.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nExperimente!",
          "quizAnswer": "cd ..",
          "quizQuestion": "Se você estiver em /home/pete/Pictures e quiser ir para /home/pete, qual é um bom atalho para usar?",
          "slug": "changedirectorycdcommand",
          "title": "cd (Change Directory)"
        },
        {
          "exercise": "Execute ls com diferentes flags e veja a saída que você recebe.",
          "id": 4,
          "lessonContent": "Agora que sabemos como nos mover pelo sistema, como descobrimos o que está disponível para nós? Atualmente, é como se estivéssemos nos movendo no escuro. Bem, podemos usar o maravilhoso comando ls para listar o conteúdo do diretório. O comando ls listará diretórios e arquivos no diretório atual por padrão, no entanto, você pode especificar o caminho que deseja listar os diretórios.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls é uma ferramenta bastante útil, também mostra informações detalhadas sobre os arquivos e diretórios que você está visualizando.\n\nTambém observe que nem todos os arquivos em um diretório serão visíveis. Os nomes de arquivos que começam com . estão ocultos, você pode visualizá-los, no entanto, com o comando ls e passar a flag -a para ele (a para todos). \n\n<pre>$ ls -a</pre>\n\nExiste também mais uma flag útil do ls, -l para longo, isso mostra uma lista detalhada de arquivos em um formato longo. Isso mostrará informações detalhadas, começando da esquerda: permissões de arquivo, número de links, nome do proprietário, grupo do proprietário, tamanho do arquivo, carimbo de data/hora da última modificação e nome do arquivo/diretório. \n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nComandos têm coisas chamadas flags (ou argumentos ou opções, como você quiser chamar) para adicionar mais funcionalidades. Veja como adicionamos -a e -l, bem, você pode adicioná-los juntos com -la. A ordem das flags determina a ordem em que ela é aplicada, na maioria das vezes isso não importa muito, então você também pode fazer ls -al e ainda funcionará.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "Qual comando você usaria para ver arquivos ocultos?",
          "slug": "listdirectorieslscommand",
          "title": "ls (Listar Diretórios)"
        },
        {
          "exercise": "<ol>\n<li>Crie um novo arquivo</li>\n<li>Anote o carimbo de data e hora</li>\n<li>Toque no arquivo e verifique o carimbo de data e hora novamente</li>\n</ol>",
          "id": 5,
          "lessonContent": "Vamos aprender como criar alguns arquivos. Uma maneira muito simples é usar o comando touch. Touch permite que você crie novos arquivos vazios.\n\n<pre>$ touch mysuperduperfile</pre>\n\nE pronto, novo arquivo! \n\nTouch também é usado para alterar os carimbos de data e hora em arquivos e diretórios existentes. Experimente, faça um ls -l em um arquivo e anote o carimbo de data e hora, em seguida, toque nesse arquivo e ele atualizará o carimbo de data e hora. \n\nExistem muitas outras maneiras de criar arquivos que envolvem outras coisas como redirecionamento e editores de texto, mas vamos chegar a isso no curso de Manipulação de Texto.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "Como você cria um arquivo chamado myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Execute o comando file em alguns diretórios e arquivos diferentes e anote a saída.",
          "id": 6,
          "lessonContent": "Na lição anterior, aprendemos sobre o comando touch, vamos voltar a isso por um momento. Você percebeu que o nome do arquivo não segue a padronização de nomenclatura como você provavelmente viu em outros sistemas operacionais como o Windows? Normalmente, você esperaria um arquivo chamado banana.jpeg e esperaria um arquivo de imagem JPEG. \n\nNo Linux, os nomes de arquivos não precisam representar o conteúdo do arquivo. Você pode criar um arquivo chamado funny.gif que na verdade não é um GIF. \n\nPara descobrir que tipo de arquivo é um arquivo, você pode usar o comando file. Ele mostrará uma descrição do conteúdo do arquivo.\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "Que comando você pode usar para encontrar o tipo de arquivo de um arquivo?",
          "slug": "comandofile",
          "title": "arquivo"
        },
        {
          "exercise": "Execute o comando cat em diferentes arquivos e diretórios. Em seguida, tente concatenar vários arquivos.",
          "id": 7,
          "lessonContent": "Estamos quase terminando de navegar pelos arquivos, mas primeiro vamos aprender como ler um arquivo. Um comando simples de usar é o comando gato, abreviação de concatenar, ele não apenas exibe o conteúdo do arquivo, mas também pode combinar vários arquivos e mostrar a saída deles. \n\n<pre>$ cat arquivo_cachorro arquivo_passaro</pre>\n\nNão é ótimo para visualizar arquivos grandes e é destinado apenas para conteúdo curto. Existem muitas outras ferramentas que usamos para visualizar arquivos de texto maiores que discutiremos na próxima lição.",
          "quizAnswer": "cat",
          "quizQuestion": "Qual é uma boa maneira de ver o conteúdo de um arquivo?",
          "slug": "comandogato",
          "title": "gato"
        },
        {
          "exercise": "Execute less em um arquivo, depois navegue para cima e ao redor do arquivo. Tente procurar por uma palavra específica. Navegue rapidamente para o início ou o final do arquivo.",
          "id": 8,
          "lessonContent": "Se você estiver visualizando arquivos de texto maiores do que uma saída simples, less é mais. (Na verdade, existe um comando chamado more que faz algo semelhante, então isso é irônico.) O texto é exibido de maneira paginada, para que você possa navegar por um arquivo de texto página por página. \n\nVá em frente e veja o conteúdo de um arquivo com less. Uma vez no comando less, você pode realmente usar outros comandos de teclado para navegar no arquivo. \n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nUse o seguinte comando para navegar pelo less: \n\n<ul>\n<li>q - Usado para sair do less e voltar ao seu shell.</li>\n<li>Page up, Page down, Up e Down - Navegue usando as teclas de seta e de página.</li>\n<li>g - Move para o início do arquivo de texto.</li>\n<li>G - Move para o final do arquivo de texto.</li>\n<li>/search - Você pode pesquisar por texto específico dentro do documento de texto. Anteceda as palavras que deseja pesquisar com /</li>\n<li>h - Se precisar de um pouco de ajuda sobre como usar less enquanto estiver no less, use help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "Como você sai de um comando less?",
          "slug": "lesscommand",
          "title": "less"
        },
        {
          "exercise": "Navegue pelo histórico de comandos anteriores com as teclas de Seta para Cima e para Baixo. Brinque com a pesquisa reversa ctrl-R.",
          "id": 9,
          "lessonContent": "No seu shell, há um histórico dos comandos que você digitou anteriormente, você pode realmente percorrer esses comandos. Isso é bastante útil quando você deseja encontrar e executar um comando que usou anteriormente sem precisar digitá-lo novamente.\n\n<pre>$ history</pre>\n\nQuer executar o mesmo comando que fez antes, basta pressionar a seta para cima.\n\nQuer executar o comando anterior sem digitá-lo novamente? Use !!. Se digitou cat file1 e deseja executá-lo novamente, pode simplesmente digitar !! e ele executará o último comando que você digitou.\n\nOutro atalho de histórico é ctrl-R, este é o comando de pesquisa reversa, se pressionar ctrl-R e começar a digitar partes do comando que deseja, ele mostrará correspondências e você pode navegar por elas pressionando novamente a tecla ctrl-R. Assim que encontrar o comando que deseja usar novamente, basta pressionar a tecla Enter.\n\nNosso terminal está ficando um pouco bagunçado, não está? Vamos fazer uma limpeza rápida, use o comando clear para limpar sua tela.\n\n<pre>$ clear</pre>\n\nAgora parece melhor, não é verdade?\n\nEnquanto falamos sobre coisas úteis, uma das características mais úteis em qualquer ambiente de linha de comando é a conclusão de tabulação. Se começar a digitar o início de um comando, arquivo, diretório, etc e pressionar a tecla Tab, ele completará com base no que encontrar no diretório que está pesquisando, desde que não tenha outros arquivos que comecem com essas letras. Por exemplo, se estivesse tentando executar o comando chrome, pode digitar chr e pressionar Tab e ele completará chrome.",
          "quizAnswer": "clear",
          "quizQuestion": "Qual é o comando para limpar o terminal?",
          "slug": "comandohistorico",
          "title": "história"
        },
        {
          "exercise": "Copie alguns arquivos, tenha cuidado para não sobrescrever nada importante.",
          "id": 10,
          "lessonContent": "Vamos começar a fazer algumas cópias desses arquivos. Assim como copiar e colar arquivos em outros sistemas operacionais, o shell nos dá uma maneira ainda mais simples de fazer isso. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile é o arquivo que você deseja copiar e /home/pete/Documents/cooldocs é para onde você está copiando o arquivo.\n\nVocê pode copiar vários arquivos e diretórios, bem como usar curingas. Um curinga é um caractere que pode ser substituído por uma seleção baseada em padrões, dando a você mais flexibilidade com pesquisas. Você pode usar curingas em todos os comandos para mais flexibilidade.\n\n<ul>\n<li>* o curinga dos curingas, é usado para representar todos os caracteres únicos ou qualquer string.</li>\n<li>? usado para representar um caractere</li>\n<li>[] usado para representar qualquer caractere dentro dos colchetes</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nIsso copiará todos os arquivos com a extensão .jpg em seu diretório atual para o diretório Pictures.\n\nUm comando útil é usar a flag -r, isso copiará recursivamente os arquivos e diretórios dentro de um diretório. \n\nTente fazer um cp em um diretório que contenha alguns arquivos para o seu diretório Documents. Não funcionou, não é? Bem, isso acontece porque você precisará copiar também os arquivos e diretórios dentro com o comando -r.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nUma coisa a se observar, se você copiar um arquivo para um diretório que tem o mesmo nome de arquivo, o arquivo será sobrescrito com o que você está copiando. Isso não é bom se você tem um arquivo que não deseja que seja sobrescrito acidentalmente. Você pode usar a flag -i (interativo) para solicitar antes de sobrescrever um arquivo. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Que flag você precisa especificar para copiar um diretório?",
          "slug": "copycpcommand",
          "title": "cp (Copiar)"
        },
        {
          "exercise": "Renomeie um arquivo e, em seguida, mova esse arquivo para um diretório diferente.",
          "id": 11,
          "lessonContent": "Usado para mover arquivos e também renomeá-los. Bastante semelhante ao comando cp em termos de flags e funcionalidade. \n\nVocê pode renomear arquivos assim:\n\n<pre>$ mv arquivo_antigo novo_arquivo</pre>\n\nOu você pode realmente mover um arquivo para um diretório diferente: \n\n<pre>$ mv arquivo2 /home/pete/Documentos</pre>\n\nE mover mais de um arquivo:\n\n<pre>$ mv arquivo_1 arquivo_2 /algumdiretorio</pre>\n\nVocê também pode renomear diretórios:\n\n<pre>$ mv diretorio1 diretorio2</pre>\n\nAssim como cp, se você mover um arquivo ou diretório, ele irá sobrescrever qualquer coisa no mesmo diretório. Portanto, você pode usar a flag -i para ser avisado antes de sobrescrever algo.\n\n<pre>mv -i diretorio1 diretorio2</pre>\n\nDigamos que você queira mover um arquivo para sobrescrever o anterior. Você também pode fazer um backup desse arquivo e ele apenas renomeará a versão antiga com um ~. \n\n<pre>$ mv -b diretorio1 diretorio2</pre>",
          "quizAnswer": "mv cat dog",
          "quizQuestion": "Como você renomeia um arquivo chamado cat para dog?",
          "slug": "comandomvmover",
          "title": "mv (Mover)"
        },
        {
          "exercise": "Crie alguns diretórios e mova alguns arquivos para esse diretório.",
          "id": 12,
          "lessonContent": "Vamos precisar de alguns diretórios para armazenar todos esses arquivos em que estivemos trabalhando. O comando mkdir (Make Directory) é útil para isso, ele criará um diretório se ele ainda não existir. Você até pode criar vários diretórios ao mesmo tempo.\n\n<pre>$ mkdir books paintings</pre>\n\nVocê também pode criar subdiretórios ao mesmo tempo com a opção -p (flag de pai).\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "Qual comando é usado para criar um diretório?",
          "slug": "makedirectorymkdircommand",
          "title": "mkdir (Criar Diretório)"
        },
        {
          "exercise": "<ol>\n<li>Crie um arquivo chamado -arquivo (não esqueça do traço!).</li>\n<li>Remova esse arquivo.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Agora eu acho que temos muitos arquivos, vamos remover alguns arquivos. Para remover arquivos, você pode usar o comando rm. O comando rm (remover) é usado para excluir arquivos e diretórios. \n\n<pre>$ rm arquivo1</pre>\n\nTenha cuidado ao usar o rm, não há uma lixeira mágica da qual você possa recuperar arquivos removidos. Uma vez que eles se foram, eles se foram para sempre, então tenha cuidado. \n\nFelizmente, existem algumas medidas de segurança implementadas, para que o usuário comum não possa simplesmente remover um monte de arquivos importantes. Arquivos protegidos contra gravação solicitarão confirmação antes de serem excluídos. Se um diretório estiver protegido contra gravação, ele também não será facilmente removido. \n\nAgora, se você não se importa com nada disso, você pode absolutamente remover um monte de arquivos. \n\n<pre>$ rm -f arquivo1</pre>\n\nA opção -f ou force diz ao rm para remover todos os arquivos, estejam eles protegidos contra gravação ou não, sem solicitar a confirmação do usuário (desde que você tenha as permissões apropriadas).\n\n<pre>$ rm -i arquivo</pre>\n\nAdicionar a flag -i como muitos dos outros comandos, lhe dará um aviso se você realmente deseja remover os arquivos ou diretórios. \n\n<pre>$ rm -r diretório</pre>\n\nVocê não pode simplesmente usar rm em um diretório por padrão, você precisará adicionar a flag -r (recursivo) para remover todos os arquivos e subdiretórios que ele possa ter.\n\nVocê pode remover um diretório com o comando rmdir.\n\n<pre>$ rmdir diretório</pre>",
          "quizAnswer": "",
          "quizQuestion": "Como você remove um arquivo chamado myfile?",
          "slug": "removermcommand",
          "title": "rm (Remover)"
        },
        {
          "exercise": "<ol>\n<li>Encontre um arquivo a partir do diretório raiz que tenha a palavra net nele.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Com todos esses arquivos que temos no sistema, pode ficar um pouco agitado tentar encontrar um específico. Bem, há um comando que podemos usar para isso, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nCom o find, você terá que especificar o diretório que estará pesquisando, o que está procurando, neste caso estamos tentando encontrar um arquivo pelo nome de puppies.jpg. \n\nVocê pode especificar que tipo de arquivo está tentando encontrar. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nVocê pode ver que defini o tipo de arquivo que estou tentando encontrar como (d) para diretório e ainda estou pesquisando pelo nome de MyFolder. \n\nUma coisa legal a se notar é que o find não para no diretório que está pesquisando, ele vai olhar dentro de quaisquer subdiretórios que esse diretório possa ter também.",
          "quizAnswer": "-name",
          "quizQuestion": "Que opção devo especificar para o find se eu quiser pesquisar por nome?",
          "slug": "comandofind",
          "title": "find"
        },
        {
          "exercise": "Execute o comando help nos comandos echo, logout e pwd.",
          "id": 15,
          "lessonContent": "O Linux possui algumas ótimas ferramentas integradas para ajudá-lo a aprender como usar um comando ou verificar quais flags estão disponíveis para um comando. Uma dessas ferramentas é o comando help, que fornece ajuda para outros comandos bash (echo, logout, pwd, etc).\n\n<pre>$ help echo</pre>\n\nIsso lhe dará uma descrição e as opções que você pode usar ao executar o comando echo. Para outros programas executáveis, é comum ter uma opção chamada --help ou algo semelhante. \n\n<pre>$ echo --help</pre>\n\n Nem todos os desenvolvedores que distribuem executáveis seguirão esse padrão, mas provavelmente é a melhor opção para encontrar ajuda em um programa.",
          "quizAnswer": "help",
          "quizQuestion": "Como obter ajuda rápida na linha de comando para comandos bash integrados?",
          "slug": "comandoajuda",
          "title": "ajuda"
        },
        {
          "exercise": "Execute o comando man no comando ls.",
          "id": 16,
          "lessonContent": "Gee, eu gostaria que alguns desses programas tivessem um manual para que pudéssemos ver mais informações sobre eles. Bem, por sorte eles têm! Chamadas de páginas man, você pode ver os manuais de um comando com o comando man. \n\n<pre>$ man ls</pre>\n\nAs páginas man são manuais que, por padrão, são incorporados na maioria dos sistemas operacionais Linux. Eles fornecem documentação sobre comandos e outros aspectos do sistema. \n\nExperimente em alguns comandos para obter mais informações sobre eles.",
          "quizAnswer": "man",
          "quizQuestion": "Como você vê os manuais de um comando?",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Execute o comando whatis no comando less.",
          "id": 17,
          "lessonContent": "Ufa, aprendemos bastante comandos até agora, se você estiver em dúvida sobre o que um comando faz, você pode usar o comando whatis. O comando whatis fornece uma breve descrição dos programas de linha de comando. \n\n<pre>$ whatis cat</pre>\n\nA descrição é obtida da página do manual de cada comando. Se você executasse whatis cat, veria que há um pequeno texto com uma breve descrição.",
          "quizAnswer": "whatis",
          "quizQuestion": "Que comando você pode usar para ver uma pequena descrição de um comando?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "Crie alguns aliases e depois remova-os.",
          "id": 18,
          "lessonContent": "Às vezes, digitar comandos pode se tornar realmente repetitivo, ou se você precisar digitar um comando longo várias vezes, é melhor ter um alias que você possa usar para isso. Para criar um alias para um comando, basta especificar um nome de alias e defini-lo como o comando. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nAgora, em vez de digitar ls -la, você pode digitar foobar e ele executará esse comando, coisas muito legais. Lembre-se de que esse comando não salvará seu alias após a reinicialização, então você precisará adicionar um alias permanente em:\n\n<pre>~/.bashrc</pre>\n\nou arquivos semelhantes se desejar que ele persista após a reinicialização.\n\nVocê pode remover aliases com o comando unalias: \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "Qual comando é usado para criar um alias?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Sair do shell e ver o que acontece. Certifique-se de que não precisa fazer mais nenhum trabalho nesse shell.",
          "id": 19,
          "lessonContent": "Bem, você fez um bom trabalho passando pelos conceitos básicos. Apenas arranhamos a superfície, agora que você aprendeu a engatinhar, nos próximos conjuntos de cursos, vou ensinar como andar. \n\nPor enquanto, você pode se dar tapinhas nas costas e fazer uma pausa. Para sair do shell, você pode usar o comando exit\n\n<pre>$ exit</pre>\n\nOu o comando logout:\n\n<pre>$ logout</pre>\n\nOu se estiver trabalhando em uma GUI de terminal, você pode simplesmente fechar o terminal, nos vemos no próximo curso!",
          "quizAnswer": "exit",
          "quizQuestion": "Como você pode sair do shell?",
          "slug": "exitcommand",
          "title": "sair"
        }
      ],
      "slug": "commandline",
      "title": "Linha de Comando"
    },
    {
      "description": "Aprenda manipulação básica de texto e navegação.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Tente alguns comandos: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Olá Mundo > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "Até agora, nos familiarizamos com muitos comandos e suas saídas e isso nos leva ao nosso próximo assunto E/S (entrada/saída). Vamos executar o seguinte comando e discutiremos como isso funciona. \n\n<pre>$ echo Olá Mundo > peanuts.txt</pre>\n\nO que acabou de acontecer? Bem, verifique o diretório onde você executou esse comando e eis que você deverá ver um arquivo chamado peanuts.txt, olhe dentro desse arquivo e você deverá ver o texto Olá Mundo. Muitas coisas aconteceram em um único comando, então vamos analisar. \n\nPrimeiro, vamos analisar a primeira parte: \n\n<pre>$ echo Olá Mundo</pre>\n\nSabemos que isso imprime Olá Mundo na tela, mas como? Os processos usam fluxos de E/S para receber entrada e retornar saída. Por padrão, o comando echo recebe a entrada (entrada padrão ou stdin) do teclado e retorna a saída (saída padrão ou stdout) para a tela. Por isso, quando você digita echo Olá Mundo no seu shell, você vê Olá Mundo na tela. No entanto, a redireção de E/S nos permite alterar esse comportamento padrão, oferecendo-nos maior flexibilidade de arquivo. \n\nVamos para a próxima parte do comando: \n\n<pre> > </pre>\n\nO > é um operador de redirecionamento que nos permite alterar para onde vai a saída padrão. Ele nos permite enviar a saída do echo Olá Mundo para um arquivo em vez da tela. Se o arquivo ainda não existir, ele será criado para nós. No entanto, se ele já existir, será sobrescrito (você pode adicionar uma flag de shell para evitar isso, dependendo do shell que estiver usando).\n\nE basicamente é assim que a redireção de stdout funciona!\n\nBem, digamos que eu não queira sobrescrever meu peanuts.txt, felizmente existe um operador de redirecionamento para isso também, >>: \n\n<pre>$ echo Olá Mundo >> peanuts.txt</pre>\n\nIsso irá anexar Olá Mundo ao final do arquivo peanuts.txt, se o arquivo ainda não existir, ele será criado para nós, assim como fez com o operador de redirecionamento >!",
          "quizAnswer": ">>",
          "quizQuestion": "Qual operador de redirecionamento você usa para anexar a saída a um arquivo?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Experimente alguns comandos:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "Na nossa lição anterior, aprendemos que temos diferentes fluxos de saída stdout que podemos usar, como um arquivo ou a tela. Bem, também existem diferentes fluxos de entrada padrão (stdin) que podemos usar. Sabemos que temos stdin de dispositivos como o teclado, mas também podemos usar arquivos, saída de outros processos e o terminal, vamos ver um exemplo. \n\nVamos usar o arquivo peanuts.txt na lição anterior para este exemplo, lembra que ele continha o texto Olá Mundo. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nAssim como tínhamos <b>&gt;</b> para redirecionamento de stdout, podemos usar <b>&lt;</b> para redirecionamento de stdin. \n\nNormalmente no comando cat, você envia um arquivo para ele e esse arquivo se torna o stdin, neste caso, redirecionamos peanuts.txt para ser nosso stdin. Em seguida, a saída de cat peanuts.txt, que seria Olá Mundo, é redirecionada para outro arquivo chamado banana.txt.",
          "quizAnswer": "<",
          "quizQuestion": "Qual redirecionador você usa para redirecionar o stdin?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Standard In)"
        },
        {
          "exercise": "O que o seguinte comando está fazendo? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Vamos tentar algo um pouco diferente agora, vamos tentar listar o conteúdo de um diretório que não existe no seu sistema e redirecionar a saída para o arquivo peanuts.txt novamente.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nO que você deve ver é: \n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nAgora você provavelmente está pensando, essa mensagem não deveria ter sido enviada para o arquivo? Na verdade, há outro fluxo de E/S em jogo aqui chamado erro padrão (stderr). Por padrão, stderr envia sua saída também para a tela, é um fluxo completamente diferente do stdout. Portanto, você precisará redirecionar sua saída de forma diferente. \n\nInfelizmente, o redirecionador não é tão simples quanto usar <b>&lt;</b> ou <b>&gt;</b>, mas é bem próximo. Teremos que usar descritores de arquivo. Um descritor de arquivo é um número não negativo usado para acessar um arquivo ou fluxo. Vamos aprofundar sobre isso mais tarde, mas por enquanto saiba que o descritor de arquivo para stdin, stdout e stderr é 0, 1 e 2, respectivamente. \n\nAgora, se quisermos redirecionar nosso stderr para o arquivo, podemos fazer isso: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nVocê deve ver apenas as mensagens de stderr em peanuts.txt. \n\nE se eu quisesse ver tanto stderr quanto stdout no arquivo peanuts.txt? É possível fazer isso também com descritores de arquivo: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nIsso envia os resultados de ls /fake/directory para o arquivo peanuts.txt e depois redireciona stderr para stdout via 2>&1. A ordem das operações aqui importa, 2>&1 envia stderr para onde stdout está apontando. Neste caso, stdout está apontando para um arquivo, então 2>&1 também envia stderr para um arquivo. Portanto, se você abrir o arquivo peanuts.txt, deverá ver tanto stderr quanto stdout. No nosso caso, o comando acima só produz stderr.\n\nHá uma maneira mais curta de redirecionar tanto stdout quanto stderr para um arquivo:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nE se eu não quiser nada disso e quiser me livrar completamente das mensagens de stderr? Bem, você também pode redirecionar a saída para um arquivo especial chamado /dev/null e ele descartará qualquer entrada.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "Qual é o redirecionador para stderr?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Erro Padrão)"
        },
        {
          "exercise": "Experimente os seguintes comandos: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Vamos falar um pouco sobre encanamento agora, na verdade não, mas quase. Vamos tentar um comando: \n\n<pre>$ ls -la /etc</pre>\n\nVocê deve ver uma lista muito longa de itens, na verdade é um pouco difícil de ler. Em vez de redirecionar essa saída para um arquivo, não seria legal se pudéssemos ver a saída em outro comando como less? Bem, podemos! \n\n<pre>$ ls -la /etc | less </pre>\n\nO operador de pipe |, representado por uma barra vertical, nos permite obter o stdout de um comando e torná-lo o stdin de outro processo. Neste caso, pegamos o stdout do ls -la /etc e então <i>pipamos</i> para o comando less. O comando de pipe é extremamente útil e continuaremos a usá-lo para toda a eternidade. \n\nE se eu quisesse escrever a saída do meu comando para dois fluxos diferentes? Isso é possível com o comando tee: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nVocê deve ver a saída do ls na sua tela e se abrir o arquivo peanuts.txt, você deve ver as mesmas informações!",
          "quizAnswer": "|",
          "quizQuestion": "Qual tecla representa o operador de pipe?",
          "slug": "pipeteeredirect",
          "title": "tubo e tee"
        },
        {
          "exercise": "O que o seguinte comando imprime? Por quê?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Execute o seguinte comando: \n\n<pre>$ echo $HOME</pre>\n\nVocê deverá ver o caminho para o seu diretório home, o meu se parece com /home/pete. \n\nE quanto a este comando? \n\n<pre>$ echo $USER </pre>\n\nVocê deverá ver o seu nome de usuário!\n\nDe onde vem essa informação? Ela vem das suas variáveis de ambiente. Você pode visualizá-las digitando\n\n<pre>$ env </pre>\n\nIsso exibe muitas informações sobre as variáveis de ambiente que você tem configuradas atualmente. Essas variáveis contêm informações úteis que o shell e outros processos podem utilizar.\n\nAqui está um exemplo breve:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nUma variável particularmente importante é a Variável PATH. Você pode acessar essas variáveis colocando um $ antes do nome da variável, assim:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nIsso retorna uma lista de caminhos separados por dois pontos que o seu sistema pesquisa quando executa um comando. Digamos que você baixe e instale manualmente um pacote da internet e o coloque em um diretório não padrão e queira executar esse comando, você digita $ coolcommand e o prompt diz comando não encontrado. Bem, isso é estranho, você está olhando para o binário em uma pasta e sabe que ele existe. O que está acontecendo é que a variável $PATH não verifica esse diretório para este binário, então está gerando um erro. \n\nDigamos que você tenha toneladas de binários que deseja executar a partir desse diretório, você pode simplesmente modificar a variável PATH para incluir esse diretório na sua variável de ambiente PATH.",
          "quizAnswer": "env",
          "quizQuestion": "Como você visualiza suas variáveis de ambiente?",
          "slug": "envenvironment",
          "title": "env (Ambiente)"
        },
        {
          "exercise": "O que o seguinte comando faz? Por quê?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Vamos aprender alguns comandos úteis que você pode usar para processar texto. Antes de começarmos, vamos criar um arquivo com o qual iremos trabalhar. Copie e cole o seguinte comando, uma vez feito isso, adicione uma TAB entre lazy e dog (pressione Ctrl-v + TAB).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nO primeiro comando que aprenderemos é o comando cut. Ele extrai partes do texto de um arquivo.\n\nPara extrair conteúdos por uma lista de caracteres:\n\n<pre>$ cut -c 5 sample.txt</pre>\n\nIsso exibe o 5º caractere em cada linha do arquivo. Neste caso, é \"q\", observe que o espaço também conta como um caractere.\n\nPara extrair o conteúdo por um campo, precisaremos fazer uma pequena modificação:\n\n<pre>$ cut -f 2 sample.txt</pre>\n\nA flag -f ou campo corta o texto com base nos campos, por padrão, ele usa TABs como delimitadores, então tudo separado por um TAB é considerado um campo. Você deve ver \"dog\" como saída.\n\nVocê pode combinar a flag de campo com a flag de delimitador para extrair o conteúdo por um delimitador personalizado:\n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nIsso mudará o delimitador TAB para um delimitador \";\" e como estamos cortando o primeiro campo, o resultado deve ser \"The quick brown\".",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "Qual comando você usaria para obter o primeiro caractere de cada linha em um arquivo?",
          "slug": "cutcommand",
          "title": "cut"
        },
        {
          "exercise": "Tente colar vários arquivos juntos, o que acontece?",
          "id": 7,
          "lessonContent": "O comando colar é semelhante ao comando cat, ele mescla linhas em um arquivo. Vamos criar um novo arquivo com o seguinte conteúdo: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nVamos combinar todas essas linhas em uma linha: \n\n<pre>$ colar -s sample2.txt</pre>\n\nO delimitador padrão para o colar é TAB, então agora há uma linha com TABs separando cada palavra.\n\nVamos alterar este delimitador (-d) para algo um pouco mais legível: \n\n<pre>$ colar -d ' ' -s sample2.txt</pre>\n\nAgora tudo deve estar em uma linha delimitada por espaços.",
          "quizAnswer": "-s",
          "quizQuestion": "Que flag você usa com colar para colocar tudo em uma linha?",
          "slug": "comandocolar",
          "title": "colar"
        },
        {
          "exercise": "O que o seguinte comando faz e por quê? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Vamos dizer que temos um arquivo muito longo, na verdade temos muitos para escolher, vá em frente e cat /var/log/syslog. Você deve ver páginas e mais páginas de texto. E se eu quisesse ver apenas as primeiras linhas deste arquivo de texto? Bem, podemos fazer isso com o comando head, por padrão o comando head mostrará as primeiras 10 linhas de um arquivo.\n\n<pre>$ head /var/log/syslog</pre>\n\nVocê também pode modificar a contagem de linhas para o que você escolher, digamos que eu queira ver as primeiras 15 linhas em vez disso. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nA bandeira -n significa número de linhas.",
          "quizAnswer": "-n",
          "quizQuestion": "Que bandeira você usaria para alterar o número de linhas que deseja visualizar para o comando head?",
          "slug": "comandohead",
          "title": "cabeça"
        },
        {
          "exercise": "Olhe a página de manual do tail e leia alguns dos outros comandos que não discutimos. \n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Similar ao comando head, o comando tail permite ver as últimas 10 linhas de um arquivo por padrão.\n\n<pre>$ tail /var/log/syslog</pre>\n\nJuntamente com o head, você pode alterar o número de linhas que deseja ver.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nOutra ótima opção que você pode usar é a flag -f (seguir), isso seguirá o arquivo conforme ele cresce. Experimente e veja o que acontece. \n\n<pre>$ tail -f /var/log/syslog</pre> \n\nSeu arquivo syslog estará continuamente mudando enquanto você interage com seu sistema e usando tail -f você pode ver tudo o que está sendo adicionado a esse arquivo.",
          "quizAnswer": "-f",
          "quizQuestion": "Qual é a flag usada para seguir um arquivo no tail?",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "O que acontece se você digitar apenas expandir sem entrada de arquivo?",
          "id": 10,
          "lessonContent": "Em nossa lição sobre o comando cut, tínhamos nosso arquivo sample.txt que continha uma guia. Normalmente, as guias geralmente mostram uma diferença perceptível, mas alguns arquivos de texto não mostram isso de forma suficiente. Ter guias em um arquivo de texto pode não ser o espaçamento desejado. Para alterar suas guias para espaços, use o comando expandir. \n\n<pre>$ expandir sample.txt</pre>\n\nO comando acima imprimirá a saída com cada guia convertida em um grupo de espaços. Para salvar esta saída em um arquivo, use a redireção de saída como abaixo. \n\n<pre>$ expandir sample.txt > result.txt</pre>\n\nAo contrário do expandir, podemos converter de volta cada grupo de espaços para uma guia com o comando desexpandir: \n\n<pre>$ desexpandir -a result.txt</pre>",
          "quizAnswer": "expandir",
          "quizQuestion": "Qual comando é usado para converter guias em espaços?",
          "slug": "comandoexpandirdesexpandir",
          "title": "expandir e desexpandir"
        },
        {
          "exercise": "Unir dois arquivos com número diferente de linhas em cada arquivo, o que acontece?",
          "id": 11,
          "lessonContent": "O comando join permite unir vários arquivos por um campo comum: \n\nDigamos que eu tenha dois arquivos que eu queira unir:\n<pre>file1.txt\n1 João\n2 Joana\n3 Maria\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 João Doe\n2 Joana Doe\n3 Maria Sue\n</pre>\n\nVeja como os arquivos foram unidos? Eles são unidos pelo primeiro campo por padrão e os campos precisam ser idênticos, se não forem, você pode ordená-los, então, neste caso, os arquivos são unidos via 1, 2, 3. \n\nComo unir os seguintes arquivos? \n\n<pre>file1.txt\nJoão 1\nJoana 2\nMaria 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nPara unir este arquivo, você precisa especificar quais campos está unindo, neste caso, queremos o campo 2 do file1.txt e o campo 1 do file2.txt, então o comando ficaria assim:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 João Doe\n2 Joana Doe\n3 Maria Sue\n</pre>\n\n-1 refere-se a file1.txt e -2 refere-se a file2.txt. Bastante útil. Você também pode dividir um arquivo em diferentes arquivos com o comando split: \n\n<pre>$ split algumArquivo</pre>\n\nIsso irá dividi-lo em diferentes arquivos, por padrão, eles serão divididos quando atingirem o limite de 1000 linhas. Os arquivos são nomeados x** por padrão.",
          "quizAnswer": "join gato cachorro vaca",
          "quizQuestion": "Qual comando você usaria para unir arquivos chamados gato cachorro vaca?",
          "slug": "comando-unir-dividir",
          "title": "unir e dividir"
        },
        {
          "exercise": "O verdadeiro poder do sort vem de sua capacidade de ser combinado com outros comandos, tente o seguinte comando e veja o que acontece?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "O comando sort é útil para classificar linhas.\n\n<pre>\narquivo1.txt\ncao\nvaca\ngato\nelefante\npassaro\n\n$ sort arquivo1.txt\npassaro\ngato\nvaca\ncao\nelefante\n</pre>\n\nVocê também pode fazer uma classificação reversa: \n\n<pre>$ sort -r arquivo1.txt\nelefante\ncao\nvaca\ngato\npassaro\n</pre>\n\nE também classificar por valor numérico: \n\n<pre>$ sort -n arquivo1.txt\npassaro\ngato\nvaca\nelefante\ncao\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Que flag você usa para fazer uma classificação reversa?",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "Tente o seguinte comando, o que acontece? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "O comando tr (translate) permite que você traduza um conjunto de caracteres em outro conjunto de caracteres. Vamos tentar um exemplo de tradução de todos os caracteres minúsculos para caracteres maiúsculos. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nComo você pode ver, fizemos os intervalos de a-z em A-Z e todo texto que digitamos em minúsculas é convertido em maiúsculas.",
          "quizAnswer": "tr",
          "quizQuestion": "Qual comando é usado para traduzir caracteres?",
          "slug": "trtranslatecommand",
          "title": "tr (Traduzir)"
        },
        {
          "exercise": "Que resultado você obteria se tentasse uniq -uc?",
          "id": 14,
          "lessonContent": "O comando uniq (único) é outra ferramenta útil para analisar texto.\n\nDigamos que você tenha um arquivo com muitas duplicatas:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nE você queria remover as duplicatas, bem, você pode usar o comando uniq:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nVamos obter a contagem de quantas ocorrências de uma linha:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nVamos apenas obter valores únicos:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nVamos apenas obter valores duplicados:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Nota</b>: uniq não detecta linhas duplicadas a menos que sejam adjacentes. Por exemplo:\n\nDigamos que você tenha um arquivo com duplicatas que não são adjacentes:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nO resultado retornado por uniq conterá todas as entradas, ao contrário do primeiro exemplo.\n\nPara superar essa limitação do uniq, podemos usar sort em combinação com uniq:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "Que comando você usaria para remover duplicatas em um arquivo?",
          "slug": "uniquniquecommand",
          "title": "uniq (Único)"
        },
        {
          "exercise": "Como você obteria a contagem total de linhas usando o arquivo nl sem precisar procurar por toda a saída? Dica: Use alguns dos outros comandos que você aprendeu neste curso.",
          "id": 15,
          "lessonContent": "O comando wc (contagem de palavras) mostra a contagem total de palavras em um arquivo. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nEle exibe o número de linhas, número de palavras e número de bytes, respectivamente.\n\nPara ver apenas a contagem de um campo específico, use -l, -w ou -c, respectivamente. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nOutro comando que você pode usar para verificar a contagem de linhas em um arquivo é o comando nl (número de linhas). \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "Que comando você usaria para obter o número total de palavras em um arquivo e apenas as palavras?",
          "slug": "nlwccommand",
          "title": "wc and nl"
        },
        {
          "exercise": "Você pode ter ouvido falar de egrep ou fgrep, essas chamadas de grep estão obsoletas e foram substituídas por grep -E e grep -F. Leia a página de manual do grep para aprender mais.",
          "id": 16,
          "lessonContent": "O comando grep é possivelmente o comando de processamento de texto mais comum que você usará. Ele permite que você pesquise arquivos em busca de caracteres que correspondam a um determinado padrão. E se você quisesse saber se um arquivo existe em um determinado diretório ou se quisesse ver se uma string foi encontrada em um arquivo? Certamente você não iria vasculhar cada linha de texto, você usaria o grep!\n\nVamos usar nosso arquivo sample.txt como exemplo: \n\n<pre>$ grep raposa sample.txt</pre>\n\nVocê deve ver que o grep encontrou a palavra raposa no arquivo sample.txt. \n\nVocê também pode pesquisar padrões que não diferenciam maiúsculas de minúsculas com a flag -i: \n\n<pre>$ grep -i algumPadrao algumArquivo</pre>\n\nPara tornar o grep ainda mais flexível, você pode combiná-lo com outros comandos com |.\n\n<pre>$ env | grep -i Usuário</pre>\n\nComo você pode ver, o grep é bastante versátil. Você até pode usar expressões regulares em seu padrão: \n\n<pre>$ ls /algumdiretorio | grep '.txt$'</pre>\n\nDeve retornar todos os arquivos que terminam com .txt em algumdiretorio.",
          "quizAnswer": "grep",
          "quizQuestion": "Qual comando você usa para encontrar um determinado padrão?",
          "slug": "comandogrep",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Navegue pelo texto como um macaco-aranha do Linux com vim e emacs.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Tente combinar expressões regulares com grep e pesquisar em alguns arquivos.\n\n<pre>\ngrep [expressão regular aqui] [arquivo]",
          "id": 1,
          "lessonContent": "Expressões regulares são uma ferramenta poderosa para fazer seleção baseada em padrões. Ela usa notações especiais semelhantes às que já encontramos, como o caractere curinga *. \n\nVamos passar por algumas das expressões regulares mais comuns, essas são quase universais em qualquer linguagem de programação.\n\nVamos usar esta frase como nossa string de teste:\n<pre>\nsally sells seashells \npela praia\n</pre>\n\n<b>1. Início de uma linha com ^</b>\n\n<pre>\n<b>^</b>pela\ncorresponderia à linha \"pela praia\"\n</pre>\n\n<b>2. Fim de uma linha com $</b>\n\n<pre>\npraia<b>$</b>\ncorresponderia à linha \"pela praia\"\n</pre>\n\n<b>3. Correspondência de qualquer caractere único com .</b>\n\n<pre>\nb<b>.</b>\ncorresponderia a by\n</pre>\n\n<b>4. Notação de colchetes com [] e ()</b>\n\nIsso pode ser um pouco complicado, colchetes nos permitem especificar caracteres encontrados dentro dos colchetes. \n\n<pre>\nd<b>[iou]</b>g\ncorresponderia a: dig, dog, dug\n</pre>\n\nA tag de âncora anterior ^ quando usada em um colchete significa qualquer coisa exceto os caracteres dentro do colchete. \n\n<pre>\nd<b>[^i]</b>g\ncorresponderia a: dog e dug, mas não a dig\n</pre>\n\nOs colchetes também podem usar intervalos para aumentar a quantidade de caracteres que você deseja usar. \n\n<pre>\nd<b>[a-c]</b>g\nirá corresponder a padrões como dag, dbg e dcg\n</pre>\n\nMas cuidado, pois os colchetes são sensíveis a maiúsculas e minúsculas:\n\n<pre>\nd<b>[A-C]</b>g\nirá corresponder a dAg, dBg e dCg, mas não a dag, dbg e dcg\n</pre>\n\nE essas são algumas expressões regulares básicas.",
          "quizAnswer": ".",
          "quizQuestion": "Que expressão regular você usaria para corresponder a um único caractere?",
          "slug": "expressoesregularesregex",
          "title": "expressões regulares (Regular Expressions)"
        },
        {
          "exercise": "Faça um pequeno tour pelo vim e emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Se você reunir alguns usuários fervorosos do Linux em uma sala e perguntar qual é o melhor editor de texto a ser usado, você ouvirá um debate interminável sobre a divindade do vim ou emacs. Nem tente mencionar o uso de um editor GUI se valoriza sua vida. \n\nVim e emacs são editores de texto populares que são instalados por padrão na maioria das distribuições Linux e ambos têm seus prós e contras. Se você deseja se movimentar pelo seu sistema como um ninja, precisará escolher um desses editores de texto para usar. Eles são essencialmente editores de código, processadores de documentos de texto e basicamente tudo em um.",
          "quizAnswer": "",
          "quizQuestion": "Sem perguntas, continue!",
          "slug": "editorestextovimoremacs",
          "title": "Editores de Texto"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Vim significa vi (Melhorado), assim como seu nome sugere, é uma versão aprimorada do comando do editor de texto vi.\n\nÉ super leve, abrir e editar um arquivo com o vim é rápido e fácil. Também está quase sempre disponível, se você inicializar uma distribuição aleatória do Linux, as chances são de que o vim esteja instalado por padrão. \n\nPara iniciar o vim, basta digitar: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "Nenhuma pergunta, continue!",
          "slug": "editor-de-texto-vim",
          "title": "Vim (Vi Melhorado)"
        },
        {
          "exercise": "Brinque com a tecla de busca, abra um arquivo de texto no vim com: vim [arquivo de texto] e comece a buscar!",
          "id": 4,
          "lessonContent": "Para buscar uma expressão, basta digitar a tecla / e em seguida o resultado da sua busca enquanto estiver em uma sessão do vim. Depois de pressionar Enter, você pode pressionar \"n\" para avançar ou \"N\" para retroceder nos resultados da busca.\n\n<pre>\nMeu arquivo bonito é muito bonito.\n\n/bonito\n\nirá encontrar as palavras bonitas no arquivo de texto.\n</pre>\n\n\nO comando de busca ? irá procurar no arquivo de texto para trás, então no exemplo anterior, a última palavra bonita apareceria primeiro. \n<pre>\nMeu arquivo bonito é muito bonito.\n\n?bonito\n\nirá encontrar as palavras bonitas no arquivo de texto.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Qual tecla é usada para buscar no vim?",
          "slug": "padroesdebuscavim",
          "title": "Padrões de Busca no Vim"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Agora você pode notar que o mouse não é usado aqui. Para navegar em um documento de texto no vim, use as seguintes teclas: \n\n<ul>\n<li>h ou a seta para a esquerda - irá movê-lo para a esquerda um caractere</li>\n<li>k ou a seta para cima - irá movê-lo para cima uma linha</li>\n<li>j ou a seta para baixo - irá movê-lo para baixo uma linha</li>\n<li>l ou a seta para a direita - irá movê-lo para a direita um caractere</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "Que letra é usada para mover para baixo?",
          "slug": "navegacaonovim",
          "title": "Navegação no Vim"
        },
        {
          "exercise": "Brinque com a entrada e saída do modo de inserção.",
          "id": 6,
          "lessonContent": "<p>Agora você pode ter percebido que se tentasse digitar algo, não seria capaz. Isso ocorre porque você está no modo de comando. Isso pode ficar bastante confuso, especialmente se você só quer abrir um arquivo e inserir texto. O modo de comando é usado quando você digita comandos como h, j, k, l, etc. Para inserir texto, você precisará primeiro entrar no modo de inserção.</p><p></p><ul><br><li>i - inserir texto antes do cursor</li><br><li>O - inserir texto na linha anterior</li><br><li>o - inserir texto na linha seguinte</li><br><li>a - anexar texto após o cursor</li><br><li>A - anexar texto no final da linha</li><br></ul><p></p><p>Observe como quando você digita qualquer um desses modos de inserção, você verá que o vim entrou no modo de inserção na parte inferior do terminal. Para sair do modo de inserção e voltar ao modo de comando, basta pressionar a tecla Esc.</p>",
          "quizAnswer": "i",
          "quizQuestion": "Qual tecla é usada para inserir texto antes do cursor?",
          "slug": "viminserindoanexandotexto",
          "title": "Vim Adicionando Texto"
        },
        {
          "exercise": "Eu sei que esta lição adicionou algumas coisas estranhas, abra um editor de texto e brinque com elas.",
          "id": 7,
          "lessonContent": "Agora que temos algumas linhas escritas, vamos editá-las um pouco mais e remover algumas coisas inúteis.<br><p></p><ul><br><li>x - usado para cortar o texto selecionado, também usado para excluir caracteres</li><br><li>dd - usado para excluir a linha atual</li><br><li>y - copiar o que estiver selecionado</li><br><li>yy - copiar a linha atual</li><br><li>p - colar o texto copiado antes do cursor</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "Qual caractere é usado para excluir uma linha inteira?",
          "slug": "vimediting",
          "title": "Edição no Vim"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 8,
          "lessonContent": "Agora que você fez suas edições, é hora de realmente salvar e sair do vim: \n\n<ul>\n<li>:w - escreve ou salva o arquivo</li>\n<li>:q - sai do vim</li>\n<li>:wq - escreve e depois sai</li>\n<li>:q! - sai do vim sem salvar o arquivo</li>\n<li>ZZ - equivalente a :wq, mas um caractere mais rápido</li>\n\n<li>u - desfaz sua última ação</li>\n<li>Ctrl-r - refaz sua última ação</li>\n</ul>\n\nVocê pode não achar o ZZ necessário, mas eventualmente verá que seus dedos podem tender a preferir isso em vez de :wq.\n\nUfa, foi muita informação sobre o Vim. Agora que você conhece alguns comandos básicos e navegação, pode começar a editar alguns arquivos de texto. Existem muitas outras opções que você pode usar no vim para aumentar sua capacidade de dominar este editor de texto, vá para o guia online do Vim para dar uma olhada.",
          "quizAnswer": ":q!",
          "quizQuestion": "Como sair do vim sem salvar?",
          "slug": "salvandoesaindodovim",
          "title": "Salvando e Saindo do Vim"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 9,
          "lessonContent": "Emacs é para usuários que desejam um editor de texto extremamente poderoso, o que pode ser um eufemismo, pois essencialmente você vive no emacs. Você pode fazer toda a edição de código, manipulação de arquivos, etc., tudo dentro do emacs. É um pouco mais lento para carregar e a curva de aprendizado é um pouco mais íngreme do que o vim, mas se você deseja um editor poderoso que seja extremamente extensível, este é o ideal para você. Quando digo extensível, quero dizer que você pode escrever scripts para o emacs que estendem sua funcionalidade.\n\nPara iniciar o emacs, basta usar:\n\n<pre>emacs</pre>\n\nVocê deve ser recebido com o buffer de boas-vindas padrão.\n\nBuffers no emacs é onde seu texto reside. Portanto, se você abrir um arquivo, um buffer é usado para armazenar o conteúdo desse arquivo. Você pode ter vários buffers abertos ao mesmo tempo e pode alternar facilmente entre buffers.",
          "quizAnswer": "",
          "quizQuestion": "Nenhuma pergunta, siga em frente!",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Brinque com a abertura de arquivos e salvamento de arquivos.",
          "id": 10,
          "lessonContent": "Em muita (se não em todas) a documentação do Emacs, você verá a sintaxe C-[letra]. Isso significa apenas pressionar a tecla Ctrl-letra, mas para fins de abreviação, chamaremos o Ctrl de C. Se você vir a sintaxe como M-[letra], isso significa usar a tecla Meta, mais comumente a tecla Alt.\n\n<b>Salvando arquivos</b>\n\n<pre>\nC-x C-s - Salvar um arquivo\nC-x C-w - Salvar arquivo como\nC-x s - Salvar todos\n</pre>\n\nAs opções de salvar arquivos irão perguntar se você deseja salvar cada arquivo.\n\n<b>Abrindo um arquivo</b>\n\n<pre>\nC-x C-f\n</pre>\n\nIsso irá solicitar que você digite um nome de arquivo para abrir. Se você não tiver um arquivo que já exista, ele criará um novo arquivo. Você também pode carregar um diretório.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "Qual comando é usado para abrir um arquivo?",
          "slug": "emacsmanipulatefiles",
          "title": "Emacs Manipular Arquivos"
        },
        {
          "exercise": "Brinque com os buffers.",
          "id": 11,
          "lessonContent": "Para mover-se entre buffers (ou arquivos que você está visitando), use os seguintes comandos:\n\n<b>Trocar buffers</b>\n\n<pre>\nC-x b - trocar buffer\nC-x seta para a direita - ciclo para a direita pelos buffers\nC-x seta para a esquerda - ciclo para a esquerda pelos buffers\n</pre>\n\n<b>Fechar o buffer</b>\n\n<pre>C-x k</pre>\n\n<b>Dividir o buffer atual</b>\n\n<pre>C-x 2</pre>\n\nIsso permite ver múltiplos buffers em uma tela. Para mover-se entre esses buffers, use: C-x o\n\n<b>Definir um único buffer como tela atual</b>\n\n<pre>C-x 1</pre>\n\nSe você já usou um multiplexador de terminal como screen e tmux, os comandos de buffer serão muito familiares.",
          "quizAnswer": "C-x k",
          "quizQuestion": "Como você mata um buffer?",
          "slug": "navegacaodebuffernoemacs",
          "title": "Navegação de Buffer no Emacs"
        },
        {
          "exercise": "Brinque com a navegação de texto.",
          "id": 12,
          "lessonContent": "<b>Navegação de Texto</b>\n\n<pre>\nC-seta para cima : mover para cima um parágrafo\nC-seta para baixo: mover para baixo um parágrafo\nC-seta para a esquerda: mover uma palavra para a esquerda\nC-seta para a direita: mover uma palavra para a direita\nM-> : mover para o final do buffer\n</pre>\n\nCom a navegação de texto, seus botões de texto regulares funcionam como deveriam, início, fim, página para cima, página para baixo e as setas, etc.\n\n<b>Recortar e Colar</b>\n\nPara recortar (matar) ou colar (inserir) no Emacs, você precisará ser capaz de selecionar o texto primeiro. Para selecionar o texto, mova o cursor para onde deseja recortar ou colar e pressione <pre>tecla C-space</pre> e depois use as teclas de navegação para selecionar o texto desejado. Agora você pode recortar e colar da seguinte forma:\n\n<pre>\nC-w : recortar\nC-y : inserir\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "Como você move para o final do buffer?",
          "slug": "emacsediting",
          "title": "Edição no Emacs"
        },
        {
          "exercise": "Visite o site do Emacs para aprender mais comandos. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Para sair do emacs</b>\n\n<pre>C-x C-c</pre>\n\nSe você tiver buffers abertos, ele pedirá para salvar antes de sair do emacs.\n\n<b>Confuso?</b>\n\n<pre>C-h C-h : menu de ajuda</pre>\n\n<b>Desfazer</b>\n\n<pre>C-x u</pre>\n\nComo você pode ver, o Emacs tem mais partes móveis, então a curva de aprendizado é um pouco mais íngreme. Em troca, no entanto, você obtém um editor de texto muito poderoso.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "Como você acessa o menu de ajuda?",
          "slug": "emacsexitingandhelp",
          "title": "Saindo e Ajuda no Emacs"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Advanced Text-Fu"
    },
    {
      "description": "Saiba mais sobre funções e gestão de usuários.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Em qualquer sistema operacional tradicional, existem usuários e grupos. Eles existem exclusivamente para acesso e permissões. Ao executar um processo, ele será executado como o proprietário desse processo, seja Jane ou Bob. O acesso e a propriedade de arquivos também dependem de permissões. Você não gostaria que Jane visse os documentos de Bob e vice-versa. \n\nCada usuário tem seu próprio diretório pessoal onde seus arquivos específicos do usuário são armazenados, geralmente localizado em /home/nome_de_usuário, mas pode variar em diferentes distribuições. \n\nO sistema usa identificadores de usuário (UID) para gerenciar usuários, os nomes de usuário são a maneira amigável de associar usuários à identificação, mas o sistema identifica os usuários pelo seu UID. O sistema também usa grupos para gerenciar permissões, grupos são apenas conjuntos de usuários com permissões definidas por esse grupo, eles são identificados pelo sistema com seu identificador de grupo (GID).\n\nNo Linux, você terá usuários além dos humanos normais que usam o sistema. Às vezes, esses usuários são daemons do sistema que executam continuamente processos para manter o sistema funcionando. Um dos usuários mais importantes é o root ou superusuário, o root é o usuário mais poderoso no sistema, o root pode acessar qualquer arquivo e iniciar e encerrar qualquer processo. Por esse motivo, pode ser perigoso operar sempre como root, você poderia potencialmente remover arquivos críticos do sistema. Felizmente, se for necessário o acesso como root e um usuário tiver acesso como root, ele pode executar um comando como root com o comando sudo. O comando sudo (superusuário faça) é usado para executar um comando com acesso de root, iremos aprofundar mais sobre como um usuário recebe acesso de root em uma lição posterior.\n\nVá em frente e tente visualizar um arquivo protegido como /etc/shadow:\n\n<pre>$ cat /etc/shadow</pre>\n\nObserve como você recebe um erro de permissão negada, veja as permissões com: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nAinda não passamos pelas permissões, mas o que está acontecendo aqui é que root é o proprietário do arquivo e você precisará de acesso como root ou fazer parte do grupo shadow para ler o conteúdo. Agora execute o comando com sudo:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nAgora você poderá ver o conteúdo do arquivo!",
          "quizAnswer": "sudo",
          "quizQuestion": "Qual comando você usa para executar como root?",
          "slug": "usuariosgrupos",
          "title": "Usuários e Grupos"
        },
        {
          "exercise": "Abra o arquivo /etc/sudoers e veja quais permissões de superusuário outros usuários na máquina têm.",
          "id": 2,
          "lessonContent": "Já vimos uma maneira de obter acesso de superusuário usando o comando sudo. Você também pode executar comandos como superusuário com o comando su. Este comando irá \"substituir usuários\" e abrir um shell root se nenhum nome de usuário for especificado. Você pode usar este comando para substituir para qualquer usuário, desde que saiba a senha. \n\n<pre>$ su</pre>\n\nExistem algumas desvantagens em usar este método: é muito mais fácil cometer um erro crítico executando tudo como root, você não terá registros dos comandos que usa para alterar as configurações do sistema, etc. Basicamente, se precisar executar comandos como superusuário, apenas use o sudo.\n\nAgora que você sabe quais comandos executar como superusuário, a questão é como saber quem tem acesso para fazer isso? O sistema não permite que qualquer pessoa execute comandos como superusuário, então como ele sabe? Existe um arquivo chamado arquivo /etc/sudoers, este arquivo lista os usuários que podem executar o sudo. Você pode editar este arquivo com o comando <b>visudo</b>.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "Qual arquivo mostra os usuários que têm acesso ao sudo?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Olhe para o seu arquivo /etc/passwd, dê uma olhada em alguns dos usuários e observe o acesso que eles têm.",
          "id": 3,
          "lessonContent": "Lembre-se de que os nomes de usuário não são realmente identificações para usuários. O sistema usa um ID de usuário (UID) para identificar um usuário. Para descobrir quais usuários estão mapeados para qual ID, olhe o arquivo /etc/passwd. \n\n<pre>$ cat /etc/passwd</pre>\n\nEste arquivo mostra uma lista de usuários e informações detalhadas sobre eles. Por exemplo, a primeira linha deste arquivo provavelmente se parece com isto:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nCada linha exibe informações do usuário para um usuário, comumente você verá o usuário root como a primeira linha. Existem muitos campos separados por dois pontos que fornecem informações adicionais sobre o usuário, vamos ver todos eles:\n\n<ol>\n<li>Nome de usuário</li>\n<li>Senha do usuário - a senha não é realmente armazenada neste arquivo, geralmente é armazenada no arquivo /etc/shadow. Discutiremos mais sobre o /etc/shadow na próxima lição, mas por enquanto, saiba que ele contém senhas de usuários criptografadas. Você pode ver muitos símbolos diferentes neste campo, se você ver um \"x\" isso significa que a senha está armazenada no arquivo /etc/shadow, um \"*\" significa que o usuário não tem acesso de login e se houver um campo em branco significa que o usuário não tem senha.</li>\n<li>O ID do usuário - como você pode ver, o root tem o UID 0</li>\n<li>O ID do grupo</li>\n<li>Campo GECOS - Isso é usado para geralmente deixar comentários sobre o usuário ou conta, como seu nome real ou número de telefone, é delimitado por vírgulas.</li>\n<li>Diretório home do usuário</li>\n<li>Shell do usuário - você provavelmente verá muitos usuários usando o bash como shell padrão</li>\n</ol>\n\nNormalmente em uma página de configuração de usuário, você esperaria ver apenas usuários humanos. No entanto, você notará que o /etc/passwd contém outros usuários. Lembre-se de que os usuários estão realmente no sistema apenas para executar processos com permissões diferentes. Às vezes queremos executar processos com permissões pré-determinadas. Por exemplo, o usuário daemon é usado para processos de daemon.\n\nTambém deve-se observar que você pode editar o arquivo /etc/passwd manualmente se quiser adicionar usuários e modificar informações com a ferramenta <b>vipw</b>, no entanto, coisas como essas são melhor deixadas para as ferramentas que discutiremos em uma lição posterior, como useradd e userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Se um usuário não tem acesso de login, como isso é indicado no /etc/passwd?",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Dê uma olhada no arquivo /etc/shadow",
          "id": 4,
          "lessonContent": "O arquivo /etc/shadow é usado para armazenar informações sobre autenticação de usuário. Requer permissões de leitura de superusuário. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nVocê notará que se parece muito com o conteúdo do /etc/passwd, no entanto, no campo de senha você verá uma senha criptografada. Os campos são separados por dois pontos da seguinte forma:\n\n<ol>\n<li>Nome de usuário</li>\n<li>Senha criptografada</li>\n<li>Data da última alteração de senha - expressa como o número de dias desde 1º de janeiro de 1970. Se for 0, significa que o usuário deve alterar sua senha na próxima vez que fizer login</li>\n<li>Idade mínima da senha - Dias que um usuário terá que esperar antes de poder alterar sua senha novamente</li>\n<li>Idade máxima da senha - Número máximo de dias antes que um usuário tenha que alterar sua senha</li>\n<li>Período de aviso de senha - Número de dias antes que uma senha expire</li>\n<li>Período de inatividade da senha - Número de dias após a expiração de uma senha para permitir login com a senha</li>\n<li>Data de expiração da conta - data em que o usuário não poderá fazer login</li>\n<li>Campo reservado para uso futuro</li>\n</ol>\n\nNa maioria das distribuições hoje, a autenticação do usuário não depende apenas do arquivo /etc/shadow, existem outros mecanismos em vigor, como o PAM (Pluggable Authentication Modules) que substituem a autenticação.",
          "quizAnswer": "",
          "quizQuestion": "Sem perguntas, continue!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Execute o comando <b>groups</b>. O que você vê?",
          "id": 5,
          "lessonContent": "Outro arquivo usado na gestão de usuários é o arquivo /etc/group. Este arquivo permite diferentes grupos com permissões diferentes. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nMuito semelhante ao campo /etc/password, os campos /etc/group são os seguintes:\n\n<ol>\n<li>Nome do grupo</li>\n<li>Senha do grupo - não há necessidade de definir uma senha de grupo, usar um privilégio elevado como sudo é padrão. Um \"*\" será colocado como valor padrão.</li>\n<li>ID do grupo (GID)</li>\n<li>Lista de usuários - você pode especificar manualmente os usuários que deseja em um grupo específico</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "Qual é o GID do root?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "Crie um novo usuário, em seguida, altere sua senha e faça login como o novo usuário.",
          "id": 6,
          "lessonContent": "A maioria dos ambientes empresariais está usando sistemas de gerenciamento para gerenciar usuários, contas e senhas. No entanto, em um único computador, existem comandos úteis para gerenciar usuários.\n\n<b>Adicionando Usuários</b>\n\nVocê pode usar o comando adduser ou useradd. O comando adduser contém mais recursos úteis, como criar um diretório home e outros. Existem arquivos de configuração para adicionar novos usuários que podem ser personalizados dependendo do que você deseja alocar a um usuário padrão. \n\n<pre>$ sudo useradd bob</pre>\n\nVocê verá que o comando acima cria uma entrada em /etc/passwd para bob, configura grupos padrão e adiciona uma entrada ao arquivo /etc/shadow.\n\n<b>Removendo Usuários</b>\n\nPara remover um usuário, você pode usar o comando userdel.\n\n<pre>$ sudo userdel bob</pre>\n\nBasicamente, isso faz o melhor para desfazer as alterações feitas por useradd.\n\n<b>Alterando Senhas</b>\n\n<pre>$ passwd bob</pre>\n\nIsso permitirá que você altere a senha de si mesmo ou de outro usuário (se você for root).",
          "quizAnswer": "passwd",
          "quizQuestion": "Qual comando é usado para alterar uma senha?",
          "slug": "ferramentasdegerenciamentodeusuarios",
          "title": "Ferramentas de Gerenciamento de Usuários"
        }
      ],
      "slug": "usermanagement",
      "title": "Gestão de Usuários"
    },
    {
      "description": "Saiba sobre níveis de permissão e modificação de permissões.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Use o comando ls -l em vários arquivos e recite suas permissões, usuário e grupo.",
          "id": 1,
          "lessonContent": "Como aprendemos anteriormente, os arquivos têm diferentes permissões ou modos de arquivo. Vamos ver um exemplo:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nExistem quatro partes nas permissões de um arquivo. A primeira parte é o tipo de arquivo, que é indicado pelo primeiro caractere nas permissões, no nosso caso, como estamos olhando para um diretório, mostra <b>d</b> para o tipo de arquivo. Mais comumente, você verá um <b>-</b> para um arquivo regular. \n\nAs próximas três partes do modo de arquivo são as permissões reais. As permissões são agrupadas em 3 bits cada. Os primeiros 3 bits são as permissões do usuário, em seguida, as permissões do grupo e depois as permissões de outros. Adicionei o pipe para facilitar a diferenciação.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nCada caractere representa uma permissão diferente: \n<ul>\n<li>r: leitura</li>\n<li>w: escrita</li>\n<li>x: executável (basicamente um programa executável)</li>\n<li>-: vazio</li>\n</ul>\n\nPortanto, no exemplo acima, vemos que o usuário pete tem permissões de leitura, escrita e execução no arquivo. O grupo penguins tem permissões de leitura e execução. E, finalmente, os outros usuários (todos os outros) têm permissões de leitura e execução.",
          "quizAnswer": "x",
          "quizQuestion": "Qual bit de permissão é usado para executável?",
          "slug": "filepermissions",
          "title": "Permissões de Arquivo"
        },
        {
          "exercise": "Altere algumas permissões básicas de arquivos de texto e veja os bits mudando conforme você faz um ls -l.",
          "id": 2,
          "lessonContent": "Alterar permissões pode ser facilmente feito com o comando <b>chmod</b>. \n\nPrimeiro, escolha qual conjunto de permissões você deseja alterar, usuário, grupo ou outro. Você pode adicionar ou remover permissões com um <b>+</b> ou <b>-</b>, vamos ver alguns exemplos.\n\n<b>Adicionando bit de permissão em um arquivo</b>\n<pre>$ chmod u+x myfile</pre>\n\nO comando acima é lido da seguinte forma: alterar permissão no myfile adicionando o bit de permissão executável no conjunto de usuário. Agora o usuário tem permissão de execução neste arquivo!\n\n<b>Removendo bit de permissão em um arquivo</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>Adicionando vários bits de permissão em um arquivo</b>\n<pre>$ chmod ug+w</pre>\n\nHá outra maneira de alterar permissões usando formato numérico. Este método permite que você altere as permissões de uma só vez. Em vez de usar r, w ou x para representar permissões, você usará uma representação numérica para um conjunto de permissões único. Portanto, não é necessário especificar o grupo com g ou o usuário com u.\n\nAs representações numéricas são vistas abaixo:\n\n<ul>\n<li>4: permissão de leitura</li>\n<li>2: permissão de escrita</li>\n<li>1: permissão de execução</li>\n</ul>\n\nVamos ver um exemplo: \n\n<pre>$ chmod 755 myfile</pre>\n\nVocê consegue adivinhar que permissões estamos dando a este arquivo? Vamos analisar isso, então agora 755 cobre as permissões para todos os conjuntos. O primeiro número (7) representa as permissões do usuário, o segundo número (5) representa as permissões do grupo e o último 5 representa as permissões de outros. \n\nEspere um minuto, 7 e 5 não foram listados acima, de onde estamos tirando esses números? Lembre-se de que estamos combinando todas as permissões em um único número agora, então você terá que envolver um pouco de matemática.\n\n7 = 4 + 2 + 1, então 7 são as permissões do usuário e ele tem permissões de leitura, escrita e execução\n\n5 = 4 + 1, o grupo tem permissões de leitura e execução\n\n5 = 4 + 1, e todos os outros usuários têm permissões de leitura e execução\n\nUma coisa a se observar: não é uma boa ideia ficar alterando permissões aleatoriamente, você poderia potencialmente expor um arquivo sensível para que todos modifiquem, no entanto, muitas vezes você quer legitimamente alterar permissões, apenas tome precauções ao usar o comando chmod.",
          "quizAnswer": "4",
          "quizQuestion": "Que número representa a permissão de leitura ao usar o formato numérico?",
          "slug": "modificandopermissoes",
          "title": "Modificando Permissões"
        },
        {
          "exercise": "Modifique o grupo e o usuário de alguns arquivos de teste. Depois, dê uma olhada nas permissões com ls -l.",
          "id": 3,
          "lessonContent": "Além de modificar permissões em arquivos, você também pode modificar o grupo e a propriedade do usuário do arquivo também. \n\n<b>Modificar a propriedade do usuário</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nEste comando definirá o proprietário de myfile como patty.\n\n<b>Modificar a propriedade do grupo</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nEste comando definirá o grupo de myfile como whales.\n\n<b>Modificar tanto a propriedade do usuário quanto do grupo ao mesmo tempo</b>\nSe você adicionar dois pontos e o nome do grupo após o usuário, você pode definir tanto o usuário quanto o grupo ao mesmo tempo.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "Qual comando você usa para alterar a propriedade do usuário?",
          "slug": "permissõesdepropriedade",
          "title": "Permissões de Propriedade"
        },
        {
          "exercise": "<ol>\n<li>Crie um novo arquivo e anote suas permissões.</li>\n<li>Modifique o umask e crie outro novo arquivo.</li>\n<li>Verifique as permissões novamente no novo arquivo, o que você espera ver?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Cada arquivo criado vem com um conjunto padrão de permissões. Se você quiser alterar esse conjunto padrão de permissões, pode fazer isso com o comando umask. Este comando utiliza o conjunto de permissões de 3 bits que vemos em permissões numéricas. \n\nEm vez de adicionar essas permissões, o umask retira essas permissões. \n\n<pre>$ umask 021</pre>\n\nNo exemplo acima, estamos declarando que queremos que as permissões padrão dos novos arquivos permitam acesso de usuários a tudo, mas para grupos queremos retirar a permissão de escrita e para outros queremos retirar a permissão de execução. O umask padrão na maioria das distribuições é 022, o que significa acesso de usuário total, mas sem acesso de escrita para grupos e outros usuários.\n\nQuando você executa o comando umask, ele fornecerá esse conjunto padrão de permissões em qualquer novo arquivo que você criar. No entanto, se você quiser que isso persista, terá que modificar seu arquivo de inicialização (.profile), mas discutiremos isso em uma lição posterior.",
          "quizAnswer": "umask",
          "quizQuestion": "Qual comando é usado para alterar as permissões padrão de arquivo?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Olhe com atenção as permissões para /etc/passwd, você nota mais alguma coisa? Arquivos com SUID habilitado também são facilmente distinguíveis.",
          "id": 5,
          "lessonContent": "Existem muitos casos em que usuários normais precisam de acesso elevado para fazer coisas. O administrador do sistema nem sempre pode estar presente para inserir uma senha de root toda vez que um usuário precisar de acesso a um arquivo protegido, então existem bits especiais de permissão de arquivo para permitir esse comportamento. O Set User ID (SUID) permite que um usuário execute um programa como o proprietário do arquivo do programa, em vez de como eles mesmos.\n\nVamos ver um exemplo: \n\nDigamos que eu queira alterar minha senha, simples certo? Basta usar o comando passwd:\n\n<pre>$ passwd</pre>\n\nO que o comando de senha está fazendo? Está modificando alguns arquivos, mas o mais importante é que está modificando o arquivo /etc/shadow. Vamos dar uma olhada nesse arquivo por um segundo: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nEspera um minuto aqui, este arquivo é de propriedade do root? Como é possível que possamos modificar um arquivo de propriedade do root? \n\nVamos dar uma olhada em outro conjunto de permissões, desta vez do comando que executamos: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nVocê notará um novo bit de permissão aqui <b>s</b>. Esse bit de permissão é o SUID, quando um arquivo tem essa permissão definida, permite que os usuários que iniciaram o programa obtenham a permissão do proprietário do arquivo, bem como a permissão de execução, neste caso root. Então, essencialmente, enquanto um usuário está executando o comando de senha, ele está sendo executado como root.\n\nÉ por isso que conseguimos acessar um arquivo protegido como /etc/shadow quando executamos o comando passwd. Agora, se você remover esse bit, verá que não conseguirá modificar /etc/shadow e, portanto, alterar sua senha. \n\n<b>Modificando SUID</b>\n\nAssim como as permissões regulares, existem duas maneiras de modificar as permissões SUID. \n\n<i>Forma simbólica:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Forma numérica:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nComo você pode ver, o SUID é denotado por um 4 e pre-pendido ao conjunto de permissões. Você pode ver o SUID denotado como um <b>S</b> maiúsculo, isso significa que ele ainda faz a mesma coisa, mas não tem permissões de execução.",
          "quizAnswer": "4",
          "quizQuestion": "Que número representa o SUID?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 6,
          "lessonContent": "Similar to the set user ID permission bit, there is a set group ID (SGID) permission bit. This bit allows a program to run as if it was a member of that group. \n\nLet's look at one example: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nAgora podemos ver que o bit de permissão está no conjunto de permissões do grupo. \n\n<b>Modificando SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nA representação numérica para SGID é 2.",
          "quizAnswer": "2",
          "quizQuestion": "Qual número representa o SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Ainda não discutimos processos, mas ainda podemos ver essa mudança acontecendo em tempo real: \n\n<ol>\n<li>Abra uma janela do terminal e execute o comando: <b>watch -n 1 \"ps aux | grep passwd\"</b>. Isso irá monitorar o processo passwd.</li>\n<li>Abra uma segunda janela do terminal e execute: <b>passwd</b></li>\n<li>Olhe para a primeira janela do terminal, você verá um processo aparecer para passwd. A primeira coluna na tabela de processos é o ID de usuário efetivo, e eis que é o usuário root!</li>\n</ol>",
          "id": 7,
          "lessonContent": "Vamos falar um pouco sobre permissões de processo, lembra quando eu disse que ao executar o comando passwd com o bit de permissão SUID ativado você executará o programa como root? Isso é verdade, porém isso significa que, sendo temporariamente root, você pode modificar as senhas de outros usuários? Não, felizmente não!\n\nIsso ocorre devido aos muitos UIDs que o Linux implementa. Existem três UIDs associados a cada processo:\n\nQuando você inicia um processo, ele é executado com as mesmas permissões do usuário ou grupo que o iniciou, isso é conhecido como um <b>ID de usuário efetivo</b>. Esse UID é usado para conceder direitos de acesso a um processo. Naturalmente, se Bob executar o comando touch, o processo será executado como ele e quaisquer arquivos que ele criar serão de sua propriedade.\n\nExiste outro UID, chamado <b>ID de usuário real</b>, que é o ID do usuário que iniciou o processo. Eles são usados para rastrear quem é o usuário que iniciou o processo.\n\nUm último UID é o <b>ID de usuário salvo</b>, que permite a um processo alternar entre o UID efetivo e o UID real, vice-versa. Isso é útil porque não queremos que nosso processo seja executado com privilégios elevados o tempo todo, é apenas uma boa prática usar privilégios especiais em momentos específicos. \n\nAgora vamos juntar tudo isso olhando para o comando passwd mais uma vez. \n\nAo executar o comando passwd, seu UID efetivo é o seu ID de usuário, digamos que seja 500 por enquanto. Ah, mas espere, lembra que o comando passwd tem a permissão SUID ativada. Então, quando você o executa, seu UID efetivo agora é 0 (0 é o UID do root). Agora este programa pode acessar arquivos como root.\n\nDigamos que você tenha um pequeno gostinho de poder e queira modificar a senha de Sally, Sally tem um UID de 600. Bem, você terá azar, felizmente o processo também tem seu UID real neste caso 500. Ele sabe que seu UID é 500 e, portanto, você não pode modificar a senha do UID 600. (Isso, é claro, é sempre contornado se você for um superusuário em uma máquina e puder controlar e alterar tudo).\n\nComo você executou o passwd, ele iniciará o processo usando seu UID real e salvará o UID do proprietário do arquivo (UID efetivo), para que você possa alternar entre os dois. Não é necessário modificar todos os arquivos com acesso root se não for necessário. \n\nNa maioria das vezes, o UID real e o UID efetivo são iguais, mas em casos como o comando passwd eles mudarão.",
          "quizAnswer": "efetivo",
          "quizQuestion": "Qual UID decide que acesso conceder?",
          "slug": "permissõesdeprocesso",
          "title": "Permissões de Processo"
        },
        {
          "exercise": "Quais outros arquivos e diretórios você acha que têm um bit sticky ativado?",
          "id": 8,
          "lessonContent": "Um último bit de permissão especial sobre o qual quero falar é o bit sticky. \n\nEste bit de permissão, \"cola um arquivo/diretório\", o que significa que apenas o proprietário ou o usuário root podem excluir ou modificar o arquivo. Isso é muito útil para diretórios compartilhados. Dê uma olhada no exemplo abaixo:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nVocê verá um bit de permissão especial no final aqui <b>t</b>, isso significa que todos podem adicionar arquivos, escrever arquivos, modificar arquivos no diretório /tmp, mas apenas o root pode excluir o diretório /tmp. \n\n<b>Modificar o bit sticky</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nA representação numérica para o bit sticky é <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "Que símbolo representa o bit sticky?",
          "slug": "stickybit",
          "title": "O Bit Sticky"
        }
      ],
      "slug": "permissions",
      "title": "Permissões"
    },
    {
      "description": "Aprenda sobre os processos em execução no sistema.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Use o comando ps com diferentes flags e veja como a saída muda.",
          "id": 1,
          "lessonContent": "Processos são os programas que estão em execução em sua máquina. Eles são gerenciados pelo kernel e cada processo tem um ID associado a ele chamado de <b>process ID (PID).</b> Este PID é atribuído na ordem em que os processos são criados. \n\nVá em frente e execute o comando ps para ver uma lista de processos em execução:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nIsso mostra uma rápida visão geral dos processos atuais:\n\n<ul>\n<li>PID: Process ID</li>\n<li>TTY: Terminal de controle associado ao processo (vamos detalhar isso mais tarde)</li>\n<li>STAT: Código de status do processo</li>\n<li>TIME: Tempo total de uso da CPU</li>\n<li>CMD: Nome do executável/comando</li>\n</ul>\n\nSe você olhar a página do manual para ps, verá que existem muitas opções de comando que você pode passar, elas variam dependendo das opções que você deseja usar - BSD, GNU ou Unix. Na minha opinião, o estilo BSD é mais popular de usar, então vamos seguir com ele. Se você estiver curioso, a diferença entre os estilos está na quantidade de traços que você usa e nas flags.\n\n<pre>$ ps aux</pre>\n\nO <b>a</b> exibe todos os processos em execução, incluindo os que estão sendo executados por outros usuários. O <b>u</b> mostra mais detalhes sobre os processos. E finalmente o <b>x</b> lista todos os processos que não têm um TTY associado a ele, esses programas mostrarão um ? no campo TTY, são mais comuns em processos de daemon que são iniciados como parte da inicialização do sistema.\n\nVocê notará que está vendo muito mais campos agora, não é necessário memorizá-los todos, em um curso posterior sobre processos avançados, revisaremos alguns deles novamente:\n\n<ul>\n<li>USER: O usuário efetivo (aquele cujo acesso estamos usando)</li>\n<li>PID: Process ID</li>\n<li>%CPU: Tempo de CPU usado dividido pelo tempo em que o processo está em execução</li>\n<li>%MEM: Proporção do tamanho do conjunto residente do processo em relação à memória física da máquina</li>\n<li>VSZ: Uso de memória virtual de todo o processo</li>\n<li>RSS: Tamanho do conjunto residente, a memória física não trocada que uma tarefa utilizou</li>\n<li>TTY: Terminal de controle associado ao processo</li>\n<li>STAT: Código de status do processo</li>\n<li>START: Hora de início do processo</li>\n<li>TIME: Tempo total de uso da CPU</li>\n<li>COMMAND: Nome do executável/comando</li>\n</ul>\n\nO comando ps pode ficar um pouco confuso de se olhar, por enquanto os campos que vamos olhar mais são PID, STAT e COMMAND. \n\nOutro comando muito útil é o comando <b>top</b>, top fornece informações em tempo real sobre os processos em execução em seu sistema em vez de uma captura de tela. Por padrão, você terá uma atualização a cada 10 segundos. Top é uma ferramenta extremamente útil para ver quais processos estão consumindo muitos de seus recursos. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "Qual flag do ps é usada para visualizar informações detalhadas sobre os processos?",
          "slug": "monitorarprocessoscomandops",
          "title": "ps (Processos)"
        },
        {
          "exercise": "Olhe para a saída do seu ps e liste todos os valores TTY únicos.",
          "id": 2,
          "lessonContent": "Discutimos como há um campo TTY na saída do comando ps. O TTY é o terminal que executou o comando.\n\nExistem dois tipos de terminais, dispositivos de terminal regulares e dispositivos de pseudoterminal. Um dispositivo de terminal regular é um dispositivo de terminal nativo no qual você pode digitar e enviar saída para o seu sistema, isso se parece com o aplicativo de terminal que você tem lançado para acessar seu shell, mas não é. \n\nVamos fazer uma transição para que você possa ver essa ação, vá em frente e digite Ctrl-Alt-F1 para entrar no TTY1 (a primeira console virtual), você notará que não tem nada além do terminal, sem gráficos, etc. Isso é considerado um dispositivo de terminal regular, você pode sair disso com Ctrl-Alt-F7. \n\nUm pseudoterminal é o que você está acostumado a trabalhar, eles emulam terminais com a janela do terminal do shell e são denotados por PTS. Se você olhar para o ps novamente, verá seu processo de shell sob pts/*. \n\nOk, agora voltando ao terminal de controle, os processos geralmente estão vinculados a um terminal de controle. Por exemplo, se você estivesse executando um programa na janela do seu shell, como find, e fechasse a janela, seu processo também seria encerrado. \n\nExistem processos como processos daemon, que são processos especiais que basicamente mantêm o sistema em funcionamento. Eles costumam iniciar na inicialização do sistema e geralmente são encerrados quando o sistema é desligado. Eles são executados em segundo plano e, como não queremos que esses processos especiais sejam encerrados, eles não estão vinculados a um terminal de controle. Na saída do ps, o TTY é listado como um ? significando que não tem um terminal de controle.",
          "quizAnswer": "?",
          "quizQuestion": "Que valor é atribuído a um processo que não tem um terminal de controle?",
          "slug": "terminaldecontrole",
          "title": "Terminal de Controle"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Antes de entrarmos em aplicações mais práticas de processos, temos que primeiro entender o que são e como funcionam. Essa parte pode ficar confusa, já que estamos nos aprofundando nos detalhes, então fique à vontade para voltar a esta lição se não quiser aprender sobre isso agora. \n\nUm processo, como mencionamos antes, é um programa em execução no sistema, mais precisamente é o sistema alocando memória, CPU, E/S para fazer o programa funcionar. Um processo é uma instância de um programa em execução, vá em frente e abra 3 janelas de terminal, em duas janelas, execute o comando <b>cat</b> sem passar nenhuma opção (o processo cat permanecerá aberto como um processo porque espera stdin). Agora, na terceira janela, execute: <b>ps aux | grep cat</b>. Você verá que existem dois processos para cat, mesmo que estejam chamando o mesmo programa.\n\nO kernel é responsável pelos processos, quando executamos um programa, o kernel carrega o código do programa na memória, determina e aloca recursos e depois mantém controle sobre cada processo, ele sabe: \n\n<ul>\n<li>O status do processo</li>\n<li>Os recursos que o processo está usando e recebendo</li>\n<li>O proprietário do processo</li>\n<li>Tratamento de sinais (mais sobre isso depois)</li>\n<li>E basicamente tudo mais</li>\n</ul>\n\nTodos os processos estão tentando obter um pedaço daquele doce recurso, é trabalho do kernel garantir que os processos recebam a quantidade certa de recursos, dependendo das demandas do processo. Quando um processo termina, os recursos que ele usou são liberados para outros processos.",
          "quizAnswer": "kernel",
          "quizQuestion": "O que gerencia e controla os processos?",
          "slug": "detalhesdoprocesso",
          "title": "Detalhes do Processo"
        },
        {
          "exercise": "Dê uma olhada nos seus processos em execução, você consegue ver quais outros processos têm pais?",
          "id": 4,
          "lessonContent": "Novamente, esta lição e a próxima são puramente informativas para que você possa ver o que está por trás, sinta-se à vontade para voltar a este conteúdo depois de ter trabalhado um pouco mais com processos.\n\nQuando um novo processo é criado, um processo existente basicamente se clona usando algo chamado de chamada de sistema fork (chamadas de sistema serão discutidas muito no futuro). A chamada de sistema fork cria um processo filho quase idêntico, este processo filho recebe um novo ID de processo (PID) e o processo original se torna seu processo pai e tem algo chamado de ID de processo pai <b>PPID</b>. Em seguida, o processo filho pode continuar a usar o mesmo programa que seu pai estava usando antes ou, mais frequentemente, usar a chamada de sistema execve para iniciar um novo programa. Esta chamada de sistema destrói a gerência de memória que o kernel estabeleceu para esse processo e configura novas para o novo programa. \n\nPodemos ver isso em ação:\n\n<pre>$ ps l</pre>\n\nA opção l nos dá um formato \"longo\" ou uma visão ainda mais detalhada de nossos processos em execução. Você verá uma coluna rotulada <b>PPID</b>, que é o ID do pai. Agora, olhe para o seu terminal, você verá um processo em execução que é o seu shell, então no meu sistema eu tenho um processo em execução do bash. Agora, lembre-se de quando você executou o comando ps l, você o executou a partir do processo que estava executando o bash. Agora você verá que o <b>PID</b> do shell bash é o <b>PPID</b> do comando <b>ps l</b>.\n\nEntão, se todo processo precisa ter um pai e eles são apenas bifurcações uns dos outros, deve haver uma mãe de todos os processos, certo? Você está correto, quando o sistema é inicializado, o kernel cria um processo chamado <b>init</b>, que tem um PID de 1. O processo init não pode ser encerrado a menos que o sistema seja desligado. Ele é executado com privilégios de root e executa muitos processos que mantêm o sistema em funcionamento. Vamos dar uma olhada mais de perto no init no curso de inicialização do sistema, por enquanto saiba que é o processo que gera todos os outros processos.",
          "quizAnswer": "fork",
          "quizQuestion": "Qual chamada de sistema cria um novo processo?",
          "slug": "criacaodeprocessos",
          "title": "Criação de Processos"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Agora que sabemos o que acontece quando um processo é criado, o que acontece quando não precisamos mais dele? Esteja avisado, às vezes o Linux pode ficar um pouco sombrio...\n\nUm processo pode sair usando a chamada de sistema _exit, isso liberará os recursos que o processo estava usando para realocação. Então, quando um processo está pronto para terminar, ele informa ao kernel o motivo pelo qual está terminando com algo chamado status de término. Mais comumente, um status de 0 significa que o processo teve sucesso. No entanto, isso não é suficiente para terminar completamente um processo. O processo pai tem que reconhecer o término do processo filho usando a chamada de sistema wait e o que isso faz é verificar o status de término do processo filho. Eu sei que é horrível pensar sobre isso, mas a chamada de wait é uma necessidade, afinal, que pai não gostaria de saber como seu filho morreu?\n\nHá outra maneira de terminar um processo e isso envolve o uso de sinais, o que discutiremos em breve.\n\n<b>Processos Órfãos</b>\n\nQuando um processo pai morre antes de um processo filho, o kernel sabe que não receberá uma chamada de wait, então em vez disso, ele torna esses processos \"órfãos\" e os coloca sob os cuidados do init (lembre-se, mãe de todos os processos). O init eventualmente realizará a chamada de sistema wait para esses órfãos para que possam morrer.\n\n<b>Processos Zumbis</b>\n\nO que acontece quando um filho termina e o processo pai ainda não chamou wait? Ainda queremos ser capazes de ver como um processo filho terminou, então mesmo que o processo filho tenha terminado, o kernel transforma o processo filho em um processo zumbi. Os recursos que o processo filho usou ainda são liberados para outros processos, no entanto, ainda há uma entrada na tabela de processos para esse zumbi. Os processos zumbis também não podem ser mortos, uma vez que estão tecnicamente \"mortos\", então você não pode usar sinais para matá-los. Eventualmente, se o processo pai chamar a chamada de sistema wait, o zumbi desaparecerá, isso é conhecido como \"reaproveitamento\". Se o pai não realizar uma chamada de wait, o init adotará o zumbi e realizará automaticamente o wait e removerá o zumbi. Pode ser ruim ter muitos processos zumbis, pois ocupam espaço na tabela de processos, se ela ficar cheia, impedirá que outros processos sejam executados.",
          "quizAnswer": "0",
          "quizQuestion": "Qual é o status de término mais comum para um processo que teve sucesso?",
          "slug": "terminacaodeprocessos",
          "title": "Terminação de Processos"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 6,
          "lessonContent": "Um sinal é uma notificação para um processo de que algo aconteceu.\n\n<b>Por que temos sinais</b>\n\nEles são interrupções de software e têm muitos usos:\n\n<ul>\n<li>Um usuário pode digitar um dos caracteres especiais do terminal (Ctrl-C) ou (Ctrl-Z) para matar, interromper ou suspender processos</li>\n<li>Problemas de hardware podem ocorrer e o kernel quer notificar o processo</li>\n<li>Problemas de software podem ocorrer e o kernel quer notificar o processo</li>\n<li>Basicamente, são formas de comunicação entre processos</li>\n</ul>\n\n<b>Processo de sinal</b>\n\nQuando um sinal é gerado por algum evento, ele é então entregue a um processo, sendo considerado em estado pendente até ser entregue. Quando o processo é executado, o sinal será entregue. No entanto, os processos têm máscaras de sinal e podem definir o bloqueio da entrega do sinal, se especificado. Quando um sinal é entregue, um processo pode fazer uma série de coisas: \n\n<ul>\n<li>Ignorar o sinal</li>\n<li>\"Capturar\" o sinal e executar uma rotina de tratamento específica</li>\n<li>O processo pode ser terminado, ao contrário da chamada de sistema de saída normal</li>\n<li>Bloquear o sinal, dependendo da máscara de sinal</li>\n</ul>\n\n<b>Sinais comuns</b>\n\nCada sinal é definido por inteiros com nomes simbólicos que estão na forma de SIGxxx. Alguns dos sinais mais comuns são: \n\n<ul>\n<li>SIGHUP ou HUP ou 1: Desconexão</li>\n<li>SIGINT ou INT ou 2: Interrupção</li>\n<li>SIGKILL ou KILL ou 9: Matar</li>\n<li>SIGSEGV ou SEGV ou 11: Falha de segmentação</li>\n<li>SIGTERM ou TERM ou 15: Término de software</li>\n<li>SIGSTOP ou STOP: Parar</li>\n</ul>\n\nOs números podem variar com os sinais, então geralmente são referidos por seus nomes.\n\nAlguns sinais são inbloqueáveis, um exemplo é o sinal SIGKILL. O sinal KILL destrói o processo.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "Qual sinal é inbloqueável?",
          "slug": "sinaisdeprocesso",
          "title": "Sinais"
        },
        {
          "exercise": "Matar alguns processos usando sinais diferentes.",
          "id": 7,
          "lessonContent": "Você pode enviar sinais que terminam processos, um comando assim é adequadamente chamado de comando kill. \n\n<pre>$ kill 12445</pre>\n\nO 12445 é o PID do processo que você deseja matar. Por padrão, ele envia um sinal TERM. O sinal SIGTERM é enviado a um processo para solicitar sua terminação, permitindo que ele libere seus recursos de forma limpa e salve seu estado. \n\nVocê também pode especificar um sinal com o comando kill: \n\n<pre>$ kill -9 12445</pre>\n\nIsso executará o sinal SIGKILL e matará o processo. \n\n<b>Diferenças entre SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nEsses sinais todos soam razoavelmente semelhantes, mas eles têm suas diferenças. \n\n<ul>\n<li>SIGHUP - Desconexão, enviado a um processo quando o terminal controlador é fechado. Por exemplo, se você fechar uma janela de terminal que tinha um processo em execução, você receberia um sinal SIGHUP. Basicamente, você foi desconectado</li>\n<li>SIGINT - É um sinal de interrupção, então você pode usar Ctrl-C e o sistema tentará encerrar o processo de forma graciosa</li>\n<li>SIGTERM - Encerra o processo, mas permite que ele faça alguma limpeza primeiro</li>\n<li>SIGKILL - Encerra o processo, mata-o com fogo, não faz nenhuma limpeza</li>\n<li>SIGSTOP - Para/suspende um processo</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "Qual é o nome do sinal para o comando kill padrão?",
          "slug": "matarprocessos",
          "title": "matar (Terminar)"
        },
        {
          "exercise": "Quais processos não são muito bons e por quê?",
          "id": 8,
          "lessonContent": "Quando você executa várias coisas em seu computador, como talvez Chrome, Microsoft Word ou Photoshop ao mesmo tempo, pode parecer que esses processos estão sendo executados ao mesmo tempo, mas isso não é exatamente verdade. \n\nOs processos usam a CPU por um pequeno período de tempo chamado fatia de tempo. Em seguida, eles pausam por milissegundos e outro processo obtém uma pequena fatia de tempo. Por padrão, o agendamento de processos acontece dessa forma round-robin. Cada processo recebe fatias de tempo suficientes até que termine o processamento. O kernel lida com todas essas trocas de processos e geralmente faz um bom trabalho na maioria das vezes.\n\nOs processos não são capazes de decidir quando e por quanto tempo recebem tempo de CPU, se todos os processos se comportassem normalmente, cada um receberia (aproximadamente) a mesma quantidade de tempo de CPU. No entanto, há uma maneira de influenciar o algoritmo de agendamento de processos do kernel com um valor de bondade. Bondade é um nome bastante estranho, mas o que significa é que os processos têm um número para determinar sua prioridade para a CPU. Um número alto significa que o processo é bom e tem uma prioridade mais baixa para a CPU e um número baixo ou negativo significa que o processo não é muito bom e deseja obter o máximo possível da CPU. \n\n<pre>$ top</pre>\n\nVocê pode ver uma coluna para NI agora, que é o nível de bondade de um processo.\n\nPara alterar o nível de bondade, você pode usar os comandos nice e renice:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nO comando nice é usado para definir a prioridade para um novo processo. O comando renice é usado para definir a prioridade em um processo existente. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "mais baixo",
          "quizQuestion": "Se eu quiser que um processo tenha mais prioridade de CPU, eu uso um número nice mais baixo ou mais alto?",
          "slug": "bondadedeprocesso",
          "title": "bondade"
        },
        {
          "exercise": "Dê uma olhada nos processos em execução em seu sistema e verifique seus estados de processo.",
          "id": 9,
          "lessonContent": "Vamos dar uma olhada no comando ps aux novamente:\n\n<pre>$ ps aux</pre>\n\nNa coluna STAT, você verá muitos valores. Um processo linux pode estar em vários estados diferentes. Os códigos de estado mais comuns que você verá são descritos abaixo:\n\n<ul>\n<li>R: em execução ou pronto para execução, está apenas esperando a CPU processá-lo</li>\n<li>S: sono interrompível, aguardando a conclusão de um evento, como entrada do terminal</li>\n<li>D: sono ininterruptível, processos que não podem ser encerrados ou interrompidos com um sinal, geralmente para fazê-los desaparecer você tem que reiniciar ou corrigir o problema</li>\n<li>Z: Zumbi, discutimos em uma lição anterior que zumbis são processos terminados que estão aguardando para ter seus status coletados</li>\n<li>T: Parado, um processo que foi suspenso/parado</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "Qual código STAT é usado para representar um sono ininterruptível?",
          "slug": "estadosdeprocesso",
          "title": "Estados de Processo"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 10,
          "lessonContent": "Lembre-se de que tudo no Linux é um arquivo, até mesmo processos. As informações do processo são armazenadas em um sistema de arquivos especial conhecido como o sistema de arquivos /proc.\n\n<pre>$ ls /proc</pre>\n\nVocê deve ver múltiplos valores aqui, existem subdiretórios para cada PID. Se você olhasse para um PID na saída do ps, seria capaz de encontrá-lo no diretório /proc.\n\nVá em frente e entre em um dos processos e olhe para esse arquivo:\n\n<pre>$ cat /proc/12345/status</pre>\n\nVocê deve ver informações de estado do processo e também informações mais detalhadas. O diretório /proc é como o kernel visualiza o sistema, então há muito mais informações aqui do que você veria no ps.",
          "quizAnswer": "/proc",
          "quizQuestion": "Qual sistema de arquivos armazena informações de processo?",
          "slug": "procfilesystem",
          "title": "/proc filesystem"
        },
        {
          "exercise": "Mova alguns jobs entre o segundo plano e o primeiro plano",
          "id": 11,
          "lessonContent": "Digamos que você esteja trabalhando em uma única janela de terminal e esteja executando um comando que está demorando muito. Você não pode interagir com o shell até que ele seja concluído, no entanto, queremos continuar trabalhando em nossas máquinas, então precisamos manter esse shell aberto. Felizmente, podemos controlar como nossos processos são executados com jobs: \n\n<b>Enviando um job para segundo plano</b>\n\nAdicionar um e comercial (&) ao comando o executará em segundo plano para que você ainda possa usar seu shell. Vamos ver um exemplo:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Visualizar todos os jobs em segundo plano</b>\n\nAgora você pode visualizar os jobs que acabou de enviar para segundo plano.\n\n<pre>$ jobs\n\n[1]    Executando     sleep 1000 &\n[2]-   Executando     sleep 1001 &\n[3]+   Executando     sleep 1002 &\n\n</pre>\n\nIsso mostrará o ID do job na primeira coluna, em seguida, o status e o comando que foi executado. O <b>+</b> ao lado do ID do job significa que é o job em segundo plano mais recente que foi iniciado. O job com o <b>-</b> é o segundo comando mais recente.\n\n<b>Enviando um job para segundo plano em um job existente</b>\n\nSe você já executou um job e deseja enviá-lo para segundo plano, não é necessário terminá-lo e reiniciá-lo. Primeiro suspenda o job com Ctrl-Z, em seguida, execute o comando <b>bg</b> para enviá-lo para segundo plano.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Parado     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Executando     sleep 1000 &\n[2]    Executando     sleep 1001 &\n[3]-   Executando     sleep 1002 &\n[4]+   Executando     sleep 1003 &\n</pre>\n\n<b>Movendo um job do segundo plano para o primeiro plano</b>\n\nPara mover um job do segundo plano, basta especificar o ID do job que você deseja. Se você executar fg sem nenhuma opção, ele trará de volta o job em segundo plano mais recente (o job com o sinal + ao lado dele)\n\n<pre>$ fg %1</pre>\n\n<b>Encerrar jobs em segundo plano</b>\n\nSemelhante à movimentação de jobs do segundo plano, você pode usar a mesma forma para encerrar os processos usando seus IDs de Job.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "Qual comando é usado para listar os jobs em segundo plano?",
          "slug": "controletrabalho",
          "title": "Controle de Trabalho"
        }
      ],
      "slug": "processes",
      "title": "Processos"
    },
    {
      "description": "Aprenda tudo sobre as ferramentas de gerenciamento de pacotes dpkg, apt-get, rpm e yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Seu sistema é composto por muitos pacotes, como navegadores de internet, editores de texto, players de mídia, etc. Esses pacotes são gerenciados por meio de gerenciadores de pacotes, que instalam e mantêm o software em seu sistema. Nem todos os pacotes são instalados por meio de gerenciadores de pacotes, no entanto, você pode instalar pacotes comumente diretamente a partir do código-fonte (falaremos sobre isso em breve). No entanto, na maioria das vezes, você usará um gerenciador de pacotes para instalar software, sendo a variedade mais comum de pacotes os Debian (.deb) e Red Hat (.rpm). Os pacotes no estilo Debian são usados em distribuições como Debian, Ubuntu, LinuxMint, etc. Os pacotes no estilo Red Hat são vistos no Red Hat Enterprise Linux, Fedora, CentOS, etc.\n\nO que são pacotes? Você pode conhecê-los como Chrome, Photoshop, etc., e são, mas na realidade são apenas muitos arquivos compilados em um só. As pessoas (ou às vezes uma única pessoa) que escrevem esse software são conhecidas como <b>fornecedores upstream</b>, eles compilam seu código e escrevem como instalá-lo. Esses fornecedores upstream trabalham para lançar novos softwares e atualizar softwares existentes. Quando estão prontos para lançá-los para o mundo, enviam seu pacote para os <b>mantenedores de pacotes</b>, que cuidam de disponibilizar esse software nas mãos dos usuários. Esses mantenedores de pacotes revisam, gerenciam e distribuem esse software na forma de pacotes.",
          "quizAnswer": "",
          "quizQuestion": "Sem perguntas, siga em frente!",
          "slug": "softwaredistribution",
          "title": "Distribuição de Software"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 2,
          "lessonContent": "Como é que os pacotes que são enviados para a internet acabam nos nossos computadores? Você vai para a página de download de cada pacote que deseja e clica em baixar e instalar? Bem, na verdade você pode fazer isso, mas há algo melhor chamado repositórios de pacotes. Repositórios são apenas locais de armazenamento central para pacotes. Existem toneladas de repositórios que contêm muitos pacotes e o melhor de tudo é que todos eles são encontrados na internet, sem discos de instalação bobos. Sua máquina não sabe onde procurar esses repositórios a menos que você diga explicitamente onde procurar.\n\nPor exemplo, digamos que eu queira o Software WackyWidgets na minha máquina. Bem, a WackyWidgets gerencia seus próprios repositórios para seus pacotes de widgets, dentro deste repositório estão 10 pacotes, o pacote CoolWidget, o pacote SuperWidget, etc. A WackyWidgets hospeda este repositório em um link de origem chamado: http://download.widgets/linux/deb/\n\nAgora, em vez de ir ao site deles para baixar o pacote diretamente, você pode dizer à sua máquina para encontrar o software WackyWidgets a partir do link de origem. \n\nSua distribuição já vem com fontes pré-aprovadas para obter pacotes e é assim que instala todos os pacotes base que você vê no seu sistema. Em um sistema Debian, este arquivo de fontes é o arquivo <b>/etc/apt/sources.list</b>. Sua máquina saberá procurar lá e verificar se há algum repositório de origem que você adicionou.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Onde está o arquivo de fontes em um sistema Debian?",
          "slug": "repositoriosdepacotes",
          "title": "Repositórios de Pacotes"
        },
        {
          "exercise": "Familiarize-se com a documentação do tar e veja as outras opções disponíveis na página de manual.",
          "id": 3,
          "lessonContent": "Antes de entrarmos na instalação de pacotes e nos diferentes gerenciadores, precisamos discutir a arquivamento e compressão de arquivos, pois você provavelmente encontrará esses conceitos ao procurar software na internet. \n\nProvavelmente você já sabe o que é um arquivo compactado, provavelmente já encontrou tipos de arquivos como .rar e .zip. Estes são arquivos compactados, contêm muitos arquivos dentro deles, mas são apresentados em um único arquivo conhecido como um arquivo compactado.\n\n<b>Compactando arquivos com gzip</b>\n\ngzip é um programa usado para compactar arquivos no Linux, eles têm a extensão .gz. \n\nPara compactar um arquivo:\n<pre>$ gzip meuarquivolegal</pre>\n\nPara descompactar o arquivo:\n<pre>$ gunzip meuarquivolegal.gz</pre>\n\n<b>Criando arquivos com tar</b>\nInfelizmente, o gzip não pode adicionar vários arquivos em um único arquivo compactado para nós. Felizmente, temos o programa tar que pode fazer isso. Quando você cria um arquivo usando tar, ele terá a extensão .tar. \n\n<pre>$ tar cvf meuarquivotar.tar meuarquivolegal1 meuarquivolegal2</pre>\n\n<ul>\n<li>c - criar</li>\n<li>v - diz ao programa para ser detalhado e nos mostrar o que está fazendo</li>\n<li>f - o nome do arquivo tar deve vir após esta opção, se você estiver criando um arquivo tar, terá que escolher um nome</li>\n</ul>\n\n<b>Descompactando arquivos com tar</b>\n\nPara extrair o conteúdo de um arquivo tar, use: \n\n<pre>$ tar xvf meuarquivotar.tar</pre>\n\n<ul>\n<li>x - extrair</li>\n<li>v - diz ao programa para ser detalhado e nos mostrar o que está fazendo</li>\n<li>f - o arquivo que deseja extrair</li>\n</ul>\n\n<b>Compactando/descompactando arquivos com tar e gzip</b>\n\nMuitas vezes você verá um arquivo tar que foi compactado, como por exemplo: meuarquivocomprimido.tar.gz, tudo o que você precisa fazer é trabalhar de fora para dentro, primeiro remova a compactação com gunzip e então você pode descompactar o arquivo tar. Ou você pode usar a opção <b>z</b> com o tar, que simplesmente diz para usar o utilitário gzip ou gunzip.\n\nCriar um arquivo tar compactado:\n<pre>$ tar czf meuarquivo.tar.gz</pre>\n\nDescompactar e extrair: \n<pre>$ tar xzf arquivo.tar</pre>\n\nSe precisar de ajuda, lembre-se disso: e<b>X</b>trair todos os <b>Z</b>íperes <b>F</b>icheiros!\n\ntar é um daqueles comandos tão importantes e ainda assim você nunca realmente se lembra, relevante xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Outros Utilitários</b>\n\nAo longo de sua jornada no Linux, você encontrará outros tipos de arquivamento e compressão, como: bzip2, compress, zip, unzip, etc. Eles são um pouco menos comuns, mas apenas tenha em mente que diferentes utilitários exigirão comandos diferentes.",
          "quizAnswer": "c",
          "quizQuestion": "Qual bandeira do tar é usada para criar arquivos?",
          "slug": "arquivocomprimidotar",
          "title": "tar and gzip"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 4,
          "lessonContent": "Pacotes raramente funcionam sozinhos, geralmente são acompanhados por dependências para ajudá-los a funcionar. Por exemplo, vamos dizer que temos um grupo de restaurantes, esses restaurantes preparam diferentes culinárias, no entanto, todos eles obtêm seus ingredientes da mesma fazenda. Sua comida depende do fornecimento da fazenda, se a fazenda parasse de fornecer comida de repente, os restaurantes estariam em maus lençóis. \n\nNo Linux, essas dependências são frequentemente outros pacotes ou bibliotecas compartilhadas. Bibliotecas compartilhadas são conjuntos de códigos que outros programas desejam usar e não querem ter que reescrever para si mesmos. Pense no restaurante novamente, quanto trabalho seria se cada restaurante também cultivasse sua própria comida? Muito.\n\nVamos explorar mais sobre bibliotecas compartilhadas no curso de sistema de arquivos, então por agora apenas lembre-se de que os pacotes têm dependências para ajudá-los a funcionar, se essas dependências forem outros pacotes ou bibliotecas, se as dependências não estiverem presentes, o pacote acabará em um estado quebrado e na maioria das vezes nem será instalado.",
          "quizAnswer": "",
          "quizQuestion": "Sem perguntas, continue!",
          "slug": "dependenciasdepacotes",
          "title": "Dependências de Pacotes"
        },
        {
          "exercise": "Encontre um programa que deseja instalar em seu sistema, como o Google Chrome, e instale-o usando um desses comandos.",
          "id": 5,
          "lessonContent": "Embora a maior parte deste curso seja sobre sistemas de gerenciamento de pacotes (os Batmans do gerenciamento de pacotes), não devemos esquecer dos Robins. Embora sejam muito úteis e confiáveis, eles não vêm com aquele doce batmóvel e cinto de utilidades.\n\nAssim como .exe é um arquivo executável único, o mesmo acontece com .deb e .rpm. Normalmente você não os veria se usasse repositórios de pacotes, mas se baixar pacotes diretamente, provavelmente os obterá nesses formatos populares. Obviamente, eles são exclusivos de suas distribuições, .deb para baseadas em Debian e .rpm para baseadas em Red Hat.\n\nPara instalar esses pacotes diretos, você pode usar os comandos de gerenciamento de pacotes: rpm e dpkg. Essas ferramentas são usadas para instalar arquivos de pacotes, no entanto, elas não instalarão as dependências do pacote, então se seu pacote tiver 10 dependências, você teria que instalar esses pacotes separadamente e então suas dependências e assim por diante. Como você pode ver, esse foi um dos motivos que trouxeram os sistemas de gerenciamento completos que discutiremos mais tarde.\n\nLembre-se de que haverá inúmeras vezes em que você precisará instalar, consultar ou verificar um pacote com uma dessas ferramentas, então lembre-se desses comandos. \n\n<b>Instalar um pacote</b>\n\n<pre>\nDebian: $ dpkg -i algum_pacote.deb\nRPM: $ rpm -i algum_pacote.rpm\n</pre>\n\nO <b>i</b> significa instalar. Você também pode usar o formato mais longo de --install. \n\n<b>Remover um pacote</b>\n\n<pre>\nDebian: $ dpkg -r algum_pacote.deb\nRPM: $ rpm -e algum_pacote.rpm\n</pre>\n\nDebian: <b>r</b> para remover\nRPM: <b>e</b> para apagar\n\n<b>Listar pacotes instalados</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> para listar\nRPM: <b>q</b> para consultar e <b>a</b> para todos",
          "quizAnswer": "dpkg",
          "quizQuestion": "Qual é a ferramenta de gerenciamento de pacotes para arquivos .deb?",
          "slug": "ferramentasinstalacaopacote",
          "title": "rpm e dpkg"
        },
        {
          "exercise": "Execute cada um desses comandos de pacote e veja a saída que você recebe.",
          "id": 6,
          "lessonContent": "Ah, os Batmans da gestão de pacotes, esses sistemas vêm com todos os ingredientes para tornar a instalação, remoção e alterações de pacotes mais fáceis, incluindo a instalação de dependências de pacotes. Dois dos sistemas de gestão mais populares são <b>yum</b> e <b>apt</b>. Yum é exclusivo da família Red Hat e apt é exclusivo da família Debian.\n\n<b>Instalar um pacote de um repositório</b>\n\n<pre>\nDebian: $ apt install nome_do_pacote\nRPM: $ yum install nome_do_pacote\n</pre>\n\n<b>Remover um pacote</b>\n\n<pre>\nDebian: $ apt remove nome_do_pacote\nRPM: $ yum erase nome_do_pacote\n</pre>\n\n<b>Atualizar pacotes de um repositório</b>\n\nÉ sempre uma boa prática atualizar seus repositórios de pacotes para que estejam atualizados antes de instalar e atualizar um pacote. \n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Obter informações sobre um pacote instalado</b>\n\n<pre>\nDebian: apt show nome_do_pacote\nRPM: yum info nome_do_pacote\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Qual comando é usado para mostrar informações do pacote em um sistema Debian?",
          "slug": "sistemasdegestaodepacotes",
          "title": "yum e apt"
        },
        {
          "exercise": "Encontre um programa de código fonte (de um site confiável) e instale a partir do código fonte.",
          "id": 7,
          "lessonContent": "Muitas vezes você encontrará um pacote obscuro que só está disponível na forma de código fonte puro. Você precisará usar alguns comandos para compilar e instalar esse pacote de código fonte no seu sistema. \n\nPrimeiramente, você precisará ter o software para instalar as ferramentas que permitirão compilar o código fonte. \n\n<pre>$ sudo apt install build-essential</pre>\n\nDepois de fazer isso, extraia o conteúdo do arquivo do pacote, provavelmente um arquivo .tar.gz. \n\n<pre>$ tar -xzvf pacote.tar.gz</pre>\n\nAntes de fazer qualquer coisa, dê uma olhada no arquivo README ou INSTALL dentro do pacote. Às vezes, haverá instruções de instalação específicas. \n\nDependendo do método de compilação que o desenvolvedor usou, você terá que usar diferentes comandos, como cmake ou algo diferente.\n\nNo entanto, mais comumente você verá a compilação básica com make, então vamos discutir isso:\n\nDentro do conteúdo do pacote haverá um script de configuração, esse script verifica as dependências no seu sistema e se estiver faltando algo, você verá um erro e precisará corrigir essas dependências. \n\n<pre>$ ./configure</pre>\n\nO <b>./</b> permite que você execute um script no diretório atual. \n\n<pre>$ make</pre>\n\nDentro do conteúdo do pacote, há um arquivo chamado Makefile que contém regras para construir o software. Quando você executa o comando make, ele olha para este arquivo para construir o software.\n\n<pre>$ sudo make install</pre>\n\nEste comando realmente instala o pacote, ele copiará os arquivos corretos para as localizações corretas no seu computador.\n\nSe você quiser desinstalar o pacote, use:\n\n<pre>$ sudo make uninstall</pre>\n\nTenha cuidado ao usar make install, você pode não perceber o quanto está acontecendo nos bastidores. Se decidir remover este pacote, talvez não remova realmente tudo porque não percebeu o que foi adicionado ao seu sistema. Em vez disso, esqueça tudo sobre make install que eu acabei de explicar e use o comando <b>checkinstall</b>. Este comando criará um arquivo .deb para você que pode ser facilmente instalado e desinstalado. \n\n<pre>$ sudo checkinstall</pre> \n\nEste comando essencialmente \"faz a instalação\" e constrói um pacote .deb e o instala. Isso facilita a remoção do pacote posteriormente.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "O que você deve usar sempre no lugar de make install?",
          "slug": "compilarcodigofonte",
          "title": "Compilar Código Fonte"
        }
      ],
      "slug": "pacotes",
      "title": "Pacotes"
    },
    {
      "description": "Aprenda sobre os dispositivos Linux e como eles interagem com o kernel e o espaço do usuário.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Confira o conteúdo do diretório /dev, reconhece algum dispositivo familiar?",
          "id": 1,
          "lessonContent": "Quando você conecta um dispositivo à sua máquina, geralmente ele precisa de um driver de dispositivo para funcionar corretamente. Você pode interagir com drivers de dispositivo através de arquivos de dispositivo ou nós de dispositivo, que são arquivos especiais que se parecem com arquivos regulares. Como esses arquivos de dispositivo são como arquivos regulares, você pode usar programas como ls, cat, etc para interagir com eles. Esses arquivos de dispositivo geralmente são armazenados no diretório /dev. Vá em frente e liste o diretório /dev em seu sistema, você verá uma grande quantidade de arquivos de dispositivos em seu sistema. \n\n<pre>$ ls /dev </pre>\n\nAlguns desses dispositivos você já usou e interagiu, como por exemplo /dev/null. Lembre-se que quando enviamos a saída para /dev/null, o kernel sabe que esse dispositivo recebe toda a nossa entrada e simplesmente a descarta, então nada é retornado.\n\nNos velhos tempos, se você quisesse adicionar um dispositivo ao seu sistema, você adicionaria o arquivo de dispositivo em /dev e provavelmente esqueceria sobre ele. Bem, repita isso algumas vezes e você verá onde estava o problema. O diretório /dev ficaria cheio de arquivos de dispositivos estáticos de dispositivos que você já atualizou, parou de usar, etc. Os dispositivos também são atribuídos arquivos de dispositivo na ordem em que o kernel os encontra. Então, se toda vez que você reiniciasse seu sistema, os dispositivos poderiam ter arquivos de dispositivo diferentes dependendo de quando foram descobertos.\n\nFelizmente, não usamos mais esse método, agora temos algo que usamos para adicionar e remover dinamicamente dispositivos que estão sendo usados no sistema e discutiremos isso nas próximas lições.",
          "quizAnswer": "/dev",
          "quizQuestion": "Onde os arquivos de dispositivo são armazenados no sistema?",
          "slug": "devdirectory",
          "title": "/dev diretório"
        },
        {
          "exercise": "Olhe para o seu diretório /dev e descubra que tipos de dispositivos você pode ver.",
          "id": 2,
          "lessonContent": "Antes de conversarmos sobre como os dispositivos são gerenciados, vamos dar uma olhada em alguns dispositivos.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nAs colunas são as seguintes da esquerda para a direita:\n\n<ul>\n<li>Permissões</li>\n<li>Proprietário</li>\n<li>Grupo</li>\n<li>Número do Dispositivo Principal</li>\n<li>Número do Dispositivo Secundário</li>\n<li>Timestamp</li>\n<li>Nome do Dispositivo</li>\n</ul>\n\nLembre-se de que no comando ls você pode ver o tipo de arquivo com o primeiro bit de cada linha. Arquivos de dispositivo são indicados da seguinte forma: \n\n<ul>\n<li>c - caractere</li>\n<li>b - bloco</li>\n<li>p - pipe</li>\n<li>s - socket</li>\n</ul>\n\n<b>Dispositivo de Caractere</b>\n\nEsses dispositivos transferem dados, mas um caractere de cada vez. Você verá muitos dispositivos pseudo (/dev/null) como dispositivos de caractere, esses dispositivos não estão realmente conectados fisicamente à máquina, mas permitem uma maior funcionalidade ao sistema operacional. \n\n<b>Dispositivo de Bloco</b>\n\nEsses dispositivos transferem dados, mas em blocos grandes de tamanho fixo. Você verá mais comumente dispositivos que utilizam blocos de dados como dispositivos de bloco, como discos rígidos, sistemas de arquivos, etc. \n\n<b>Dispositivo de Pipe</b>\n\nOs pipes nomeados permitem que dois ou mais processos se comuniquem entre si, sendo semelhantes aos dispositivos de caractere, mas em vez de ter a saída enviada para um dispositivo, ela é enviada para outro processo. \n\n<b>Dispositivo de Socket</b>\n\nOs dispositivos de socket facilitam a comunicação entre processos, semelhante aos dispositivos de pipe, mas podem se comunicar com vários processos ao mesmo tempo. \n\n<b>Caracterização do Dispositivo</b>\n\nOs dispositivos são caracterizados usando dois números, <b>número do dispositivo principal</b> e <b>número do dispositivo secundário</b>. Você pode ver esses números no exemplo de ls acima, eles são separados por uma vírgula. Por exemplo, digamos que um dispositivo tivesse os números de dispositivo: <b>8, 0</b>:\n\nO número do dispositivo principal representa o driver do dispositivo que está sendo usado, neste caso 8, que é frequentemente o número principal para dispositivos de bloco sd. O número secundário informa ao kernel qual dispositivo único é nessa classe de driver, neste caso 0 é usado para representar o primeiro dispositivo (a).",
          "quizAnswer": "c",
          "quizQuestion": "Qual é o símbolo para dispositivos de caractere no comando ls -l?",
          "slug": "tiposdedispositivos",
          "title": "tipos de dispositivos"
        },
        {
          "exercise": "Escreva nos dispositivos pseudo e veja o que acontece, tenha cuidado para não gravar em seus discos nesses dispositivos!",
          "id": 3,
          "lessonContent": "Aqui estão os nomes de dispositivos mais comuns que você encontrará: \n\n<b>Dispositivos SCSI</b>\n\nSe você tiver algum tipo de armazenamento em massa em sua máquina, é provável que esteja usando o protocolo SCSI (pronunciado \"scuzzy\"). SCSI significa Interface de Sistema de Computador Pequeno, é um protocolo usado para permitir a comunicação entre discos, impressoras, scanners e outros periféricos com seu sistema. Você pode ter ouvido falar de dispositivos SCSI que na verdade não estão em uso em sistemas modernos, no entanto, nossos sistemas Linux correspondem discos SCSI com unidades de disco rígido em /dev. Eles são representados por um prefixo de sd (disco SCSI):\n\nArquivos de dispositivo SCSI comuns:\n\n<ul>\n<li>/dev/sda - Primeiro disco rígido</li>\n<li>/dev/sdb - Segundo disco rígido</li>\n<li>/dev/sda3 - Terceira partição no primeiro disco rígido</li>\n</ul>\n\n<b>Dispositivos Pseudo</b>\n\nComo discutimos anteriormente, dispositivos pseudo não estão realmente conectados fisicamente ao seu sistema, os dispositivos pseudo mais comuns são dispositivos de caractere: \n\n<ul>\n<li>/dev/zero - aceita e descarta toda entrada, produz uma sequência contínua de bytes NULL (valor zero)</li>\n<li>/dev/null - aceita e descarta toda entrada, não produz saída</li>\n<li>/dev/random - produz números aleatórios</li>\n</ul>\n\n<b>Dispositivos PATA</b>\n\nÀs vezes, em sistemas mais antigos, você pode ver unidades de disco rígido sendo referidas com um prefixo hd: \n\n<ul>\n<li>/dev/hda - Primeiro disco rígido</li>\n<li>/dev/hdd2 - Segunda partição no 4º disco rígido</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "Qual seria comumente o nome do dispositivo para a primeira partição no segundo disco SCSI?",
          "slug": "nomesdedispositivos",
          "title": "Nomes de Dispositivos"
        },
        {
          "exercise": "Verifique o conteúdo do diretório /sys e veja quais arquivos estão localizados lá.",
          "id": 4,
          "lessonContent": "Sysfs foi criado há muito tempo para gerenciar melhor dispositivos em nosso sistema que o diretório /dev falhou em fazer. Sysfs é um sistema de arquivos virtual, mais frequentemente montado no diretório /sys. Ele nos fornece informações mais detalhadas do que seríamos capazes de ver no diretório /dev. Ambos os diretórios /sys e /dev parecem ser muito semelhantes e são em alguns aspectos, mas eles têm diferenças importantes. Basicamente, o diretório /dev é simples, permite que outros programas acessem os dispositivos em si, enquanto o sistema de arquivos /sys é usado para visualizar informações e gerenciar o dispositivo. \n\nO sistema de arquivos /sys basicamente contém todas as informações de todos os dispositivos em seu sistema, como o fabricante e modelo, onde o dispositivo está conectado, o estado do dispositivo, a hierarquia dos dispositivos e muito mais. Os arquivos que você vê aqui não são nós de dispositivo, então você não interage realmente com dispositivos a partir do diretório /sys, mas sim está gerenciando dispositivos. \n\nDê uma olhada no conteúdo do diretório /sys:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "Qual diretório é usado para visualizar informações detalhadas sobre dispositivos?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Execute o comando udevadm fornecido e verifique a entrada.",
          "id": 5,
          "lessonContent": "Nos velhos tempos e na verdade até hoje, se você realmente quisesse, você criaria nós de dispositivo usando um comando como: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nEste comando irá criar um nó de dispositivo /dev/sdb1 e o tornará um dispositivo de bloco (b) com um número major de 8 e um número minor de 3.\n\nPara remover um dispositivo, você simplesmente <b>rm</b> o arquivo do dispositivo no diretório /dev. \n\nFelizmente, realmente não precisamos mais fazer isso por causa do udev. O sistema udev cria e remove dinamicamente arquivos de dispositivo para nós, dependendo se estão conectados ou não. Há um daemon udevd que está em execução no sistema e ele escuta mensagens do kernel sobre dispositivos conectados ao sistema. Udevd irá analisar essas informações e irá corresponder os dados com as regras especificadas em /etc/udev/rules.d, dependendo dessas regras provavelmente criará nós de dispositivo e links simbólicos para os dispositivos. Você pode escrever suas próprias regras udev, mas isso foge um pouco do escopo desta lição. Felizmente, seu sistema já vem com muitas regras udev, então você talvez nunca precise escrever as suas próprias.\n\nVocê também pode visualizar o banco de dados udev e sysfs usando o comando <b>udevadm</b>. Esta ferramenta é muito útil, mas às vezes pode ficar muito confusa, um comando simples para visualizar informações de um dispositivo seria:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "O que adiciona e remove dispositivos dinamicamente?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Experimente cada um desses comandos e veja a saída que você recebe.",
          "id": 6,
          "lessonContent": "Assim como usaríamos o comando ls para listar arquivos e diretórios, podemos usar ferramentas semelhantes que listam informações sobre dispositivos.\n\n<b>Listando Dispositivos USB</b>\n\n<pre>$ lsusb </pre>\n\n<b>Listando Dispositivos PCI</b>\n\n<pre>$ lspci </pre>\n\n<b>Listando Dispositivos SCSI</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "Qual comando pode ser usado para visualizar dispositivos usb?",
          "slug": "listagemdispositivos",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Use o comando dd para fazer um backup do seu drive e defina a saída para um arquivo .img.",
          "id": 7,
          "lessonContent": "A ferramenta dd é super útil para converter e copiar dados. Ele lê a entrada de um arquivo ou fluxo de dados e escreve em um arquivo ou fluxo de dados. \n\nConsidere o seguinte comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nEste comando está copiando o conteúdo de backup.img para /dev/sdb. Ele copiará os dados em blocos de 1024 bytes até que não haja mais dados para serem copiados. \n\n<ul>\n<li>if=arquivo - Arquivo de entrada, lê de um arquivo em vez da entrada padrão</li>\n<li>of=arquivo - Arquivo de saída, escreve em um arquivo em vez da saída padrão</li>\n<li>bs=bytes - Tamanho do bloco, lê e escreve essa quantidade de bytes de dados de cada vez. Você pode usar diferentes métricas de tamanho denotando o tamanho com k para kilobyte, m para megabyte, etc, então 1024 bytes é 1k</li>\n<li>count=número - Número de blocos a serem copiados.</li>\n</ul>\n\nVocê verá alguns comandos dd que usam a opção count, geralmente com dd if você deseja copiar um arquivo que é 1 megabyte, geralmente desejará ver esse arquivo como 1 megabyte quando terminar de ser copiado. Digamos que você execute o seguinte comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nNosso arquivo backup.img tem 10M, no entanto, estamos dizendo neste comando para copiar 1M 2 vezes, então apenas 2M está sendo copiado, deixando nossos dados copiados incompletos. Count pode ser útil em muitas situações, mas se você está apenas copiando dados, pode praticamente omitir count e até mesmo bs. Se você realmente deseja otimizar suas transferências de dados, então você vai querer começar a usar essas opções.\n\ndd é extremamente poderoso, você pode usá-lo para fazer backups de qualquer coisa, incluindo discos inteiros, restaurar imagens de disco e muito mais. Tenha cuidado, essa ferramenta poderosa pode ter um preço se você não souber o que está fazendo.",
          "quizAnswer": "bs",
          "quizQuestion": "Qual é a opção do dd para o tamanho do bloco?",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Dispositivos"
    },
    {
      "description": "Aprenda sobre o sistema de arquivos do Linux, os diferentes tipos de sistemas de arquivos, particionamento e muito mais.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Olhe dentro do seu diretório /usr, que tipo de informações estão localizadas lá?",
          "id": 1,
          "lessonContent": "Neste ponto, você provavelmente está bem familiarizado com a estrutura de diretórios do seu sistema, se não estiver, em breve estará. Os sistemas de arquivos podem variar quanto à sua estrutura, mas em sua maior parte devem estar em conformidade com o Padrão de Hierarquia do Sistema de Arquivos. \n\nVá em frente e execute um <b>ls -l /</b> para ver os diretórios listados sob o diretório raiz, o seu pode parecer diferente do meu, mas os diretórios devem, em sua maior parte, se parecer com o seguinte:\n\n<ul>\n<li>/ - O diretório raiz de toda a hierarquia do sistema de arquivos, tudo está aninhado sob este diretório.</li>\n<li>/bin - Programas essenciais prontos para serem executados (binários), inclui os comandos mais básicos como ls e cp.</li>\n<li>/boot - Contém arquivos do carregador de inicialização do kernel.</li>\n<li>/dev - Arquivos de dispositivo.</li>\n<li>/etc - Diretório de configuração do sistema central, deve conter apenas arquivos de configuração e não binários.</li>\n<li>/home - Diretórios pessoais para usuários, armazena seus documentos, arquivos, configurações, etc.</li>\n<li>/lib - Armazena arquivos de biblioteca que binários podem usar.</li>\n<li>/media - Usado como ponto de conexão para mídias removíveis como pen drives USB.</li>\n<li>/mnt - Sistemas de arquivos montados temporariamente.</li>\n<li>/opt - Pacotes de software de aplicativos opcionais.</li>\n<li>/proc - Informações sobre os processos em execução atualmente.</li>\n<li>/root - Diretório pessoal do usuário root.</li>\n<li>/run - Informações sobre o sistema em execução desde a última inicialização.</li>\n<li>/sbin - Contém binários essenciais do sistema, geralmente só podem ser executados pelo root.</li>\n<li>/srv - Dados específicos do site que são servidos pelo sistema.</li>\n<li>/tmp - Armazenamento para arquivos temporários.</li>\n<li>/usr - Infelizmente nomeado, na maioria das vezes não contém arquivos de usuário no sentido de uma pasta pessoal. Destina-se a software e utilitários instalados pelo usuário, no entanto, isso não impede que você adicione diretórios pessoais lá. Dentro deste diretório estão subdiretórios para /usr/bin, /usr/local, etc.</li>\n<li>/var - Diretório variável, é usado para registro do sistema, rastreamento de usuários, caches, etc. Basicamente qualquer coisa que está sujeita a mudanças o tempo todo.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "Em qual diretório são armazenados os logs?",
          "slug": "hierarquiadosistemaarquivos",
          "title": "Hierarquia do Sistema de Arquivos"
        },
        {
          "exercise": "Faça um pouco de pesquisa online sobre os outros tipos de sistemas de arquivos: ReiserFS, ZFS, JFS e outros que você encontrar.",
          "id": 2,
          "lessonContent": "Existem muitas implementações de sistemas de arquivos disponíveis. Alguns são mais rápidos do que outros, alguns suportam armazenamento de maior capacidade e outros funcionam apenas em armazenamentos de capacidade menor. Diferentes sistemas de arquivos têm maneiras diferentes de organizar seus dados e vamos detalhar quais tipos de sistemas de arquivos existem. Como há tantas implementações diferentes disponíveis, as aplicações precisam de uma maneira de lidar com as diferentes operações. Então existe algo chamado de camada de abstração do Sistema de Arquivos Virtual (VFS). É uma camada entre as aplicações e os diferentes tipos de sistemas de arquivos, para que, não importa qual sistema de arquivos você tenha, suas aplicações consigam trabalhar com ele. \n\nVocê pode ter muitos sistemas de arquivos em seus discos, dependendo de como eles estão particionados e vamos abordar isso em uma próxima lição.\n\n<b>Journaling</b>\n\nO journaling vem por padrão na maioria dos tipos de sistemas de arquivos, mas caso não tenha, você deve saber o que ele faz. Digamos que você esteja copiando um arquivo grande e de repente perca energia. Bem, se estiver em um sistema de arquivos sem journaling, o arquivo acabaria corrompido e seu sistema de arquivos ficaria inconsistente e então, quando você reiniciar, seu sistema fará uma verificação do sistema de arquivos para garantir que tudo está ok. No entanto, os reparos podem demorar dependendo do tamanho do seu sistema de arquivos. \n\nAgora, se você estivesse em um sistema com journaling, antes mesmo de sua máquina começar a copiar o arquivo, ele escreverá o que você vai fazer em um arquivo de log (journal). Agora, quando você realmente copiar o arquivo, uma vez concluído, o journal marca essa tarefa como concluída. O sistema de arquivos está sempre em um estado consistente por causa disso, então ele saberá exatamente onde você parou se sua máquina desligar repentinamente. Isso também diminui o tempo de inicialização, pois em vez de verificar o sistema de arquivos inteiro, ele apenas olha para o seu journal.\n\n<b>Tipos Comuns de Sistemas de Arquivos de Desktop</b>\n\n<ul>\n<li>ext4 - Esta é a versão mais atual dos sistemas de arquivos nativos do Linux. É compatível com as versões mais antigas ext2 e ext3. Suporta volumes de disco de até 1 exabyte e tamanhos de arquivo de até 16 terabytes e muito mais. É a escolha padrão para sistemas de arquivos do Linux.</li>\n<li>Btrfs - \"Better or Butter FS\", é um novo sistema de arquivos para o Linux que vem com snapshots, backups incrementais, aumento de desempenho e muito mais. Está amplamente disponível, mas ainda não é totalmente estável e compatível.</li>\n<li>XFS - Sistema de arquivos de journaling de alto desempenho, ótimo para um sistema com arquivos grandes, como um servidor de mídia.</li>\n<li>NTFS e FAT - Sistemas de arquivos do Windows</li>\n<li>HFS+ - Sistema de arquivos do Macintosh</li>\n</ul>\n\nConfira quais sistemas de arquivos estão em sua máquina: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nO comando <b>df</b> relata o uso do espaço em disco do sistema de arquivos e outros detalhes sobre seu disco, falaremos mais sobre essa ferramenta posteriormente.",
          "quizAnswer": "ext4",
          "quizQuestion": "Qual é o tipo comum de sistema de arquivos do Linux?",
          "slug": "tipos-de-sistemas-de-arquivos",
          "title": "Tipos de Sistemas de Arquivos"
        },
        {
          "exercise": "Execute <b>parted -l</b> em sua máquina e avalie seus resultados.",
          "id": 3,
          "lessonContent": "Os discos rígidos podem ser subdivididos em partições, essencialmente criando vários dispositivos de bloco. Lembre-se de exemplos como, /dev/sda1 e /dev/sda2, /dev/sda é o disco inteiro, mas /dev/sda1 é a primeira partição nesse disco. As partições são extremamente úteis para separar dados e, se você precisar de um determinado sistema de arquivos, pode facilmente criar uma partição em vez de tornar o disco inteiro de um tipo de sistema de arquivos.\n\n<b>Tabela de Partições</b>\n\nCada disco terá uma tabela de partições, essa tabela informa ao sistema como o disco está particionado. Essa tabela informa onde as partições começam e terminam, quais partições são inicializáveis, quais setores do disco são alocados para qual partição, etc. Existem dois esquemas principais de tabela de partições usados, Registro de Inicialização Principal (MBR) e Tabela de Partição GUID (GPT).\n\n<b>Partição</b>\n\nOs discos são compostos por partições que nos ajudam a organizar nossos dados. Você pode ter várias partições em um disco e elas não podem se sobrepor umas às outras. Se houver espaço que não está alocado para uma partição, então é conhecido como espaço livre. Os tipos de partições dependem da sua tabela de partições. Dentro de uma partição, você pode ter um sistema de arquivos ou dedicar uma partição a outras coisas como swap (falaremos sobre isso em breve).\n\n<i>MBR</i>\n\n<ul>\n<li>Tabela de partição tradicional, era usada como padrão</li>\n<li>Pode ter partições primárias, estendidas e lógicas</li>\n<li>O MBR tem um limite de quatro partições primárias</li>\n<li>Partições adicionais podem ser feitas transformando uma partição primária em uma partição estendida (só pode haver uma partição estendida em um disco). Em seguida, dentro da partição estendida, você adiciona partições lógicas. As partições lógicas são usadas como qualquer outra partição. Bobo, eu sei.</li>\n<li>Suporta discos de até 2 terabytes</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>A Tabela de Partição GUID (GPT) está se tornando o novo padrão para particionamento de disco</li>\n<li>Possui apenas um tipo de partição e você pode criar muitas delas</li>\n<li>Cada partição tem um ID globalmente único (GUID)</li>\n<li>Usado principalmente em conjunto com inicialização baseada em UEFI (entraremos em detalhes em outro curso)</li>\n</ul>\n\n<b>Estrutura do Sistema de Arquivos</b>\n\nSabemos de nossa lição anterior que um sistema de arquivos é uma coleção organizada de arquivos e diretórios. Em sua forma mais simples, é composto por um banco de dados para gerenciar arquivos e os próprios arquivos, no entanto, vamos entrar em um pouco mais de detalhes.\n\n<ul>\n<li>Bloco de inicialização - Este está localizado nos primeiros setores do sistema de arquivos e não é realmente usado pelo sistema de arquivos. Em vez disso, contém informações usadas para inicializar o sistema operacional. Apenas um bloco de inicialização é necessário pelo sistema operacional. Se você tiver várias partições, elas terão blocos de inicialização, mas muitos deles não são usados.</li>\n<li>Bloco super - Este é um bloco único que vem após o bloco de inicialização e contém informações sobre o sistema de arquivos, como o tamanho da tabela de inode, o tamanho dos blocos lógicos e o tamanho do sistema de arquivos.</li>\n<li>Tabela de inode - Pense nisso como o banco de dados que gerencia nossos arquivos (temos uma lição inteira sobre inodes, então não se preocupe). Cada arquivo ou diretório tem uma entrada única na tabela de inode e possui várias informações sobre o arquivo.</li>\n<li>Blocos de dados - Estes são os dados reais dos arquivos e diretórios.</li>\n</ul>\n\nVamos dar uma olhada nas diferentes tabelas de partições. Abaixo está um exemplo de uma partição usando a tabela de partições MBR (msdos). Você pode ver as partições primárias, estendidas e lógicas na máquina.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModelo: Seagate (scsi)\nDisco /dev/sda: 21.5GB\nTamanho do setor (lógico/físico): 512B/512B\nTabela de Partições: msdos\n\nNúmero  Início   Fim     Tamanho  Tipo      Sistema de arquivos     Flags\n 1      1049kB  6860MB  6859MB  primária   ext4                    boot\n 2      6861MB  21.5GB  14.6GB  estendida\n 5      6861MB  7380MB  519MB   lógica    linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  lógica    xfs\n</pre>\n\n\nEste exemplo é GPT, usando apenas um ID único para as partições.\n\n<pre>\nModelo: Thumb Drive (scsi)\nDisco /dev/sdb: 4041MB\nTamanho do setor (lógico/físico): 512B/512B\nTabela de Partições: gpt\n\nNúmero  Início   Fim     Tamanho   Sistema de arquivos  Nome        Flags\n 1      17.4kB  1000MB  1000MB                  primeiro\n 2      1000MB  4040MB  3040MB                  segundo\n</pre>",
          "quizAnswer": "estendida",
          "quizQuestion": "Que tipo de partição é usada para criar mais de 4 partições no esquema de particionamento MBR?",
          "slug": "anatomia-de-um-disco",
          "title": "Anatomia de um Disco"
        },
        {
          "exercise": "Particionar uma unidade USB com metade do disco como ext4 e a outra metade como espaço livre.",
          "id": 4,
          "lessonContent": "Vamos fazer algumas coisas práticas com sistemas de arquivos trabalhando no processo em uma unidade USB. Se você não tiver uma, não se preocupe, você ainda pode acompanhar as próximas lições. \n\nPrimeiro, precisamos particionar nosso disco. Existem muitas ferramentas disponíveis para fazer isso: \n\n<ul>\n<li>fdisk - ferramenta básica de particionamento de linha de comando, não suporta GPT</li>\n<li>parted - esta é uma ferramenta de linha de comando que suporta particionamento MBR e GPT</li>\n<li>gparted - esta é a versão GUI do parted</li>\n<li>gdisk - fdisk, mas não suporta MBR, apenas GPT</li>\n</ul>\n\nVamos usar o parted para fazer nosso particionamento. Digamos que eu conecte o dispositivo USB e vejamos que o nome do dispositivo é /dev/sdb2. \n\n<b>Iniciar o parted</b>\n\n<pre>$ sudo parted</pre>\n\nVocê entrará na ferramenta parted, onde poderá executar comandos para particionar seu dispositivo. \n\n<b>Selecionar o dispositivo</b>\n\n<pre>select /dev/sdb2</pre>\n\nPara selecionar o dispositivo com o qual você estará trabalhando, selecione-o pelo nome do dispositivo.\n\n<b>Visualizar a tabela de partições atual</b>\n\n<pre>\n(parted) print                                                            \nModelo: Seagate (scsi)\nDisco /dev/sda: 21.5GB\nTamanho do setor (lógico/físico): 512B/512B\nTabela de Partições: msdos\n\nNúmero  Início   Fim     Tamanho  Tipo      Sistema de arquivos     Flags\n 1      1049kB  6860MB  6859MB  primária   ext4                    boot\n 2      6861MB  21.5GB  14.6GB  estendida\n 5      6861MB  7380MB  519MB   lógica    linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  lógica    xfs\n</pre>\n\nAqui você verá as partições disponíveis no dispositivo. Os pontos de <b>início</b> e <b>fim</b> são onde as partições ocupam espaço no disco rígido, você deve encontrar um bom local de início e fim para suas partições. \n\n<b>Particionar o dispositivo</b>\n\n<pre>mkpart primária 123 4567</pre>\n\nAgora basta escolher um ponto de início e fim e fazer a partição, você precisará especificar o tipo de partição dependendo da tabela que você usou. \n\n<b>Redimensionar uma partição</b>\n\nVocê também pode redimensionar uma partição se não tiver espaço. \n\n<pre>resize 2 1245 3456</pre>\n\nSelecione o número da partição e, em seguida, os pontos de início e fim para onde deseja redimensioná-la. \n\nO parted é uma ferramenta muito poderosa e você deve ter cuidado ao particionar seus discos.",
          "quizAnswer": "mkpart",
          "quizQuestion": "Qual é o comando do parted para fazer uma partição?",
          "slug": "particionamentodedisco",
          "title": "Particionamento de Disco"
        },
        {
          "exercise": "Faça um sistema de arquivos ext4 na unidade USB.",
          "id": 5,
          "lessonContent": "Agora que você realmente particionou um disco, vamos criar um sistema de arquivos!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nSimples assim! A ferramenta <b>mkfs</b> (make filesystem) nos permite especificar o tipo de sistema de arquivos que queremos e onde queremos. Você só vai querer criar um sistema de arquivos em um disco recém-particionado ou se estiver reparticionando um antigo. Provavelmente deixará seu sistema de arquivos em um estado corrompido se tentar criar um em cima de um existente.",
          "quizAnswer": "mkfs",
          "quizQuestion": "Qual comando é usado para criar um sistema de arquivos?",
          "slug": "criandosistemasdearquivos",
          "title": "Criando Sistemas de Arquivos"
        },
        {
          "exercise": "Olhe a página de manual para mount e umount e veja quais outras opções você pode usar.",
          "id": 6,
          "lessonContent": "Antes de poder visualizar o conteúdo do seu sistema de arquivos, você terá que montá-lo. Para fazer isso, vou precisar da localização do dispositivo, do tipo de sistema de arquivos e de um ponto de montagem, o ponto de montagem é um diretório no sistema onde o sistema de arquivos será anexado. Então, basicamente queremos montar nosso dispositivo em um ponto de montagem. \n\nPrimeiro crie o ponto de montagem, no nosso caso <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nSimples assim! Agora, quando formos para /mydrive, podemos ver o conteúdo do nosso sistema de arquivos, o <b>-t</b> especifica o tipo de sistema de arquivos, em seguida, temos a localização do dispositivo e, por fim, o ponto de montagem. \n\nPara desmontar um dispositivo de um ponto de montagem: \n\n<pre>$ sudo umount /mydrive \nou \n$ sudo umount /dev/sdb2</pre>\n\nLembre-se de que o kernel nomeia os dispositivos na ordem em que os encontra. E se o nome do nosso dispositivo mudar por algum motivo depois de montá-lo? Bem, felizmente, você pode usar o ID único universal (UUID) de um dispositivo em vez de um nome.\n\nPara visualizar os UUIDs no seu sistema para dispositivos de bloco:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nPodemos ver os nomes dos nossos dispositivos, seus tipos de sistema de arquivos correspondentes e seus UUIDs. Agora, quando quisermos montar algo, podemos usar:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nNa maioria das vezes, você não precisará montar dispositivos via seus UUIDs, é muito mais fácil usar o nome do dispositivo e muitas vezes o sistema operacional saberá montar dispositivos comuns como unidades USB. Se você precisar montar automaticamente um sistema de arquivos na inicialização, como se adicionasse um disco rígido secundário, você vai querer usar o UUID e vamos abordar isso na próxima lição.",
          "quizAnswer": "mount",
          "quizQuestion": "Qual comando é usado para anexar um sistema de arquivos?",
          "slug": "montagemedesmontagemdesistemasdearquivos",
          "title": "montar e desmontar"
        },
        {
          "exercise": "Adicione a unidade USB com a qual estamos trabalhando como uma entrada em /etc/fstab, quando reiniciar você ainda deverá vê-la montada.",
          "id": 7,
          "lessonContent": "Quando queremos montar automaticamente sistemas de arquivos na inicialização, podemos adicioná-los a um arquivo chamado /etc/fstab (pronunciado \"eff es tab\" e não \"eff stab\"), abreviação de tabela de sistema de arquivos. Este arquivo contém uma lista permanente de sistemas de arquivos que estão montados.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nCada linha representa um sistema de arquivos, os campos são: \n\n<ul>\n<li>UUID - Identificador do dispositivo</li>\n<li>Ponto de montagem - Diretório em que o sistema de arquivos está montado</li>\n<li>Tipo de sistema de arquivos</li>\n<li>Opções - outras opções de montagem, consulte a página do manual para mais detalhes</li>\n<li>Dump - usado pelo utilitário de backup para decidir quando fazer um backup, você deve apenas manter o padrão 0</li>\n<li>Pass - Usado pelo fsck para decidir a ordem em que os sistemas de arquivos devem ser verificados, se o valor for 0, ele não será verificado</li>\n</ul>\n\nPara adicionar uma entrada, basta modificar diretamente o arquivo /etc/fstab usando a sintaxe de entrada acima. Tenha cuidado ao modificar este arquivo, você poderia potencialmente tornar sua vida um pouco mais difícil se errar.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "Qual arquivo é usado para definir como os sistemas de arquivos devem ser montados?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Particionar o espaço livre na unidade USB para espaço de swap.",
          "id": 8,
          "lessonContent": "No nosso exemplo anterior, mostrei como ver a sua tabela de partições, vamos revisitar esse exemplo, mais especificamente esta linha:\n\n<pre>\nNúmero  Início   Fim     Tamanho    Tipo      Sistema de arquivos     Flags\n 5      6861MB  7380MB  519MB   lógico   linux-swap(v1)\n</pre>\n\nO que é esta partição de swap? Bem, swap é o que usamos para alocar memória virtual para o nosso sistema. Se estiver com pouca memória, o sistema usa esta partição para \"trocar\" pedaços de memória de processos inativos para o disco, para que não fique sem memória.\n\n<b>Usando uma partição para espaço de swap</b>\n\nDigamos que queremos definir nossa partição /dev/sdb2 para ser usada como espaço de swap. \n\n<ol>\n<li>Primeiro, certifique-se de que não há nada na partição</li>\n<li>Execute: mkswap /dev/sdb2 para inicializar as áreas de swap</li>\n<li>Execute: swapon /dev/sdb2 para ativar o dispositivo de swap</li>\n<li>Se deseja que a partição de swap persista na inicialização, é necessário adicionar uma entrada ao arquivo /etc/fstab. sw é o tipo de sistema de arquivos que você usará.</li>\n<li>Para remover a swap: swapoff /dev/sdb2</li>\n</ol>\n\nGeralmente, você deve alocar cerca de duas vezes mais espaço de swap do que a memória que possui. Mas os sistemas modernos de hoje geralmente são bastante poderosos e têm RAM suficiente como está.",
          "quizAnswer": "swapon",
          "quizQuestion": "Qual é o comando para ativar o espaço de swap em um dispositivo?",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "Olhe para o uso do disco e espaço livre com du e df.",
          "id": 9,
          "lessonContent": "Existem algumas ferramentas que você pode usar para ver a utilização de seus discos: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocos    Usado Disponível Uso% Montado em\n/dev/sda1       6.2G  2.3G  3.6G  40% /\n</pre>\n\nO comando df mostra a utilização de seus sistemas de arquivos atualmente montados. A bandeira -h fornece um formato legível para humanos. Você pode ver qual é o dispositivo, e quanto de capacidade está sendo usada e disponível. \n\nDigamos que seu disco esteja ficando cheio e você queira saber quais arquivos ou diretórios estão ocupando esse espaço, para isso você pode usar o comando <b>du</b>. \n\n<pre>$ du -h</pre>\n\nIsso mostra o uso do disco do diretório atual em que você está, você pode dar uma olhada no diretório raiz com <b>du -h /</b> mas isso pode ficar um pouco confuso.\n\nAmbos os comandos são tão semelhantes em sintaxe que pode ser difícil lembrar qual usar, para verificar quanto do seu <b>disco</b> está <b>livre</b> use df. Para verificar o <b>uso do disco</b>, use du.",
          "quizAnswer": "df",
          "quizQuestion": "Qual comando é usado para mostrar quanto espaço está livre em seu disco?",
          "slug": "uso-do-disco",
          "title": "Uso do Disco"
        },
        {
          "exercise": "Olhe a página de manual do fsck para ver o que mais ele pode fazer.",
          "id": 10,
          "lessonContent": "Às vezes, nosso sistema de arquivos nem sempre está na melhor condição, se tivermos um desligamento repentino, nossos dados podem se corromper. Cabe ao sistema tentar nos colocar de volta em um estado de funcionamento (embora certamente possamos tentar por nós mesmos). \n\nO comando <b>fsck</b> (verificação do sistema de arquivos) é usado para verificar a consistência de um sistema de arquivos e até mesmo tentar repará-lo para nós. Geralmente, quando você inicializa um disco, o fsck será executado antes que seu disco seja montado para garantir que tudo esteja ok. Às vezes, no entanto, seu disco está tão ruim que você precisará fazer isso manualmente. No entanto, certifique-se de fazer isso enquanto estiver em um disco de resgate ou em algum lugar onde possa acessar seu sistema de arquivos sem que ele esteja montado.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "Qual comando é usado para verificar a integridade de um sistema de arquivos?",
          "slug": "reparo-do-sistema-de-arquivos",
          "title": "Reparo do Sistema de Arquivos"
        },
        {
          "exercise": "Observe alguns números de inode para diferentes arquivos, quais costumam ser criados primeiro?",
          "id": 11,
          "lessonContent": "Lembra como nosso sistema de arquivos é composto por todos os nossos arquivos reais e um banco de dados que gerencia esses arquivos? O banco de dados é conhecido como a tabela de inode. \n\n<b>O que é um inode?</b>\n\nUm inode (nó de índice) é uma entrada nesta tabela e há um para cada arquivo. Ele descreve tudo sobre o arquivo, como:\n\n<ul>\n<li>Tipo de arquivo - arquivo regular, diretório, dispositivo de caractere, etc</li>\n<li>Proprietário</li>\n<li>Grupo</li>\n<li>Permissões de acesso</li>\n<li>Carimbos de data/hora - mtime (hora da última modificação do arquivo), ctime (hora da última alteração de atributo), atime (hora do último acesso)</li>\n<li>Número de links rígidos para o arquivo</li>\n<li>Tamanho do arquivo</li>\n<li>Número de blocos alocados para o arquivo</li>\n<li>Ponteiros para os blocos de dados do arquivo - mais importante!</li>\n</ul>\n\nBasicamente, os inodes armazenam tudo sobre o arquivo, exceto o nome do arquivo e o arquivo em si!\n\n<b>Quando os inodes são criados?</b>\n\nQuando um sistema de arquivos é criado, espaço para inodes também é alocado. Existem algoritmos que determinam quanto espaço de inode você precisa, dependendo do volume do disco e mais. Você provavelmente em algum momento da sua vida viu erros de falta de espaço em disco. Bem, o mesmo pode ocorrer com os inodes também (embora menos comum), você pode ficar sem inodes e, portanto, ser incapaz de criar mais arquivos. Lembre-se de que o armazenamento de dados depende tanto dos dados quanto do banco de dados (inodes). \n\nPara ver quantos inodes restam no seu sistema, use o comando <b>df -i</b>\n\n<b>Informações de Inode</b>\n\nOs inodes são identificados por números, quando um arquivo é criado, é atribuído um número de inode, o número é atribuído em ordem sequencial. No entanto, às vezes você pode notar que ao criar um novo arquivo, ele recebe um número de inode menor que outros, isso ocorre porque uma vez que os inodes são excluídos, eles podem ser reutilizados por outros arquivos. Para visualizar os números de inode, execute <b>ls -li</b>:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nO primeiro campo neste comando lista o número de inode.\n\nVocê também pode ver informações detalhadas sobre um arquivo com stat, ele fornece informações sobre o inode também.\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  Arquivo: ‘/home/pete/Desktop/’\n  Tamanho: 6               Blocos: 0          Bloco de E/S: 4096   diretório\nDispositivo: 806h/2054d      Inode: 140         Links: 2\nAcesso: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAcesso: 2016-01-20 20:13:50.647435982 -0800\nModificar: 2016-01-20 20:13:06.191675843 -0800\nAlterar: 2016-01-20 20:13:06.191675843 -0800\n Criação: -\n</pre>\n\n\n<b>Como os inodes localizam arquivos?</b>\n\nSabemos que nossos dados estão em algum lugar no disco, infelizmente provavelmente não foram armazenados sequencialmente, então temos que usar inodes. Os inodes apontam para os blocos de dados reais de seus arquivos. Em um sistema de arquivos típico (nem todos funcionam da mesma maneira), cada inode contém 15 ponteiros, os primeiros 12 ponteiros apontam diretamente para os blocos de dados. O 13º ponteiro aponta para um bloco contendo ponteiros para mais blocos, o 14º ponteiro aponta para outro bloco aninhado de ponteiros e o 15º ponteiro aponta novamente para outro bloco de ponteiros! Confuso, eu sei! A razão para fazer isso dessa maneira é manter a estrutura do inode a mesma para cada inode, mas ser capaz de referenciar arquivos de tamanhos diferentes. Se você tiver um arquivo pequeno, poderá encontrá-lo mais rapidamente com os primeiros 12 ponteiros diretos, arquivos maiores podem ser encontrados com os aninhamentos de ponteiros. De qualquer forma, a estrutura do inode é a mesma.",
          "quizAnswer": "df -i",
          "quizQuestion": "Como você vê quantos inodes restam no seu sistema?",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "Brinque fazendo symlinks e hardlinks, delete alguns e veja o que acontece.",
          "id": 12,
          "lessonContent": "Vamos usar um exemplo anterior de informações de inode: \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nVocê pode ter notado que temos ignorado o terceiro campo no comando ls, esse campo é o contador de links. O contador de links é o número total de links rígidos que um arquivo possui, bem, isso não significa nada para você agora. Então vamos falar sobre links primeiro. \n\n<b>Symlinks</b>\n\nNo sistema operacional Windows, existem coisas conhecidas como atalhos, atalhos são apenas aliases para outros arquivos. Se você fizer algo no arquivo original, você poderia potencialmente quebrar o atalho. No Linux, o equivalente a atalhos são os links simbólicos (ou links suaves ou symlinks). Symlinks nos permitem linkar para outro arquivo pelo seu nome de arquivo. Outro tipo de links encontrados no Linux são os hardlinks, que são na verdade outro arquivo com um link para um inode. Vamos ver o que quero dizer na prática começando com symlinks.\n\n<pre>\npete@icebox:~/Desktop$ echo 'meuarquivo' > meuarquivo\npete@icebox:~/Desktop$ echo 'meuarquivo2' > meuarquivo2\npete@icebox:~/Desktop$ echo 'meuarquivo3' > meuarquivo3\n\npete@icebox:~/Desktop$ ln -s meuarquivo meulink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 meuarquivo\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 meuarquivo2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 meuarquivo3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 meulink -> meuarquivo\n</pre>\n\nVocê pode ver que eu criei um link simbólico chamado meulink que aponta para meuarquivo. Os links simbólicos são indicados por ->. Note como eu obtive um novo número de inode, no entanto, symlinks são apenas arquivos que apontam para nomes de arquivos. Quando você modifica um symlink, o arquivo também é modificado. Os números de inode são únicos para sistemas de arquivos, você não pode ter dois do mesmo número de inode em um único sistema de arquivos, o que significa que você não pode referenciar um arquivo em um sistema de arquivos diferente pelo seu número de inode. No entanto, se você usar symlinks, eles não usam números de inode, eles usam nomes de arquivos, então podem ser referenciados em diferentes sistemas de arquivos. \n\n<b>Hardlinks</b>\n\nVamos ver um exemplo de um hardlink:\n\n<pre>\npete@icebox:~/Desktop$ ln meuarquivo2 meuhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 meuarquivo\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 meuarquivo2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 meuarquivo3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 meulink -> meuarquivo\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 meuhardlink\n</pre>\n\nUm hardlink apenas cria outro arquivo com um link para o mesmo inode. Então, se eu modificasse o conteúdo de meuarquivo2 ou meuhardlink, a mudança seria vista em ambos, mas se eu deletasse meuarquivo2, o arquivo ainda seria acessível através de meuhardlink. Aqui é onde entra em jogo o contador de links em o comando ls. O contador de links é o número de hardlinks que um inode possui, quando você remove um arquivo, ele diminuirá esse contador de links. O inode só é excluído quando todos os hardlinks para o inode forem excluídos. Quando você cria um arquivo, seu contador de links é 1 porque é o único arquivo que está apontando para aquele inode. Ao contrário dos symlinks, os hardlinks não abrangem sistemas de arquivos porque os inodes são únicos para o sistema de arquivos. \n\n<b>Criando um symlink</b>\n\n<pre>\n$ ln -s meuarquivo meulink</pre>\n\nPara criar um link simbólico, você usa o comando ln com -s para simbólico e especifica um arquivo de destino e depois um nome de link. \n\n<b>Criando um hardlink</b>\n\n<pre>\n$ ln algumArquivo algumLink</pre>\n\nSemelhante à criação de um symlink, exceto que desta vez você deixa de fora o -s.",
          "quizAnswer": "ln -s",
          "quizQuestion": "Qual é o comando usado para fazer um symlink?",
          "slug": "symlinks",
          "title": "symlinks"
        }
      ],
      "slug": "osistema-de-arquivos",
      "title": "O Sistema de Arquivos"
    },
    {
      "description": "Aprenda sobre as etapas do processo de inicialização do Linux.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Reinicie seu sistema e veja se consegue identificar cada etapa conforme sua máquina inicializa.",
          "id": 1,
          "lessonContent": "Agora que temos uma boa compreensão de alguns dos componentes importantes do Linux, vamos juntá-los aprendendo sobre como o sistema inicializa. Quando você liga sua máquina, ela faz algumas coisas interessantes, como mostrar a tela do logotipo, passar por diferentes mensagens e, no final, você é solicitado com uma janela de login. Bem, na verdade, há muita coisa acontecendo entre o momento em que você pressiona o botão de energia até o momento em que faz login, e discutiremos isso neste curso. \n\nO processo de inicialização do Linux pode ser dividido em 4 etapas simples: \n\n<b>1. BIOS</b>\n\nA BIOS (que significa \"Sistema Básico de Entrada/Saída\") inicializa o hardware e garante com um teste de autoverificação (POST) que todo o hardware está pronto para funcionar. O principal trabalho da BIOS é carregar o carregador de inicialização.\n\n<b>2. Carregador de Inicialização</b>\n\nO carregador de inicialização carrega o kernel na memória e então inicia o kernel com um conjunto de parâmetros do kernel. Um dos carregadores de inicialização mais comuns é o GRUB, que é um padrão universal do Linux. \n\n<b>3. Kernel</b>\n\nQuando o kernel é carregado, ele inicializa imediatamente dispositivos e memória. O principal trabalho do kernel é carregar o processo init. \n\n<b>4. Init</b>\n\nLembre-se de que o processo init é o primeiro processo que é iniciado, o init inicia e interrompe processos de serviço essenciais no sistema. Existem três implementações principais do init em distribuições Linux. Vamos revisá-las brevemente e depois nos aprofundar nelas em outro curso.\n\nAqui está, a explicação (bem) simples do processo de inicialização do Linux. Vamos detalhar mais essas etapas nas próximas lições.",
          "quizAnswer": "init",
          "quizQuestion": "Qual é a última etapa no processo de inicialização do Linux?",
          "slug": "visao-geral-do-processo-de-inicializacao",
          "title": "Visão Geral do Processo de Inicialização"
        },
        {
          "exercise": "Acesse o menu da BIOS e veja se a inicialização UEFI está ativada.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nO primeiro passo no processo de inicialização do Linux é a BIOS, que realiza verificações de integridade do sistema. A BIOS é um firmware que é mais comum em computadores compatíveis com IBM PC, o tipo dominante de computadores existente hoje. Você provavelmente já usou o firmware da BIOS para alterar a ordem de inicialização dos seus discos rígidos, verificar a hora do sistema, o endereço MAC da sua máquina, etc. O objetivo principal da BIOS é encontrar o carregador de inicialização do sistema.\n\nEntão, uma vez que a BIOS inicializa o disco rígido, ela procura pelo bloco de inicialização para descobrir como inicializar o sistema. Dependendo de como você particionou seu disco, ela procurará o registro de inicialização principal (MBR) ou GPT. O MBR está localizado no primeiro setor do disco rígido, nos primeiros 512 bytes. O MBR contém o código para carregar outro programa em algum lugar do disco, e esse programa, por sua vez, carrega nosso carregador de inicialização.\n\nAgora, se você particionou seu disco com GPT, a localização do carregador de inicialização muda um pouco.\n\n<b>UEFI</b>\n\nExiste outra maneira de inicializar seu sistema em vez de usar a BIOS, e isso é com o UEFI (que significa \"Interface de Firmware Extensível Unificada\"). O UEFI foi projetado para ser o sucessor da BIOS, a maioria do hardware existente hoje vem com o firmware UEFI embutido. As máquinas Macintosh têm usado inicialização EFI há anos e a Microsoft mudou a maior parte de suas coisas para inicialização UEFI. O formato GPT foi destinado ao uso com EFI. Você não necessariamente precisa de EFI se estiver inicializando um disco GPT. O primeiro setor de um disco GPT é reservado para um \"MBR protetor\" para tornar possível a inicialização em uma máquina baseada em BIOS.\n\nO UEFI armazena todas as informações sobre a inicialização em um arquivo .efi. Este arquivo é armazenado em uma partição especial chamada partição de sistema EFI no hardware. Dentro desta partição, ele conterá o carregador de inicialização. O UEFI traz muitas melhorias em relação ao firmware da BIOS tradicional. No entanto, como estamos usando o Linux, a maioria de nós está usando a BIOS. Portanto, todas essas lições seguirão essa premissa.",
          "quizAnswer": "carregador de inicialização",
          "quizQuestion": "O que a BIOS carrega?",
          "slug": "processoinicializacaobios",
          "title": "Processo de Inicialização: BIOS"
        },
        {
          "exercise": "Se você tem o GRUB como seu bootloader, acesse o menu do GRUB com 'e' e dê uma olhada nas configurações.",
          "id": 3,
          "lessonContent": "As principais responsabilidades do bootloader são:\n\n<ul>\n<li>Inicializar em um sistema operacional, também pode ser usado para inicializar em sistemas operacionais não-Linux</li>\n<li>Selecionar um kernel para usar</li>\n<li>Especificar parâmetros do kernel</li>\n</ul>\n\nO bootloader mais comum para o Linux é o GRUB, você provavelmente está usando em seu sistema. Existem muitos outros bootloaders que você pode usar, como LILO, efilinux, coreboot, SYSLINUX e mais. No entanto, estaremos trabalhando apenas com o GRUB como nosso bootloader.\n\nEntão sabemos que o objetivo principal do bootloader é carregar o kernel, mas onde ele encontra o kernel? Para encontrá-lo, precisaremos olhar para nossos parâmetros do kernel. Os parâmetros podem ser encontrados acessando o menu do GRUB na inicialização usando a tecla 'e'. Se você não tiver o GRUB, não se preocupe, passaremos pelos parâmetros de inicialização que você verá:\n\n<ul>\n<li>initrd - Especifica a localização do disco RAM inicial (falaremos mais sobre isso na próxima lição).</li>\n<li>BOOT_IMAGE - Aqui é onde a imagem do kernel está localizada</li>\n<li>root - A localização do sistema de arquivos raiz, o kernel procura dentro desta localização para encontrar o init. Geralmente é representado por seu UUID ou pelo nome do dispositivo, como /dev/sda1.</li>\n<li>ro - Este parâmetro é bastante padrão, ele monta o sistema de arquivos como modo somente leitura.</li>\n<li>quiet - Isso é adicionado para que você não veja mensagens de exibição que estão ocorrendo em segundo plano durante a inicialização.</li>\n<li>splash - Isso permite que a tela de abertura seja exibida.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "Qual parâmetro do kernel faz com que você não veja as mensagens de inicialização?",
          "slug": "processoinicializacaobootloader",
          "title": "Processo de Inicialização: Bootloader"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 4,
          "lessonContent": "Agora que nosso carregador de inicialização passou os parâmetros necessários, vamos ver como ele é iniciado:\n\n<b>Initrd vs Initramfs</b>\n\nExiste um problema um tanto quanto complicado quando falamos sobre a inicialização do kernel. O kernel gerencia o hardware de nossos sistemas, no entanto, nem todos os drivers estão disponíveis para o kernel durante a inicialização. Portanto, dependemos de um sistema de arquivos raiz temporário que contém apenas os módulos essenciais necessários para o kernel acessar o restante do hardware. Em versões mais antigas do Linux, essa tarefa era atribuída ao initrd (disco RAM inicial). O kernel montava o initrd, obtinha os drivers de inicialização necessários e, quando terminava de carregar tudo o que precisava, substituía o initrd pelo sistema de arquivos raiz real. Atualmente, temos algo chamado initramfs, que é um sistema de arquivos raiz temporário integrado ao próprio kernel para carregar todos os drivers necessários para o sistema de arquivos raiz real, sem a necessidade de localizar o arquivo initrd. \n\n<b>Montando o sistema de arquivos raiz</b>\n\nAgora o kernel possui todos os módulos necessários para criar um dispositivo raiz e montar a partição raiz. Antes de prosseguir, no entanto, a partição raiz é montada primeiro em modo somente leitura para que o fsck possa ser executado com segurança e verificar a integridade do sistema. Em seguida, remonta o sistema de arquivos raiz em modo leitura-escrita. Em seguida, o kernel localiza o programa init e o executa.",
          "quizAnswer": "initramfs",
          "quizQuestion": "O que é usado em sistemas modernos para carregar um sistema de arquivos raiz temporário?",
          "slug": "processoinicializacaokernel",
          "title": "Processo de Inicialização: Kernel"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Nós discutimos init em lições anteriores e sabemos que é o primeiro processo que é iniciado e inicia todos os outros serviços essenciais em nosso sistema. Mas como?\n\nNa verdade, existem três implementações principais de init no Linux: \n\n<b>System V init (sysv)</b>\n\nEste é o sistema init tradicional. Ele inicia e para processos sequencialmente, com base em scripts de inicialização. O estado da máquina é indicado por níveis de execução, cada nível de execução inicia ou para uma máquina de maneira diferente. \n\n<b>Upstart</b>\n\nEste é o init que você encontrará em instalações mais antigas do Ubuntu. Upstart usa a ideia de trabalhos e eventos e funciona iniciando trabalhos que realizam certas ações em resposta a eventos. \n\n<b>Systemd</b>\n\nEste é o novo padrão para init, é orientado por objetivos. Basicamente, você tem um objetivo que deseja alcançar e o systemd tenta satisfazer as dependências do objetivo para completá-lo. \n\nTemos um curso inteiro sobre sistemas de Inicialização onde iremos nos aprofundar em cada um desses sistemas com mais detalhes.",
          "quizAnswer": "systemd",
          "quizQuestion": "Qual é o novo padrão para init?",
          "slug": "bootprocessinit",
          "title": "Processo de Inicialização: Init"
        }
      ],
      "slug": "iniciarosistema",
      "title": "Iniciar o Sistema"
    },
    {
      "description": "A parte mais importante do sistema Linux, aprenda como funciona e como configurá-lo.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Como você aprendeu até este ponto, o kernel é o núcleo do sistema operacional. Falamos sobre as outras partes do sistema operacional, mas ainda não mostramos como todas elas funcionam juntas. O sistema operacional Linux pode ser organizado em três níveis diferentes de abstração.\n\nO nível mais básico é o hardware, isso inclui nossa CPU, memória, discos rígidos, portas de rede, etc. A camada física que realmente calcula o que nossa máquina está fazendo.\n\nO próximo nível é o kernel, que lida com o gerenciamento de processos e memória, comunicação de dispositivos, chamadas de sistema, configura nosso sistema de arquivos, etc. O trabalho do kernel é falar com o hardware para garantir que ele faça o que queremos que nossos processos façam.\n\nE o nível com o qual você está familiarizado é o espaço do usuário, o espaço do usuário inclui o shell, os programas que você executa, os gráficos, etc.\n\nNeste curso, estaremos focando no kernel e aprendendo suas complexidades.",
          "quizAnswer": "kernel",
          "quizQuestion": "Qual nível do sistema operacional gerencia dispositivos?",
          "slug": "kerneloverview",
          "title": "Visão Geral do Kernel"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 2,
          "lessonContent": "As próximas lições ficam bastante teóricas, então se você está procurando por algo prático, pode pular adiante e voltar depois.\n\nPor que temos diferentes camadas de abstração para o espaço do usuário e o kernel? Por que não podemos combinar ambos os poderes em uma única camada? Bem, existe uma razão muito boa para essas duas camadas existirem separadamente. Ambas operam em modos diferentes, o kernel opera no modo kernel e o espaço do usuário opera no modo usuário. \n\nNo modo kernel, o kernel tem acesso completo ao hardware, ele controla tudo. No modo espaço do usuário, há uma pequena quantidade de memória segura e CPU que você pode acessar. Basicamente, quando queremos fazer qualquer coisa que envolva hardware, ler dados de nossos discos, escrever dados em nossos discos, controlar nossa rede, etc., tudo é feito no modo kernel. Por que isso é necessário? Imagine se sua máquina estivesse infectada com spyware, você não gostaria que ele tivesse acesso direto ao hardware do seu sistema. Ele pode acessar todos os seus dados, sua webcam, etc., e isso não é bom. \n\nEsses modos diferentes são chamados de níveis de privilégio (apropriadamente nomeados pelos níveis de privilégio que você obtém) e são frequentemente descritos como anéis de proteção. Para facilitar a compreensão, vamos dizer que você descobre que Britney Spears está na cidade em seu klerb local, ela está protegida por seus seguranças pessoais, depois por seus guarda-costas pessoais e depois pelo segurança na porta do klerb. Você quer conseguir um autógrafo dela (por que não?), mas não consegue chegar até ela porque ela está muito protegida. Os anéis funcionam da mesma maneira, o anel mais interno corresponde ao nível de privilégio mais alto. Existem dois níveis principais ou modos em uma arquitetura de computador x86. O Anel #3 é o privilégio no qual as aplicações do modo usuário são executadas, o Anel #0 é o privilégio no qual o kernel é executado. O Anel #0 pode executar qualquer instrução do sistema e tem total confiança. Agora que sabemos como esses níveis de privilégio funcionam, como conseguimos escrever algo em nosso hardware? Não estaremos sempre em um modo diferente do kernel? \n\nA resposta está nas chamadas de sistema, as chamadas de sistema nos permitem executar uma instrução privilegiada no modo kernel e depois voltar ao modo usuário.",
          "quizAnswer": "0",
          "quizQuestion": "Qual número de anel tem os privilégios mais altos?",
          "slug": "kernelprivilegelevels",
          "title": "Níveis de Privilégio"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Lembra-se da Britney na lição anterior? Digamos que queremos encontrá-la e tomar algumas bebidas juntos, como podemos sair de pé do lado de fora, no meio da multidão de pessoas, para dentro do círculo mais íntimo dela? Usaríamos chamadas de sistema. As chamadas de sistema são como os passes VIP que te levam a uma porta lateral secreta que leva diretamente à Britney.\n\nAs chamadas de sistema (syscall) fornecem aos processos do espaço do usuário uma maneira de solicitar ao kernel que faça algo por nós. O kernel disponibiliza certos serviços por meio da API de chamadas de sistema. Esses serviços nos permitem ler ou escrever em um arquivo, modificar o uso de memória, modificar nossa rede, etc. A quantidade de serviços é fixa, então você não pode adicionar chamadas de sistema aleatoriamente, seu sistema já possui uma tabela do que as chamadas de sistema existem e cada chamada de sistema tem um ID único. \n\nNão entrarei em detalhes sobre chamadas de sistema, pois isso exigiria que você soubesse um pouco de C, mas o básico é que quando você chama um programa como ls, o código dentro deste programa contém um invólucro de chamada de sistema (portanto, ainda não é a chamada de sistema real). Dentro deste invólucro, ele invoca a chamada de sistema que executará uma armadilha, esta armadilha é então capturada pelo manipulador de chamadas de sistema e depois faz referência à chamada de sistema na tabela de chamadas de sistema. Digamos que estamos tentando chamar a chamada de sistema stat(), ela é identificada por um ID de chamada de sistema e o objetivo da chamada de sistema stat() é consultar o status de um arquivo. Agora lembre-se, você estava executando o programa ls no modo não privilegiado. Então, agora ele vê que você está tentando fazer uma chamada de sistema, ele então o transfere para o modo kernel, lá ele faz muitas coisas, mas o mais importante é que ele verifica o número da sua chamada de sistema, encontra-o em uma tabela com base no ID da chamada de sistema e então executa a função que você queria executar. Quando terminar, ele retornará ao modo de usuário e seu processo receberá um status de retorno se foi bem-sucedido ou se ocorreu um erro. Os detalhes internos das chamadas de sistema são muito detalhados, eu recomendaria procurar informações online se quiser aprender mais. \n\nVocê pode realmente visualizar as chamadas de sistema que um processo faz com o comando strace. O comando strace é útil para depurar como um programa foi executado. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "chamada de sistema",
          "quizQuestion": "O que é usado para alternar do modo de usuário para o modo kernel?",
          "slug": "chamadasdesistema",
          "title": "Chamadas de Sistema"
        },
        {
          "exercise": "<ol>\n<li>Descubra qual versão do kernel você tem.</li>\n<li>Pesquise sobre as diferentes versões de kernels disponíveis</li>\n</ol>",
          "id": 4,
          "lessonContent": "Ok, agora que nos livramos de todas aquelas coisas chatas, vamos falar sobre realmente instalar e modificar kernels. Você pode instalar vários kernels no seu sistema, lembra da nossa aula sobre o processo de inicialização? No menu GRUB, podemos escolher qual kernel inicializar. \n\nPara ver qual versão do kernel você tem no seu sistema, use o seguinte comando:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nO comando uname imprime informações do sistema, o comando -r irá exibir toda a versão de lançamento do kernel.\n\nVocê pode instalar o kernel Linux de diferentes maneiras, pode baixar o pacote de origem e compilar a partir da fonte ou pode instalá-lo usando ferramentas de gerenciamento de pacotes.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\ne então reinicie no kernel que você instalou. Simples, certo? Mais ou menos, você também precisará instalar outros pacotes do Linux, como os linux-headers, linux-image-generic, etc). Você também pode especificar o número da versão, então o comando acima pode parecer com, <b>sudo apt install 3.19.0-43-generic</b>\n\nAlternativamente, se você apenas deseja a versão atualizada do kernel, basta usar dist-upgrade, ele realiza atualizações em todos os pacotes do seu sistema:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nExistem muitas versões diferentes de kernel, algumas são usadas como LTS (suporte de longo prazo), outras são as mais recentes e melhores, a compatibilidade pode ser muito diferente entre as versões do kernel, então você pode querer experimentar diferentes kernels.",
          "quizAnswer": "uname -r",
          "quizQuestion": "Como você vê a versão do kernel do seu sistema?",
          "slug": "instalacaodokernel",
          "title": "Instalação do Kernel"
        },
        {
          "exercise": "Vá para o seu diretório /boot e veja quais arquivos estão lá.",
          "id": 5,
          "lessonContent": "O que acontece quando você instala um novo kernel? Bem, na verdade, ele adiciona alguns arquivos ao seu sistema, esses arquivos geralmente são adicionados ao diretório /boot. \n\nVocê verá vários arquivos para diferentes versões de kernel:\n\n<ul>\n<li>vmlinuz - este é o kernel linux real</li>\n<li>initrd - como discutimos anteriormente, o initrd é usado como um sistema de arquivos temporário, usado antes de carregar o kernel</li>\n<li>System.map - tabela de pesquisa simbólica</li>\n<li>config - configurações de configuração do kernel, se você estiver compilando seu próprio kernel, você pode definir quais módulos podem ser carregados</li>\n</ul>\n\nSe o seu diretório /boot ficar sem espaço, você sempre pode excluir versões antigas desses arquivos ou simplesmente usar um gerenciador de pacotes, mas tenha cuidado ao fazer manutenção neste diretório e não exclua acidentalmente o kernel que está usando.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "Como é chamada a imagem do kernel em /boot?",
          "slug": "localizacaokernel",
          "title": "Localização do Kernel"
        },
        {
          "exercise": "Descarregue o seu módulo bluetooth com modprobe e veja o que acontece. Como você vai corrigir isso?",
          "id": 6,
          "lessonContent": "Digamos que eu tenha um carro legal, invisto muito tempo e dinheiro nele. Adiciono um aerofólio, engate, suporte para bicicleta e outras coisas aleatórias. Esses componentes na verdade não alteram a funcionalidade principal do carro e posso removê-los e adicioná-los facilmente. O kernel usa o mesmo conceito com módulos do kernel.\n\nO kernel em si é uma peça de software monolítica, quando queremos adicionar suporte para um novo tipo de teclado, não escrevemos esse código diretamente no código do kernel. Assim como não acoplaríamos um suporte para bicicleta ao nosso carro (bem, talvez algumas pessoas fizessem isso). Os módulos do kernel são pedaços de código que podem ser carregados e descarregados no kernel sob demanda. Eles nos permitem estender a funcionalidade do kernel sem realmente adicionar ao código principal do kernel. Também podemos adicionar módulos sem precisar reiniciar o sistema (na maioria dos casos).\n\n<b>Visualizar uma lista de módulos atualmente carregados</b>\n\n<pre>$ lsmod</pre>\n\n<b>Carregar um módulo</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe tenta carregar o módulo de <b>/lib/modules/(versão do kernel)/kernel/drivers</b>. Os módulos do kernel também podem ter dependências, modprobe carrega as dependências do nosso módulo se elas ainda não estiverem carregadas.\n\n<b>Remover um módulo</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Carregar na inicialização</b>\n\nVocê também pode carregar módulos durante a inicialização do sistema, em vez de carregá-los temporariamente com modprobe (que será descarregado quando você reiniciar). Basta modificar o diretório <b>/etc/modprobe.d</b> e adicionar um arquivo de configuração nele da seguinte forma:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\nUm exemplo um pouco extravagante, mas se você tivesse um módulo chamado peanut_butter e quisesse adicionar um parâmetro de kernel para type=almond, você pode fazer com que ele seja carregado na inicialização usando este arquivo de configuração. Também observe que os módulos do kernel têm seus próprios parâmetros de kernel, então você vai querer ler sobre o módulo especificamente para saber mais.\n\n<b>Não carregar na inicialização</b>\n\nVocê também pode garantir que um módulo não seja carregado na inicialização adicionando um arquivo de configuração da seguinte forma:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "Qual comando é usado para descarregar um módulo?",
          "slug": "kernelmodules",
          "title": "Módulos do Kernel"
        }
      ],
      "slug": "kernel",
      "title": "Kernel"
    },
    {
      "description": "Aprenda sobre os diferentes sistemas de inicialização, SysV, Upstart e systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Se você estiver executando o System V, altere o runlevel padrão de sua máquina para algo diferente e veja o que acontece.",
          "id": 1,
          "lessonContent": "O principal objetivo do init é iniciar e parar processos essenciais no sistema. Existem três implementações principais do init no Linux, System V, Upstart e systemd. Nesta lição, vamos revisar a versão mais tradicional do init, System V init ou Sys V (pronunciado como 'System Five'). \n\nPara descobrir se você está usando a implementação Sys V init, se você tiver um arquivo /etc/inittab, é muito provável que esteja executando o Sys V. \n\nO Sys V inicia e para processos sequencialmente, então, digamos que você queira iniciar um serviço chamado foo-a, bem antes que foo-b possa funcionar, você precisa garantir que foo-a já esteja em execução. O Sys V faz isso com scripts, esses scripts iniciam e param serviços para nós, podemos escrever nossos próprios scripts ou na maioria das vezes usar os que já estão incorporados no sistema operacional e são usados para carregar serviços essenciais. \n\nAs vantagens de usar essa implementação do init é que é relativamente fácil resolver dependências, já que você sabe que foo-a vem antes de foo-b, no entanto, o desempenho não é ótimo porque geralmente uma coisa está iniciando ou parando de cada vez. \n\nAo usar o Sys V, o estado da máquina é definido por runlevels que são configurados de 0 a 6. Esses modos diferentes variam dependendo da distribuição, mas na maioria das vezes parecerão o seguinte: \n\n<ul>\n<li>0: Desligamento</li>\n<li>1: Modo de Usuário Único</li>\n<li>2: Modo multiusuário sem rede</li>\n<li>3: Modo multiusuário com rede</li>\n<li>4: Não utilizado</li>\n<li>5: Modo multiusuário com rede e GUI</li>\n<li>6: Reinicialização</li>\n</ul>\n\nQuando seu sistema é iniciado, ele verifica em qual runlevel você está e executa scripts localizados dentro da configuração desse runlevel. Os scripts estão localizados em <b>/etc/rc.d/rc[número do runlevel].d/</b> ou <b>/etc/init.d</b>. Scripts que começam com S (start) ou K (kill) serão executados na inicialização e no desligamento, respectivamente. Os números ao lado desses caracteres são a sequência em que são executados. \n\nPor exemplo:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nVemos que ao mudarmos para o runlevel 0 ou modo de desligamento, nossa máquina tentará executar um script para encerrar os serviços de atualização e depois openvpn. Para descobrir em qual runlevel sua máquina está inicializando, você pode ver o runlevel padrão no arquivo /etc/inittab. Você também pode alterar seu runlevel padrão neste arquivo também. \n\nUma coisa a se notar, o System V está lentamente sendo substituído, talvez não hoje, ou mesmo daqui a anos. No entanto, você pode ver runlevels surgindo em outras implementações de init, principalmente para suportar os serviços que são apenas iniciados ou interrompidos usando scripts de init do System V.",
          "quizAnswer": "0",
          "quizQuestion": "Qual runlevel é geralmente usado para desligamento?",
          "slug": "sysvoverview",
          "title": "Visão Geral do System V"
        },
        {
          "exercise": "Gerencie alguns serviços e altere seus estados, o que você observa?",
          "id": 2,
          "lessonContent": "Existem muitas ferramentas de linha de comando que você pode usar para gerenciar serviços Sys V. \n\n<b>Listar serviços</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Iniciar um serviço</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Parar um serviço</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Reiniciar um serviço</b>\n\n<pre>$ sudo service networking restart</pre>\n\nEsses comandos não são específicos para sistemas de inicialização Sys V, você pode usá-los para gerenciar serviços Upstart também. Como o Linux está tentando se afastar dos scripts de inicialização Sys V mais tradicionais, ainda existem coisas em vigor para ajudar nessa transição.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Qual é o comando para parar um serviço chamado peanut com Sys V?",
          "slug": "sysvservices",
          "title": "Serviço do System V"
        },
        {
          "exercise": "Se estiver a executar o Upstart, veja se consegue compreender as configurações de tarefas em /etc/init.",
          "id": 3,
          "lessonContent": "O Upstart foi desenvolvido pela Canonical, então foi a implementação init no Ubuntu por um tempo, no entanto, nas instalações modernas do Ubuntu, o systemd é agora utilizado. O Upstart foi criado para melhorar os problemas com o Sys V, como os processos de inicialização rigorosos, bloqueio de tarefas, etc. O modelo orientado a eventos e tarefas do Upstart permite que ele responda aos eventos conforme eles ocorrem. \n\nPara descobrir se está a usar o Upstart, se tiver um diretório /usr/share/upstart, isso é um indicador bastante bom. \n\nAs tarefas são as ações que o Upstart executa e os eventos são mensagens recebidas de outros processos para acionar tarefas. Para ver uma lista de tarefas e suas configurações:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nDentro destas configurações de tarefas, incluirá informações sobre como iniciar tarefas e quando iniciar tarefas.\n\nPor exemplo, no arquivo networking.conf, poderia dizer algo tão simples como:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nIsso significa que iniciará a configuração de rede no runlevel 2, 3 ou 5 e interromperá a rede no runlevel 0. Existem muitas maneiras de escrever o arquivo de configuração e descobrirá isso ao analisar as diferentes configurações de tarefas disponíveis. \n\nA forma como o Upstart funciona é a seguinte: \n\n<ol>\n<li>Primeiro, carrega as configurações de tarefas de /etc/init</li>\n<li>Uma vez que ocorre um evento de inicialização, executará as tarefas acionadas por esse evento.</li>\n<li>Essas tarefas criarão novos eventos e então esses eventos acionarão mais tarefas</li>\n<li>O Upstart continua a fazer isso até concluir todas as tarefas necessárias</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Qual é a implementação init utilizada pelo Ubuntu?",
          "slug": "upstartoverview",
          "title": "Visão Geral do Upstart"
        },
        {
          "exercise": "Observe sua lista de trabalhos do Upstart, agora altere o estado do trabalho com um dos comandos que aprendemos hoje. O que você percebe depois?",
          "id": 4,
          "lessonContent": "O Upstart pode desencadear muitos eventos e trabalhos para serem executados, infelizmente não há uma maneira fácil de ver de onde um evento ou trabalho se originou, então você terá que investigar as configurações de trabalho em /etc/init. Na maioria das vezes, você nunca precisará olhar os arquivos de configuração de trabalho do Upstart, mas você vai querer controlar alguns trabalhos específicos de forma mais fácil. Existem muitos comandos úteis que você pode usar em um sistema Upstart. \n\n<b>Ver trabalhos</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nVocê verá uma lista de trabalhos do Upstart com diferentes status aplicados a eles. Em cada linha, o nome do trabalho é o primeiro valor e o segundo campo (antes da /) é na verdade o objetivo do trabalho, o terceiro valor (após a /) é o status atual. Então vemos que nosso trabalho de desligamento eventualmente quer parar, mas atualmente está em um estado de espera. O status e os objetivos do trabalho mudarão conforme você inicia ou interrompe trabalhos. \n\n<b>Ver trabalho específico</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nNão entraremos em detalhes sobre como escrever uma configuração de trabalho do Upstart, no entanto, já sabemos que os trabalhos são parados, iniciados e reiniciados nessas configurações. Esses trabalhos também emitem eventos, então podem iniciar outros trabalhos. Vamos passar pelos comandos manuais da operação do Upstart, mas se você estiver curioso, deve investigar os arquivos .conf com mais profundidade.\n\n<b>Iniciar manualmente um trabalho</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Parar manualmente um trabalho</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Reiniciar manualmente um trabalho</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Emitir manualmente um evento</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Como eu reiniciaria manualmente um trabalho do Upstart chamado peanuts?",
          "slug": "trabalhos-do-upstart",
          "title": "Trabalhos do Upstart"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Systemd está lentamente se tornando o padrão emergente para init. Se você tem um diretório /usr/lib/systemd, provavelmente está usando systemd.\n\nSystemd usa metas para iniciar e executar o sistema. Basicamente, você tem um alvo que deseja alcançar e esse alvo também tem dependências que precisamos alcançar. Systemd é extremamente flexível e robusto, não segue uma sequência rígida para iniciar processos. Aqui está o que acontece durante a inicialização típica do systemd:\n\n<ol>\n<li>Primeiro, o systemd carrega seus arquivos de configuração, geralmente localizados em /etc/systemd/system ou /usr/lib/systemd/system</li>\n<li>Em seguida, determina sua meta de inicialização, que geralmente é default.target</li>\n<li>O systemd descobre as dependências da meta de inicialização e as ativa</l>\n</ol>\n\nSemelhante aos runlevels do Sys V, o systemd inicializa em diferentes alvos:\n\n<ul>\n<li>poweroff.target - desligar o sistema</li>\n<li>rescue.target - modo de usuário único</li>\n<li>multi-user.target - multiusuário com rede</li>\n<li>graphical.target - multiusuário com rede e GUI</li>\n<li>reboot.target - reiniciar</li>\n</ul>\n\nA meta de inicialização padrão default.target geralmente aponta para graphical.target. \n\nO principal objeto com o qual o systemd trabalha são conhecidos como unidades. Systemd não apenas para e inicia serviços, ele pode montar sistemas de arquivos, monitorar seus soquetes de rede, etc e devido a essa robustez, ele opera com diferentes tipos de unidades. As unidades mais comuns são:\n\n<ul>\n<li>Unidades de serviço - são os serviços que temos iniciado e parado, esses arquivos de unidade terminam em .service</li>\n<li>Unidades de montagem - montam sistemas de arquivos, esses arquivos de unidade terminam em .mount</li>\n<li>Unidades de alvo - agrupam outras unidades, os arquivos terminam em .target</li>\n</ul>\n\nPor exemplo, digamos que inicializamos em nosso default.target, bem, esse alvo agrupa a unidade networking.service, a unidade crond.service, etc, então uma vez que ativamos uma única unidade, tudo abaixo dessa unidade também é ativado.",
          "quizAnswer": "alvo",
          "quizQuestion": "Que unidade é usada para agrupar outras unidades?",
          "slug": "visao-geral-do-systemd",
          "title": "Visão Geral do Systemd"
        },
        {
          "exercise": "Verifique os status das unidades e inicie e pare alguns serviços. O que você observa?",
          "id": 6,
          "lessonContent": "Não vamos entrar em detalhes sobre a escrita de arquivos de unidade do systemd. No entanto, vamos dar uma breve visão geral de um arquivo de unidade e como controlar unidades manualmente. \n\nAqui está um arquivo de unidade de serviço básico: foobar.service\n\n<pre>\n[Unit]\nDescription=Meu Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nEste é um alvo de serviço simples, no início do arquivo vemos uma seção para [Unit], isso nos permite dar uma descrição ao nosso arquivo de unidade, bem como controlar a ordem de quando ativar a unidade. A próxima parte é a seção [Service], aqui podemos iniciar, parar ou recarregar um serviço. E a seção [Install] é usada para dependência. Isso é apenas a ponta do iceberg para escrever arquivos systemd, então eu te imploro a ler mais sobre o assunto se quiser saber mais. \n\nAgora, vamos ver alguns comandos que você pode usar com unidades systemd: \n\n<b>Listar unidades</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Verificar status da unidade</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Iniciar um serviço</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Parar um serviço</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Reiniciar um serviço</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Ativar uma unidade</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Desativar uma unidade</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nNovamente, você ainda não viu o quanto o systemd pode ser profundo, então leia mais sobre ele se quiser aprender mais.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "Qual é o comando para iniciar um serviço chamado peanut.service?",
          "slug": "systemdgoals",
          "title": "Objetivos do Systemd"
        },
        {
          "exercise": "O que você acha que está acontecendo com o init quando desliga sua máquina?",
          "id": 7,
          "lessonContent": "Difícil de acreditar que ainda não discutimos formas de controlar o estado do seu sistema através da linha de comando, mas ao falar sobre o init, não apenas falamos sobre os modos que nos permitem iniciar nosso sistema, mas também aqueles que o desligam.\n\nPara desligar o seu sistema:\n\n<pre>$ sudo shutdown -h now</pre>\n\nIsso irá parar o sistema (desligá-lo), você também deve especificar um horário para que isso aconteça. Você pode adicionar um tempo em minutos que irá desligar o sistema em determinado tempo.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nIsso irá desligar o seu sistema em dois minutos. Você também pode reiniciar com o comando shutdown: \n\n<pre>$ sudo shutdown -r now</pre>\n\nOu simplesmente usar o comando reboot:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "Qual é o comando para desligar o seu sistema em 4 minutos?",
          "slug": "powerstates",
          "title": "Estados de Energia"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Aprenda monitoramento de recursos com top, médias de carga, iostat e muito mais!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Experimente o comando top e veja quais processos estão usando mais recursos.",
          "id": 1,
          "lessonContent": "Neste curso, vamos aprender como ler e analisar a utilização de recursos em seu sistema, esta lição mostra algumas ótimas ferramentas para usar quando você precisa rastrear o que um processo está fazendo. \n\n<b>top</b>\n\nJá discutimos o top antes, mas vamos nos aprofundar nos detalhes do que ele realmente está exibindo. Lembre-se de que o top é a ferramenta que usamos para obter uma visualização em tempo real da utilização do sistema pelos nossos processos:\n\n<pre>\ntop - 18:06:26 up 6 days,  4:07,  2 usuários,  carga média: 0.92, 0.62, 0.59\nTarefas: 389 no total,   1 em execução, 387 dormindo,   0 parado,   1 zumbi\n%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  32870888 total, 27467976 usado,  5402912 livre,   518808 buffers\nKiB Swap: 33480700 total,    39892 usado, 33440808 livre. 19454152 Memória cacheada\n\n  PID USUÁRIO      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMANDO                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nVamos analisar o que essa saída significa, você não precisa memorizar isso, mas volte a este conteúdo quando precisar de uma referência.\n\n<b>1ª linha: Esta é a mesma informação que você veria se executasse o comando uptime (mais informações a seguir)</b>\n\nOs campos são da esquerda para a direita:\n<ol>\n<li>Tempo atual</li>\n<li>Há quanto tempo o sistema está em execução</li>\n<li>Quantos usuários estão atualmente logados</li>\n<li>Carga média do sistema (mais informações a seguir)</li>\n</ol>\n\n<b>2ª linha: Tarefas em execução, dormindo, paradas e zumbis</b>\n\n<b>3ª linha: Informações da CPU</b>\n\n<ol>\n<li>us: tempo de CPU do usuário - Porcentagem do tempo de CPU gasto executando processos de usuários que não são nice</li>\n<li>sy: tempo de CPU do sistema - Porcentagem do tempo de CPU gasto executando o kernel e processos do kernel</li>\n<li>ni: tempo de CPU nice - Porcentagem do tempo de CPU gasto executando processos nice</li>\n<li>id: tempo de CPU ocioso - Porcentagem do tempo de CPU gasto ocioso</li>\n<li>wa: espera de E/S - Porcentagem do tempo de CPU gasto aguardando E/S. Se esse valor for baixo, o problema provavelmente não é E/S de disco ou rede</li> \n<li>hi: interrupções de hardware - Porcentagem do tempo de CPU gasto atendendo interrupções de hardware</li>\n<li>si: interrupções de software - Porcentagem do tempo de CPU gasto atendendo interrupções de software</li>\n<li>st: tempo de roubo - Se você estiver executando máquinas virtuais, esta é a porcentagem de tempo de CPU que foi roubada de você para outras tarefas</li>\n</ol>\n\n<b>4ª e 5ª linha: Uso de Memória e Uso de Swap</b>\n\n<b>Lista de Processos Atualmente em Uso</b>\n\n<ol>\n<li>PID: Id do processo</li>\n<li>USUÁRIO: usuário que é o proprietário do processo</li>\n<li>PR: Prioridade do processo</li>\n<li>NI: O valor nice</li>\n<li>VIRT: Memória virtual usada pelo processo</li>\n<li>RES: Memória física usada pelo processo</li>\n<li>SHR: Memória compartilhada do processo</li>\n<li>S: Indica o status do processo: S=dormindo, R=em execução, Z=zumbi,D=ininterruptível,T=parado</li>\n<li>%CPU - esta é a porcentagem de CPU usada por este processo</li>\n<li>%MEM - porcentagem de RAM usada por este processo</li>\n<li>TIME+ - tempo total de atividade deste processo</li>\n<li>COMANDO - nome do processo</li>\n</ol>\n\nVocê também pode especificar um ID de processo se quiser rastrear determinados processos:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "Qual comando exibe a mesma saída que a primeira linha no top?",
          "slug": "rastreandoprocessostop",
          "title": "Rastreando processos: top"
        },
        {
          "exercise": "Leia as páginas de manual para lsof e fuser, há muitas informações que não cobrimos que permitem ter maior flexibilidade com essas ferramentas.",
          "id": 2,
          "lessonContent": "Digamos que você conectou uma unidade USB e começou a trabalhar em alguns arquivos, uma vez que terminou, você desmonta o dispositivo USB e recebe um erro \"Dispositivo ou Recurso Ocupado\". Como você descobriria quais arquivos na unidade USB ainda estão em uso? Na verdade, existem duas ferramentas que você pode usar para isso: \n\n<b>lsof</b>\n\nLembre-se de que arquivos não são apenas arquivos de texto, imagens, etc., são tudo no sistema, discos, pipes, soquetes de rede, dispositivos, etc. Para ver o que está em uso por um processo, você pode usar o comando lsof (abreviação de \"listar arquivos abertos\"), isso mostrará uma lista de todos os arquivos abertos e seus processos associados. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nAgora posso ver quais processos estão atualmente mantendo o dispositivo/arquivo aberto. Em nosso exemplo USB, você também pode encerrar esses processos para desmontar essa unidade irritante.\n\n<b>fuser</b>\n\nOutra maneira de rastrear um processo é o comando fuser (abreviação de \"file user\"), isso mostrará informações sobre o processo que está usando o arquivo ou o usuário do arquivo. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nPodemos ver quais processos estão usando atualmente nosso diretório /home/pete. As ferramentas lsof e fuser são muito semelhantes, familiarize-se com essas ferramentas e tente usá-las da próxima vez que precisar rastrear um arquivo ou processo.",
          "quizAnswer": "lsof",
          "quizQuestion": "Qual comando é usado para listar arquivos abertos e suas informações de processo?",
          "slug": "rastreandoprocessoslsoffuser",
          "title": "lsof e fuser"
        },
        {
          "exercise": "Execute o comando <b>ps m</b> e veja quais processos em execução são de múltiplas threads.",
          "id": 3,
          "lessonContent": "Você pode ter ouvido falar dos termos processos de única thread e processos de múltiplas threads. Threads são muito semelhantes a processos, no sentido de que são usados para executar o mesmo programa, sendo frequentemente referidos como processos leves. Se um processo tem uma thread, é de única thread e se um processo tem mais de uma thread, é de múltiplas threads. No entanto, todos os processos têm pelo menos uma thread. \n\nOs processos operam com seus próprios recursos de sistema isolados, no entanto, as threads podem compartilhar esses recursos entre si facilmente, tornando mais fácil a comunicação entre elas e, às vezes, é mais eficiente ter um aplicativo de múltiplas threads do que um aplicativo de múltiplos processos.\n\nBasicamente, vamos dizer que você abre o LibreOffice Writer e o Chrome, cada um é seu próprio processo separado. Agora você entra no Writer e começa a editar texto, quando você edita o texto, ele é salvo automaticamente. Esses dois processos paralelos de salvar e editar são threads. \n\nPara visualizar as threads de processo, você pode usar: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nOs processos são indicados com cada PID e abaixo dos processos estão suas threads (indicadas por --). Assim, você pode ver que os processos acima são ambos de única thread.",
          "quizAnswer": "Verdadeiro",
          "quizQuestion": "Verdadeiro ou falso, todos os processos começam como de única thread.",
          "slug": "threadsdeprocesso",
          "title": "Threads de Processo"
        },
        {
          "exercise": "Verifique a carga média do seu sistema e veja o que está acontecendo.",
          "id": 4,
          "lessonContent": "Vamos revisar um comando útil, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 ligado 1 dia,  5:59,  2 usuários,  carga média: 0.00, 0.02, 0.05\n</pre>\n\nNós falamos sobre o uptime na primeira lição deste curso, mas não abordamos o campo de carga média. As cargas médias são uma boa maneira de ver a carga da CPU no seu sistema. Esses números representam a carga média da CPU em intervalos de 1, 5 e 15 minutos. O que eu quero dizer com carga da CPU, a carga da CPU é o número médio de processos que estão esperando para serem executados pela CPU.\n\nDigamos que você tenha uma CPU de núcleo único, pense neste núcleo como uma faixa única no trânsito. Se for hora do rush na rodovia, esta faixa estará muito movimentada e o trânsito estará a 100% ou uma carga de 1. Agora o trânsito ficou tão ruim que está congestionando a rodovia e deixando as estradas regulares movimentadas com o dobro de carros, podemos dizer que sua carga é de 200% ou uma carga de 2. Agora digamos que melhora um pouco e há apenas metade dos carros na faixa da rodovia, podemos dizer que a carga da faixa é 0.5. Quando o trânsito não existe e podemos chegar em casa mais rápido, a carga idealmente deve ser muito baixa, como o trânsito das 2h da manhã. Os carros neste caso são processos e esses processos estão apenas esperando para sair da rodovia e chegar em casa.\n\nApenas porque você tem uma carga média de 1 não significa que seu computador está arrastando. A maioria das máquinas modernas hoje em dia tem vários núcleos. Se você tiver um processador quad-core (4 núcleos) e sua carga média for 1, ela realmente está afetando apenas 25% da sua CPU. Pense em cada núcleo como uma faixa no trânsito. Você pode ver a quantidade de núcleos que tem no seu sistema com <b>cat /proc/cpuinfo</b>.\n\nAo observar a carga média, você precisa levar em conta o número de núcleos, se você perceber que sua máquina está sempre usando uma carga acima da média, pode haver algo errado acontecendo.",
          "quizAnswer": "uptime",
          "quizQuestion": "Que comando você pode usar para ver a carga média?",
          "slug": "monitoramentocpu",
          "title": "Monitoramento da CPU"
        },
        {
          "exercise": "Use o iostat para visualizar o uso do seu disco.",
          "id": 5,
          "lessonContent": "Também podemos monitorar o uso da CPU, bem como o uso do disco com uma ferramenta útil conhecida como <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nA primeira parte é a informação da CPU:\n\n<ul>\n<li>%user - Mostra a porcentagem de utilização da CPU que ocorreu durante a execução no nível do usuário (aplicativo)</li>\n<li>%nice - Mostra a porcentagem de utilização da CPU que ocorreu durante a execução no nível do usuário com prioridade nice.utilização da CPU do usuário com prioridades nice</li>\n<li>%system - Mostra a porcentagem de utilização da CPU que ocorreu durante a execução no nível do sistema (kernel).</li>\n<li>%iowait - Mostra a porcentagem de tempo em que a CPU ou CPUs estavam ociosas durante as quais o sistema tinha uma solicitação de E/S de disco pendente.</li>\n<li>%steal - Mostra a porcentagem de tempo gasto em espera involuntária pela CPU virtual ou CPUs enquanto o hipervisor estava atendendo a outro processador virtual.</li>\n<li>%idle - Mostra a porcentagem de tempo em que a CPU ou CPUs estavam ociosas e o sistema não tinha uma solicitação de E/S de disco pendente.</li>\n</ul>\n\nA segunda parte é a utilização do disco:\n\n<ul>\n<li>tps - Indica o número de transferências por segundo que foram emitidas para o dispositivo. Uma transferência é uma solicitação de E/S para o dispositivo. Múltiplas solicitações lógicas podem ser combinadas em uma única solicitação de E/S para o dispositivo. Uma transferência é de tamanho indeterminado.</li>\n<li>kB_read/s - Indica a quantidade de dados lidos do dispositivo expressa em kilobytes por segundo.</li>\n<li>kB_wrtn/s - Indica a quantidade de dados gravados no dispositivo expressa em kilobytes por segundo.</li>\n<li>kB_read - O número total de kilobytes lidos.</li>\n<li>kB_wrtn - O número total de kilobytes gravados.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "Qual comando pode ser usado para visualizar o uso de E/S e da CPU?",
          "slug": "monitoramento-de-e-s",
          "title": "Monitoramento de E/S"
        },
        {
          "exercise": "Observe o uso de memória com vmstat.",
          "id": 6,
          "lessonContent": "Além do monitoramento da CPU e do monitoramento de E/S, você pode monitorar o uso de memória com <b>vmstat</b>\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nOs campos são os seguintes:\n\n<b>procs</b>\n<ul>\n<li>r - Número de processos em execução</li>\n<li>b - Número de processos em sono ininterruptível</li>\n</ul>\n\n<b>memória</b>\n<ul>\n<li>swpd - Quantidade de memória virtual usada</li>\n<li>free - Quantidade de memória livre</li>\n<li>buff - Quantidade de memória usada como buffers</li>\n<li>cache - Quantidade de memória usada como cache</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Quantidade de memória trocada do disco para a memória</li>\n<li>so - Quantidade de memória trocada da memória para o disco</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Quantidade de blocos recebidos de um dispositivo de bloco</li>\n<li>bo - Quantidade de blocos enviados para um dispositivo de bloco</li>\n</ul>\n\n<b>sistema</b>\n<ul>\n<li>in - Número de interrupções por segundo</li>\n<li>cs - Número de trocas de contexto por segundo</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Tempo gasto em tempo de usuário</li>\n<li>sy - Tempo gasto em tempo de kernel</li>\n<li>id - Tempo gasto ocioso</li>\n<li>wa - Tempo gasto esperando por E/S</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "Qual ferramenta é usada para visualizar a utilização de memória?",
          "slug": "monitoramentomemoria",
          "title": "Monitoramento de Memória"
        },
        {
          "exercise": "Instale o sar no seu sistema e comece a coletar e analisar a utilização de recursos do seu sistema.",
          "id": 7,
          "lessonContent": "Essas ferramentas de monitoramento são boas para verificar quando sua máquina está com problemas, mas e quanto às máquinas que estão com problemas quando você não está olhando. Para esses casos, você precisará usar uma ferramenta de monitoramento contínuo, algo que irá coletar, relatar e salvar as informações de atividade do seu sistema. Nesta lição, vamos falar sobre uma ótima ferramenta para usar <b>sar</b>.\n\n<b>Instalando sar</b>\nSar é uma ferramenta usada para análise histórica do seu sistema, primeiro certifique-se de tê-la instalada instalando o pacote sysstat <b>sudo apt install sysstat</b>.\n\n<b>Configurando a coleta de dados</b>\nNormalmente, uma vez que você instala o sysstat, seu sistema começará automaticamente a coletar dados, se não o fizer, você pode habilitá-lo modificando o campo ENABLED em /etc/default/sysstat.\n\n<b>Usando sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nEste comando listará os detalhes desde o início do dia.\n\n<pre>$ sudo sar -r</pre>\n\nIsso listará os detalhes do uso de memória desde o início do dia.\n\n<pre>$ sudo sar -P</pre>\n\nIsso listará os detalhes do uso da CPU. \n\nPara ver uma visualização de um dia diferente, você pode acessar /var/log/sysstat/saXX onde XX é o dia que deseja visualizar. \n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "Qual é uma boa ferramenta para monitorar os recursos do sistema?",
          "slug": "monitoramentocontínuo",
          "title": "Monitoramento Contínuo"
        },
        {
          "exercise": "Crie um trabalho cron que você deseja executar em um horário agendado.",
          "id": 8,
          "lessonContent": "Embora tenhamos falado sobre utilização de recursos, acho que este seria um bom momento para mencionar uma ferramenta interessante no Linux que é usada para agendar tarefas usando o cron. Existe um serviço que executa programas para você no horário que você agendar. Isso é realmente útil se você tem um script que deseja executar uma vez por dia e que precisa fazer algo por você. \n\nPor exemplo, vamos dizer que eu tenho um script localizado em /home/pete/scripts/change_wallpaper. Eu uso esse script todas as manhãs para mudar a imagem que uso como papel de parede, mas todas as manhãs tenho que executar manualmente esse script. Em vez disso, posso criar um trabalho cron que execute meu script através do cron. Posso especificar o horário em que quero que esse trabalho cron seja executado e executar meu script. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nOs campos são os seguintes da esquerda para a direita:\n<ul>\n<li>Minuto - (0-59)</li>\n<li>Hora - (0-23)</li>\n<li>Dia do mês - (1-31)</li>\n<li>Mês - (1-12)</li>\n<li>Dia da semana - (0-7). 0 e 7 são denotados como Domingo</li>\n</ul>\n\nO asterisco no campo significa corresponder a todos os valores. Portanto, no meu exemplo acima, quero que isso seja executado todos os dias em todos os meses às 8:30 da manhã.\n\nPara criar um trabalho cron, basta editar o arquivo crontab:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "Qual é o comando para editar seus trabalhos cron?",
          "slug": "cronjobs",
          "title": "Trabalhos Cron"
        }
      ],
      "slug": "processutilization",
      "title": "Utilização de Processos"
    },
    {
      "description": "Aprenda sobre logs do sistema e o diretório /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Olhe para o seu ficheiro /var/log/syslog e veja o que mais está a acontecer na sua máquina.",
          "id": 1,
          "lessonContent": "Os serviços, kernel, daemons, etc no seu sistema estão constantemente a fazer algo, esses dados são enviados para serem guardados no seu sistema na forma de registos. Isto permite-nos ter um registo legível por humanos dos eventos que estão a ocorrer no nosso sistema. Estes dados são normalmente mantidos no diretório /var, o diretório /var é onde mantemos os nossos dados variáveis, como registos!\n\nComo é que estas mensagens estão a ser recebidas no seu sistema? Existe um serviço chamado syslog que envia esta informação para o registo do sistema. \n\nO syslog na verdade contém muitos componentes, um dos mais importantes é um daemon em execução chamado syslogd (distribuições Linux mais recentes usam rsyslogd), que espera que ocorram mensagens de eventos e filtra aquelas sobre as quais deseja ser informado e, dependendo do que deve fazer com essa mensagem, irá enviá-la para um ficheiro, para o seu terminal ou não fazer nada com ela.\n\nPoderia pensar que este registo do sistema é o local centralizado para gerir os registos, mas infelizmente não é. Verá muitas aplicações que escrevem as suas próprias regras de registo e geram diferentes ficheiros de registo, no entanto, em geral, o formato dos registos deve incluir um carimbo de data/hora e os detalhes do evento. \n\nAqui está um exemplo de uma linha do syslog:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nAqui podemos ver que em Jan 27 07:41:32 o nosso serviço cron executou o trabalho cron.weekly. Pode ver todas as mensagens de eventos que o syslog recolhe no ficheiro /var/log/syslog.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "Qual é o daemon que gere os registos nos sistemas Linux mais recentes?",
          "slug": "registo-de-sistema",
          "title": "Registo de Sistema"
        },
        {
          "exercise": "Olhe o seu arquivo de configuração /etc/rsyslog.d e veja o que mais está sendo registrado via o registrador do sistema.",
          "id": 2,
          "lessonContent": "O serviço syslog gerencia e envia logs para o registrador do sistema. Rsyslog é uma versão avançada do syslog, a maioria das distribuições Linux deve estar usando esta nova versão. A saída de todos os logs coletados pelo serviço syslog pode ser encontrada em /var/log/syslog (cada mensagem exceto mensagens de autenticação).\n\nPara descobrir quais arquivos são mantidos pelo nosso registrador de sistema, olhe os arquivos de configuração em /etc/rsyslog.d:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nEssas regras para arquivos de log são indicadas pelo seletor na coluna da esquerda e a ação na coluna da direita. A ação nos diz para onde enviar as informações de log, em um arquivo, console, etc. Lembre-se de que nem todas as aplicações e serviços usam o rsyslog para gerenciar seus logs, então se você quiser saber especificamente o que está sendo registrado, terá que olhar dentro deste diretório.\n\nVamos realmente ver o registro em ação, você pode enviar manualmente um log com o comando logger:\n\n<pre>\nlogger -s Olá\n</pre>\n\nAgora olhe dentro do seu /var/log/syslog e você deverá ver esta entrada nos seus logs!",
          "quizAnswer": "logger",
          "quizQuestion": "Que comando você pode usar para registrar manualmente uma mensagem?",
          "slug": "syslog",
          "title": "Primeiro alguns arquivos de log padrão. Log por facilidade."
        },
        {
          "exercise": "Olhe para os seus ficheiros /var/log/messages e /var/log/syslog e veja quais são as diferenças.",
          "id": 3,
          "lessonContent": "Existem muitos ficheiros de registo que pode visualizar no seu sistema, muitos dos mais importantes podem ser encontrados em /var/log. Não vamos passar por todos, mas vamos discutir alguns dos principais. \n\nExistem dois ficheiros de registo gerais que pode visualizar para ter uma ideia do que o seu sistema está a fazer:\n\n<b>/var/log/messages</b>\n\nEste registo contém todas as mensagens não críticas e não de depuração, inclui mensagens registadas durante a inicialização (dmesg), autenticação, cron, daemon, etc. Muito útil para ter uma ideia de como a sua máquina está a funcionar. \n\n<b>/var/log/syslog</b>\n\nEste regista tudo exceto mensagens de autenticação, sendo extremamente útil para depurar erros na sua máquina. \n\nEstes dois registos devem ser mais do que suficientes ao resolver problemas com o seu sistema. No entanto, se apenas quiser visualizar um componente de registo específico, também existem registos separados para esses.",
          "quizAnswer": "syslog",
          "quizQuestion": "Que ficheiro de registo regista tudo exceto mensagens de autenticação?",
          "slug": "registo-geral",
          "title": "Registo Geral"
        },
        {
          "exercise": "Olhe para seus logs de dmesg e kern, que diferenças você nota?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nAo inicializar, o seu sistema regista informações sobre o buffer de anel do kernel. Isso nos mostra informações sobre drivers de hardware, informações do kernel e status durante a inicialização e muito mais. Este arquivo de log pode ser encontrado em /var/log/dmesg e é redefinido a cada inicialização, você pode não ver realmente nenhuma utilidade nele agora, mas se você tiver problemas com algo durante a inicialização ou um problema de hardware, o dmesg é o melhor lugar para procurar. Você também pode visualizar este log usando o comando dmesg. \n\n<b>/var/log/kern.log</b>\nOutro log que você pode usar para visualizar informações do kernel é o arquivo /var/log/kern.log, este loga as informações e eventos do kernel em seu sistema, também loga a saída do dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "Que comando pode ser usado para visualizar mensagens de inicialização do kernel?",
          "slug": "kernellogging",
          "title": "Registo do Kernel"
        },
        {
          "exercise": "Faça algumas tentativas de início de sessão falhadas e depois uma bem-sucedida, verifique o seu /var/log/auth.log e veja o que aconteceu.",
          "id": 5,
          "lessonContent": "O registo de autenticação pode ser muito útil para analisar se está a ter problemas ao iniciar sessão. \n\n<b>/var/log/auth.log</b>\n\nEste ficheiro contém registos de autorização do sistema, como o início de sessão do utilizador e o método de autenticação utilizado. \n\nExcerto de exemplo:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "Que registo é utilizado para autenticação de utilizador?",
          "slug": "authenticationlogging",
          "title": "Registo de Autenticação"
        },
        {
          "exercise": "Olhe para o seu arquivo de configuração do logrotate e veja como ele gerencia alguns dos seus logs.",
          "id": 6,
          "lessonContent": "Os arquivos de log geram muitos dados e armazenam esses dados em seus discos rígidos, no entanto, existem muitos problemas com isso, na maior parte do tempo só queremos ser capazes de ver logs mais recentes, também queremos gerenciar nosso espaço em disco de forma eficiente, então como fazemos tudo isso? A resposta é com o logrotate. \n\nA utilidade logrotate faz o gerenciamento de logs para nós. Possui um arquivo de configuração que nos permite especificar quantos e quais logs manter, como comprimir nossos logs para economizar espaço e mais. A ferramenta logrotate geralmente é executada pelo cron uma vez por dia e os arquivos de configuração podem ser encontrados em /etc/logrotate.d. \n\nExistem outras ferramentas de rotação de logs que você pode usar para gerenciar seus logs, mas o logrotate é o mais comum.",
          "quizAnswer": "logrotate",
          "quizQuestion": "Qual utilitário é usado para gerenciar logs?",
          "slug": "gerenciandoarquivosdelog",
          "title": "Gerenciando Arquivos de Log"
        }
      ],
      "slug": "logging",
      "title": "Logging"
    },
    {
      "description": "Aprenda sobre compartilhamento de rede com rsync, scp, nfs e mais.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Tente copiar um arquivo com o scp de uma máquina para outra.",
          "id": 1,
          "lessonContent": "Normalmente, você não é o único computador em sua rede, especialmente se estiver trabalhando em um ambiente comercial. Quando queremos transferir dados de uma máquina para outra, às vezes pode ser mais fácil conectar uma unidade USB e copiá-los manualmente. Mas na maioria das vezes, se estiver trabalhando com máquinas na mesma rede, a maneira de transferir dados é através do compartilhamento de arquivos em rede. \n\nNeste curso, vamos revisar alguns métodos diferentes para copiar dados de e para diferentes máquinas em sua rede. Vamos discutir algumas cópias simples de arquivos e, em seguida, falaremos sobre montar diretórios inteiros em sua máquina que funcionam como uma unidade separada. \n\nUma ferramenta simples de compartilhamento de arquivos é o comando <b>scp</b>. O comando scp significa cópia segura, funciona exatamente como o comando cp, mas permite que você copie de um host para outro host na mesma rede. Ele funciona via ssh, então todas as suas ações estão usando a mesma autenticação e segurança do ssh. \n\n<b>Para copiar um arquivo de um host local para um host remoto</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>Para copiar um arquivo de um host remoto para seu host local</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>Para copiar um diretório do seu host local para um host remoto</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "Que comando você pode usar para copiar arquivos com segurança de um host para outro?",
          "slug": "compartilhamentodearquivosnarede",
          "title": "Visão Geral do Compartilhamento de Arquivos"
        },
        {
          "exercise": "Use o rsync para sincronizar um diretório com outro diretório, certifique-se de não sobrescrever um diretório importante!",
          "id": 2,
          "lessonContent": "Outra ferramenta usada para copiar dados de hosts diferentes é o rsync (abreviação de sincronização remota). O rsync é muito semelhante ao scp, mas tem uma diferença importante. O rsync utiliza um algoritmo especial que verifica antecipadamente se já existem dados que você está copiando e só copiará as diferenças. Por exemplo, digamos que você estava copiando um arquivo e sua rede foi interrompida, portanto, sua cópia parou no meio. Em vez de recopiar tudo desde o início, o rsync só copiará as partes que não foram copiadas.\n\nEle também verifica a integridade de um arquivo que está sendo copiado com checksums. Essas pequenas otimizações permitem uma maior flexibilidade na transferência de arquivos e tornam o rsync ideal para sincronização de diretórios remotamente e localmente, backups de dados, transferências de dados grandes e muito mais.\n\nAlgumas opções comumente usadas do rsync:\n\n<ul>\n<li>v - saída detalhada</li>\n<li>r - recursivo em diretórios</li>\n<li>h - saída legível para humanos</li>\n<li>z - comprimido para transferência mais fácil, ótimo para conexões lentas</li>\n</ul>\n\n<b>Copiar/sincronizar arquivos no mesmo host</b>\n\n<pre>$ rsync -zvr /meu/diretório/local/um /meu/diretório/local/dois</pre>\n\n<b>Copiar/sincronizar arquivos para o host local de um host remoto</b>\n\n<pre>$ rsync /diretório/local nomedeusuário@hostremoto.com:/diretório/remoto</pre>\n\n<b>Copiar/sincronizar arquivos para um host remoto de um host local</b>\n\n<pre>$ rsync nomedeusuário@hostremoto.com:/diretório/remoto /diretório/local</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "Qual comando seria útil para backups de dados?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "Tente configurar um SimpleHTTPServer!",
          "id": 3,
          "lessonContent": "O Python possui uma ferramenta super útil para servir arquivos via HTTP. Isso é ótimo se você apenas deseja criar uma rápida compartilhamento de rede que outras máquinas em sua rede possam acessar. Para fazer isso, basta ir para o diretório que deseja compartilhar e executar:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nIsso configura um servidor web básico que você pode acessar através do endereço localhost. Portanto, pegue o endereço IP da máquina em que você executou isso e, em outra máquina, acesse-o no navegador com: http://ENDEREÇO_IP:8000. Em sua própria máquina, você pode visualizar os arquivos disponíveis digitando: http://localhost:8000 em seu navegador da web.\n\nVocê também pode fazer isso com node ou, se estiver executando Python 3, a sintaxe será um pouco diferente.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Que ferramenta você pode usar para criar um servidor http simples com python?",
          "slug": "simplehttpserver",
          "title": "Servidor HTTP Simples"
        },
        {
          "exercise": "Leia a página do manual do NFS para aprender mais.",
          "id": 4,
          "lessonContent": "A forma mais padrão de compartilhamento de arquivos em rede para Linux é o NFS (Network File System), o NFS permite que um servidor compartilhe diretórios e arquivos com um ou mais clientes pela rede. \n\nNão entraremos em detalhes sobre como criar um servidor NFS, pois pode ficar complexo, no entanto, discutiremos a configuração de clientes NFS.\n\n<b>Configurando um cliente NFS</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>Montagem Automática</b>\n\nDigamos que você use o servidor NFS com frequência e deseja mantê-lo montado permanentemente, normalmente você pensaria em editar o arquivo /etc/fstab, mas nem sempre você terá uma conexão com o servidor e isso pode causar problemas durante a inicialização. Em vez disso, o que você deseja fazer é configurar a montagem automática para que você possa se conectar ao servidor NFS quando precisar. Isso é feito com a ferramenta <b>automount</b> ou, em versões recentes do Linux, <b>amd</b>. Quando um arquivo é acessado em um diretório específico, o automount procurará o servidor remoto e o montará automaticamente.",
          "quizAnswer": "automount",
          "quizQuestion": "Qual ferramenta é usada para gerenciar pontos de montagem automaticamente?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Configure um compartilhamento do Samba, se você não tiver um, abra o smb.conf e familiarize-se com as opções no arquivo de configuração.",
          "id": 5,
          "lessonContent": "Nos primeiros dias da computação, tornou-se necessário que máquinas Windows compartilhassem arquivos com máquinas Linux, assim nasceu o protocolo Server Message Block (SMB). O SMB era usado para compartilhar arquivos entre sistemas operacionais Windows (o Mac também tem compartilhamento de arquivos com SMB) e depois foi posteriormente limpo e otimizado na forma do protocolo Common Internet File System (CIFS).\n\nSamba é o que chamamos de utilitários Linux para trabalhar com CIFS no Linux. Além do compartilhamento de arquivos, você também pode compartilhar recursos como impressoras.\n\n<b>Criar um compartilhamento de rede com o Samba</b>\n\nVamos passar pelos passos básicos para criar um compartilhamento de rede que uma máquina Windows pode acessar:\n\n<b>Instalar o Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Configurar smb.conf</b>\n\nO arquivo de configuração do Samba é encontrado em /etc/samba/smb.conf, este arquivo deve informar ao sistema quais diretórios devem ser compartilhados, suas permissões de acesso e mais opções. O smb.conf padrão já vem com muito código comentado e você pode usá-los como exemplo para escrever suas próprias configurações.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Configurar uma senha para o Samba</b>\n\n<pre>$ sudo smbpasswd -a [nome de usuário]</pre>\n\n<b>Criar um diretório compartilhado</b>\n\n<pre>$ mkdir /meu/diretório/para/compartilhar</pre>\n\n<b>Reiniciar o serviço do Samba</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Acessar um compartilhamento do Samba via Windows</b>\n\nNo Windows, basta digitar a conexão de rede no prompt de execução: \\\\HOST\\nomedocompartilhamento.\n\n<b>Acessar um compartilhamento do Samba/Windows via Linux</b>\n\n<pre>$ smbclient //HOST/diretório -U usuário</pre>\n\nO pacote Samba inclui uma ferramenta de linha de comando chamada <b>smbclient</b> que você pode usar para acessar qualquer servidor Windows ou Samba. Uma vez conectado ao compartilhamento, você pode navegar e transferir arquivos.\n\n<b>Anexar um compartilhamento do Samba ao seu sistema</b>\n\nEm vez de transferir arquivos um por um, você pode simplesmente montar o compartilhamento de rede em seu sistema.\n\n<pre>$ sudo mount -t cifs nomeservidor:diretório pontomontagem -o usuário=nomeusuário,senha=senha</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Qual é o protocolo mais recente usado para transferência de arquivos entre Windows e Linux?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Compartilhamento de Rede"
    },
    {
      "description": "Aprenda sobre os fundamentos de rede e o modelo TCP/IP.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Vamos dar uma olhada em uma rede doméstica típica, você tem alguns componentes diferentes. \n\n<ul>\n<li>ISP - Seu provedor de serviços de Internet, a empresa que você paga para obter Internet em sua casa.</li>\n<li>Router - O roteador permite que cada máquina em sua rede se conecte à Internet. Na maioria dos roteadores modernos, você pode se conectar via wireless ou um cabo Ethernet.</li>\n<li>WAN - Rede de Área Ampla, é isso que chamamos a rede que abrange tudo entre seu roteador e uma rede mais ampla, como a Internet.</li>\n<li>WLAN - Rede Local sem Fio, é a rede entre seu roteador e quaisquer dispositivos sem fio que você possa ter, como laptops.</li>\n<li>LAN - Rede Local, é a rede entre seu roteador e quaisquer dispositivos com fio, como PCs de mesa.</li>\n<li>Hosts - Cada máquina em uma rede é conhecida como um host.</li>\n</ul>\n\nOs dados e informações que são transmitidos pelas redes são conhecidos como pacotes e, até o final da seção do Networking Nomad, você entenderá em detalhes como um pacote viaja de e para os hosts.",
          "quizAnswer": "LAN",
          "quizQuestion": "Como é conhecida a rede local?",
          "slug": "noçõesbásicasderede",
          "title": "Noções Básicas de Rede"
        },
        {
          "exercise": "Leia mais sobre o modelo OSI: <a href=\"https://en.wikipedia.org/wiki/OSI_model\">https://en.wikipedia.org/wiki/OSI_model</a>",
          "id": 2,
          "lessonContent": "Antes de podermos olhar para algumas coisas práticas de rede, temos que revisar alguns termos chatos que você provavelmente já ouviu falar antes. O modelo OSI (Open Systems Interconnection) é um modelo teórico de rede. Este modelo nos mostra como um pacote percorre uma rede em sete camadas diferentes. Não entrarei em detalhes sobre este modelo, já que a maioria desses cursos de rede será focada no modelo TCP/IP, mas deve ser mencionado que existe um modelo teórico de rede e que realmente desempenhou um grande papel no modelo de rede TCP/IP que usamos hoje.",
          "quizAnswer": "OSI",
          "quizQuestion": "O que é usado como modelo teórico de rede?",
          "slug": "osimodel",
          "title": "Modelo OSI"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 3,
          "lessonContent": "O modelo OSI deu origem ao que eventualmente se tornou o modelo TCP/IP e este modelo é na verdade no que a Internet é baseada. É a implementação real de redes. O modelo TCP/IP utiliza o conjunto de protocolos TCP/IP, que comumente nos referimos apenas como TCP/IP. Esses protocolos trabalham juntos para especificar como os dados devem ser coletados, endereçados, transmitidos e roteados através de uma rede. Usando o modelo TCP/IP, podemos ver como esses protocolos são usados para mostrar a decomposição de como um pacote viaja pela rede.\n\n<b>Camada de Aplicação</b>\n\nA camada superior do modelo TCP/IP. Ela determina como os programas do seu computador (como seu navegador da web) interagem com os serviços da camada de transporte para visualizar os dados que são enviados ou recebidos.\n\nEsta camada utiliza:\n<ul>\n<li>HTTP (Protocolo de Transferência de Hipertexto) - usado para as páginas da web na Internet.</li>\n<li>SMTP (Protocolo Simples de Transferência de Correio) - transmissão de correio eletrônico (email)</li>\n</ul>\n\n<b>Camada de Transporte</b>\n\nComo os dados serão transmitidos, inclui verificação das portas corretas, integridade dos dados e basicamente entrega de nossos pacotes.\n\nEsta camada utiliza:\n<ul>\n<li>TCP (Protocolo de Controle de Transmissão) - entrega confiável de dados</li>\n<li>UDP (Protocolo de Datagrama de Usuário) - entrega não confiável de dados</li>\n</ul>\n\n<b>Camada de Rede</b>\n\nEsta camada especifica como mover pacotes entre hosts e através de redes.\n\nEsta camada utiliza:\n<ul>\n<li>IP (Protocolo de Internet) - Ajuda a rotear pacotes de uma máquina para outra.</li>\n<li>ICMP (Protocolo de Mensagem de Controle da Internet) - Ajuda a nos dizer o que está acontecendo, como mensagens de erro e informações de depuração.</li>\n</ul>\n\n<b>Camada de Link</b>\n\nEsta camada especifica como enviar dados através de um pedaço físico de hardware. Como dados que viajam através de Ethernet, fibra, etc.\n\nAs listas acima dos protocolos que cada camada utiliza não são extensivas e você encontrará muitos outros protocolos que entram em jogo.\n\nNas próximas lições, vamos mergulhar em cada uma dessas camadas e discutir como nosso pacote atravessa a rede aos olhos do modelo TCP/IP (existem muitas perspectivas sobre como um pacote viaja através de redes, não vamos examiná-las todas, mas esteja ciente de que elas existem).",
          "quizAnswer": "Aplicação",
          "quizQuestion": "Qual é a camada superior do modelo TCP/IP?",
          "slug": "modelo-tcpip",
          "title": "Modelo TCP/IP"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 4,
          "lessonContent": "Antes de vermos como um pacote se move através de uma rede, precisamos nos familiarizar com alguns termos. Quando você envia uma carta, é preciso saber para quem está sendo enviada e de onde está vindo. Os pacotes precisam das mesmas informações, nossos hosts e outros hosts são identificados usando endereços MAC (controle de acesso à mídia) e endereços IP, para facilitar para nós humanos, usamos nomes de host para identificar um host.\n\n<b>Endereços MAC</b>\n\nUm endereço MAC é um identificador único usado como um endereço de hardware. Esse endereço nunca mudará. Quando você deseja acessar a Internet, sua máquina precisa ter um dispositivo chamado placa de interface de rede. Este adaptador de rede tem seu próprio endereço de hardware que é usado para identificar sua máquina. Um endereço MAC para um dispositivo Ethernet se parece com isso 00:C4:B5:45:B2:43. Os endereços MAC são atribuídos aos adaptadores de rede quando são fabricados. Cada fabricante possui um identificador exclusivo organizacional (OUI) para identificá-los como o fabricante. Este OUI é representado pelos primeiros 3 bytes do endereço MAC. Por exemplo, a Dell tem 00-14-22, então um adaptador de rede da Dell poderia ter um endereço MAC como: 00-14-22-34-B2-C2.\n\n<b>Endereços IP</b>\n\nUm endereço IP é usado para identificar um dispositivo em uma rede, eles são independentes de hardware e podem variar em sintaxe dependendo se você está usando IPv4 ou IPv6 (mais sobre isso depois). Por enquanto, vamos assumir que você está usando IPv4, então um endereço IP típico seria assim: 10.24.12.4. Os endereços IP são usados no lado do software da rede. Sempre que um sistema está conectado à Internet, ele deve ter um endereço IP. Eles também podem mudar se sua rede mudar e são únicos para toda a Internet (isso nem sempre é o caso quando aprendemos sobre NAT).\n\nLembre-se que são necessários tanto software quanto hardware para mover pacotes através de redes, então temos dois identificadores para cada um, MAC (hardware) e IP (software).\n\n<b>Nomes de Host</b>\n\nUma última maneira de identificar suas máquinas é através do nome de host. Os nomes de host pegam seu endereço IP e permitem que você associe esse endereço a um nome legível por humanos. Em vez de lembrar 192.12.41.4, você pode simplesmente lembrar meuhost.com.",
          "quizAnswer": "4",
          "quizQuestion": "Quantos bytes há em um endereço IPv4?",
          "slug": "enderecamentoderede",
          "title": "Endereçamento de Rede"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Vamos supor que eu queira enviar um e-mail para a Patty. Vamos passar por cada uma das camadas TCP/IP para ver isso em ação. \n\nLembre-se de que pacotes são usados para transmitir dados através de redes, um pacote consiste em um cabeçalho e carga útil. O cabeçalho contém informações sobre para onde o pacote está indo e de onde ele veio. A carga útil são os dados reais que estão sendo transferidos. Conforme nosso pacote percorre a rede, cada camada adiciona um pouco de informação ao cabeçalho do pacote. Também tenha em mente que diferentes camadas usam um termo diferente para nosso \"pacote\". Na camada de transporte, essencialmente encapsulamos nossos dados em um segmento e na camada de enlace nos referimos a isso como um quadro, mas saiba que pacote pode ser usado em relação à mesma coisa.\n\nPrimeiro, começamos na camada de aplicação. Quando enviamos nosso e-mail através de nosso cliente de e-mail, a camada de aplicação encapsulará esses dados. A camada de aplicação se comunica com a camada de transporte por meio de uma porta especificada e através dessa porta envia seus dados. Queremos enviar um e-mail através do protocolo da camada de aplicação SMTP (protocolo de transferência de e-mail simples). Os dados são enviados através de nosso protocolo de transporte que abre uma conexão para esta porta (a porta 25 é usada para SMTP), então obtemos esses dados enviados através desta porta e esses dados são enviados para a camada de transporte para ser encapsulado em segmentos.",
          "quizAnswer": "Aplicação",
          "quizQuestion": "Qual camada é usada para apresentar os dados do pacote em um formato amigável ao usuário?",
          "slug": "camadadeaplicacao",
          "title": "Camada de Aplicação"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 6,
          "lessonContent": "A camada de transporte nos ajuda a transferir nossos dados de uma maneira que as redes possam lê-los. Ela quebra nossos dados em pedaços que serão transportados e reunidos na ordem correta. Esses pedaços são conhecidos como segmentos. Os segmentos facilitam o transporte de dados pelas redes. \n\n<b>Portas</b>\n\nMesmo sabendo para onde estamos enviando nossos dados por meio de endereços IP, eles não são específicos o suficiente para enviar nossos dados para determinados processos ou serviços. Serviços como HTTP usam um canal de comunicação via portas. Se quisermos enviar dados de uma página da web, precisamos enviá-los pela porta HTTP (porta 80). Além de formar segmentos, a camada de transporte também anexará as portas de origem e destino ao segmento, para que, quando o receptor receber o pacote final, saiba qual porta usar. \n\n<b>UDP</b>\n\nExistem dois protocolos de transporte populares, UDP e TCP. Vamos discutir brevemente o UDP e passar a maior parte do tempo no TCP, pois é o mais comumente usado.\n\nO UDP não é um método confiável de transporte de dados, na verdade, não se importa se você recebe todos os seus dados originais. Isso pode parecer terrível, mas tem seus usos, como para streaming de mídia, tudo bem se você perder alguns quadros, em troca, obtém seus dados um pouco mais rápido. \n\n<b>TCP</b>\n\nO TCP fornece uma conexão confiável e orientada a conexão de fluxo de dados. O TCP usa portas para enviar dados de e para hosts. Uma aplicação abre uma conexão de uma porta em seu host para outra porta em um host remoto. Para estabelecer a conexão, usamos o handshake do TCP. \n\n<ul>\n<li>O cliente (processo de conexão) envia um segmento SYN para o servidor para solicitar uma conexão</li>\n<li>O servidor envia ao cliente um segmento SYN-ACK para reconhecer a solicitação de conexão do cliente</li>\n<li>O cliente envia um ACK ao servidor para reconhecer a solicitação de conexão do servidor</li>\n</ul>\n\nUma vez estabelecida essa conexão, os dados podem ser trocados por meio de uma conexão TCP. Os dados são enviados em segmentos diferentes e são rastreados com números de sequência TCP para que possam ser organizados na ordem correta quando forem entregues. Em nosso exemplo de e-mail, a camada de transporte anexa a porta de destino (25) à porta de origem do host de origem.",
          "quizAnswer": "TCP",
          "quizQuestion": "Qual é um protocolo de transporte confiável?",
          "slug": "camadadetransporte",
          "title": "Camada de Transporte"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 7,
          "lessonContent": "A camada de rede determina o roteamento dos nossos pacotes do nosso host de origem para um host de destino. Felizmente, em nosso exemplo, nosso pacote está viajando apenas dentro da mesma rede, mas a Internet é composta por muitas redes. Essas redes menores que compõem a Internet são conhecidas como sub-redes. Todas as sub-redes se conectam de alguma forma, por isso conseguimos acessar www.google.com mesmo que esteja em sua própria rede. Não entrarei em detalhes, pois temos um curso inteiro dedicado às sub-redes, mas por enquanto, em relação à nossa camada de rede, saiba que os endereços IP definem as regras para viajar para diferentes sub-redes. \n\nNa camada de rede, ela recebe o segmento vindo da camada de transporte e encapsula esse segmento em um pacote IP, em seguida, anexa o endereço IP do host de origem e o endereço IP do host de destino ao cabeçalho do pacote. Neste ponto, nosso pacote tem informações sobre para onde está indo e de onde veio. Agora ele envia nosso pacote para a camada de hardware físico.",
          "quizAnswer": "sub-redes",
          "quizQuestion": "Como são chamadas as redes menores que compõem a Internet?",
          "slug": "camadaderede",
          "title": "Camada de Rede"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 8,
          "lessonContent": "No fundo do modelo TCP/IP está a Camada de Ligação. Esta camada é a camada específica de hardware.\n\nNa camada de ligação, nosso pacote é encapsulado mais uma vez em algo chamado de quadro. O cabeçalho do quadro anexa os endereços MAC de origem e destino de nossos hosts, checksums e separadores de pacotes para que o receptor possa saber quando um pacote termina. \n\nFelizmente estamos na mesma rede, então nosso pacote não terá que viajar muito longe. Primeiro, a camada de ligação anexa meu endereço MAC de origem ao cabeçalho do quadro, mas também precisa saber o endereço MAC da Patty. Como ele sabe disso e como eu o encontro, já que não está na Internet? Usamos ARP!\n\n<b>ARP (Protocolo de Resolução de Endereços)</b>\n\nO ARP encontra o endereço MAC associado a um endereço IP. O ARP é usado dentro da mesma rede. Se a Patty não estivesse na mesma rede, usaríamos um sistema de roteamento para determinar o próximo roteador que receberia o pacote e uma vez que estivéssemos na mesma rede, poderíamos usar o ARP. \n\nUma vez que estamos na mesma rede, os sistemas primeiro usam a tabela de pesquisa ARP que armazena informações sobre quais endereços IP estão associados a quais endereços MAC. Se o valor não estiver lá, então o ARP é usado. Em seguida, o sistema enviará uma mensagem de broadcast para a rede usando o protocolo ARP para descobrir qual host possui o IP 10.10.1.4. Uma mensagem de broadcast é uma mensagem especial que é enviada para todos os hosts em uma rede (adequadamente nomeada para enviar um broadcast). Qualquer máquina com o endereço IP solicitado responderá com um pacote ARP contendo o endereço IP e o endereço MAC.\n\nAgora que temos todos os dados necessários, endereços IP e MAC, nossa camada de ligação encaminha este quadro através de nosso cartão de interface de rede, para o próximo dispositivo e encontra a rede da Patty. Este passo é um pouco mais complexo do que eu acabei de explicar, mas discutiremos mais detalhes no curso de Roteamento.\n\nE aí está uma travessia de pacotes simples (ou não tão simples) pela camada TCP/IP. Tenha em mente que os pacotes não viajam de forma unidirecional como esta. Ainda nem chegamos à rede da Patty! Ao viajar pelas redes, é necessário passar pelo modelo TCP/IP pelo menos duas vezes antes que quaisquer dados sejam enviados ou recebidos. Na realidade, a aparência deste pacote seria algo assim: \n\n<b>Travessia de Pacotes</b>\n\n<ol>\n<li>Pete envia um e-mail para a Patty: esses dados são enviados para a camada de transporte.</li>\n<li>A camada de transporte encapsula os dados em um cabeçalho TCP ou UDP para formar um segmento, o segmento anexa a porta TCP ou UDP de destino e de origem, em seguida, o segmento é enviado para a camada de rede.</li>\n<li>A camada de rede encapsula o segmento TCP dentro de um pacote IP, anexa os endereços IP de origem e destino. Em seguida, roteia o pacote para a camada de ligação.</li>\n<li>O pacote então chega ao hardware físico do Pete e é encapsulado em um quadro. Os endereços MAC de origem e destino são adicionados ao quadro.</li>\n<li>A Patty recebe este quadro de dados através de sua camada física e verifica cada quadro quanto à integridade dos dados, em seguida, desencapsula o conteúdo do quadro e envia o pacote IP para a camada de rede.</li>\n<li>A camada de rede lê o pacote para encontrar o IP de origem e destino que foi anexado anteriormente. Ele verifica se seu IP é o mesmo que o IP de destino, o que é! Ele desencapsula o pacote e envia o segmento para a camada de transporte.</li>\n<li>A camada de transporte desencapsula os segmentos, verifica os números das portas TCP ou UDP e estabelece uma conexão com a camada de aplicação com base nesses números de porta.</li>\n<li>A camada de aplicação recebe os dados da camada de transporte na porta especificada e os apresenta para a Patty na forma da mensagem de e-mail final</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "O que é usado para encontrar o endereço MAC na mesma rede?",
          "slug": "camadaligacao",
          "title": "Camada de Ligação"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 9,
          "lessonContent": "Um conceito importante de rede que ainda não abordamos é o DHCP (Protocolo de Configuração Dinâmica de Host)\n\nO DHCP atribui endereços IP, máscaras de sub-rede e gateways às nossas máquinas. Por exemplo, digamos que você tenha um celular e queira obter um número de celular para começar a falar com as pessoas. Você precisa ligar para sua operadora de telefonia e eles lhe darão um número. Enquanto você pagar suas contas, poderá continuar usando seu telefone. O DHCP é a operadora de telefonia nesse caso, ele fornece a você um endereço IP para que você possa falar com outros endereços IP. Você também recebe um endereço IP em regime de locação, que dura por um determinado período de tempo e será renovado dependendo de como você configurou suas definições de locação. \n\nO DHCP é ótimo por muitas razões, ele permite que um administrador de rede não se preocupe em atribuir endereços IP e também impede a configuração de endereços IP duplicados. Cada rede física deve ter seu próprio servidor DHCP para que um host possa solicitar um endereço IP. Em um ambiente doméstico comum, o roteador geralmente atua como servidor DHCP.\n\nO DHCP obtém todas as suas informações de host dinâmicas da seguinte maneira:\n\n<ol>\n<li>DHCP DISCOVER - Esta mensagem é transmitida para procurar um servidor DHCP.</li>\n<li>DHCP OFFER - O servidor DHCP na rede responde com uma mensagem de oferta. A oferta contém um pacote com tempo de locação DHCP, máscara de sub-rede, endereço IP, etc.</li>\n<li>DHCP REQUEST - O cliente envia outra transmissão para informar a todos os servidores DHCP qual oferta ele aceitou.</li>\n<li>DHCP ACK - O servidor envia um reconhecimento.</li>\n</ol>\n\nO DHCP é mais complexo do que isso, mas esta é a essência dele.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "Quais são as etapas em uma solicitação DHCP?",
          "slug": "visao-geral-dhcp",
          "title": "Visão Geral do DHCP"
        }
      ],
      "slug": "networkbasics",
      "title": "Fundamentos de Rede"
    },
    {
      "description": "Aprenda sobre sub-redes e como fazer aritmética de sub-redes!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Encontre seu endereço IP com ifconfig.",
          "id": 1,
          "lessonContent": "Cada host de rede tem um endereço único, e cada endereço único pode ser usado para localizar o host dentro da rede. Esses endereços únicos são conhecidos como 'endereços IP'. Um endereço IPv4 se parece com isso:\n\n<pre>204.23.124.23</pre>\n\nEste endereço na verdade contém duas partes: a parte da rede (que identifica em qual rede está) e a parte do host (que identifica o host). Para este curso, estaremos principalmente discutindo endereços IPv4, que é o que você comumente verá ao se referir a 'endereços IP'.\n\nUm endereço IP é separado em octetos pelos pontos. Existem 4 octetos em um endereço IPv4. Se você conhece um pouco de ciência da computação, saberá que um octeto é composto por 8 bits e que 8 bits na verdade equivalem a 1 byte. Isso significa que um endereço IPv4 tem 4 bytes. Usamos bits com frequência ao lidar com sub-redes e endereços IP.\n\nVocê pode ver seu endereço IP com o comando 'ifconfig -a':\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nComo você pode ver, meu endereço IPv4 é: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "Quantos bytes há em um endereço IPv4?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Use ifconfig para visualizar sua máscara de sub-rede.",
          "id": 2,
          "lessonContent": "Como posso saber se estou na mesma rede que a Patty? Bem, podemos simplesmente olhar para a sub-rede, abreviação de sub-rede. Uma sub-rede é um grupo de hosts com endereços IP que são semelhantes de certa forma. Esses hosts geralmente estão em uma localização próxima uns dos outros e você pode facilmente enviar dados de e para hosts na mesma sub-rede. Pense nisso como enviar correio no mesmo código postal, é muito mais fácil do que enviar correio para um estado diferente. \n\nPor exemplo, todos os hosts com um endereço IP que começa com 123.45.67 estariam na mesma sub-rede. Meu host tem um IP de 123.45.67.8 e o da Patty tem um IP de 123.45.67.9. Os números comuns são meu prefixo de rede e o 8 e 9 são nossos hosts, portanto minha rede é a mesma que a da Patty. Uma sub-rede é dividida em um prefixo de rede, como 123.45.67.0 e uma máscara de sub-rede.\n\n<b>Máscaras de Sub-rede</b>\n\nAs máscaras de sub-rede determinam qual parte do seu endereço IP é a parte de rede e qual parte é a parte do host. \n\nUma máscara de sub-rede típica pode se parecer com isso:\n\n<pre>255.255.255.0</pre>\n\nA parte 255 é na verdade nossa máscara. Para facilitar um pouco o entendimento, lembre-se de como nos referimos a cada octeto como 8 bits? Em ciência da computação, um bit é representado por um 0 ou um 1 na forma binária. Quando números binários são usados, 1 significa ligado e 0 significa desligado. Então o que 8 0's ou 1's equivalem?\n\nDigite no Google \"calculadora de binário para decimal\" e converta 11111111 em forma decimal. O que você obtém? 255! Então um octeto varia de 0 a 255. Então se tivéssemos uma máscara de sub-rede de 255.255.255.0 e um endereço IP de 192.168.1.0, quantos hosts estão nessa sub-rede? Descobriremos a resposta para isso em nossa lição de matemática de sub-rede.\n\nAlém disso, quando falamos sobre nossa sub-rede, comumente a denotamos pelo prefixo de rede seguido pela máscara de sub-rede:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>Por quê?</b>\n\nPor que diabos fazemos sub-redes? O particionamento de sub-redes é usado para segmentar redes e controlar o fluxo de tráfego dentro dessa rede. Portanto, um host em uma sub-rede não pode interagir com outro host em uma sub-rede diferente. \n\nMas espere um minuto, e se eu quiser me conectar a outros hosts como yahoo.com? Então você precisa conectar sub-redes juntas. Para conectar sub-redes, você só precisa encontrar os hosts que estão conectados a mais de uma sub-rede. Por exemplo, se meu host em 192.168.1.129 está conectado a uma rede local de 192.168.1.129/24, ele pode alcançar qualquer host nessa rede. Para alcançar hosts no restante da Internet, ele precisa se comunicar através do roteador. Tradicionalmente, na maioria das redes com uma máscara de sub-rede de 255.255.255.0, o roteador geralmente está no endereço 1 da sub-rede, então 192.168.1.1. Agora, esse roteador terá uma porta que o conecta a outra sub-rede (mais no curso de Roteamento). Certos endereços IP (redes privadas) não são visíveis para a internet, e temos coisas como NAT em vigor (mais sobre isso depois).",
          "quizAnswer": "Verdadeiro",
          "quizQuestion": "Verdadeiro ou falso, uma sub-rede consiste em uma máscara de sub-rede e prefixo de rede.",
          "slug": "sub-redes",
          "title": "Sub-redes"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Ok, sabemos que as máscaras de subrede são importantes para descobrir quantos hosts podemos ter em nossa subrede. Então, quantos hosts seriam esses? \n\nDigamos que eu tenha um endereço IP de <b>192.168.1.0</b> e uma máscara de subrede de <b>255.255.255.0</b>, agora vamos alinhar esses números em forma binária. Por enquanto, use uma calculadora online para converter esses valores de decimal para binário.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nO endereço IP é mascarado pela nossa máscara de subrede, quando você vê um 1, ele está mascarado e fingimos que não o vemos. Portanto, os únicos hosts possíveis que podemos ter são da região 00000000. Lembre-se de que 11111111 em forma binária equivale a 255, também consideramos 0 como um número de host, então existem 256 opções possíveis. No entanto, pode parecer que temos 256 opções possíveis, mas na verdade subtraímos 2 hosts porque precisamos considerar o endereço de broadcast e o endereço de subrede, o que nos deixa com 254 hosts possíveis em nossa subrede. Portanto, sabemos que podemos ter hosts com endereços IP variando de 192.168.1.1 a 192.168.1.254.",
          "quizAnswer": "11111111",
          "quizQuestion": "Qual é o equivalente binário de 255?",
          "slug": "subnetmath",
          "title": "Matemática de Subrede"
        },
        {
          "exercise": "Olhe para seu endereço IP e máscara de sub-rede e veja quantos hosts você pode ter em sua sub-rede.",
          "id": 4,
          "lessonContent": "Eu odeio ter que adicionar esta seção, no mundo real você provavelmente nunca teria que fazer cálculos de sub-rede à mão, no entanto, se você estivesse sendo entrevistado sobre isso, teria que saber como converter para e de forma binária para subnetting. Felizmente, existem algumas dicas de aritmética que você pode memorizar. \n\nPrimeiro, memorize seus cálculos em base-2, apenas faça isso:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Tabela Decimal para Binário</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nExistem muitas razões pelas quais o gráfico a seguir parece da maneira que parece, se você estiver curioso sobre como funciona, existem muitos recursos online.\n\nOk, memorizou esses? Vamos fazer uma rápida conversão de decimal para binário:\n\n<b>Converter 192.168.23.43 para Binário</b>\n\nLembre-se: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nVamos passar pela conversão do primeiro octeto para binário e você entenderá como o restante funciona.\n\n<ol>\n<li>Você consegue subtrair 192 - 128? Sim, então o primeiro bit é 1</li>\n<li>192 - 128 = 64, o próximo número no gráfico é 64, você consegue subtrair 64 - 64? Sim, então o segundo bit é 1</li>\n<li>Nós acabamos de números para subtrair, então nossa forma binária de 192 é 11000000</li>\n</ol>\n\n<b>Converter Binário 11000000 para Decimal</b>\n\nPara a conversão de binário para decimal, some os números que têm 1, então:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "Qual é a conversão binária de 123?",
          "slug": "dicas-de-subnetting",
          "title": "Dicas de Subnetting"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "CIDR (classless inter-domain routing) é usado para representar uma máscara de sub-rede de forma mais compacta. Você pode ver sub-redes notadas na notação CIDR, onde uma sub-rede como 10.42.3.0/255.255.255.0 é escrita como 10.42.3.0/24, o que significa que inclui tanto o prefixo da sub-rede quanto a máscara da sub-rede.\n\nLembre-se de que um endereço IP consiste em 4 bytes ou 32 bits, o CIDR indica a quantidade de bits usados como prefixo de rede. Portanto, 123.12.24.0/23 significa que os primeiros 23 bits são usados. Bem, o que isso significa? Quantos hosts são esses?\n\nUm truque simples é subtrair o total de bits que um endereço IP pode ter (32) do endereço CIDR (23), o que deixa 9 bits, 2^9 = 512, mas temos que remover 2 endereços (endereço de sub-rede e endereço de broadcast), então temos 510 hosts utilizáveis.",
          "quizAnswer": "",
          "quizQuestion": "Nenhuma pergunta, continue!",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 6,
          "lessonContent": "Já mencionamos o NAT (tradução de endereços de rede) antes, mas não aprofundamos. Quando estamos trabalhando em nossa rede, isso significa que a Internet pode ver nosso endereço IP? Não exatamente.\n\nO NAT faz com que um dispositivo como nosso roteador atue como intermediário entre a Internet e a rede privada. Assim, apenas um único endereço IP exclusivo é necessário para representar todo um grupo de computadores.\n\nPense no NAT como um recepcionista em um grande escritório, se alguém quiser entrar em contato com você, eles só conhecem o número do escritório inteiro, o recepcionista então teria que procurar o seu número de ramal e encaminhar a ligação para você.\n\n<b>Como funciona?</b>\n\nUm caso simples seria assim:\n\n<ol>\n<li>Patty quer se conectar ao www.google.com, então sua máquina envia essa solicitação através do roteador</li>\n<li>O roteador pega essa solicitação e abre sua própria conexão com o google.com, então envia a solicitação de Patty assim que estabelece a conexão</li>\n<li>O roteador é o intermediário entre Patty e www.google.com. O Google não sabe sobre Patty, em vez disso, tudo o que pode ver é o roteador.</li>\n</ol>\n\nO NAT e o roteamento de pacotes em geral podem ficar bastante complicados, mas não vamos nos aprofundar nos detalhes.",
          "quizAnswer": "NAT",
          "quizQuestion": "O que é usado para representar um único endereço privado para a Internet?",
          "slug": "traducaodenatdeenderecoderede",
          "title": "NAT"
        },
        {
          "exercise": "Verifique ifconfig para ver se você tem um endereço IPv6 listado.",
          "id": 7,
          "lessonContent": "Já ouvimos o termo IPv6 aqui e ali, mas o que é? Cada dispositivo que se conecta à Internet recebe seu próprio endereço IP, bem, isso acontece ser um número finito que estamos prestes a atingir nesta era digital. O IPv6 foi criado para nos permitir conectar mais hosts à Internet, ele vem com mais melhorias de IP, no entanto, sua adoção é bastante lenta. Não é destinado a substituir o IPv4, eles são destinados a se complementar. Os dois protocolos IP são muito semelhantes e se você conhece o IPv4, você entenderá o IPv6, a principal diferença é a forma como o endereço é escrito. Aqui está como um endereço IPv6 típico se parece:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "Qual endereço IP é usado para aumentar o número de hosts que podem se conectar à Internet?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Sub-rede"
    },
    {
      "description": "Aprenda como os pacotes são roteados em redes!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Já usamos o termo roteador antes, espero que saiba o que é, já que provavelmente tem um em casa. Um roteador permite que máquinas em uma rede se comuniquem entre si e com outras redes. Em um roteador típico, você terá portas LAN, que permitem que suas máquinas se conectem à mesma rede local, e também terá uma porta de uplink para a Internet que o conecta à Internet, às vezes você verá essa porta sendo rotulada como WAN, porque essencialmente está conectando você a uma rede mais ampla. Quando fazemos qualquer tipo de atividade de rede, ela precisa passar pelo roteador. O roteador decide para onde vão nossos pacotes de rede e quais entram. Ele roteia nossos pacotes entre várias redes para ir do host de origem ao host de destino. \n\n<b>Como um roteador funciona?</b>\n\nPense no roteamento da mesma forma que a entrega de correio, temos um endereço para o qual queremos enviar uma carta, quando a enviamos para o correio, eles pegam a carta e veem, oh, isso vai para a Califórnia, vou colocá-la no caminhão que vai para a Califórnia (sinceramente, não faço ideia de como funciona o sistema postal). A carta então é enviada para São Francisco, dentro de São Francisco existem diferentes códigos postais, e dentro desses códigos postais existem códigos de endereço menores, até que finalmente alguém consegue entregar sua carta no endereço desejado. Por outro lado, se você já mora em São Francisco e no mesmo código postal, o entregador de correio provavelmente saberá exatamente para onde a carta deve ir sem entregá-la a mais ninguém. \n\nQuando roteamos pacotes, eles usam \"rotas\" de endereço semelhantes, como para chegar à rede A, envie esses pacotes para a rede B. Quando não temos uma rota definida para isso, temos uma rota padrão que nossos pacotes usarão. Essas rotas são definidas em uma tabela de roteamento que nosso sistema usa para nos guiar entre redes.\n\n<b>Hops</b>\n\nÀ medida que os pacotes se movem entre redes, eles viajam em saltos, um salto é como medimos aproximadamente a distância que o pacote deve percorrer para ir da origem ao destino. Digamos que tenho dois roteadores conectando o host A ao host B, portanto, dizemos que existem dois saltos entre o host A e o host B. Cada salto é um dispositivo intermediário como os roteadores pelos quais devemos passar.\n\n<b>Compreendendo a diferença básica entre Comutação, Roteamento e Flood?</b>\nA COMUTAÇÃO de pacotes basicamente consiste em receber, processar e encaminhar dados para o dispositivo de destino.\nO ROTEAMENTO é um processo de criação da tabela de roteamento, para que possamos fazer a COMUTAÇÃO de forma mais eficiente.\nAntes do roteamento, era usado o FLOODING. Se um roteador não souber para onde enviar um pacote, então cada pacote recebido é enviado por cada link de saída, exceto aquele pelo qual chegou.",
          "quizAnswer": "saltos",
          "quizQuestion": "Como os pacotes medem a distância?",
          "slug": "oqueeoroteador",
          "title": "O que é um roteador?"
        },
        {
          "exercise": "Olhe sua tabela de roteamento e veja para onde seus pacotes podem ir.",
          "id": 2,
          "lessonContent": "Olhe a tabela de roteamento da sua máquina:\n\n<pre>\npete@icebox:~$ sudo route -n\nTabela de roteamento IP do Kernel\nDestino         Gateway         Máscara de rede  Flags Métrica Ref    Uso Interface\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destino</b>\n\nNo primeiro campo, temos um endereço IP de destino de 192.168.224.0, isso significa que qualquer pacote que tente ir para essa rede, sai através do meu cabo Ethernet (eth0). Se eu fosse 192.168.224.5 e quisesse chegar a 192.168.224.7, eu usaria a interface de rede eth0 diretamente.\n\nObserve que temos endereços de <b>0.0.0.0</b>, isso significa que nenhum endereço está especificado ou é desconhecido. Então, por exemplo, se eu quisesse enviar um pacote para o endereço IP 151.123.43.6, nossa tabela de roteamento não sabe para onde isso vai, então o denota como 0.0.0.0 e, portanto, roteia nosso pacote para o Gateway.\n\n<b>Gateway</b>\n\nSe estivermos enviando um pacote que não está na mesma rede, ele será enviado para este endereço de Gateway. Que é apropriadamente chamado de Gateway para outra rede.\n\n<b>Máscara de rede</b>\n\nEsta é a máscara de sub-rede, usada para descobrir quais endereços IP correspondem a qual destino.\n\n<b>Flags</b>\n\n<ul>\n<li>UG - A rede está ativa e é um Gateway</li>\n<li>U - A rede está ativa</li>\n</ul>\n\n<b>Interface</b>\n\nEsta é a interface pela qual nosso pacote sairá, eth0 geralmente representa o primeiro dispositivo Ethernet em seu sistema.",
          "quizAnswer": "Gateway",
          "quizQuestion": "Para onde os pacotes são roteados se nossa tabela de roteamento não souber?",
          "slug": "tabela-de-roteamento",
          "title": "Tabela de Roteamento"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 3,
          "lessonContent": "<b>Vamos ver como um pacote viaja dentro de sua rede local</b>\n\n<ol>\n<li>Primeiro, a máquina local irá comparar o endereço IP de destino para ver se está na mesma sub-rede, olhando para sua máscara de sub-rede.</li>\n<li>Quando os pacotes são enviados, eles precisam ter um endereço MAC de origem, endereço MAC de destino, endereço IP de origem e endereço IP de destino, neste ponto não sabemos o endereço MAC de destino.</li>\n<li>Para chegar ao host de destino, usamos ARP para transmitir uma solicitação na rede local para encontrar o endereço MAC do host de destino.</li>\n<li>Agora o pacote pode ser enviado com sucesso!</li>\n</ol>\n\n<b>Vamos ver como um pacote viaja fora de sua rede</b>\n\n<ol>\n<li>Primeiro, a máquina local irá comparar o endereço IP de destino, como está fora de nossa rede, não vê o endereço MAC do host de destino. E não podemos usar ARP porque a solicitação ARP é uma transmissão para hosts conectados localmente.</li>\n<li>Então nosso pacote agora olha para a tabela de roteamento, não conhece o endereço do IP de destino, então o envia para o gateway padrão (outro roteador). Agora nosso pacote contém nosso IP de origem, IP de destino e MAC de origem, porém não temos um MAC de destino. Lembre-se que os endereços MAC só são alcançados através da mesma rede. O que fazemos então? Enviamos uma solicitação ARP para obter o endereço MAC do gateway padrão.</li>\n<li>O roteador olha para o pacote e confirma o endereço MAC de destino, mas não é o endereço IP de destino final, então continua olhando para a tabela de roteamento para encaminhar o pacote para outro endereço IP que pode ajudar o pacote a seguir em direção ao seu destino. Sempre que o pacote se move, ele remove os antigos endereços MAC de origem e destino e atualiza o pacote com os novos endereços MAC de origem e destino.</li>\n<li>Uma vez que o pacote é encaminhado para a mesma rede, usamos ARP para encontrar o endereço MAC de destino final</li>\n<li>Ao longo desse processo, nosso pacote não altera o endereço IP de origem ou de destino.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Como encontramos o endereço MAC de um endereço IP?",
          "slug": "caminhodeumpacote",
          "title": "Caminho de um Pacote"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 4,
          "lessonContent": "Seria uma dor ter que configurar manualmente rotas em uma tabela de roteamento para cada dispositivo em sua rede, então em vez disso usamos o que são conhecidos como protocolos de roteamento. Os protocolos de roteamento são usados para ajudar nosso sistema a se adaptar a mudanças na rede, ele aprende diferentes rotas, as constrói na tabela de roteamento e então roteia nossos pacotes por esse caminho. Existem dois tipos principais de protocolos de roteamento, protocolos de vetor de distância e protocolos de estado de link.\n\n<b>Convergência</b>\n\nAntes de falarmos sobre os protocolos, devemos revisar um termo usado em roteamento conhecido como convergência. Ao usar protocolos de roteamento, os roteadores se comunicam com outros roteadores para coletar e trocar informações sobre a rede. Quando concordam sobre como uma rede deve ser, cada tabela de roteamento mapeia a topologia completa da rede, assim \"convergindo\". Quando algo ocorre na topologia da rede, a convergência será temporariamente interrompida até que todos os roteadores estejam cientes dessa mudança.",
          "quizAnswer": "convergência",
          "quizQuestion": "Qual é o termo usado quando todas as tabelas de roteamento conhecem a topologia da rede?",
          "slug": "protocolosderoteamento",
          "title": "Protocolos de Roteamento"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Os protocolos de vetor de distância determinam o caminho de outras redes usando o número de saltos que um pacote faz pela rede. Se a rede A estiver a 3 saltos de distância e a rede B estiver ao lado da rede A, então assumimos que deve estar a 4 saltos de distância. Nos protocolos de vetor de distância, a próxima rota seria aquela com a menor quantidade de saltos.\n\nOs protocolos de vetor de distância são ótimos para redes pequenas, mas quando as redes começam a escalar, leva mais tempo para os roteadores convergirem porque periodicamente enviam a tabela de roteamento inteira para todos os roteadores. Outra desvantagem dos protocolos de vetor de distância é a eficiência, pois escolhem rotas mais próximas em saltos, mas nem sempre escolhem a rota mais eficiente.\n\nUm dos protocolos de vetor de distância comuns é o RIP (Routing Information Protocol), que transmite a tabela de roteamento para todos os roteadores na rede a cada 30 segundos. Para uma rede grande, isso pode exigir muita capacidade, e por isso o RIP limita sua contagem de saltos para 15.",
          "quizAnswer": "falso",
          "quizQuestion": "Verdadeiro ou falso, os protocolos de distância usam a rota com a menor quantidade de largura de banda?",
          "slug": "protocolosdevetordedistancia",
          "title": "Protocolos de Vetor de Distância"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 6,
          "lessonContent": "Os protocolos de estado de ligação são ótimos para redes de grande escala, são mais complexos do que os protocolos de vetor de distância, no entanto, uma grande vantagem é a capacidade de convergir rapidamente, isso ocorre porque, em vez de enviar periodicamente toda a tabela de roteamento, eles enviam apenas atualizações para rotas vizinhas. Eles usam um algoritmo diferente para calcular o caminho mais curto primeiro e constroem sua topologia de rede na forma de um gráfico para mostrar quais roteadores estão conectados a outros roteadores.\n\nUm dos protocolos de estado de ligação comuns é o OSPF (Open Shortest Path First), ele atualiza apenas as tabelas de roteamento se houver uma alteração na rede. Ele não tem um limite de saltos.",
          "quizAnswer": "OSPF",
          "quizQuestion": "Qual é um dos protocolos de estado de ligação mais comuns?",
          "slug": "protocolosdeestadodeligacao",
          "title": "Protocolos de Estado de Ligação"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 7,
          "lessonContent": "O último protocolo importante que discutiremos é o BGP, o BGP é basicamente como a Internet funciona. É usado para coletar e trocar informações de roteamento entre sistemas autônomos. Pense em um sistema autônomo como um provedor de serviços de Internet, uma empresa, universidade, qualquer organização, etc. Sem o BGP, esses sistemas não saberiam como se comunicar entre si, eles seriam isolados. Em vez de rotear dentro desses sistemas autônomos, o BGP roteia entre eles.\n\nDigamos que você esteja na sua rede doméstica e eu esteja trabalhando no Starbucks, quero poder me comunicar com você, então envio um e-mail e o pacote de rede viaja pela rede do Starbucks, ele circula por lá e passa pelas tabelas de roteamento na rede do Starbucks até finalmente atingir um ponto na fronteira da rede do Starbucks e passá-lo para um roteador de Gateway de Borda. Este roteador contém as informações para que meu pacote saia da rede do Starbucks e atravesse outras redes.",
          "quizAnswer": "BGP",
          "quizQuestion": "Qual protocolo basicamente faz a Internet funcionar?",
          "slug": "protocolodegatewaydeborda",
          "title": "Protocolo de Gateway de Borda"
        }
      ],
      "slug": "roteamento",
      "title": "Roteamento"
    },
    {
      "description": "Aprenda sobre configuração de rede usando ferramentas do Linux!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Tente alterar o estado de suas interfaces de rede para cima ou para baixo e observe o que acontece.\n\nVocê consegue alterar suas interfaces de rede com os comandos ifconfig e ip ?",
          "id": 1,
          "lessonContent": "Uma interface de rede é como o kernel conecta o lado do software de rede ao lado do hardware. Já vimos um exemplo disso: \n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> O comando ifconfig</b>\n\nA ferramenta <b>ifconfig</b> nos permite configurar nossas interfaces de rede, se não tivermos nenhuma interface de rede configurada, os drivers de dispositivo do kernel e a rede não saberão como se comunicar entre si. O ifconfig é executado na inicialização e configura nossas interfaces por meio de arquivos de configuração, mas também podemos modificá-los manualmente. A saída do ifconfig mostra o nome da interface no lado esquerdo e do lado direito mostra informações detalhadas. Você verá mais comumente interfaces nomeadas como eth0 (primeiro cartão Ethernet na máquina), wlan0 (interface sem fio), lo (interface de loopback). A interface de loopback é usada para representar seu computador, ela apenas o faz voltar para si mesmo. Isso é bom para depuração ou conexão com servidores em execução localmente. \n\nO status das interfaces pode ser up ou down, como você pode imaginar, se quiser \"desativar\" uma interface, pode defini-la como down. Os campos que você provavelmente olhará mais na saída do ifconfig são o HWaddr (endereço MAC da interface), endereço inet (endereço IPv4) e inet6 (endereço IPv6). Claro que você também pode ver que a máscara de sub-rede e o endereço de broadcast estão lá. Você também pode visualizar informações da interface em /etc/network/interfaces.\n\n<b>Para criar uma interface e ativá-la</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nIsso atribui um endereço IP e máscara de rede à interface eth0 e também a ativa.\n\n<b>Para ativar ou desativar uma interface</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> O comando ip </b>\n\nO comando <b>ip</b> também nos permite manipular a pilha de rede de um sistema. Dependendo da distribuição que você está usando, pode ser o método preferido para manipular suas configurações de rede. \n\nAqui estão alguns exemplos de uso:\n\n<b>Para mostrar informações da interface para todas as interfaces </b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Para mostrar as estatísticas de uma interface</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>Para mostrar os endereços IP alocados para interfaces</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>Para ativar e desativar interfaces</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Para adicionar um endereço IP a uma interface</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "Qual é o comando para configurar nossas interfaces de rede?",
          "slug": "interfacesderede",
          "title": "Interfaces de Rede"
        },
        {
          "exercise": "Não há exercícios para esta lição, mas você pode ler mais informações sobre os comandos discutidos aqui nas páginas do manual\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Já discutimos como visualizar nossas tabelas de roteamento com o comando route, se você quiser adicionar ou remover rotas, pode fazê-lo manualmente.\n\n<b>Adicionar uma nova rota</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Excluir uma rota</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nVocê também pode fazer essas alterações com o comando <b>ip</b>:\n\n<b>Para adicionar uma rota</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Para excluir uma rota</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\nou\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "Qual é a flag do comando para excluir uma rota?",
          "slug": "rota",
          "title": "rota"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Já discutimos sobre o DHCP antes e na maioria das vezes você nunca precisará definir estaticamente seus endereços IP, máscaras de sub-rede, etc. Em vez disso, você estará usando o DHCP! O dhclient é iniciado durante a inicialização e obtém uma lista de interfaces de rede do arquivo dhclient.conf. Para cada interface listada, ele tenta configurar a interface usando o protocolo DHCP.\n\nNo arquivo dhclient.leases, o dhclient mantém uma lista de concessões através dos reinícios do sistema, após ler o dhclient.conf, o arquivo dhclient.leases é lido para informá-lo sobre quais concessões ele já atribuiu.\n\n<b>Para obter um novo IP</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "O que tenta atribuir endereços IP com o protocolo DHCP?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 4,
          "lessonContent": "Claro, se você deseja ter a rede do seu sistema funcionando automaticamente, há algo já disponível para isso. A maioria das distribuições utiliza o daemon NetworkManager para configurar suas redes automaticamente. \n\nVocê notará o NetworkManager na forma de um applet em algum lugar na barra de tarefas da sua área de trabalho se estiver usando uma GUI. Como você pode ver, ele gerencia o hardware da sua rede e as informações de conexão. Por exemplo, na inicialização, o NetworkManager coleta informações do hardware de rede, procura por conexões sem fio, com fio, etc. e então as ativa.\n\nTambém existem ferramentas de linha de comando para interagir com o NetworkManager:\n\n<b>nm-tool</b>\n\nnm-tool relata o estado do NetworkManager e seus dispositivos\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nEstado: conectado (global)\n\n- Dispositivo: eth0  [Conexão com fio 1] -------------------------------------------\n  Tipo:              Com fio\n  Driver:            pcnet32\n  Estado:             conectado\n  Padrão:           sim\n  Endereço MAC:        12:3D:45:56:7D:CC\n\n  Capacidades:\n    Detectar Portadora:  sim\n\n  Propriedades com fio\n    Portadora:         ligada\n\n  Configurações IPv4:\n    Endereço:         192.168.22.1\n    Prefixo:          24 (255.255.255.0)\n    Gateway:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nO comando nmcli permite controlar e modificar o NetworkManager, consulte o manual para mais detalhes.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "Qual é o comando para visualizar as informações do NetworkManager?",
          "slug": "networkmanager",
          "title": "Gerenciador de Rede"
        },
        {
          "exercise": "Observe o que acontece com seu cache ARP quando você reinicia sua máquina e depois faz algo na rede.",
          "id": 5,
          "lessonContent": "Lembre-se de que ao pesquisarmos um endereço MAC com ARP, ele primeiro verifica o cache ARP armazenado localmente em nosso sistema, você pode realmente visualizar esse cache: \n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nO cache ARP está realmente vazio quando uma máquina é inicializada, ele é preenchido à medida que os pacotes são enviados para outros hosts. Se enviarmos um pacote para um destino que não está no cache ARP, o seguinte acontece:\n\n<ol>\n<li>O host de origem cria o quadro Ethernet com um pacote de solicitação ARP</li>\n<li>O host de origem transmite este quadro para toda a rede</li>\n<li>Se um dos hosts na rede conhece o endereço MAC correto, ele enviará um pacote de resposta e um quadro contendo o endereço MAC</li>\n<li>O host de origem adiciona o mapeamento de IP para endereço MAC ao cache ARP e então prossegue com o envio do pacote</li>\n</ol>\n\nVocê também pode visualizar seu cache ARP via o comando ip:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "Que comando você pode usar para visualizar seu cache ARP?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Configuração de Rede"
    },
    {
      "description": "Saiba mais sobre ferramentas de rede comuns para ajudá-lo a diagnosticar e resolver problemas!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 1,
          "lessonContent": "O Protocolo de Mensagem de Controle da Internet (ICMP) faz parte da suíte de protocolos TCP/IP, é usado para enviar atualizações e mensagens de erro e é um protocolo extremamente útil usado para depurar problemas de rede, como uma entrega de pacote falhada.\n\nCada mensagem ICMP contém um campo tipo, código e checksum. O campo tipo é o tipo de mensagem ICMP, o código é um subtipo e descreve mais informações sobre a mensagem e o checksum é usado para detectar problemas com a integridade da mensagem.\n\nVamos ver alguns tipos comuns de ICMP:\n\n<ul>\n<li>Tipo 0 - Resposta de Eco</li>\n<li>Tipo 3 - Destino Inalcançável</li>\n<li>Tipo 8 - Solicitação de Eco</li>\n<li>Tipo 11 - Tempo Excedido</li>\n</ul>\n\nQuando um pacote não consegue chegar a um destino, é gerada uma mensagem ICMP do Tipo 3, dentro do Tipo 3 existem 16 valores de código que descreverão ainda mais por que não consegue chegar ao destino: \n\n<ul>\n<li>Código 0 - Rede Inalcançável</li>\n<li>Código 1 - Host Inalcançável</li>\netc..etc..\n</ul>\n\nEssas mensagens farão mais sentido à medida que utilizarmos algumas ferramentas de resolução de problemas de rede.",
          "quizAnswer": "8",
          "quizQuestion": "Qual é o tipo ICMP para solicitação de eco?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Faça um ping em um site e veja a saída que você recebe.",
          "id": 2,
          "lessonContent": "Um dos mais simples ferramentas de rede <b>ping</b>, é usado para testar se um pacote pode alcançar um host. Funciona enviando pacotes de solicitação de eco ICMP (Tipo 8) para o host de destino e aguardando uma resposta de eco ICMP (Tipo 0). O ping é bem-sucedido quando um host envia o pacote de solicitação e recebe uma resposta do destino. Vamos ver um exemplo: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) bytes of data.\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nNeste exemplo, estamos usando o ping para verificar se conseguimos chegar ao www.google.com. A bandeira -c (contagem) é usada para parar de enviar pacotes de solicitação de eco após a contagem ter sido atingida. \n\nA primeira parte diz que estamos enviando pacotes de 64 bytes para 74.125.239.112 (google.com) e o restante nos mostra os detalhes da viagem. Por padrão, ele envia um pacote por segundo.\n\n<b>icmp_seq</b>\n\nO campo icmp_seq é usado para mostrar o número de sequência dos pacotes enviados, então neste caso, enviei 3 pacotes e podemos ver que 3 pacotes retornaram. Se você fizer um ping e alguns números de sequência estiverem faltando, isso significa que algum problema de conectividade está ocorrendo e nem todos os seus pacotes estão passando. Se o número de sequência estiver fora de ordem, sua conexão provavelmente está muito lenta, pois seus pacotes estão excedendo o padrão de um segundo. \n\n<b>ttl</b>\n\nO campo Time To Live (ttl) é usado como um contador de saltos, à medida que você faz saltos, ele decrementa o contador em um e, uma vez que o contador de saltos atinge 0, nosso pacote morre. Isso é para dar ao pacote uma vida útil, não queremos que nossos pacotes viajem para sempre.\n\n<b>time</b>\n\nO tempo de ida e volta desde o envio do pacote de solicitação de eco até receber uma resposta de eco.",
          "quizAnswer": "ms",
          "quizQuestion": "Qual é a unidade de medida do tempo de ida e volta?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Execute o comando traceroute em sua máquina e observe a saída.",
          "id": 3,
          "lessonContent": "O comando traceroute é usado para ver como os pacotes estão sendo roteados. Ele funciona enviando pacotes com valores de TTL crescentes, começando com 1. Assim, o primeiro roteador recebe o pacote e decrementa o valor de TTL em um, fazendo com que o pacote seja descartado. O roteador envia de volta uma mensagem ICMP Time Exceeded para nós. E então o próximo pacote recebe um TTL de 2, então ele passa pelo primeiro roteador, mas quando chega ao segundo roteador, o TTL é 0 e ele retorna outra mensagem ICMP Time Exceeded. O traceroute funciona dessa maneira porque, ao enviar e descartar pacotes, ele constrói uma lista de roteadores que os pacotes percorrem, até finalmente chegar ao seu destino e receber uma mensagem ICMP Echo Reply. \n\nAqui está um pequeno trecho de um traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute para google.com (216.58.216.174), no máximo 30 saltos, pacotes de 60 bytes                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nCada linha é um roteador ou máquina que está entre mim e meu destino. Mostra o nome do destino e seu endereço IP, e as últimas três colunas correspondem ao tempo de ida e volta de um pacote para chegar a esse roteador. Por padrão, enviamos três pacotes ao longo da rota.",
          "quizAnswer": "ttl",
          "quizQuestion": "O que é decrementado em um ao fazer saltos pela rede?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Consulte a página do manual para o netstat e aprenda todas as funcionalidades que ele tem a oferecer.",
          "id": 4,
          "lessonContent": "<b>Portas Bem Conhecidas</b>\n\nNós discutimos a transmissão de dados através de portas em nossa máquina, vamos olhar algumas portas bem conhecidas.\n\nVocê pode obter uma lista de portas bem conhecidas olhando o arquivo <b>/etc/services</b>: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..etc..\n</pre>\n\nA primeira coluna é o nome do serviço, em seguida, o número da porta e o protocolo da camada de transporte que ele usa.\n\n<b>netstat</b>\n\nUma ferramenta extremamente útil para obter informações detalhadas sobre sua rede é o <b>netstat</b>. Netstat exibe várias informações relacionadas à rede, como conexões de rede, tabelas de roteamento, informações sobre interfaces de rede e muito mais, é a ferramenta canivete suíço das ferramentas de rede. Vamos nos concentrar principalmente em uma funcionalidade que o netstat possui e é o status das conexões de rede. Antes de vermos um exemplo, vamos falar sobre sockets e portas primeiro. Um socket é uma interface que permite que programas enviem e recebam dados, enquanto uma porta é usada para identificar qual aplicativo deve enviar ou receber dados. O endereço do socket é a combinação do endereço IP e da porta. Cada conexão entre um host e um destino requer um socket único. Por exemplo, o HTTP é um serviço que roda na porta 80, no entanto, podemos ter muitas conexões HTTP e para manter cada conexão, um socket é criado por conexão.\n\n<pre>\npete@icebox:~$ netstat -at\nConexões ativas na Internet (servidores e estabelecidas)\nProto Recv-Q Send-Q Endereço Local           Endereço Remoto         Estado      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nO comando netstat -a mostra os sockets ouvintes e não ouvintes para conexões de rede, a flag -t mostra apenas conexões tcp. \n\nAs colunas são as seguintes da esquerda para a direita:\n\n<ul>\n<li>Proto: Protocolo utilizado, TCP ou UDP.</li>\n<li>Recv-Q: Dados enfileirados para serem recebidos</li>\n<li>Send-Q: Dados enfileirados para serem enviados</li>\n<li>Endereço Local: Host conectado localmente</li>\n<li>Endereço Remoto: Host conectado remotamente</li>\n<li>Estado: O estado do socket</li>\n</ul>\n\nConsulte a página do manual para uma lista de estados de socket, mas aqui estão alguns:\n\n<ul>\n<li>LISTENING: O socket está ouvindo conexões de entrada, lembre-se que quando fazemos uma conexão TCP, nosso destino tem que estar ouvindo para que possamos nos conectar.</li>\n<li>SYN_SENT: O socket está tentando ativamente estabelecer uma conexão.</li>\n<li>ESTABLISHED: O socket tem uma conexão estabelecida</li>\n<li>CLOSE_WAIT: O host remoto encerrou e estamos aguardando o fechamento do socket</li>\n<li>TIME_WAIT: O socket está aguardando após o fechamento para lidar com pacotes ainda na rede</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "Qual porta é usada para HTTPS?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Baixe e instale a ferramenta Wireshark e explore a interface.",
          "id": 5,
          "lessonContent": "O assunto da análise de pacotes poderia preencher um curso inteiro e existem muitos livros escritos apenas sobre análise de pacotes. No entanto, hoje aprenderemos apenas o básico. Existem dois analisadores de pacotes extremamente populares, Wireshark e tcpdump. Essas ferramentas escaneiam suas interfaces de rede, capturam a atividade dos pacotes, analisam os pacotes e nos mostram as informações. Elas nos permitem entrar nos detalhes da análise de rede e nos aprofundar nas questões de baixo nível. Vamos usar o tcpdump, já que ele tem uma interface mais simples, no entanto, se você quiser adotar a análise de pacotes em suas ferramentas, eu recomendaria dar uma olhada no Wireshark.\n\n<b>Instalar o tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Capturar dados do pacote em uma interface</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: saída detalhada suprimida, use -v ou -vv para decodificação completa do protocolo\nescutando em wlan0, tipo de link EN10MB (Ethernet), tamanho de captura 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitação de eco ICMP, id 1901, seq 2, comprimento 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: resposta de eco ICMP, id 1901, seq 2, comprimento 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitação de eco ICMP, id 1901, seq 3, comprimento 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: resposta de eco ICMP, id 1901, seq 3, comprimento 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitação de eco ICMP, id 1901, seq 4, comprimento 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: resposta de eco ICMP, id 1901, seq 4, comprimento 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitação de eco ICMP, id 1901, seq 5, comprimento 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: resposta de eco ICMP, id 1901, seq 5, comprimento 64\n11:28:30.674953 ARP, Solicitação quem-tem 172.254.1.0 informar ThePickleParty.lan, comprimento 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, comprimento 306\n</pre>\n\nVocê notará muitas coisas acontecendo quando executar uma captura de pacotes, bem, isso é de se esperar, há muita atividade de rede acontecendo em segundo plano. No meu exemplo acima, peguei apenas um trecho da minha captura, especificamente o momento em que decidi fazer ping em www.google.com. \n\n<b>Entendendo a saída</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitação de eco ICMP, id 1901, seq 2, comprimento 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: resposta de eco ICMP, id 1901, seq 2, comprimento 64\n</pre>\n\n<ul>\n<li>O primeiro campo é um carimbo de data/hora da atividade de rede</li>\n<li>IP, isso contém as informações do protocolo</li>\n<li>Em seguida, você verá o endereço de origem e destino: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, este é o número de sequência inicial e final dos pacotes TCP</li>\n<li>comprimento, comprimento em bytes</li>\n</ul>\n\nComo você pode ver em nossa saída do tcpdump, estamos enviando um pacote de solicitação de eco ICMP para www.google.com e recebendo um pacote de resposta de eco ICMP em retorno! Também observe que diferentes pacotes fornecerão informações diferentes, consulte o manual para ver quais são essas informações.\n\n<b>Escrevendo a saída do tcpdump em um arquivo</b>\n\n<pre>\n$ sudo tcpdump -w /algum/arquivo\n</pre>\n\n\nAlguns pensamentos finais: apenas arranhamos a superfície do assunto da análise de pacotes. Há muito para se explorar e nem mesmo tocamos em ir ainda mais fundo com a saída Hex e ASCII. Existem muitos recursos online para ajudá-lo a aprender mais sobre analisadores de pacotes e eu o encorajo a encontrá-los!",
          "quizAnswer": "-i",
          "quizQuestion": "Qual é a flag para capturar uma interface específica com o tcpdump?",
          "slug": "analise-de-pacotes",
          "title": "Análise de Pacotes"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Resolução de Problemas"
    },
    {
      "description": "Tudo e mais que você queria saber sobre DNS.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 1,
          "lessonContent": "Imagine se toda vez que você quisesse fazer uma pesquisa no Google, tivesse que digitar http://192.78.12.4 em vez de www.google.com. Bem, sem o DNS (\"Domain Name System\") é exatamente o que aconteceria. A rede de baixo nível só entende o endereço IP bruto para identificar um host. O DNS nos permite, humanos, acompanhar sites e hosts pelo nome em vez de um endereço IP. É como uma lista de contatos para a Internet. Se você conhece o nome de alguém, mas não sabe o número de telefone, pode simplesmente procurá-lo em sua lista de contatos.\n\nO DNS é fundamentalmente um banco de dados distribuído de nomes de host para endereços IP, gerenciamos nosso banco de dados para que as pessoas saibam como chegar ao nosso site/domínio, e em outro lugar outra pessoa está gerenciando seu banco de dados para que outros possam chegar ao seu domínio. Esses domínios são então capazes de se comunicar entre si e construir uma enorme lista de contatos da Internet.\n\nNeste curso, abordaremos alguns conceitos básicos de DNS, mas esteja ciente de que o DNS é um tópico exaustivo e se você realmente quiser se aprofundar nele, precisará fazer alguma pesquisa adicional.",
          "quizAnswer": "falso",
          "quizQuestion": "Verdadeiro ou falso, o DNS nos ajuda a encontrar endereços MAC para nomes de host?",
          "slug": "o-que-e-dns",
          "title": "O que é DNS?"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 2,
          "lessonContent": "O banco de dados do DNS da Internet depende de sites e organizações que fornecem parte desse banco de dados. Para fazer isso, eles precisam:\n\n<b>Servidor de Nomes</b>\n\nConfiguramos o DNS via \"servidores de nomes\", os servidores de nomes carregam nossas configurações de DNS e respostas e respondem a quaisquer perguntas de clientes ou outros servidores que queiram saber coisas como \"Quem é google.com?\". Se o servidor de nomes não souber a resposta para essa consulta, ele redirecionará a solicitação para outros servidores de nomes. Os servidores de nomes podem ser \"autoritativos\", o que significa que eles possuem os registros DNS reais que você está procurando, ou \"recursivos\", o que significa que eles perguntariam a outros servidores e esses servidores perguntariam a outros servidores até encontrarem um servidor autoritativo que contenha os registros DNS. Os servidores recursivos também podem ter as informações que queremos em cache em vez de alcançar um servidor autoritativo.\n\n<b>Arquivo de Zona</b>\n\nDentro de um servidor de nomes existe algo chamado arquivos de zona. Os arquivos de zona são como o servidor de nomes armazena informações sobre o domínio ou como chegar ao domínio se não souber.\n\n<b>Registros de Recursos</b>\n\nUm arquivo de zona é composto por entradas de registros de recursos. Cada linha é um registro e contém informações sobre hosts, servidores de nomes, outros recursos, etc. Os campos consistem no seguinte:\n\n<ul>\n<li>Nome do Registro</li>\n<li>TTL - O tempo após o qual descartamos o registro e obtemos um novo, no DNS o TTL é representado pelo tempo, então os registros podem ter um TTL de uma hora. A razão pela qual fazemos isso é porque a Internet está em constante mudança, um minuto um host pode ser mapeado para o endereço IP X e no próximo pode estar no endereço IP Y</li>\n<li>Classe - Namespace das informações do registro, mais comumente IN é usado para Internet</li>\n<li>Tipo - Tipo de informação armazenada nos dados do registro. Não entraremos nos tipos de registros, mas você provavelmente já viu tipos comuns como A para endereço, MX ou mail exchanger, etc.</li>\n<li>Dados - Este campo pode conter um endereço IP se for um registro A ou algo mais dependendo do tipo de registro.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "Qual tipo de registro de recurso é usado para trocadores de correio?",
          "slug": "componentesdodns",
          "title": "Componentes do DNS"
        },
        {
          "exercise": "Sem exercícios para esta lição.",
          "id": 3,
          "lessonContent": "Vamos ver um exemplo de como seu host encontra um domínio (catzontheinterwebz.com) com DNS. Basicamente, seguimos nosso caminho até chegarmos ao servidor DNS que conhece esse domínio.\n\n<b>Servidor DNS Local</b>\n\nPrimeiro, nosso host pergunta: \"Onde está catzontheinterwebz.com?\", nosso servidor DNS local não sabe, então ele começa do topo do funil para perguntar aos Servidores Raiz. Tenha em mente que nosso host não está fazendo essas solicitações para encontrar catzontheinterwebz.com diretamente, a maioria dos usuários fala com um servidor DNS recursivo fornecido por seus provedores de serviços de Internet e esse servidor é encarregado de encontrar a localização de catzontheinterwebz.com.\n\n<b>Servidores Raiz</b>\n\nExistem 13 Servidores Raiz para a Internet, eles são espelhados e distribuídos ao redor do mundo para lidar com solicitações DNS para a Internet, então realmente existem centenas de servidores que estão trabalhando, eles são controlados por diferentes organizações e contêm informações sobre Domínios de Nível Superior. Domínios de nível superior são o que você conhece como endereços .org, .com, .net, etc. Então, o Servidor Raiz não sabe onde está catzontheinterwebz.com, então ele nos diz para perguntar ao Servidor DNS de Domínio de Nível Superior .com em um endereço IP que ele nos fornece. \n\n<b>Domínio de Nível Superior</b>\n\nAgora enviamos outra solicitação ao servidor de nomes que conhece os endereços \".com\" e perguntamos se ele sabe onde está catzontheinterwebz.com? O TLD não tem o catzontheinterwebz.com em seus arquivos de zona, mas ele vê um registro para o servidor de nomes de catzontheinterwebz.com. Então ele nos dá o endereço IP desse servidor de nomes e nos diz para procurar lá.\n\n<b>Servidor DNS Autoritativo</b>\n\nAgora enviamos uma solicitação final ao servidor DNS que realmente tem o registro que queremos. O servidor de nomes vê que tem um arquivo de zona para catzontheinterwebz.com e há um registro de recurso para 'www' para este host. Então ele nos dá o endereço IP deste host e finalmente podemos ver alguns gatos na Internet.",
          "quizAnswer": "TLD",
          "quizQuestion": "Qual é a abreviação para os servidores de nomes onde são encontrados os endereços .com, .net, .org, etc?",
          "slug": "dnsprocess",
          "title": "Processo DNS"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 4,
          "lessonContent": "<p>Antes de nossa máquina realmente acessar o DNS para fazer uma consulta, ela primeiro verifica localmente em nossas máquinas.</p><br><p><b>/etc/hosts</b></p><p>O arquivo /etc/hosts contém mapeamentos de alguns nomes de host para endereços IP. Os campos são bastante autoexplicativos, há um para o endereço IP, o nome do host e então quaisquer alias para o host.</p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1 localhost<br>127.0.1.1 icebox</pre><p>Geralmente você verá seu endereço localhost listado como padrão neste arquivo. Você também pode gerenciar o acesso aos hosts modificando os arquivos /etc/hosts.deny ou /etc/hosts.allow. No entanto, se você for consciente da segurança, esta não é realmente a maneira correta de fazer e você deve estar modificando suas regras de firewall em vez disso.</p><p>Vamos ver um exemplo divertido de /etc/hosts. Modifique o arquivo e adicione uma linha para:</p><pre>123.45.6.7  www.google.com</pre><p>Salve o arquivo e agora acesse www.google.com. Está tendo problemas, não está? Bem, isso ocorre porque acabamos de mapear www.google.com para um endereço IP completamente errado. Como nossos hosts primeiro procuram localmente por mapeamentos de endereços IP, ele nunca alcança o DNS para encontrar google.com.</p><p><b>/etc/resolv.conf</b></p><p>Tradicionalmente, usamos um arquivo chamado /etc/resolv.conf para mapear servidores de nomes DNS para consultas mais eficientes, no entanto, com as melhorias feitas no DNS, este arquivo é frequentemente irrelevante, na verdade, você pode ver em meu exemplo abaixo que /etc/resolv.conf não é gerenciado manualmente. Consulte as configurações específicas de sua distribuição para gerenciar os mapeamentos de servidores de nomes DNS.</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     NÃO EDITE ESTE ARQUIVO MANUALMENTE - SUAS ALTERAÇÕES SERÃO SOBRESCRITAS<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "Qual arquivo é usado para mapear nomes de host para endereços IP em nossas máquinas?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "Não há exercícios para esta lição.",
          "id": 5,
          "lessonContent": "Não vamos passar pela configuração de um servidor DNS, pois isso seria um tutorial bastante extenso. Em vez disso, aqui está uma lista de comparação rápida dos servidores DNS populares para usar com o Linux.\n\n<b>BIND</b>\n\nO servidor DNS mais popular na Internet, é o padrão usado nas distribuições Linux. Foi originalmente desenvolvido na Universidade da Califórnia em Berkeley, daí o nome BIND (Berkeley Internet Name Domain). Se você precisa de poder e flexibilidade completos, não pode errar com o BIND.\n\n<b>DNSmasq</b>\n\nLeve e muito mais fácil de configurar do que o BIND. Se você deseja simplicidade e não precisa de todos os recursos do BIND, use o DNSmasq. Ele vem com todas as ferramentas necessárias para configurar DHCP e DNS, recomendado para uma rede menor.\n\n<b>PowerDNS</b>\n\nCompleto e semelhante ao BIND, oferece um pouco mais de flexibilidade com opções. Ele lê informações de múltiplos bancos de dados como MySQL, PostgreSQL, etc. para uma administração mais fácil. Apenas porque o BIND tem sido o modo como fazemos as coisas, não significa que tenha que permanecer assim.\n\nEsta não é uma lista completa, mas deve dar uma ideia de onde procurar se estiver configurando seu próprio servidor DNS.",
          "quizAnswer": "BIND",
          "quizQuestion": "Qual é o servidor DNS de facto para o Linux?",
          "slug": "configuracao-dns",
          "title": "Configuração de DNS"
        },
        {
          "exercise": "Leia a página de manual para dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nA ferramenta \"name server lookup\" é usada para consultar servidores de nomes para encontrar informações sobre registros de recursos. Vamos descobrir onde está o servidor de nomes para google.com:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nResposta não autoritativa:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (domain information groper) é uma ferramenta poderosa para obter informações sobre servidores de nomes DNS, é mais flexível do que nslookup e ótimo para solucionar problemas de DNS.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; opções globais: +cmd\n;; Resposta recebida:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: versão: 0, flags:; MBZ: 0005 , udp: 512\n;; SEÇÃO DE PERGUNTA:\n;www.google.com.                        IN      A\n\n;; SEÇÃO DE RESPOSTA:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Tempo de consulta: 27 msec\n;; SERVIDOR: 127.0.1.1#53(127.0.1.1)\n;; QUANDO: Dom Fev 07 10:14:00 PST 2016\n;; TAMANHO DA MSG  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "Qual ferramenta é usada para obter informações detalhadas sobre servidores de nomes DNS?",
          "slug": "ferramentas-dns",
          "title": "Ferramentas DNS"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Conteúdo",
      "exerciseAndQuiz": "Exercício e quiz"
    },
    "exerciseBox": {
      "exercise": "Exercício"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Uma nova vida para o LinuxJourney, que ajudou tantas pessoas a dar os primeiros passos no mundo do Linux.",
      "title": "Desbloqueie o poder do Linux"
    },
    "navbar": {
      "home": "Início",
      "language": "Idioma",
      "lessons": "Lições",
      "resources": "Recursos",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Voltar para os capítulos",
      "checkAnswer": "Verificar Resposta",
      "correctAnswer": "Resposta correta: ",
      "nextLesson": "Próxima lição",
      "placeholderAnswer": "Digite sua resposta aqui",
      "quiz": "Quiz",
      "showCorrectAnswer": "Mostrar resposta correta"
    },
    "resources": {
      "data": [
        {
          "description": "Um guia passo a passo para iniciantes que explica a história do terminal e comandos básicos",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Tutorial oficial do Ubuntu"
        },
        {
          "description": "Uma visão clara de como o terminal funciona, como executar comandos e navegar no sistema de arquivos.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "Um dos livros mais altamente recomendados!",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "Como o Linux Funciona"
        },
        {
          "description": "Livro extremamente abrangente para todo SysAdmin.",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "Manual de Administração de Sistemas UNIX e Linux"
        },
        {
          "description": "Ótimo guia abrangente para script shell.",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Bíblia de Comandos do Linux"
        },
        {
          "description": "Para usuários sérios de Linux, ótimo começo para programação de kernel.",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "A Interface de Programação do Linux: Um Sistema Linux e UNIX"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Descubra livros, tutoriais e ferramentas selecionadas para aprofundar seu conhecimento em Linux.",
        "title": "Recursos"
      },
      "title": "Recursos"
    }
  }
}