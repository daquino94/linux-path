{
  "chapters": [
    {
      "description": "Что такое Linux? Начните с выбора дистрибутива и установки.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Дополнительное чтение:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Кен Томпсон</a></li>\n<li><a href='https://stallman.org/'>Ричард Столлман</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Линус Торвальдс</a></li>",
          "id": 1,
          "lessonContent": "Привет, новичок! Так что, ты решил погрузиться в этот замечательный мир, известный как Linux? Лучше пристегнись, потому что тебя ждет долгий и трудный путь. Меня зовут Пингвин Пит, и я здесь, чтобы провести тебя через этот путь. Давай начнем с небольшой предыстории о Linux. \n\nЧтобы узнать, как появился Linux, давай вернемся к началу, к 1969 году, когда Кен Томпсон и Деннис Ритчи из Bell Laboratories разработали операционную систему UNIX. Позже ее переписали на C, чтобы сделать ее более переносимой, и в конечном итоге она стала широко используемой операционной системой. \n\nДесять лет спустя Ричард Столлман начал работу над проектом GNU (GNU is Not UNIX), ядро GNU, названное Hurd, которое, к сожалению, так и не было завершено. Также в результате этого была создана GNU General Public License (GPL), лицензия на свободное программное обеспечение.\n\nЯдро - самая важная часть операционной системы. Оно позволяет аппаратному обеспечению общаться с программным обеспечением. Оно также делает много других вещей, но мы рассмотрим это в другом курсе. Пока просто знай, что ядро контролирует практически все, что происходит в вашей системе. \n\nВ это время также были разработаны другие усилия, такие как BSD, MINIX и т. д., чтобы быть похожими на UNIX-системы. Однако одним из общих недостатков всех этих UNIX-подобных систем было отсутствие унифицированного ядра. \n\nЗатем в 1991 году молодой человек по имени Линус Торвальдс начал разработку того, что мы сегодня знаем как ядро Linux.",
          "quizAnswer": "Линус Торвальдс",
          "quizQuestion": "Кто разработал ядро Linux?",
          "slug": "linuxhistory",
          "title": "История"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 2,
          "lessonContent": "В предыдущем уроке мы узнали о ядре Linux, которое каждый день запускает миллионы устройств. Прежде чем двигаться дальше, стоит отметить, что термин Linux на самом деле не совсем корректен, поскольку он фактически относится к ядру Linux. Тем не менее, многие дистрибутивы используют ядро Linux, поэтому обычно известны как операционные системы Linux. \n\nСистема Linux делится на три основные части:\n\n<ul>\n<li>Аппаратное обеспечение - сюда входят все устройства, на которых работает ваша система, а также память, ЦП, диски и т. д.</li>\n<li>Ядро Linux - Как мы уже обсудили, ядро является основой операционной системы. Оно управляет аппаратным обеспечением и указывает ему, как взаимодействовать с системой.</li>\n<li>Пространство пользователя - Здесь пользователи, включая вас, будут непосредственно взаимодействовать с системой.</li>\n</ul>\n\nИтак, первым шагом, который нам нужно предпринять, будет установка Linux на ваш компьютер. У вас есть много вариантов на выбор, и этот курс поможет вам разобраться и начать выбор дистрибутива Linux. \n\nСуществует множество дистрибутивов Linux на выбор, мы рассмотрим наиболее популярные варианты.",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, переходите к следующему уроку!",
          "slug": "выбордистрибутивалinux",
          "title": "Выбор дистрибутива Linux"
        },
        {
          "exercise": "Если вас заинтересовала Debian в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Обзор</b>\nDebian - это операционная система, состоящая исключительно из свободного и открытого программного обеспечения. Она широко известна и находится в разработке уже более 20 лет. Есть три ветки, которые вы можете использовать: Stable, Testing и Unstable.\n\nStable - в целом хорошая ветка для использования. Testing и Unstable - это постоянные релизы. Это означает, что любые инкрементальные изменения в этих ветках в конечном итоге станут Stable. Например, если вы хотите перейти от Windows 8 к Windows 10, вам придется выполнить полную установку Windows 10. Однако, находясь на релизе Testing, вы автоматически получите обновления, пока он не станет следующим выпуском операционной системы, не выполняя полной установки.\n\n<b>Управление пакетами</b>\nDebian также использует инструменты управления пакетами Debian. Каждое распространение Linux устанавливает и управляет пакетами по-разному, используя различные инструменты управления пакетами. Мы подробнее рассмотрим это в следующем курсе.\n\n<b>Настройка</b>\nDebian может не получать последние обновления, но она крайне стабильна. Если вам нужна хорошая \"ядреная\" операционная система, то это то, что вам нужно.\n\n<b>Применение</b>\nDebian - в целом отличная операционная система для любой платформы.",
          "quizAnswer": "Rolling",
          "quizQuestion": "Какой вид релиза есть у Testing и Unstable?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Если вас заинтересовала ОС RHEL, перейдите в раздел установки и попробуйте: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Обзор</b>\nRed Hat Enterprise Linux, обычно называемый RHEL, разрабатывается компанией Red Hat. У RHEL есть строгие правила, ограничивающие свободное распространение, хотя он все равно предоставляет исходный код бесплатно.\n\n<b>Управление пакетами</b>\nRHEL использует другой менеджер пакетов, чем Debian, менеджер пакетов RPM, о котором мы в конечном итоге тоже узнаем.\n\n<b>Настройка</b>\nОперационные системы на основе RHEL немного отличаются от операционных систем на основе Debian, наиболее заметно в управлении пакетами. Если вы решите выбрать RHEL, лучше знать, что вам придется работать с ним.\n\n<b>Применение</b>\nКак следует из названия, он в основном используется в корпоративной среде, поэтому если вам нужна надежная серверная ОС, это было бы хорошим выбором.",
          "quizAnswer": "RPM",
          "quizQuestion": "Какой менеджер пакетов использует RHEL?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Если вас заинтересовала Ubuntu в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Обзор</b>\nОдним из самых популярных дистрибутивов Linux для персональных компьютеров является Ubuntu. Ubuntu также выпускает свою собственную среду рабочего стола Unity по умолчанию. \n\n<b>Управление пакетами</b>\nUbuntu - это операционная система на основе Debian, разработанная Canonical. Поэтому она использует основную систему управления пакетами Debian.\n\n<b>Возможность настройки</b>\nUbuntu - отличный выбор для начинающих, кто хочет попробовать Linux. Ubuntu предлагает простоту использования и отличный пользовательский интерфейс, что привело к его широкому распространению. Он широко используется и поддерживается, и больше всего похож на другие операционные системы, такие как OSX и Windows, с точки зрения удобства использования.\n\n<b>Применение</b>\nОтлично подходит для любой платформы: настольного компьютера, ноутбука и сервера.",
          "quizAnswer": "Debian",
          "quizQuestion": "На основе какой операционной системы основан Ubuntu?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Если вас заинтересовала Fedora в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Обзор</b>\nПоддерживаемый Red Hat, проект Fedora является сообществом, содержащим открытое программное обеспечение и бесплатное программное обеспечение. Red Hat Enterprise Linux отходит от Fedora, поэтому думайте о Fedora как об операционной системе RHEL. В конечном итоге RHEL будет получать обновления от Fedora после тщательного тестирования и обеспечения качества. Подумайте о Fedora как об эквиваленте Ubuntu, который использует бэкэнд Red Hat вместо Debian.\n\n<b>Управление пакетами</b>\nИспользует менеджер пакетов Red Hat.\n\n<b>Конфигурируемость</b>\nЕсли вы хотите использовать операционную систему на основе Red Hat, это дружественная к пользователю версия.\n\n<b>Использование</b>\nFedora отлично подходит, если вы хотите операционную систему на основе Red Hat без ценника. Рекомендуется для настольных компьютеров и ноутбуков.",
          "quizAnswer": "Fedora",
          "quizQuestion": "От чего отходит RHEL?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Если вас заинтересовал Linux Mint в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Обзор</b>\nLinux Mint основан на Ubuntu. Он использует репозитории программного обеспечения Ubuntu, поэтому одни и те же пакеты доступны в обеих дистрибутивах. Linux Mint предпочтительнее для некоторых пользователей по сравнению с Ubuntu, потому что не поставляется с некоторым проприетарным программным обеспечением, которое включено в Ubuntu, таким как Unity.\n\n<b>Управление пакетами</b>\nПоскольку Linux Mint основан на Ubuntu, он использует менеджер пакетов Debian.\n\n<b>Настройка</b>\nОтличный пользовательский интерфейс, отлично подходит для начинающих и менее надут, чем Ubuntu. В этом курсе я буду использовать Linux Mint, но можно использовать любое другое распространение.\n\n<b>Применение</b>\nОтлично подходит для настольных компьютеров и ноутбуков.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "На чем основан Linux Mint?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Если вас заинтересовал Gentoo в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Обзор</b>\nGentoo предлагает невероятную гибкость операционной системы за определенную цену. Он создан для опытных пользователей, которым не страшно познакомиться с системой ближе.\n\n<b>Управление пакетами</b>\nGentoo использует собственную систему управления пакетами, Portage. Система управления пакетами Portage очень модульная и легка в обслуживании, что играет большую роль в том, что операционная система в целом очень гибкая.\n\n<b>Настройка</b>\nЕсли вы только начинаете знакомиться с Linux и хотите выбрать более сложный путь, я бы выбрал Gentoo или Arch Linux в качестве вашего дистрибутива.\n\n<b>Применение</b>\nОтлично подходит для настольных компьютеров и ноутбуков.",
          "quizAnswer": "Portage",
          "quizQuestion": "Какую систему управления пакетами использует Gentoo?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Если вас заинтересовал Arch в качестве вашей операционной системы, перейдите в раздел установки и попробуйте: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Обзор</b>\nArch - это легкий и гибкий дистрибутив Linux, разрабатываемый на 100% сообществом. Подобно Debian, Arch использует модель постоянного обновления, поэтому постепенные обновления в конечном итоге становятся стабильными. Вам действительно нужно попотеть, чтобы понять систему и ее функции, но взамен вы получаете полный контроль над своей системой.\n\n<b>Управление пакетами</b>\nДля установки, обновления и управления пакетами Arch использует свой собственный менеджер пакетов, Pacman.\n\n<b>Настройка</b>\nЕсли вам нужна легкая операционная система и вы действительно хотите понять Linux, используйте Arch! Здесь есть небольшой кривая обучения, но для опытных пользователей Linux это отличный выбор.\n\n<b>Применение</b>\nОтлично подходит для настольных компьютеров и ноутбуков. Если у вас также есть небольшое устройство, такое как Raspberry Pi, и вам нужно установить на него легкую ОС, то Arch - отличный выбор.",
          "quizAnswer": "Pacman",
          "quizQuestion": "Какой менеджер пакетов использует Arch Linux?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Если вас заинтересовала openSUSE в качестве вашей операционной системы, перейдите на страницу загрузки и попробуйте: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Обзор</b>\nopenSUSE Linux создан проектом openSUSE. Сообщество, которое поощряет использование Linux везде, работая вместе открытым, прозрачным и дружелюбным образом как часть всемирного сообщества свободного и открытого программного обеспечения. openSUSE - второй по старшинству дистрибутив Linux, который использует базовую систему, совместимую с заслуживающими награды продуктами SUSE Linux Enterprise.\n\n<b>Управление пакетами</b>\nИспользует менеджер пакетов RPM.\n\n<b>Конфигурируемость</b>\nopenSUSE - отличный выбор для нового пользователя Linux. Он предлагает простое графическое приложение для установки/администрирования (<a href=\"http://yast.github.io/\">YaST</a>) и аккуратную базовую систему, с которой легко экспериментировать. openSUSE включает все необходимое для безопасного использования Интернета без вирусов/шпионского ПО и для воплощения своей креативности, будь то с фотографиями, видео, музыкой или кодом.\n\n<b>Применение</b>\nopenSUSE Leap полностью подходит для использования на настольном ПК и ноутбуке.",
          "quizAnswer": "yast",
          "quizQuestion": "Как называется Инструмент Администрирования/Установки openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Начало работы"
    },
    {
      "description": "Изучите основы командной строки, навигацию по файлам, каталогам и многое другое.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Попробуйте другие команды Linux и посмотрите, что они выводят:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "Мир - ваша устрица, или, вернее, раковина - ваша устрица. Что такое раковина? Раковина - это в основном программа, которая принимает ваши команды с клавиатуры и отправляет их в операционную систему для выполнения. Если вы когда-либо использовали графический интерфейс, вы, вероятно, видели программы, такие как \"Terminal\" или \"Console\", это просто программы, которые запускают для вас оболочку. На протяжении всего этого курса мы будем изучать чудеса оболочки. \n\nВ этом курсе мы будем использовать программу оболочку bash (Bourne Again shell), почти все дистрибутивы Linux по умолчанию используют оболочку bash. Существуют и другие оболочки, такие как ksh, zsh, tsch, но мы не будем в них углубляться. \n\nДавайте приступим! В зависимости от дистрибутива ваш приглашающий символ оболочки может измениться, но в большинстве случаев он должен соответствовать следующему формату:\n<pre>имя_пользователя@имя_хоста:текущий_каталог\npete@icebox:/home/pete $</pre>\n\nЗаметили $ в конце приглашения? Разные оболочки будут иметь разные приглашения, в нашем случае $ предназначен для обычного пользователя, использующего Bash, Bourne или Korn shell, вы не добавляете символ приглашения при вводе команды, просто знайте, что он там.\n\nНачнем с простой команды, echo. Команда echo просто выводит текстовые аргументы на экран.\n\n<pre>$ echo Hello World</pre>",
          "quizAnswer": "Hello World",
          "quizQuestion": "Что должно быть выведено на экран, когда вы вводите echo Hello World?",
          "slug": "theshell",
          "title": "The Shell"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 2,
          "lessonContent": "В Linux все является файлом. Погружаясь глубже в Linux, вы это поймете, но пока просто имейте это в виду. Каждый файл организован в иерархическом дереве каталогов. Первый каталог в файловой системе называется 'корневой каталог'. В корневом каталоге есть много папок и файлов, в которых вы можете хранить еще больше папок и файлов, и так далее. Вот пример того, как выглядит дерево каталогов: \n\n<pre>/\n|-- bin\n|   |-- file1\n|   |-- file2\n|-- etc\n|   |-- file3\n|   `-- directory1\n|       |-- file4\n|       `-- file5\n|-- home\n|-- var\n</pre>\n\nМестоположения этих файлов и каталогов называются 'путями'. Если у вас есть папка с именем 'home', внутри которой есть папка с именем 'pete' и еще одна папка в этой папке с именем 'Movies', этот путь будет выглядеть так: '/home/pete/Movies'. Довольно просто, не правда ли?\n\nНавигация по файловой системе, подобно навигации в реальной жизни, проще, если вы знаете, где вы находитесь и куда идете. Чтобы узнать, где вы находитесь, вы можете использовать команду 'pwd'. Эта команда означает «печать рабочего каталога» и показывает вам, в каком каталоге вы находитесь. Обратите внимание, что путь исходит из корневого каталога.\n\n<pre>$ pwd</pre>\n\nГде ты? Где я? Попробуйте сами.",
          "quizAnswer": "pwd",
          "quizQuestion": "Как узнать, в каком каталоге вы находитесь в данный момент?",
          "slug": "printworkingdirectorypwdcommand",
          "title": "pwd (Print Working Directory)"
        },
        {
          "exercise": "<ol>\n<li>Запустите команду cd без флагов, куда вы попадете?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Теперь, когда вы знаете, где находитесь, давайте посмотрим, можем ли мы немного перемещаться по файловой системе. Помните, что нам нужно будет перемещаться, используя пути. Существуют два различных способа указания пути: абсолютный и относительный пути. \n\n<ul>\n<li>Абсолютный путь: Это путь от корневого каталога. Корень - это главный. Корневой каталог обычно обозначается как косая черта. Каждый раз, когда ваш путь начинается с /, это означает, что вы начинаете с корневого каталога. Например, /home/pete/Desktop.</li>\n\n<li>Относительный путь: Это путь от вашего текущего местоположения в файловой системе. Если я нахожусь в месте /home/pete/Documents и хочу перейти в каталог внутри Documents с именем taxes, мне не нужно указывать весь путь от корня, как /home/pete/Documents/taxes, я могу просто перейти в taxes/.</li>\n</ul>\n\nТеперь, когда вы знаете, как работают пути, нам просто нужно что-то, чтобы помочь нам перейти в нужный каталог. К счастью, у нас есть cd или «change directory» для этого. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nТеперь я изменил местоположение моего каталога на /home/pete/Pictures.\n\nТеперь в этом каталоге у меня есть папка с именем Hawaii, я могу перейти в эту папку с помощью:\n\n<pre>$ cd Hawaii</pre>\n\nЗаметьте, как я просто использовал имя папки? Это потому, что я уже находился в /home/pete/Pictures.\n\nМожет быть довольно утомительно постоянно перемещаться с помощью абсолютных и относительных путей, к счастью, есть несколько ярлыков, которые могут вам помочь. \n\n<ul>\n<li>. (текущий каталог). Это каталог, в котором вы находитесь в данный момент. </li>\n<li>.. (предыдущий каталог). Переносит вас в каталог выше вашего текущего.</li>\n<li>~ (домашний каталог). Этот каталог по умолчанию является вашим «домашним каталогом». Например, /home/pete.</li>\n<li>- (предыдущий каталог). Это перенесет вас в предыдущий каталог, в котором вы только что находились.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nПопробуйте их!",
          "quizAnswer": "cd ..",
          "quizQuestion": "Если вы находитесь в /home/pete/Pictures и хотите перейти в /home/pete, какой хороший ярлык использовать?",
          "slug": "changedirectorycdcommand",
          "title": "cd (Изменение каталога)"
        },
        {
          "exercise": "Запустите ls с различными флагами и посмотрите результат, который вы получите.",
          "id": 4,
          "lessonContent": "Теперь, когда мы знаем, как перемещаться по системе, как мы можем узнать, что доступно нам? Сейчас это похоже на то, что мы движемся в темноте. Хорошо, мы можем использовать замечательную команду ls для отображения содержимого каталога. Команда ls отобразит каталоги и файлы в текущем каталоге по умолчанию, однако вы можете указать путь, для которого хотите увидеть список каталогов.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls - довольно полезный инструмент, он также показывает вам подробную информацию о файлах и каталогах, которые вы просматриваете.\n\nТакже обратите внимание, что не все файлы в каталоге будут видны. Имена файлов, начинающиеся с точки, скрыты, однако вы можете их просмотреть с помощью команды ls и передать флаг -a (a для всех).\n\n<pre>$ ls -a</pre>\n\nЕсть еще один полезный флаг ls, -l для long, который показывает подробный список файлов в длинном формате. Это покажет вам подробную информацию, начиная слева: разрешения файла, количество ссылок, имя владельца, группа владельца, размер файла, временная метка последней модификации и имя файла/каталога.\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nУ команд есть так называемые флаги (или аргументы или опции, как вы хотите их назвать), чтобы добавить больше функциональности. Заметьте, как мы добавили -a и -l, так вот, вы можете добавить их вместе с -la. Порядок флагов определяет их последовательность, большую часть времени это не имеет значения, поэтому вы также можете использовать ls -al и это все равно будет работать.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "Какую команду вы использовали бы для просмотра скрытых файлов?",
          "slug": "listdirectorieslscommand",
          "title": "ls (Список каталогов)"
        },
        {
          "exercise": "<ol>\n<li>Создайте новый файл</li>\n<li>Запомните временную метку</li>\n<li>Выполните touch для файла и еще раз проверьте временную метку</li>\n</ol>",
          "id": 5,
          "lessonContent": "Давайте научимся создавать файлы. Очень простой способ - использовать команду touch. Touch позволяет создавать новые пустые файлы.\n\n<pre>$ touch mysuperduperfile</pre>\n\nИ вуаля, новый файл! \n\nTouch также используется для изменения временных меток на существующих файлах и каталогах. Попробуйте сделать ls -l для файла и запомните временную метку, затем выполните touch для этого файла, и временная метка обновится. \n\nСуществует множество других способов создания файлов, которые включают другие вещи, такие как перенаправление и текстовые редакторы, но мы к этому вернемся в курсе по манипуляции текстом.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "Как создать файл с именем myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Запустите команду file на нескольких разных каталогах и файлах и запишите вывод.",
          "id": 6,
          "lessonContent": "На предыдущем уроке мы узнали о команде touch, вернемся к этому немного. Заметили ли вы, что имя файла не соответствует стандартному именованию, как вы, вероятно, видели в других операционных системах, таких как Windows? Обычно вы ожидаете файл с именем banana.jpeg и ожидаете файл изображения JPEG. \n\nВ Linux имена файлов не обязаны отражать содержимое файла. Вы можете создать файл с именем funny.gif, который на самом деле не является файлом GIF. \n\nЧтобы узнать, какого типа файл, вы можете использовать команду file. Она покажет вам описание содержимого файла.\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "Какую команду можно использовать для определения типа файла?",
          "slug": "командаФайла",
          "title": "файл"
        },
        {
          "exercise": "Запустите cat на разных файлах и каталогах. Затем попробуйте объединить несколько файлов с помощью cat.",
          "id": 7,
          "lessonContent": "Мы почти закончили работу с навигацией по файлам, но сначала давайте научимся читать файл. Простой командой для этого является команда cat, сокращение от concatenate, она не только отображает содержимое файла, но также может объединять несколько файлов и показывать вам результат их объединения. \n\n<pre>$ cat dogfile birdfile</pre>\n\nОна не очень хорошо подходит для просмотра больших файлов и предназначена только для короткого содержимого. Существует много других инструментов, которые мы используем для просмотра больших текстовых файлов, о которых мы поговорим в следующем уроке.",
          "quizAnswer": "cat",
          "quizQuestion": "Какой хороший способ увидеть содержимое файла?",
          "slug": "командакот",
          "title": "кот"
        },
        {
          "exercise": "Запустите less на файле, затем пролистайте его вверх и вниз. Попробуйте найти определенное слово. Быстро переместитесь в начало или конец файла.",
          "id": 8,
          "lessonContent": "Если вы просматриваете текстовые файлы, размер которых превышает простой вывод, less - это то, что вам нужно. (Фактически существует команда под названием more, которая делает нечто подобное, так что это иронично.) Текст отображается постранично, поэтому вы можете перемещаться по текстовому файлу страница за страницей. \n\nПродолжайте и изучайте содержимое файла с помощью less. Как только вы введете команду less, вы сможете использовать другие клавиатурные команды для навигации по файлу. \n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nИспользуйте следующую команду для навигации по less: \n\n<ul>\n<li>q - Используется для выхода из less и возврата в оболочку.</li>\n<li>Page up, Page down, Up and Down - Навигация с помощью стрелок и клавиш страниц.</li>\n<li>g - Переход к началу текстового файла.</li>\n<li>G - Переход к концу текстового файла.</li>\n<li>/search - Вы можете искать определенный текст внутри текстового документа. Предварительно введите символ / перед словами, которые хотите найти.</li>\n<li>h - Если вам нужна небольшая помощь по использованию less во время его использования, воспользуйтесь командой help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "Как выйти из команды less?",
          "slug": "lesscommand",
          "title": "less"
        },
        {
          "exercise": "Перемещайтесь по истории ваших предыдущих команд с помощью клавиш Вверх и Вниз. Поиграйтесь с обратным поиском ctrl-R.",
          "id": 9,
          "lessonContent": "В вашем оболочке есть история команд, которые вы ранее вводили, вы можете просмотреть эти команды. Это довольно полезно, когда вы хотите найти и выполнить команду, которую вы использовали ранее, не вводя ее снова.\n\n<pre>$ history</pre>\n\nХотите выполнить ту же команду, что и раньше? Просто нажмите стрелку вверх. \n\nХотите выполнить предыдущую команду, не вводя ее снова? Используйте !!. Если вы ввели cat file1 и хотите выполнить ее снова, вы можете просто ввести !! и она выполнит последнюю команду, которую вы выполнили. \n\nЕще один сокращенный вариант истории - ctrl-R, это команда обратного поиска, если вы нажмете ctrl-R и начнете вводить части команды, которую хотите, он покажет вам совпадения, и вы сможете просто перемещаться по ним, нажимая клавишу ctrl-R снова. Как только вы найдете команду, которую хотите использовать снова, просто нажмите клавишу Enter.\n\nНаш терминал немного перегружен, не так ли? Давайте немного уберем мусор, используйте команду clear, чтобы очистить ваш дисплей.\n\n<pre>$ clear</pre>\n\nТеперь выглядит лучше, не так ли? \n\nПока мы говорим о полезных вещах, одна из самых полезных функций в любой среде командной строки - это автозаполнение по Tab. Если вы начнете вводить начало команды, файла, каталога и нажмете клавишу Tab, он автоматически дополнит на основе того, что он находит в каталоге, который вы ищете, пока у вас нет других файлов, которые начинаются с этих букв. Например, если вы пытаетесь выполнить команду chrome, вы можете ввести chr и нажать Tab, и он автоматически дополнит chrome.",
          "quizAnswer": "clear",
          "quizQuestion": "Какая команда используется для очистки терминала?",
          "slug": "командапоистории",
          "title": "история"
        },
        {
          "exercise": "Скопируйте несколько файлов, будьте осторожны, чтобы не перезаписать что-то важное.",
          "id": 10,
          "lessonContent": "Давайте начнем делать копии этих файлов. Подобно копированию и вставке файлов в других операционных системах, оболочка предоставляет нам еще более простой способ сделать это. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile - это файл, который вы хотите скопировать, а /home/pete/Documents/cooldocs - это место, куда вы копируете файл.\n\nВы также можете копировать несколько файлов и каталогов, а также использовать шаблоны. Шаблон - это символ, который может быть заменен на выборочное совпадение, что дает вам большую гибкость при поиске. Вы можете использовать шаблоны в каждой команде для большей гибкости.\n\n<ul>\n<li>* самый универсальный шаблон, используется для представления всех отдельных символов или любой строки.</li>\n<li>? используется для представления одного символа</li>\n<li>[] используется для представления любого символа внутри скобок</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nЭто скопирует все файлы с расширением .jpg из вашего текущего каталога в каталог Pictures.\n\nПолезной командой является использование флага -r, который рекурсивно скопирует файлы и каталоги внутри каталога. \n\nПопробуйте выполнить cp для каталога, содержащего несколько файлов, в ваш каталог Documents. Не сработало, верно? Это потому, что вам нужно скопировать также файлы и каталоги внутри с помощью команды -r.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nОдна вещь, которую стоит отметить, если вы копируете файл в каталог с тем же именем файла, файл будет перезаписан тем, что вы копируете. Это не очень хорошо, если у вас есть файл, который вы не хотите случайно перезаписать. Вы можете использовать флаг -i (интерактивный), чтобы запросить подтверждение перед перезаписью файла. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Какой флаг вам нужно указать, чтобы скопировать каталог?",
          "slug": "copycpcommand",
          "title": "cp (Копирование)"
        },
        {
          "exercise": "Переименуйте файл, затем переместите этот файл в другой каталог.",
          "id": 11,
          "lessonContent": "Используется для перемещения файлов и их переименования. Довольно похож на команду cp по флагам и функциональности. \n\nВы можете переименовывать файлы так:\n\n<pre>$ mv старый_файл новый_файл</pre>\n\nИли переместить файл в другой каталог: \n\n<pre>$ mv файл2 /home/pete/Documents</pre>\n\nИ переместить более одного файла:\n\n<pre>$ mv файл_1 файл_2 /некоторый_каталог</pre>\n\nТакже можно переименовывать каталоги:\n\n<pre>$ mv каталог1 каталог2</pre>\n\nКак и cp, если вы перемещаете файл или каталог, он перезапишет все в том же каталоге. Поэтому можно использовать флаг -i, чтобы запросить подтверждение перед перезаписью чего-либо.\n\n<pre>mv -i каталог1 каталог2</pre>\n\nПредположим, вы хотите переместить файл, чтобы перезаписать предыдущий. Также можно создать резервную копию этого файла, и старая версия будет переименована с помощью ~. \n\n<pre>$ mv -b каталог1 каталог2</pre>",
          "quizAnswer": "mv cat dog",
          "quizQuestion": "Как переименовать файл с именем cat в dog?",
          "slug": "movemvcommand",
          "title": "mv (Move)"
        },
        {
          "exercise": "Создайте несколько каталогов и переместите некоторые файлы в этот каталог.",
          "id": 12,
          "lessonContent": "Нам понадобятся некоторые каталоги для хранения всех этих файлов, над которыми мы работали. Команда mkdir (Make Directory) полезна для этого, она создаст каталог, если его еще не существует. Вы даже можете создать несколько каталогов одновременно.\n\n<pre>$ mkdir books paintings</pre>\n\nВы также можете создавать подкаталоги одновременно с флагом -p (родительский флаг).\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "Какая команда используется для создания каталога?",
          "slug": "makedirectorymkdircommand",
          "title": "mkdir (Создание каталога)"
        },
        {
          "exercise": "<ol>\n<li>Создайте файл с именем -file (не забудьте дефис!).</li>\n<li>Удалите этот файл.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Теперь, кажется, у нас слишком много файлов, давайте удалим некоторые из них. Для удаления файлов вы можете использовать команду rm. Команда rm (remove) используется для удаления файлов и каталогов. \n\n<pre>$ rm file1</pre>\n\nБудьте осторожны при использовании команды rm, нет волшебного мусорного бака, из которого можно достать удаленные файлы. Как только они исчезли, они исчезли навсегда, так что будьте осторожны. \n\nК счастью, существуют некоторые меры безопасности, чтобы обычный пользователь не мог просто так удалить кучу важных файлов. Защищенные от записи файлы потребуют подтверждения перед удалением. Если каталог защищен от записи, его также не так-то просто удалить. \n\nТеперь, если вам все равно, вы абсолютно можете удалить кучу файлов. \n\n<pre>$ rm -f file1</pre>\n\nОпция -f или force говорит rm удалить все файлы, независимо от того, защищены они от записи или нет, без запроса пользователя (при наличии соответствующих разрешений).\n\n<pre>$ rm -i file</pre>\n\nДобавление флага -i, как и во многих других командах, предложит вам запрос о том, хотите ли вы действительно удалить файлы или каталоги. \n\n<pre>$ rm -r directory</pre>\n\nВы не можете просто так удалить каталог с помощью rm по умолчанию, вам нужно добавить флаг -r (рекурсивный), чтобы удалить все файлы и любые подкаталоги, которые могут быть в нем.\n\nКаталог можно удалить с помощью команды rmdir.\n\n<pre>$ rmdir directory</pre>",
          "quizAnswer": "",
          "quizQuestion": "Как удалить файл с именем myfile?",
          "slug": "removermcommand",
          "title": "rm (Remove)"
        },
        {
          "exercise": "<ol>\n<li>Найдите файл из корневого каталога, в имени которого есть слово net.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Со всеми этими файлами, которые у нас есть в системе, может быть немного сложно найти конкретный. Но есть команда, которую мы можем использовать для этого, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nС find вам придется указать каталог, в котором будете искать, то, что вы ищете, в данном случае мы пытаемся найти файл с именем puppies.jpg. \n\nВы можете указать, какой тип файла вы пытаетесь найти. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nВы видите, что я установил тип файла, который я пытаюсь найти, как (d) для каталога, и все еще ищу по имени MyFolder. \n\nОдна интересная вещь, которую стоит отметить, это то, что find не останавливается на каталоге, который вы ищете, он будет искать внутри любых подкаталогов этого каталога.",
          "quizAnswer": "-name",
          "quizQuestion": "Какой опцией мне следует указать для find, если я хочу искать по имени?",
          "slug": "findcommand",
          "title": "find"
        },
        {
          "exercise": "Запустите help для команды echo, команды logout и команды pwd.",
          "id": 15,
          "lessonContent": "Linux имеет несколько отличных встроенных инструментов, которые помогут вам разобраться в использовании команды или проверить доступные флаги для команды. Один из таких инструментов - help, встроенная команда bash, которая предоставляет справку по другим командам bash (echo, logout, pwd и т. д.).\n\n<pre>$ help echo</pre>\n\nЭто позволит вам получить описание и варианты использования при запуске команды echo. Для других исполняемых программ принято иметь опцию под названием --help или что-то подобное.\n\n<pre>$ echo --help</pre>\n\nНе все разработчики, выпускающие исполняемые файлы, следуют этому стандарту, но это, вероятно, лучший способ получить помощь по программе.",
          "quizAnswer": "help",
          "quizQuestion": "Как получить быструю справку по встроенным командам bash через командную строку?",
          "slug": "helpcommand",
          "title": "help"
        },
        {
          "exercise": "Запустите команду man для команды ls.",
          "id": 16,
          "lessonContent": "Как бы мне хотелось, чтобы у некоторых из этих программ было руководство, чтобы мы могли узнать больше информации о них. К счастью, они есть! Называемые страницами man, вы можете увидеть руководства по команде с помощью команды man. \n\n<pre>$ man ls</pre>\n\nСтраницы man - это руководства, которые по умолчанию встроены в большинство операционных систем Linux. Они предоставляют документацию о командах и других аспектах системы. \n\nПопробуйте это на нескольких командах, чтобы получить больше информации о них.",
          "quizAnswer": "man",
          "quizQuestion": "Как вы видите руководства по команде?",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Запустите команду whatis на команде less.",
          "id": 17,
          "lessonContent": "Фух, мы уже узнали много команд, если вы когда-нибудь сомневаетесь в том, что делает команда, вы можете использовать команду whatis. Команда whatis предоставляет краткое описание командных программ. \n\n<pre>$ whatis cat</pre>\n\nОписание берется из страницы руководства каждой команды. Если вы запустите whatis cat, вы увидите короткое описание.",
          "quizAnswer": "whatis",
          "quizQuestion": "Какую команду вы можете использовать, чтобы увидеть краткое описание команды?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "Создайте несколько псевдонимов, а затем удалите их.",
          "id": 18,
          "lessonContent": "Иногда ввод команд может стать действительно монотонным, или если вам нужно вводить длинную команду много раз, лучше создать псевдоним, который можно использовать для этого. Чтобы создать псевдоним для команды, просто укажите имя псевдонима и установите его для команды. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nТеперь вместо ввода ls -la вы можете ввести foobar, и он выполнит эту команду, довольно удобно. Имейте в виду, что эта команда не сохранит ваш псевдоним после перезагрузки, поэтому вам нужно добавить постоянный псевдоним в:\n\n<pre>~/.bashrc</pre>\n\nили в подобные файлы, если вы хотите, чтобы он сохранялся после перезагрузки.\n\nВы можете удалить псевдонимы с помощью команды unalias: \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "Какая команда используется для создания псевдонима?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Выйди из оболочки и посмотри, что произойдет. Убедись, что тебе больше не нужно работать в этой оболочке.",
          "id": 19,
          "lessonContent": "Ну что, ты действительно хорошо справился с основами. Мы только почесали поверхность, и теперь, когда ты научился ползать, в следующем наборе курсов я научу тебя ходить. \n\nА пока можешь похвалить себя и отдохнуть. Чтобы выйти из оболочки, ты можешь использовать команду exit\n\n<pre>$ exit</pre>\n\nИли команду logout:\n\n<pre>$ logout</pre>\n\nИли если ты работаешь в терминальном графическом интерфейсе, просто закрой терминал, увидимся в следующем курсе!",
          "quizAnswer": "exit",
          "quizQuestion": "Как можно выйти из оболочки?",
          "slug": "командавыход",
          "title": "выход"
        }
      ],
      "slug": "commandline",
      "title": "Command Line"
    },
    {
      "description": "Изучите основы манипулирования текстом и навигации.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Попробуйте несколько команд: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hello World > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "К настоящему моменту мы уже хорошо знакомы с многими командами и их выводом, и это приводит нас к следующей теме - потокам ввода/вывода (input/output). Давайте выполним следующую команду, и мы обсудим, как это работает. \n\n<pre>$ echo Hello World > peanuts.txt</pre>\n\nЧто только что произошло? Проверьте каталог, где вы выполнили эту команду, и о, чудо, вы должны увидеть файл с именем peanuts.txt, посмотрите внутрь этого файла, и вы увидите текст Hello World. В одной команде произошло много вещей, так что давайте разберем это. \n\nСначала давайте разберем первую часть: \n\n<pre>$ echo Hello World</pre>\n\nМы знаем, что это выводит Hello World на экран, но как? Процессы используют потоки ввода/вывода для получения ввода и возврата вывода. По умолчанию команда echo берет ввод (стандартный ввод или stdin) с клавиатуры и возвращает вывод (стандартный вывод или stdout) на экран. Поэтому, когда вы вводите echo Hello World в своем оболочке, вы видите Hello World на экране. Однако перенаправление ввода/вывода позволяет нам изменить это поведение по умолчанию, что дает нам большую гибкость с файлами. \n\nПерейдем к следующей части команды: \n\n<pre> > </pre>\n\n> - это оператор перенаправления, который позволяет нам изменить место, куда отправляется стандартный вывод. Он позволяет нам отправить вывод echo Hello World в файл вместо экрана. Если файл еще не существует, он будет создан. Однако, если файл уже существует, он будет перезаписан (в зависимости от оболочки, которую вы используете, можно добавить флаг оболочки, чтобы предотвратить это).\n\nИ вот как работает перенаправление stdout!\n\nДопустим, я не хочу перезаписывать мой peanuts.txt, к счастью, для этого также существует оператор перенаправления, >>: \n\n<pre>$ echo Hello World >> peanuts.txt</pre>\n\nЭто добавит Hello World в конец файла peanuts.txt, если файла еще не существует, он будет создан, как это было с оператором >!",
          "quizAnswer": ">>",
          "quizQuestion": "Какой оператор перенаправления используется для добавления вывода в файл?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Попробуйте несколько команд:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "В нашем предыдущем уроке мы узнали, что у нас есть различные потоки stdout, которые мы можем использовать, такие как файл или экран. Ну, также есть различные стандартные потоки ввода (stdin), которые мы также можем использовать. Мы знаем, что у нас есть stdin от устройств, таких как клавиатура, но мы также можем использовать файлы, вывод от других процессов и терминал, давайте посмотрим на пример. \n\nДавайте использовать файл peanuts.txt из предыдущего урока для этого примера, помните, в нем был текст Hello World. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nТочно так же, как у нас был <b>&gt;</b> для перенаправления stdout, мы можем использовать <b>&lt;</b> для перенаправления stdin. \n\nОбычно в команде cat вы отправляете файл в нее, и этот файл становится stdin, в этом случае мы перенаправили peanuts.txt, чтобы он стал нашим stdin. Затем вывод cat peanuts.txt, который был Hello World, перенаправляется в другой файл с именем banana.txt.",
          "quizAnswer": "<",
          "quizQuestion": "Какой перенаправитель вы используете для перенаправления stdin?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Стандартный ввод)"
        },
        {
          "exercise": "Что делает следующая команда? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Давайте попробуем что-то немного отличающееся теперь, давайте попробуем вывести содержимое каталога, которого нет в вашей системе, и снова перенаправить вывод в файл peanuts.txt.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nЧто вы должны увидеть: \n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nТеперь вы, вероятно, думаете, не должно ли это сообщение быть отправлено в файл? Здесь фактически используется еще один поток ввода-вывода, называемый стандартная ошибка (stderr). По умолчанию stderr также отправляет свой вывод на экран, это совершенно другой поток, чем stdout. Поэтому вам нужно перенаправить его вывод по-другому. \n\nК сожалению, перенаправление не так просто, как использование <b>&lt;</b> или <b>&gt;</b>, но это довольно близко. Нам нужно использовать файловые дескрипторы. Файловый дескриптор - это неотрицательное число, которое используется для доступа к файлу или потоку. Мы подробно рассмотрим это позже, но пока знайте, что дескриптор файла для stdin, stdout и stderr равен соответственно 0, 1 и 2. \n\nТак что теперь, если мы хотим перенаправить наш stderr в файл, мы можем сделать это так: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nВы должны увидеть только сообщения stderr в peanuts.txt. \n\nЧто если я хочу видеть как stderr, так и stdout в файле peanuts.txt? Это также возможно с помощью файловых дескрипторов: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nЭто отправляет результаты ls /fake/directory в файл peanuts.txt, а затем перенаправляет stderr в stdout через 2>&1. Здесь важен порядок операций, 2>&1 отправляет stderr туда, куда указывает stdout. В данном случае stdout указывает на файл, поэтому 2>&1 также отправляет stderr в файл. Так что если вы откроете файл peanuts.txt, вы увидите как stderr, так и stdout. В нашем случае вышеуказанная команда выводит только stderr.\n\nСуществует более короткий способ перенаправить как stdout, так и stderr в файл:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nЧто если мне не нужен весь этот мусор и я хочу полностью избавиться от сообщений stderr? Также можно перенаправить вывод в специальный файл с именем /dev/null, и он отбросит любой ввод.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "Какой перенаправитель для stderr?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Стандартная ошибка)"
        },
        {
          "exercise": "Попробуйте следующие команды: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Давайте перейдем к некоторым водопроводным работам, на самом деле нет, но в некотором роде. Давайте попробуем команду: \n\n<pre>$ ls -la /etc</pre>\n\nВы должны увидеть очень длинный список элементов, его довольно трудно прочитать на самом деле. Вместо перенаправления этого вывода в файл, не было бы здорово, если бы мы могли просто увидеть вывод в другой команде, например, less? Ну мы можем!\n\n<pre>$ ls -la /etc | less </pre>\n\nОператор трубы |, представленный вертикальной чертой, позволяет нам получить stdout команды и сделать его stdin для другого процесса. В этом случае мы взяли stdout ls -la /etc, а затем <i>перенаправили</i> его на команду less. Команда трубы чрезвычайно полезна, и мы будем продолжать использовать ее вечно. \n\nЧто если я хочу записать вывод моей команды в два разных потока? Это возможно с помощью команды tee: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nВы должны увидеть вывод ls на своем экране, и если вы откроете файл peanuts.txt, вы должны увидеть ту же информацию!",
          "quizAnswer": "|",
          "quizQuestion": "Какой ключ представляет оператор трубы?",
          "slug": "pipeteeredirect",
          "title": "труба и труба"
        },
        {
          "exercise": "Что выведет следующая команда? Почему?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Запустите следующую команду: \n\n<pre>$ echo $HOME</pre>\n\nВы должны увидеть путь к вашему домашнему каталогу, мой выглядит как /home/pete. \n\nЧто насчет этой команды? \n\n<pre>$ echo $USER </pre>\n\nВы должны увидеть свое имя пользователя!\n\nОткуда берется эта информация? Она берется из ваших переменных окружения. Вы можете просмотреть их, набрав\n\n<pre>$ env </pre>\n\nЭто выводит множество информации о переменных окружения, которые у вас в настоящее время установлены. Эти переменные содержат полезную информацию, которую оболочка и другие процессы могут использовать.\n\nВот небольшой пример:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nОдной из особенно важных переменных является переменная PATH. Вы можете получить доступ к этим переменным, добавив $ перед именем переменной, например так:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nЭто возвращает список путей, разделенных двоеточием, по которым ваша система ищет при запуске команды. Допустим, вы вручную загрузили и установили пакет из интернета и поместили его в нестандартный каталог, и хотите запустить эту команду, вы вводите $ coolcommand и приглашение говорит, что команда не найдена. Ну, это глупо, вы смотрите на бинарный файл в папке и знаете, что он существует. Происходит то, что переменная $PATH не проверяет этот каталог на наличие этого бинарного файла, поэтому возникает ошибка. \n\nПредположим, у вас есть множество бинарных файлов, которые вы хотите запустить из этого каталога, вы можете просто изменить переменную PATH, чтобы включить этот каталог в вашу переменную окружения PATH.",
          "quizAnswer": "env",
          "quizQuestion": "Как вы просматриваете свои переменные окружения?",
          "slug": "envenvironment",
          "title": "env (Окружение)"
        },
        {
          "exercise": "Что делает следующая команда? Почему?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Мы собираемся изучить несколько полезных команд, которые вы можете использовать для обработки текста. Прежде чем мы начнем, давайте создадим файл, с которым будем работать. Скопируйте и вставьте следующую команду, после этого добавьте TAB между lazy и dog (удерживайте Ctrl-v + TAB).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nПервая команда, о которой мы узнаем, - это команда cut. Она извлекает части текста из файла. \n\nДля извлечения содержимого по списку символов: \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nЭто выводит 5-й символ в каждой строке файла. В данном случае это \"q\", обратите внимание, что пробел также считается символом. \n\nДля извлечения содержимого по полю нам потребуется небольшая модификация: \n\n<pre>$ cut -f 2 sample.txt</pre>\n\nФлаг -f или field вырезает текст на основе полей, по умолчанию он использует TAB в качестве разделителей, поэтому все, что разделено TAB, считается полем. Вы должны увидеть \"dog\" в качестве вывода.\n\nВы можете объединить флаг поля с флагом разделителя, чтобы извлечь содержимое по пользовательскому разделителю: \n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nЭто изменит разделитель TAB на разделитель \";\" и поскольку мы вырезаем первое поле, результат должен быть \"The quick brown\".",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "Какую команду вы бы использовали, чтобы получить первый символ каждой строки в файле?",
          "slug": "cutcommand",
          "title": "cut"
        },
        {
          "exercise": "Попробуйте объединить несколько файлов с помощью paste, что произойдет?",
          "id": 7,
          "lessonContent": "Команда paste аналогична команде cat, она объединяет строки в файле. Давайте создадим новый файл со следующим содержимым: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nДавайте объединим все эти строки в одну строку: \n\n<pre>$ paste -s sample2.txt</pre>\n\nПо умолчанию разделителем для paste является TAB, поэтому теперь есть одна строка с TAB между каждым словом.\n\nДавайте изменить этот разделитель (-d) на что-то более читаемое: \n\n<pre>$ paste -d ' ' -s sample2.txt</pre>\n\nТеперь все должно быть в одной строке, разделенной пробелами.",
          "quizAnswer": "-s",
          "quizQuestion": "Какой флаг вы используете с paste, чтобы все было в одной строке?",
          "slug": "pastecommand",
          "title": "paste"
        },
        {
          "exercise": "Что делает следующая команда и почему? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Допустим, у нас есть очень длинный файл, на самом деле у нас есть много файлов на выбор, давайте посмотрим содержимое /var/log/syslog. Вы увидите страницы текста. Что, если мне нужно увидеть только первые несколько строк в этом текстовом файле? Мы можем сделать это с помощью команды head, по умолчанию эта команда покажет вам первые 10 строк файла.\n\n<pre>$ head /var/log/syslog</pre>\n\nВы также можете изменить количество строк на любое, допустим, я хочу увидеть первые 15 строк. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nФлаг -n означает количество строк.",
          "quizAnswer": "-n",
          "quizQuestion": "Какой флаг вы бы использовали, чтобы изменить количество строк, которые вы хотите увидеть при использовании команды head?",
          "slug": "headcommand",
          "title": "head"
        },
        {
          "exercise": "Посмотрите страницу справки по tail и прочтите некоторые другие команды, о которых мы не говорили. \n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Подобно команде head, команда tail позволяет просматривать по умолчанию последние 10 строк файла.\n\n<pre>$ tail /var/log/syslog</pre>\n\nКак и с head, вы можете изменить количество строк, которые хотите увидеть.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nЕще один отличный вариант - использовать флаг -f (follow), который будет отслеживать рост файла. Попробуйте и посмотрите, что произойдет. \n\n<pre>$ tail -f /var/log/syslog</pre> \n\nВаш файл syslog будет постоянно меняться, пока вы взаимодействуете с системой, и используя tail -f, вы можете видеть все, что добавляется в этот файл.",
          "quizAnswer": "-f",
          "quizQuestion": "Какой флаг используется для отслеживания файла в tail?",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "Что произойдет, если вы просто введете команду expand без ввода файла?",
          "id": 10,
          "lessonContent": "В нашем уроке по команде cut у нас был файл sample.txt, содержащий табуляцию. Обычно табуляции обычно показывают заметную разницу, но некоторые текстовые файлы не показывают этого достаточно хорошо. Наличие табуляций в текстовом файле может не соответствовать желаемому пробелу. Чтобы изменить ваши табуляции на пробелы, используйте команду expand. \n\n<pre>$ expand sample.txt</pre>\n\nКоманда выше выведет результат с каждой табуляцией, преобразованной в группу пробелов. Чтобы сохранить этот вывод в файл, используйте перенаправление вывода, как показано ниже. \n\n<pre>$ expand sample.txt > result.txt</pre>\n\nВ противоположность команде expand, мы можем преобразовать обратно каждую группу пробелов в табуляцию с помощью команды unexpand: \n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "Какая команда используется для преобразования табуляций в пробелы?",
          "slug": "expandunexpandcommand",
          "title": "expand и unexpand"
        },
        {
          "exercise": "Объедините два файла с разным количеством строк в каждом файле, что произойдет?",
          "id": 11,
          "lessonContent": "Команда join позволяет объединить несколько файлов по общему полю: \n\nДопустим, у меня есть два файла, которые я хочу объединить:\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\nЗаметьте, как файлы были объединены? По умолчанию они объединены по первому полю, и поля должны быть идентичными, в противном случае их можно отсортировать, так что в этом случае файлы объединены через 1, 2, 3. \n\nКак объединить следующие файлы? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nЧтобы объединить этот файл, вам нужно указать, какие поля вы объединяете, в этом случае мы хотим объединить поле 2 в file1.txt и поле 1 в file2.txt, поэтому команда будет выглядеть так:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 относится к file1.txt, а -2 к file2.txt. Довольно удобно. Вы также можете разделить файл на разные файлы с помощью команды split: \n\n<pre>$ split somefile</pre>\n\nЭто разделит его на разные файлы, по умолчанию они будут разделены, когда достигнут предел в 1000 строк. Файлы по умолчанию называются x**.",
          "quizAnswer": "join cat dog cow",
          "quizQuestion": "Какую команду вы бы использовали, чтобы объединить файлы с именами cat dog cow?",
          "slug": "joinsplitcommand",
          "title": "join and split"
        },
        {
          "exercise": "Настоящая мощь команды sort проявляется в ее способности комбинироваться с другими командами, попробуйте следующую команду и посмотрите, что произойдет?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "Команда sort полезна для сортировки строк.\n\n<pre>\nfile1.txt\ndog\ncow\ncat\nelephant\nbird\n\n$ sort file1.txt\nbird\ncat\ncow\ndog\nelephant\n</pre>\n\nТакже можно выполнить обратную сортировку: \n\n<pre>$ sort -r file1.txt\nelephant\ndog\ncow\ncat\nbird\n</pre>\n\nИ также сортировку по числовому значению: \n\n<pre>$ sort -n file1.txt\nbird\ncat\ncow\nelephant\ndog\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Какой флаг используется для выполнения обратной сортировки?",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "Попробуйте следующую команду, что произойдет? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "Команда tr (translate) позволяет вам переводить набор символов на другой набор символов. Давайте попробуем пример перевода всех символов в нижнем регистре в символы верхнего регистра. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nКак видите, мы изменили диапазоны a-z на A-Z, и весь текст, который мы вводим в нижнем регистре, преобразуется в верхний регистр.",
          "quizAnswer": "tr",
          "quizQuestion": "Какая команда используется для перевода символов?",
          "slug": "trtranslatecommand",
          "title": "tr (Translate)"
        },
        {
          "exercise": "Какой результат вы получите, если попробуете uniq -uc?",
          "id": 14,
          "lessonContent": "Команда uniq (уникальный) - еще один полезный инструмент для анализа текста.\n\nПредположим, у вас есть файл с большим количеством дубликатов:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nИ вы хотите удалить дубликаты, тогда вы можете использовать команду uniq:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nДавайте посчитаем, сколько раз встречается строка:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nДавайте получим только уникальные значения:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nДавайте получим только дубликаты:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Примечание</b>: uniq не обнаруживает дублирующие строки, если они не являются смежными. Например:\n\nПредположим, у вас есть файл с дубликатами, которые не являются смежными:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nРезультат, возвращаемый uniq, будет содержать все записи, в отличие от первого примера.\n\nЧтобы преодолеть это ограничение uniq, мы можем использовать сортировку в сочетании с uniq:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "Какую команду вы используете для удаления дубликатов в файле?",
          "slug": "uniquniquecommand",
          "title": "uniq (Уникальный)"
        },
        {
          "exercise": "Как вы получите общее количество строк, используя файл nl, не просматривая весь вывод? Подсказка: Используйте некоторые из других команд, которые вы изучили в этом курсе.",
          "id": 15,
          "lessonContent": "Команда wc (word count) показывает общее количество слов в файле. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nОна отображает количество строк, количество слов и количество байт соответственно.\n\nЧтобы увидеть только количество определенного поля, используйте -l, -w или -c соответственно. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nДругая команда, которую можно использовать для проверки количества строк в файле, - команда nl (number lines). \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "Какую команду вы бы использовали, чтобы получить общее количество слов в файле и только сами слова?",
          "slug": "nlwccommand",
          "title": "wc и nl"
        },
        {
          "exercise": "Возможно, вы слышали о egrep или fgrep, эти вызовы grep устарели и были заменены на grep -E и grep -F. Прочтите страницу руководства по grep, чтобы узнать больше.",
          "id": 16,
          "lessonContent": "Команда grep, вероятно, является самой распространенной командой обработки текста, которую вы будете использовать. Она позволяет искать файлы на наличие символов, соответствующих определенному шаблону. Что если вы хотели бы узнать, существует ли файл в определенном каталоге, или если вы хотели бы узнать, найдена ли строка в файле? Вы определенно не будете рыться в каждой строке текста, вы будете использовать grep!\n\nДавайте воспользуемся нашим файлом sample.txt в качестве примера: \n\n<pre>$ grep fox sample.txt</pre>\n\nВы должны увидеть, что grep нашел fox в файле sample.txt. \n\nВы также можете использовать grep для поиска шаблонов, игнорируя регистр с флагом -i: \n\n<pre>$ grep -i somepattern somefile</pre>\n\nЧтобы сделать grep еще более гибким, вы можете объединить его с другими командами с помощью |.\n\n<pre>$ env | grep -i User</pre>\n\nКак видите, grep довольно универсален. Вы даже можете использовать регулярные выражения в вашем шаблоне: \n\n<pre>$ ls /somedir | grep '.txt$'</pre>\n\nДолжен вернуть все файлы, оканчивающиеся на .txt в somedir.",
          "quizAnswer": "grep",
          "quizQuestion": "Какую команду вы используете для поиска определенного шаблона?",
          "slug": "командагреп",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Навигация по тексту как Linux-обезьяна-паука с помощью vim и emacs.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Попробуйте объединить регулярные выражения с grep и искать по некоторым файлам.\n\n<pre>\ngrep [регулярное выражение здесь] [файл]",
          "id": 1,
          "lessonContent": "Регулярные выражения - это мощный инструмент для выбора по шаблону. Они используют специальные обозначения, аналогичные тем, с которыми мы уже сталкивались, таким как символ *.\n\nМы рассмотрим несколько наиболее распространенных регулярных выражений, которые практически универсальны для любого языка программирования.\n\nМы будем использовать эту фразу в качестве тестируемой строки:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. Начало строки с ^</b>\n\n<pre>\n<b>^</b>by\nсоответствует строке \"by the seashore\"\n</pre>\n\n<b>2. Конец строки с $</b>\n\n<pre>\nseashore<b>$</b>\nсоответствует строке \"by the seashore\"\n</pre>\n\n<b>3. Сопоставление с любым одиночным символом с помощью .</b>\n\n<pre>\nb<b>.</b>\nсоответствует by\n</pre>\n\n<b>4. Нотация с квадратными скобками [] и ()</b>\n\nЭто может быть немного сложно, скобки позволяют нам указать символы, найденные внутри скобок. \n\n<pre>\nd<b>[iou]</b>g\nсоответствует: dig, dog, dug\n</pre>\n\nПредыдущий якорный тег ^ при использовании в скобках означает все, кроме символов в скобках. \n\n<pre>\nd<b>[^i]</b>g\nсоответствует: dog и dug, но не dig\n</pre>\n\nСкобки также могут использовать диапазоны для увеличения количества символов, которые вы хотите использовать. \n\n<pre>\nd<b>[a-c]</b>g\nбудет соответствовать шаблонам, таким как dag, dbg и dcg\n</pre>\n\nОднако будьте осторожны, так как скобки чувствительны к регистру:\n\n<pre>\nd<b>[A-C]</b>g\nбудет соответствовать dAg, dBg и dCg, но не dag, dbg и dcg\n</pre>\n\nИ это основные регулярные выражения.",
          "quizAnswer": ".",
          "quizQuestion": "Какое регулярное выражение вы бы использовали для сопоставления с одним символом?",
          "slug": "regularexpressionsregex",
          "title": "регулярные выражения (Regular Expressions)"
        },
        {
          "exercise": "Совершите небольшую экскурсию по vim и emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Если вы соберете в комнате пару заядлых пользователей Linux и спросите их, какой же лучший текстовый редактор использовать, вы услышите бесконечные споры о божественности vim или emacs. Даже не пытайтесь упомянуть использование графического редактора, если цените свою жизнь. \n\nVim и emacs - популярные текстовые редакторы, которые установлены по умолчанию в большинстве дистрибутивов Linux, и у каждого из них есть свои плюсы и минусы. Если вы хотите мастерски управляться в системе, вам нужно будет освоить один из этих текстовых редакторов. Они в основном предназначены для написания кода, обработки документов и в целом являются универсальными редакторами.",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, двигаемся дальше!",
          "slug": "texteditorsvimoremacs",
          "title": "Текстовые редакторы"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 3,
          "lessonContent": "Vim расшифровывается как vi (Improved), как и следует из названия, это улучшенная версия командного текстового редактора vi.\n\nОн очень легкий, открытие и редактирование файла с помощью vim быстро и легко. Кроме того, он почти всегда доступен: если вы загрузили случайное распределение Linux, вероятно, vim устанавливается по умолчанию. \n\nДля запуска vim просто введите: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, двигаемся дальше!",
          "slug": "vimtexteditor",
          "title": "Vim (Vi Improved)"
        },
        {
          "exercise": "Поиграйте с клавишей поиска, откройте текстовый файл в vim с помощью: vim [имя_файла] и начните поиск!",
          "id": 4,
          "lessonContent": "Для поиска выражения просто введите ключ / и затем ваш результат поиска, находясь в сеансе vim. После нажатия клавиши Enter вы можете нажать \"n\" для перехода вперед или \"N\" для перехода назад по результатам поиска.\n\n<pre>\nМой красивый файл очень красивый.\n\n/красивый\n\nнайдет красивые слова в текстовом файле.\n</pre>\n\n\nКоманда поиска ? будет искать текстовый файл в обратном направлении, поэтому в предыдущем примере последнее \"красивый\" появится первым. \n<pre>\nМой красивый файл очень красивый.\n\n?красивый\n\nнайдет красивые слова в текстовом файле.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Какая клавиша используется для поиска в vim?",
          "slug": "vimsearchpatterns",
          "title": "Vim Поиск Шаблонов"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 5,
          "lessonContent": "Теперь вы можете заметить, что мышь здесь нигде не используется. Для навигации по текстовому документу в vim используйте следующие клавиши: \n\n<ul>\n<li>h или стрелка влево - переместит вас на один символ влево</li>\n<li>k или стрелка вверх - переместит вас на одну строку вверх</li>\n<li>j или стрелка вниз - переместит вас на одну строку вниз</li>\n<li>l или стрелка вправо - переместит вас на один символ вправо</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "Какая буква используется для перемещения вниз?",
          "slug": "vimnavigation",
          "title": "Навигация в Vim"
        },
        {
          "exercise": "Поиграйтесь с входом и выходом из режима вставки.",
          "id": 6,
          "lessonContent": "<p>Теперь вы могли заметить, что если попытаетесь что-то набрать, у вас не получится. Это потому, что вы находитесь в режиме команд. Это может быть довольно запутанным, особенно если вы просто хотите открыть файл и ввести текст. Режим команд используется для ввода команд, таких как h, j, k, l и т. д. Чтобы вставить текст, вам нужно сначала перейти в режим вставки.</p><p></p><ul><br><li>i - вставить текст перед курсором</li><br><li>O - вставить текст на предыдущей строке</li><br><li>o - вставить текст на следующей строке</li><br><li>a - добавить текст после курсора</li><br><li>A - добавить текст в конце строки</li><br></ul><p></p><p>Обратите внимание, что когда вы вводите любой из этих режимов вставки, вы увидите, что vim перешел в режим вставки внизу оболочки. Чтобы выйти из режима вставки и вернуться в режим команд, просто нажмите клавишу Esc.</p>",
          "quizAnswer": "i",
          "quizQuestion": "Какая клавиша используется для вставки текста перед курсором?",
          "slug": "viminsertingappendingtext",
          "title": "Добавление текста в Vim"
        },
        {
          "exercise": "Я знаю, что этот урок добавил немного странностей, откройте текстовый редактор и поиграйтесь с этими командами.",
          "id": 7,
          "lessonContent": "Теперь, когда у нас есть несколько написанных строк, давайте немного отредактируем и удалим ненужное.<br><p></p><ul><br><li>x - используется для вырезания выбранного текста, также используется для удаления символов</li><br><li>dd - используется для удаления текущей строки</li><br><li>y - копировать выделенный текст</li><br><li>yy - копировать текущую строку</li><br><li>p - вставить скопированный текст перед курсором</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "Какой символ используется для удаления целой строки?",
          "slug": "редактирование-vim",
          "title": "Редактирование в Vim"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 8,
          "lessonContent": "Теперь, когда вы закончили редактирование, пришло время фактически сохранить и выйти из vim: \n\n<ul>\n<li>:w - записывает или сохраняет файл</li>\n<li>:q - выход из vim</li>\n<li>:wq - записать и затем выйти</li>\n<li>:q! - выход из vim без сохранения файла</li>\n<li>ZZ - эквивалент :wq, но на один символ быстрее</li>\n\n<li>u - отменить последнее действие</li>\n<li>Ctrl-r - повторить последнее действие</li>\n</ul>\n\nВозможно, вам покажется, что ZZ не обязателен, но вы в конечном итоге увидите, что ваши пальцы могут склоняться к этому, а не к :wq.\n\nУф, это было много информации о Vim. Теперь, когда вы знаете некоторые основные команды и навигацию, вы можете начать редактировать текстовые файлы. В vim есть еще много других опций, которые вы можете использовать, чтобы улучшить свои навыки работы с этим текстовым редактором, перейдите в онлайн-руководство Vim, чтобы ознакомиться.",
          "quizAnswer": ":q!",
          "quizQuestion": "Как выйти из vim без сохранения?",
          "slug": "vimsavingandexiting",
          "title": "Сохранение и выход из Vim"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 9,
          "lessonContent": "Emacs предназначен для пользователей, которые хотят использовать чрезвычайно мощный текстовый редактор, что может быть преуменьшением, потому что вы фактически живете в emacs. Вы можете выполнять все операции по редактированию кода, манипулированию файлами и т. д. прямо в emacs. Он немного медленнее загружается и кривая обучения немного круче, чем у vim, но если вам нужен мощный редактор, который можно крайне расширить, то это то, что вам нужно. Когда я говорю о расширяемости, я буквально имею в виду, что вы можете писать сценарии для emacs, расширяющие его функциональность.\n\nЧтобы запустить emacs, просто используйте:\n\n<pre>emacs</pre>\n\nВы должны увидеть стандартный приветственный буфер.\n\nБуферы в emacs - это то, где находится ваш текст. Так что если вы открываете файл, буфер используется для хранения содержимого этого файла. Вы можете иметь открытыми несколько буферов одновременно и легко переключаться между ними.",
          "quizAnswer": "",
          "quizQuestion": "Никаких вопросов, двигайтесь дальше!",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Поиграйте с открытием файлов и сохранением файлов.",
          "id": 10,
          "lessonContent": "Во многих (если не во всех) документациях по Emacs вы увидите синтаксис C-[буква]. Это просто означает нажать Ctrl-буква, но для краткости мы будем называть Ctrl просто C. Если вы видите синтаксис вроде M-[буква], это означает использовать клавишу Meta, обычно это клавиша Alt.\n\n<b>Сохранение файлов</b>\n\n<pre>\nC-x C-s - Сохранить файл\nC-x C-w - Сохранить файл как\nC-x s - Сохранить все\n</pre>\n\nОпции сохранения файла будут запрашивать вас, хотите ли вы сохранить каждый файл.\n\n<b>Открытие файла</b>\n\n<pre>\nC-x C-f\n</pre>\n\nЭто позволит вам ввести имя файла для открытия. Если у вас нет файла, который уже существует, будет создан новый файл. Вы также можете загрузить каталог.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "Какая команда используется для открытия файла?",
          "slug": "emacsmanipulatefiles",
          "title": "Управление файлами в Emacs"
        },
        {
          "exercise": "Поиграйте с буферами.",
          "id": 11,
          "lessonContent": "Для перемещения по буферам (или файлам, которые вы посещаете), используйте следующие команды:\n\n<b>Переключение буферов</b>\n\n<pre>\nC-x b - переключить буфер\nC-x стрелка вправо - циклический переход вправо по буферам\nC-x стрелка влево - циклический переход влево по буферам\n</pre>\n\n<b>Закрытие буфера</b>\n\n<pre>C-x k</pre>\n\n<b>Разделение текущего буфера</b>\n\n<pre>C-x 2</pre>\n\nЭто позволяет видеть несколько буферов на одном экране. Для переключения между этими буферами используйте: C-x o\n\n<b>Установить один буфер как текущий экран</b>\n\n<pre>C-x 1</pre>\n\nЕсли вы когда-либо использовали терминальный мультиплексор, такой как screen и tmux, команды для работы с буферами будут вам очень знакомы.",
          "quizAnswer": "C-x k",
          "quizQuestion": "Как закрыть буфер?",
          "slug": "emacsbuffernavigation",
          "title": "Навигация по буферам в Emacs"
        },
        {
          "exercise": "Поиграйте с навигацией по тексту.",
          "id": 12,
          "lessonContent": "<b>Навигация по тексту</b>\n\n<pre>\nC-up arrow : переместиться на один абзац вверх\nC-down arrow: переместиться на один абзац вниз\nC-left arrow: переместиться на одно слово влево\nC-right arrow: переместиться на одно слово вправо\nM-> : переместиться в конец буфера\n</pre>\n\nС навигацией по тексту ваши обычные текстовые кнопки работают так, как должны: home, end, page up, page down и стрелки, и т. д.\n\n<b>Вырезание и вставка</b>\n\nЧтобы вырезать (удалить) или вставить (вставить) в Emacs, вам нужно сначала выбрать текст. Чтобы выбрать текст, переместите курсор туда, где хотите вырезать или вставить, и нажмите <pre>C-space key</pre>, затем вы можете использовать клавиши навигации, чтобы выбрать нужный текст. Теперь вы можете вырезать и вставлять так:\n\n<pre>\nC-w : вырезать\nC-y : вставить\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "Как переместиться в конец буфера?",
          "slug": "редактированиеemacs",
          "title": "Редактирование в Emacs"
        },
        {
          "exercise": "Посетите сайт Emacs, чтобы узнать о других командах. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Чтобы закрыть Emacs</b>\n\n<pre>C-x C-c</pre>\n\nЕсли у вас есть открытые буферы, он попросит вас сохранить их перед закрытием Emacs.\n\n<b>Запутались?</b>\n\n<pre>C-h C-h : меню помощи</pre>\n\n<b>Отменить</b>\n\n<pre>C-x u</pre>\n\nКак видите, в Emacs больше движущихся частей, поэтому кривая обучения немного круче. Зато взамен вы получаете очень мощный текстовый редактор.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "Как получить доступ к меню помощи?",
          "slug": "emacsexitingandhelp",
          "title": "Выход из Emacs и Справка"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Advanced Text-Fu"
    },
    {
      "description": "Узнайте о ролях пользователей и управлении ими.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "В любой традиционной операционной системе существуют пользователи и группы. Они существуют исключительно для доступа и разрешений. При запуске процесса он будет запущен от имени владельца этого процесса, будь то Джейн или Боб. Доступ к файлам и владение ими также зависит от разрешений. Вы бы не хотели, чтобы Джейн видела документы Боба и наоборот. \n\nУ каждого пользователя есть свой домашний каталог, где хранятся его собственные файлы, обычно он находится в /home/имя_пользователя, но может отличаться в различных дистрибутивах. \n\nСистема использует идентификаторы пользователей (UID) для управления пользователями, имена пользователей - это дружественный способ ассоциировать пользователей с идентификацией, но система идентифицирует пользователей по их UID. Система также использует группы для управления разрешениями, группы - это просто наборы пользователей с разрешениями, установленными для этой группы, они идентифицируются системой с помощью их идентификатора группы (GID).\n\nВ Linux у вас будут пользователи, помимо обычных людей, использующих систему. Иногда это пользователи системных служб, которые непрерывно запускают процессы для обеспечения функционирования системы. Один из самых важных пользователей - root или суперпользователь, root - самый мощный пользователь в системе, root может получить доступ к любому файлу, запустить и завершить любой процесс. Поэтому постоянная работа от имени root может быть опасной, вы можете потенциально удалить критически важные файлы системы. К счастью, если требуется доступ root и у пользователя есть такой доступ, он может запустить команду от имени root с помощью команды sudo. Команда sudo (superuser do) используется для выполнения команды с доступом root, мы более подробно рассмотрим, как пользователь получает доступ root, в следующем уроке.\n\nПопробуйте просмотреть защищенный файл, например /etc/shadow:\n\n<pre>$ cat /etc/shadow</pre>\n\nОбратите внимание, что вы получите ошибку доступа запрещен, посмотрите разрешения с помощью: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nМы еще не рассматривали разрешения, но что происходит здесь, это то, что root является владельцем файла, и вам понадобится доступ root или быть частью группы shadow для чтения содержимого. Теперь выполните команду с sudo:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nТеперь вы сможете увидеть содержимое файла!",
          "quizAnswer": "sudo",
          "quizQuestion": "Какую команду вы используете для выполнения от имени root?",
          "slug": "usersandgroups",
          "title": "Пользователи и Группы"
        },
        {
          "exercise": "Откройте файл /etc/sudoers и посмотрите, какие разрешения суперпользователя есть у других пользователей на машине.",
          "id": 2,
          "lessonContent": "Мы рассмотрели один из способов получения суперпользовательского доступа с помощью команды sudo. Вы также можете запускать команды от имени суперпользователя с помощью команды su. Эта команда будет \"заменять пользователей\" и открывать оболочку root, если не указано имя пользователя. Вы можете использовать эту команду для замены на любого пользователя, пока знаете пароль. \n\n<pre>$ su</pre>\n\nЕсть недостатки использования этого метода: намного легче допустить критическую ошибку, выполняя все под root, у вас не будет записей о командах, которые вы используете для изменения конфигураций системы и т. д. В общем, если вам нужно запускать команды от имени суперпользователя, просто используйте sudo.\n\nТеперь, когда вы знаете, какие команды нужно запускать от имени суперпользователя, вопрос в том, как узнать, кто имеет доступ к этому? Система не позволяет каждому Джо Шмо запускать команды от имени суперпользователя, так как она это узнает? Существует файл под названием /etc/sudoers, в котором перечислены пользователи, которые могут запускать sudo. Вы можете редактировать этот файл с помощью команды <b>visudo</b>.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "Какой файл показывает пользователей, имеющих доступ к sudo?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Посмотрите свой файл /etc/passwd, взгляните на некоторых пользователей и обратите внимание на доступ, который у них есть.",
          "id": 3,
          "lessonContent": "Помните, что имена пользователей на самом деле не являются идентификаторами для пользователей. Система использует идентификатор пользователя (UID) для идентификации пользователя. Чтобы узнать, какие пользователи сопоставлены с каким идентификатором, посмотрите файл /etc/passwd. \n\n<pre>$ cat /etc/passwd</pre>\n\nЭтот файл показывает вам список пользователей и подробную информацию о них. Например, первая строка в этом файле, скорее всего, выглядит так:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nКаждая строка отображает информацию о пользователе, обычно вы увидите пользователя root как первую строку. Есть много полей, разделенных двоеточиями, которые сообщают вам дополнительную информацию о пользователе, давайте рассмотрим их все:\n\n<ol>\n<li>Имя пользователя</li>\n<li>Пароль пользователя - пароль на самом деле не хранится в этом файле, обычно он хранится в файле /etc/shadow. Мы обсудим больше в следующем уроке о /etc/shadow, но пока знайте, что он содержит зашифрованные пароли пользователей. Вы увидите много различных символов в этом поле, если вы видите \"x\", это означает, что пароль хранится в файле /etc/shadow, \"*\" означает, что пользователь не имеет доступа к входу, и если поле пустое, это означает, что у пользователя нет пароля.</li>\n<li>Идентификатор пользователя - как вы видите, у root UID 0</li>\n<li>Идентификатор группы</li>\n<li>Поле GECOS - используется для общих комментариев о пользователе или учетной записи, таких как их настоящее имя или номер телефона, оно разделено запятыми.</li>\n<li>Домашний каталог пользователя</li>\n<li>Оболочка пользователя - вы, вероятно, увидите, что многие пользователи используют bash в качестве своей оболочки по умолчанию</li>\n</ol>\n\nОбычно на странице настройки пользователя вы ожидаете увидеть только человеческих пользователей. Однако вы заметите, что в /etc/passwd содержатся и другие пользователи. Помните, что пользователи на самом деле находятся на системе только для запуска процессов с разрешениями. Иногда мы хотим запускать процессы с заранее определенными разрешениями. Например, пользователь демона используется для демонических процессов.\n\nТакже стоит отметить, что вы можете редактировать файл /etc/passwd вручную, если хотите добавить пользователей и изменить информацию с помощью инструмента <b>vipw</b>, однако такие вещи лучше оставить для инструментов, о которых мы поговорим в следующем уроке, таких как useradd и userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Как обозначается отсутствие доступа к входу у пользователя в файле /etc/passwd?",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Взгляните на файл /etc/shadow",
          "id": 4,
          "lessonContent": "Файл /etc/shadow используется для хранения информации об аутентификации пользователя. Для доступа к нему требуются права суперпользователя. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nВы заметите, что он очень похож на содержимое файла /etc/passwd, однако в поле пароля вы увидите зашифрованный пароль. Поля разделены двоеточиями следующим образом:\n\n<ol>\n<li>Имя пользователя</li>\n<li>Зашифрованный пароль</li>\n<li>Дата последнего изменения пароля - выражена в виде количества дней с 1 января 1970 года. Если значение равно 0, это означает, что пользователю следует изменить пароль при следующем входе в систему</li>\n<li>Минимальный срок действия пароля - количество дней, которые пользователь должен подождать перед тем, как сможет изменить пароль снова</li>\n<li>Максимальный срок действия пароля - максимальное количество дней, прежде чем пользователь должен изменить пароль</li>\n<li>Период предупреждения о пароле - количество дней до истечения срока действия пароля</li>\n<li>Период неактивности пароля - количество дней после истечения срока действия пароля, в течение которых пользователь может войти с помощью своего пароля</li>\n<li>Дата истечения учетной записи - дата, после которой пользователь не сможет войти в систему</li>\n<li>Зарезервированное поле для будущего использования</li>\n</ol>\n\nВ большинстве современных дистрибутивов аутентификация пользователей не зависит только от файла /etc/shadow, есть и другие механизмы, такие как PAM (Pluggable Authentication Modules), которые заменяют аутентификацию.",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, двигаемся дальше!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Запустите команду <b>groups</b>. Что вы видите?",
          "id": 5,
          "lessonContent": "Другой файл, используемый в управлении пользователями, - это файл /etc/group. Этот файл позволяет создавать различные группы с разрешениями. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nОчень похоже на поле /etc/password, поля /etc/group имеют следующий формат:\n\n<ol>\n<li>Название группы</li>\n<li>Пароль группы - нет необходимости устанавливать пароль группы, использование повышенных привилегий, таких как sudo, является стандартным. По умолчанию будет установлен символ \"*\".</li>\n<li>Идентификатор группы (GID)</li>\n<li>Список пользователей - вы можете вручную указать пользователей, которых вы хотите добавить в определенную группу</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "Какой GID у пользователя root?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "Создайте нового пользователя, затем измените его пароль и войдите под новым пользователем.",
          "id": 6,
          "lessonContent": "Большинство корпоративных сред используют системы управления для управления пользователями, учетными записями и паролями. Однако на одном компьютере можно использовать полезные команды для управления пользователями.\n\n<b>Добавление пользователей</b>\n\nМожно использовать команду adduser или useradd. Команда adduser содержит более полезные функции, такие как создание домашнего каталога и другие. Есть файлы конфигурации для добавления новых пользователей, которые можно настроить в зависимости от того, что вы хотите выделить для пользователя по умолчанию. \n\n<pre>$ sudo useradd bob</pre>\n\nВы увидите, что вышеприведенная команда создает запись в /etc/passwd для bob, настраивает группы по умолчанию и добавляет запись в файл /etc/shadow.\n\n<b>Удаление пользователей</b>\n\nДля удаления пользователя можно использовать команду userdel.\n\n<pre>$ sudo userdel bob</pre>\n\nЭто в основном отменяет изменения файлов, внесенные командой useradd.\n\n<b>Изменение паролей</b>\n\n<pre>$ passwd bob</pre>\n\nЭто позволит вам изменить пароль себе или другому пользователю (если вы root).",
          "quizAnswer": "passwd",
          "quizQuestion": "Какая команда используется для изменения пароля?",
          "slug": "tools",
          "title": "Инструменты управления пользователями"
        }
      ],
      "slug": "usermanagement",
      "title": "Управление пользователями"
    },
    {
      "description": "Узнайте о уровнях разрешений и изменении разрешений.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Используйте команду ls -l на нескольких файлах и перечислите их разрешения, пользователя и группу.",
          "id": 1,
          "lessonContent": "Как мы узнали ранее, у файлов есть различные разрешения или режимы файла. Давайте посмотрим на пример:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nУ разрешений файла есть четыре части. Первая часть - это тип файла, который обозначается первым символом в разрешениях, в нашем случае, так как мы рассматриваем каталог, показан символ <b>d</b> для типа файла. Чаще всего вы увидите <b>-</b> для обычного файла.\n\nСледующие три части режима файла - это фактические разрешения. Разрешения группируются по 3 бита в каждой группе. Первые 3 бита - это разрешения пользователя, затем разрешения группы и, наконец, разрешения других. Я добавил вертикальную черту, чтобы было легче их различить.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nКаждый символ представляет различное разрешение:\n<ul>\n<li>r: чтение</li>\n<li>w: запись</li>\n<li>x: исполнение (программа, которую можно выполнить)</li>\n<li>-: пусто</li>\n</ul>\n\nТаким образом, в приведенном выше примере мы видим, что у пользователя pete есть разрешения на чтение, запись и выполнение файла. Группа penguins имеет разрешения на чтение и выполнение. И, наконец, другие пользователи (все остальные) имеют разрешения на чтение и выполнение.",
          "quizAnswer": "x",
          "quizQuestion": "Какой бит разрешения используется для исполнения?",
          "slug": "filepermissions",
          "title": "Права доступа к файлам"
        },
        {
          "exercise": "Измените разрешения некоторого текстового файла и посмотрите, как меняются биты при выполнении ls -l.",
          "id": 2,
          "lessonContent": "Изменение прав доступа легко выполняется с помощью команды <b>chmod</b>. \n\nСначала выберите, какой набор разрешений вы хотите изменить: пользователь, группа или другие. Вы можете добавлять или удалять разрешения с помощью <b>+</b> или <b>-</b>, давайте рассмотрим несколько примеров.\n\n<b>Добавление бита разрешения к файлу</b>\n<pre>$ chmod u+x myfile</pre>\n\nВ приведенной выше команде это означает: изменить разрешение на myfile, добавив исполняемый бит разрешения в набор пользователя. Теперь пользователь имеет исполняемое разрешение на этот файл!\n\n<b>Удаление бита разрешения из файла</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>Добавление нескольких битов разрешения к файлу</b>\n<pre>$ chmod ug+w</pre>\n\nСуществует еще один способ изменения прав доступа с использованием числового формата. Этот метод позволяет вам изменить все разрешения сразу. Вместо использования r, w или x для представления разрешений, вы будете использовать числовое представление для одного набора разрешений. Так что нет необходимости указывать группу с g или пользователя с u.\n\nЧисловые представления приведены ниже:\n\n<ul>\n<li>4: разрешение на чтение</li>\n<li>2: разрешение на запись</li>\n<li>1: разрешение на выполнение</li>\n</ul>\n\nДавайте рассмотрим пример: \n\n<pre>$ chmod 755 myfile</pre>\n\nМожете ли вы догадаться, какие разрешения мы даем этому файлу? Давайте разберем это, теперь 755 охватывает разрешения для всех наборов. Первое число (7) представляет разрешения пользователя, второе число (5) представляет разрешения группы, и последнее 5 представляет разрешения для других пользователей. \n\nПодождите минутку, 7 и 5 не были перечислены выше, откуда мы берем эти числа? Помните, что теперь мы объединяем все разрешения в одно число, поэтому вам придется использовать немного математики.\n\n7 = 4 + 2 + 1, таким образом, 7 - это разрешения пользователя, и у него есть разрешения на чтение, запись и выполнение\n\n5 = 4 + 1, у группы есть разрешения на чтение и выполнение\n\n5 = 4 + 1, и все остальные пользователи имеют разрешения на чтение и выполнение\n\nОдно важное замечание: не стоит менять разрешения бездумно, вы можете потенциально выставить на изменение чувствительный файл для всех, однако много раз вам действительно захочется изменить разрешения, просто будьте осторожны при использовании команды chmod.",
          "quizAnswer": "4",
          "quizQuestion": "Какое число представляет разрешение на чтение при использовании числового формата?",
          "slug": "modifyingpermissions",
          "title": "Изменение прав доступа"
        },
        {
          "exercise": "Измените группу и пользователя некоторых тестовых файлов. Затем посмотрите на разрешения с помощью ls -l.",
          "id": 3,
          "lessonContent": "Помимо изменения разрешений на файлы, вы также можете изменить группу и владельца файла. \n\n<b>Изменение владельца пользователя</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nЭта команда установит владельца myfile на patty.\n\n<b>Изменение группы владельца</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nЭта команда установит группу myfile на whales.\n\n<b>Изменение как владельца пользователя, так и группы одновременно</b>\nЕсли вы добавите двоеточие и название группы после пользователя, вы можете установить и пользователя, и группу одновременно.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "Какую команду вы используете для изменения владельца пользователя?",
          "slug": "ownershippermissions",
          "title": "Права собственности"
        },
        {
          "exercise": "<ol>\n<li>Создайте новый файл, затем запишите его разрешения.</li>\n<li>Измените umask, а затем создайте еще один новый файл.</li>\n<li>Проверьте разрешения еще раз на новом файле, что вы ожидаете увидеть?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Каждый файл, который создается, имеет набор разрешений по умолчанию. Если вы когда-либо захотите изменить этот набор разрешений по умолчанию, вы можете сделать это с помощью команды umask. Эта команда принимает набор разрешений из 3 бит, который мы видим в числовых разрешениях. \n\nВместо добавления этих разрешений, umask убирает эти разрешения. \n\n<pre>$ umask 021</pre>\n\nВ приведенном выше примере мы указываем, что мы хотим, чтобы разрешения по умолчанию для новых файлов позволяли пользователям получить доступ ко всему, но для групп мы хотим убрать их разрешение на запись, а для других пользователей мы хотим убрать их разрешение на выполнение. Умолчание umask на большинстве дистрибутивов - 022, что означает полный доступ пользователя, но без доступа на запись для группы и других пользователей.\n\nКогда вы запускаете команду umask, она устанавливает этот набор разрешений по умолчанию для любого нового файла, который вы создаете. Однако, если вы хотите, чтобы он сохранялся, вам придется изменить ваш файл запуска (.profile), но мы обсудим это в следующем уроке.",
          "quizAnswer": "umask",
          "quizQuestion": "Какая команда используется для изменения разрешений файлов по умолчанию?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Внимательно изучите разрешения для /etc/passwd, замечаете что-то еще? Файлы с включенным SUID также легко отличимы.",
          "id": 5,
          "lessonContent": "Существует много случаев, когда обычным пользователям требуется повышенный доступ для выполнения определенных действий. Администратор системы не всегда может быть рядом, чтобы вводить пароль суперпользователя каждый раз, когда пользователю требуется доступ к защищенному файлу, поэтому существуют специальные биты разрешений файлов, позволяющие такое поведение. Установка идентификатора пользователя (SUID) позволяет пользователю запускать программу от имени владельца файла программы, а не от себя.\n\nДавайте рассмотрим пример: \n\nПредположим, я хочу изменить свой пароль, просто, верно? Я просто использую команду passwd:\n\n<pre>$ passwd</pre>\n\nЧто делает команда passwd? Она изменяет несколько файлов, но, что самое важное, она изменяет файл /etc/shadow. Давайте посмотрим на этот файл на секунду: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nОй, подождите минутку, этот файл принадлежит root? Как мы можем изменять файл, принадлежащий root? \n\nДавайте посмотрим на другой набор разрешений, на этот раз команды, которую мы выполнили: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nВы заметите новый бит разрешений здесь <b>s</b>. Этот бит разрешений - SUID, когда у файла установлено это разрешение, пользователи, запустившие программу, получают разрешение владельца файла, а также разрешение на выполнение, в данном случае root. По сути, когда пользователь запускает команду passwd, он работает от имени root.\n\nВот почему мы можем получить доступ к защищенному файлу, такому как /etc/shadow, когда мы запускаем команду passwd. Теперь, если бы вы удалили этот бит, вы бы увидели, что не сможете изменить /etc/shadow и, следовательно, изменить свой пароль. \n\n<b>Изменение SUID</b>\n\nКак и обычные разрешения, существуют два способа изменения разрешений SUID. \n\n<i>Символьный способ:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Числовой способ:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nКак видите, SUID обозначается цифрой 4 и добавляется к набору разрешений. Вы можете видеть, что SUID обозначается как заглавная <b>S</b>, это означает, что оно по-прежнему делает то же самое, но не имеет разрешений на выполнение.",
          "quizAnswer": "4",
          "quizQuestion": "Какое число представляет собой SUID?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 6,
          "lessonContent": "Аналогично биту разрешения установки ID пользователя существует бит разрешения установки ID группы (SGID). Этот бит позволяет программе запускаться, как если бы она была членом этой группы. \n\nДавайте рассмотрим один пример: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nТеперь мы видим, что бит разрешения находится в групповом наборе разрешений. \n\n<b>Изменение SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nЧисловое представление для SGID - 2.",
          "quizAnswer": "2",
          "quizQuestion": "Какое число представляет SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Мы еще не обсудили процессы, но мы все равно можем посмотреть, как это происходит в реальном времени:\n\n<ol>\n<li>Откройте одно окно терминала и запустите команду: <b>watch -n 1 \"ps aux | grep passwd\"</b>. Это будет отслеживать процесс passwd.</li>\n<li>Откройте второе окно терминала и запустите: <b>passwd</b></li>\n<li>Посмотрите на первое окно терминала, вы увидите процесс для passwd. Первый столбец в таблице процессов - это эффективный идентификатор пользователя, о чудо, это пользователь root!</li>\n</ol>",
          "id": 7,
          "lessonContent": "Давайте немного поговорим о разрешениях процессов. Помните, как я говорил вам, что при запуске команды passwd с включенным битом разрешения SUID программа будет запущена от имени root? Это правда, но это не означает, что поскольку вы временно root, вы можете изменять пароли других пользователей? Нет, к счастью, нет!\n\nЭто связано с множеством UID, которые реализует Linux. У каждого процесса есть три UID:\n\nПри запуске процесса он работает с теми же разрешениями, что и пользователь или группа, запустившие его, это известно как <b>эффективный идентификатор пользователя</b>. Этот UID используется для предоставления прав доступа процессу. Так что, если, например, Bob запустил команду touch, процесс будет работать от его имени, и любые созданные им файлы будут принадлежать ему.\n\nСуществует еще один UID, называемый <b>реальным идентификатором пользователя</b>, это идентификатор пользователя, который запустил процесс. Они используются для определения пользователя, запустившего процесс.\n\nПоследний UID - <b>сохраненный идентификатор пользователя</b>, который позволяет процессу переключаться между эффективным UID и реальным UID, и наоборот. Это полезно, потому что мы не хотим, чтобы наш процесс работал с повышенными привилегиями все время, хорошая практика использовать специальные привилегии в определенные моменты.\n\nТеперь давайте свяжем это все вместе, посмотрев на команду passwd еще раз.\n\nПри запуске команды passwd ваш эффективный UID - это ваш идентификатор пользователя, допустим, пусть это будет 500. О, но подождите, помните, что у команды passwd включено разрешение SUID. Так что, когда вы ее запускаете, ваш эффективный UID становится 0 (0 - это UID root). Теперь эта программа может обращаться к файлам как root.\n\nДопустим, вы почувствовали себя немного могущественным и хотите изменить пароль Sally, у Sally UID 600. Ну, вам не повезло, к счастью, процесс также имеет ваш реальный UID в данном случае 500. Он знает, что ваш UID - 500, и поэтому вы не можете изменить пароль UID 600. (Конечно, это всегда обходится, если вы суперпользователь на машине и можете контролировать и изменять все).\n\nПоскольку вы запустили passwd, процесс начнется с использованием вашего реального UID, и он сохранит UID владельца файла (эффективный UID), чтобы вы могли переключаться между ними. Нет необходимости изменять все файлы с доступом root, если это не требуется.\n\nБольшую часть времени реальный UID и эффективный UID совпадают, но в таких случаях, как команда passwd, они изменяются.",
          "quizAnswer": "эффективный",
          "quizQuestion": "Какой UID решает, какой доступ предоставить?",
          "slug": "processpermissions",
          "title": "Процесс разрешений"
        },
        {
          "exercise": "Какие другие файлы и каталоги, на ваш взгляд, имеют включенный клейкий бит?",
          "id": 8,
          "lessonContent": "Еще один специальный бит разрешения, о котором я хочу поговорить, - это клейкий бит. \n\nЭтот бит разрешения \"приклеивает\" файл/каталог, что означает, что только владелец или пользователь root может удалить или изменить файл. Это очень полезно для общих каталогов. Взгляните на пример ниже:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nВы увидите специальный бит разрешения в конце здесь <b>t</b>, это означает, что каждый может добавлять файлы, записывать файлы, изменять файлы в каталоге /tmp, но только root может удалить каталог /tmp. \n\n<b>Изменение клейкого бита</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nЧисловое представление клейкого бита - <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "Какой символ представляет клейкий бит?",
          "slug": "stickybit",
          "title": "Клейкий бит"
        }
      ],
      "slug": "permissions",
      "title": "Разрешения"
    },
    {
      "description": "Узнайте о запущенных процессах в системе.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Используйте команду ps с различными флагами и посмотрите, как меняется вывод.",
          "id": 1,
          "lessonContent": "Процессы - это программы, которые работают на вашем компьютере. Они управляются ядром, и у каждого процесса есть связанный с ним идентификатор, называемый <b>идентификатор процесса (PID).</b> Этот PID присваивается в порядке создания процессов. \n\nПродолжайте и выполните команду ps, чтобы увидеть список работающих процессов:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nЭто показывает вам краткую информацию о текущих процессах:\n\n<ul>\n<li>PID: Идентификатор процесса</li>\n<li>TTY: Управляющий терминал, связанный с процессом (мы рассмотрим это подробнее позже)</li>\n<li>STAT: Код статуса процесса</li>\n<li>TIME: Общее время использования ЦП</li>\n<li>CMD: Имя исполняемой команды</li>\n</ul>\n\nЕсли вы посмотрите на страницу руководства по ps, вы увидите, что существует множество опций команд, которые можно передать, они будут различаться в зависимости от того, какие опции вы хотите использовать - BSD, GNU или Unix. На мой взгляд, стиль BSD более популярен, поэтому мы выберем его. Если вас интересует разница между стилями, то она заключается в количестве тире и флагах.\n\n<pre>$ ps aux</pre>\n\n<b>a</b> отображает все работающие процессы, включая те, которые запущены другими пользователями. <b>u</b> показывает более подробную информацию о процессах. И, наконец, <b>x</b> перечисляет все процессы, которым не назначен TTY, эти программы будут показывать ? в поле TTY, они наиболее распространены в демонических процессах, которые запускаются во время загрузки системы.\n\nВы заметите, что теперь вы видите гораздо больше полей, не нужно запоминать их все, в следующем курсе по продвинутым процессам мы еще раз рассмотрим некоторые из них:\n\n<ul>\n<li>USER: Эффективный пользователь (тот, чьи права доступа мы используем)</li>\n<li>PID: Идентификатор процесса</li>\n<li>%CPU: Время использования ЦП, деленное на время работы процесса</li>\n<li>%MEM: Соотношение размера набора резидентной памяти процесса к физической памяти на компьютере</li>\n<li>VSZ: Использование виртуальной памяти всего процесса</li>\n<li>RSS: Размер набора резидентной памяти, не подкачанной в файл подкачки, который использовало задание</li>\n<li>TTY: Управляющий терминал, связанный с процессом</li>\n<li>STAT: Код статуса процесса</li>\n<li>START: Время запуска процесса</li>\n<li>TIME: Общее время использования ЦП</li>\n<li>COMMAND: Имя исполняемой команды</li>\n</ul>\n\nКоманда ps может выглядеть немного запутанно, на данный момент поля, на которые мы будем смотреть чаще всего, - это PID, STAT и COMMAND. \n\nЕще одна очень полезная команда - <b>top</b>, top предоставляет вам информацию в реальном времени о работающих процессах на вашей системе вместо снимка. По умолчанию обновление происходит каждые 10 секунд. Top - это чрезвычайно полезный инструмент для просмотра процессов, потребляющих много ресурсов. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "Какой флаг ps используется для просмотра подробной информации о процессах?",
          "slug": "monitorprocessespscommand",
          "title": "ps (Процессы)"
        },
        {
          "exercise": "Посмотрите вывод ps и перечислите все уникальные значения TTY.",
          "id": 2,
          "lessonContent": "Мы обсудили, что в выводе ps есть поле TTY. TTY - это терминал, в котором была выполнена команда.\n\nСуществуют два типа терминалов: обычные <b>терминальные устройства</b> и <b>псевдотерминальные устройства</b>. Обычное терминальное устройство - это нативное терминальное устройство, в которое вы можете вводить текст и отправлять вывод на вашу систему, это похоже на терминальное приложение, которое вы запускали для доступа к оболочке, но это не то. \n\nМы сейчас перейдем, чтобы вы увидели это действие, нажмите Ctrl-Alt-F1, чтобы попасть в TTY1 (первая виртуальная консоль), вы заметите, что у вас нет ничего, кроме терминала, никакой графики и т. д. Это считается обычным терминальным устройством, вы можете выйти из него с помощью Ctrl-Alt-F7. \n\nПсевдотерминал - это то, в чем вы привыкли работать, они эмулируют терминалы с окном оболочки терминала и обозначаются как PTS. Если вы снова посмотрите на ps, вы увидите ваш процесс оболочки под pts/*. \n\nХорошо, теперь вернемся к управляющему терминалу, процессы обычно привязаны к управляющему терминалу. Например, если вы запустили программу в окне оболочки, такую как find, и закрыли окно, ваш процесс также завершится. \n\nСуществуют процессы, такие как демонические процессы, которые являются специальными процессами, обеспечивающими работу системы. Они часто запускаются при загрузке системы и обычно завершаются при выключении системы. Они работают в фоновом режиме, и поскольку мы не хотим, чтобы эти специальные процессы завершались, они не привязаны к управляющему терминалу. В выводе ps TTY указан как <b>?</b>, что означает, что у него нет управляющего терминала.",
          "quizAnswer": "?",
          "quizQuestion": "Какое значение указывается для процесса, у которого нет управляющего терминала?",
          "slug": "controllingterminal",
          "title": "Управление терминалом"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 3,
          "lessonContent": "Прежде чем мы перейдем к более практическим применениям процессов, нам нужно понять, что они такое и как они работают. Эта часть может быть запутанной, поскольку мы погружаемся в детали, так что не стесняйтесь вернуться к этому уроку, если сейчас не хотите об этом узнавать. \n\nПроцесс, как мы уже говорили, - это запущенная программа в системе, точнее, это система выделяет память, ЦПУ, ввод-вывод для запуска программы. Процесс - это экземпляр запущенной программы, откройте три терминальных окна, в двух окнах выполните команду <b>cat</b> без передачи каких-либо параметров (процесс cat останется открытым как процесс, потому что он ожидает ввода с клавиатуры). Теперь в третьем окне выполните: <b>ps aux | grep cat</b>. Вы увидите, что есть два процесса для cat, даже если они вызывают одну и ту же программу.\n\nЯдро отвечает за процессы, когда мы запускаем программу, ядро загружает код программы в память, определяет и выделяет ресурсы, а затем следит за каждым процессом, оно знает: \n\n<ul>\n<li>Статус процесса</li>\n<li>Ресурсы, которые процесс использует и получает</li>\n<li>Владелец процесса</li>\n<li>Обработка сигналов (подробнее об этом позже)</li>\n<li>И в общем все остальное</li>\n</ul>\n\nВсе процессы пытаются добраться до этого сладкого пирога ресурсов, задача ядра - убедиться, что процессы получают правильное количество ресурсов в зависимости от требований процесса. Когда процесс завершается, используемые им ресурсы освобождаются для других процессов.",
          "quizAnswer": "ядро",
          "quizQuestion": "Что управляет и контролирует процессы?",
          "slug": "processdetails",
          "title": "Детали процесса"
        },
        {
          "exercise": "Посмотрите на ваши работающие процессы, можете ли вы увидеть, у каких других процессов есть родители?",
          "id": 4,
          "lessonContent": "Снова этот урок и следующий - это просто информация, чтобы вы могли увидеть, что находится под капотом. Не стесняйтесь вернуться к этому, когда поработаете с процессами немного больше.\n\nКогда создается новый процесс, существующий процесс в основном клонирует себя, используя что-то, называемое вызовом системы fork (вызовы системы будут обсуждаться очень далеко в будущем). Вызов системы fork создает в основном идентичный дочерний процесс, этот дочерний процесс получает новый идентификатор процесса (PID), исходный процесс становится его родительским процессом и имеет так называемый идентификатор родительского процесса <b>PPID</b>. Затем дочерний процесс может либо продолжать использовать ту же программу, которую использовал его родитель, либо, чаще всего, использовать вызов системы execve для запуска новой программы. Этот вызов системы разрушает управление памятью, которое ядро установило для этого процесса, и устанавливает новые для новой программы. \n\nМы можем увидеть это на деле:\n\n<pre>$ ps l</pre>\n\nОпция l дает нам \"длинный формат\" или еще более подробный вид наших работающих процессов. Вы увидите столбец с меткой <b>PPID</b>, это идентификатор родителя. Теперь посмотрите на ваш терминал, вы увидите работающий процесс, это ваша оболочка, так что на моей системе работает процесс bash. Теперь помните, когда вы запускали команду ps l, вы запускали ее из процесса, который запускал bash. Теперь вы увидите, что <b>PID</b> оболочки bash является <b>PPID</b> команды <b>ps l</b>.\n\nИтак, если каждый процесс должен иметь родителя, и они просто являются копиями друг друга, должна быть мать всех процессов, верно? Вы правы, когда система загружается, ядро создает процесс под названием <b>init</b>, у него PID 1. Процесс init не может быть завершен, пока система не выключится. Он работает с привилегиями root и запускает множество процессов, которые поддерживают работу системы. Мы рассмотрим init ближе в курсе загрузки системы, а пока просто знайте, что это процесс, который порождает все остальные процессы.",
          "quizAnswer": "fork",
          "quizQuestion": "Какой вызов системы создает новый процесс?",
          "slug": "созданиепроцесса",
          "title": "Создание процесса"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 5,
          "lessonContent": "Теперь, когда мы знаем, что происходит при создании процесса, что происходит, когда нам он больше не нужен? Будьте предупреждены, иногда Linux может стать немного мрачным...\n\nПроцесс может завершиться с помощью системного вызова _exit, это освободит ресурсы, которые процесс использовал для повторного выделения. Поэтому, когда процесс готов к завершению, он сообщает ядру, почему он завершается, с помощью чего-то, называемого статусом завершения. Наиболее распространенный статус 0 означает, что процесс завершился успешно. Однако этого недостаточно для полного завершения процесса. Родительский процесс должен подтвердить завершение дочернего процесса, используя системный вызов wait, который проверяет статус завершения дочернего процесса. Я знаю, что довольно мрачно думать об этом, но вызов wait - это необходимость, в конце концов, какой родитель не хотел бы знать, как умер его ребенок?\n\nСуществует еще один способ завершения процесса, который включает использование сигналов, о которых мы скоро поговорим.\n\n<b>Сиротские процессы</b>\n\nКогда родительский процесс умирает до дочернего процесса, ядро понимает, что не получит вызов wait, поэтому оно делает эти процессы \"сиротами\" и передает их под опеку init (помните мать всех процессов). В конечном итоге init выполнит системный вызов wait для этих сирот, чтобы они могли умереть.\n\n<b>Зомби-процессы</b>\n\nЧто происходит, когда дочерний процесс завершается, а родительский процесс еще не вызвал wait? Мы все равно хотим видеть, как завершился дочерний процесс, поэтому, даже если дочерний процесс завершился, ядро превращает его в зомби-процесс. Ресурсы, которые использовал дочерний процесс, все еще освобождаются для других процессов, однако в таблице процессов все еще есть запись об этом зомби. Зомби-процессы также не могут быть убиты, поскольку они технически \"мертвы\", поэтому их нельзя убить сигналами. В конце концов, если родительский процесс вызывает системный вызов wait, зомби исчезнет, это известно как \"пожинание\". Если родитель не делает вызов wait, init усыновит зомби и автоматически выполнит wait и удалит зомби. Бывает плохо иметь слишком много зомби-процессов, поскольку они занимают место в таблице процессов, и если она заполнится, это помешает запуску других процессов.",
          "quizAnswer": "0",
          "quizQuestion": "Какой наиболее распространенный статус завершения для успешного процесса?",
          "slug": "processtermination",
          "title": "Прекращение процесса"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 6,
          "lessonContent": "Сигнал - это уведомление процессу о том, что что-то произошло.\n\n<b>Зачем нам нужны сигналы</b>\n\nОни являются программными прерываниями и имеют много применений:\n\n<ul>\n<li>Пользователь может нажать один из специальных символов терминала (Ctrl-C) или (Ctrl-Z), чтобы завершить, прервать или приостановить процессы</li>\n<li>Могут возникнуть проблемы с аппаратным обеспечением, и ядро хочет уведомить процесс</li>\n<li>Могут возникнуть проблемы с программным обеспечением, и ядро хочет уведомить процесс</li>\n<li>Это в основном способы взаимодействия процессов</li>\n</ul>\n\n<b>Процесс сигнала</b>\n\nКогда сигнал генерируется каким-либо событием, он затем доставляется процессу, считается ожидающим до момента доставки. Когда процесс запущен, сигнал будет доставлен. Однако у процессов есть маски сигналов, и они могут установить блокировку доставки сигнала, если указано. Когда сигнал доставлен, процесс может сделать множество вещей: \n\n<ul>\n<li>Игнорировать сигнал</li>\n<li>\"Поймать\" сигнал и выполнить определенную обработчик рутины</li>\n<li>Процесс может быть завершен, в отличие от обычного вызова системы выхода</li>\n<li>Блокировать сигнал в зависимости от маски сигнала</li>\n</ul>\n\n<b>Общие сигналы</b>\n\nКаждый сигнал определяется целыми числами с символическими именами в форме SIGxxx. Некоторые из наиболее распространенных сигналов: \n\n<ul>\n<li>SIGHUP или HUP или 1: Обрыв связи</li>\n<li>SIGINT или INT или 2: Прерывание</li>\n<li>SIGKILL или KILL или 9: Уничтожение</li>\n<li>SIGSEGV или SEGV или 11: Ошибка сегментации</li>\n<li>SIGTERM или TERM или 15: Программное завершение</li>\n<li>SIGSTOP или STOP: Остановка</li>\n</ul>\n\nЧисла могут варьироваться с сигналами, поэтому обычно на них ссылается по их именам.\n\nНекоторые сигналы нельзя заблокировать, один из примеров - сигнал SIGKILL. Сигнал KILL уничтожает процесс.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "Какой сигнал нельзя заблокировать?",
          "slug": "processsignals",
          "title": "Сигналы"
        },
        {
          "exercise": "Завершите некоторые процессы, используя различные сигналы.",
          "id": 7,
          "lessonContent": "Вы можете отправлять сигналы для завершения процессов, такая команда называется командой kill. \n\n<pre>$ kill 12445</pre>\n\n12445 - это PID процесса, который вы хотите завершить. По умолчанию отправляется сигнал TERM. Сигнал SIGTERM отправляется процессу для запроса его завершения, позволяя ему чисто освободить ресурсы и сохранить свое состояние. \n\nВы также можете указать сигнал с помощью команды kill: \n\n<pre>$ kill -9 12445</pre>\n\nЭто запустит сигнал SIGKILL и завершит процесс. \n\n<b>Различия между SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nЭти сигналы звучат достаточно похоже, но у них есть свои различия. \n\n<ul>\n<li>SIGHUP - Завершение, отправлено процессу, когда управляющий терминал закрыт. Например, если вы закрыли окно терминала, в котором работал процесс, вы получите сигнал SIGHUP. Так что, по сути, вас повесили</li>\n<li>SIGINT - Сигнал прерывания, поэтому вы можете использовать Ctrl-C, и система попытается грациозно завершить процесс</li>\n<li>SIGTERM - Завершить процесс, но позволить ему сначала выполнить некоторую очистку</li>\n<li>SIGKILL - Завершить процесс, убить его огнем, не выполняя очистку</li>\n<li>SIGSTOP - Остановить/приостановить процесс</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "Какое название сигнала для команды kill по умолчанию?",
          "slug": "killprocesses",
          "title": "kill (Завершить)"
        },
        {
          "exercise": "Какие процессы не очень добры и почему?",
          "id": 8,
          "lessonContent": "Когда вы запускаете несколько приложений на своем компьютере, например, Chrome, Microsoft Word или Photoshop одновременно, может показаться, что эти процессы работают одновременно, но это не совсем так. \n\nПроцессы используют ЦП на небольшой промежуток времени, называемый квантом времени. Затем они приостанавливаются на миллисекунды, и другой процесс получает небольшой квант времени. По умолчанию планирование процессов происходит круговым образом. Каждый процесс получает достаточно квантов времени, пока он не завершит обработку. Ядро обрабатывает все эти переключения процессов, и в большинстве случаев оно справляется с этим довольно хорошо.\n\nПроцессы не могут решать, когда и как долго им получать время ЦП, если бы все процессы вели себя нормально, каждый из них (примерно) получил бы равное количество времени ЦП. Однако есть способ влиять на алгоритм планирования процессов ядра с помощью значения nice. Доброта - довольно странное название, но это означает, что процессы имеют число для определения их приоритета для ЦП. Высокое число означает, что процесс добр и имеет более низкий приоритет для ЦП, а низкое или отрицательное число означает, что процесс не очень добр и хочет получить как можно больше времени ЦП. \n\n<pre>$ top</pre>\n\nСейчас вы можете увидеть столбец NI, который представляет уровень доброты процесса.\n\nЧтобы изменить уровень доброты, вы можете использовать команды nice и renice:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nКоманда nice используется для установки приоритета для нового процесса. Команда renice используется для установки приоритета для существующего процесса. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "низкое",
          "quizQuestion": "Если я хочу, чтобы процесс получил больший приоритет ЦП, я использую более низкое или более высокое значение nice?",
          "slug": "добротапроцесса",
          "title": "доброта"
        },
        {
          "exercise": "Посмотрите на работающие процессы на вашей системе и изучите их состояния процессов.",
          "id": 9,
          "lessonContent": "Давайте еще раз посмотрим на команду ps aux:\n\n<pre>$ ps aux</pre>\n\nВ столбце STAT вы увидите много значений. Процесс в Linux может находиться в различных состояниях. Наиболее распространенные коды состояний, которые вы увидите, описаны ниже:\n\n<ul>\n<li>R: работает или готов к выполнению, просто ожидает, когда процессор начнет его обрабатывать</li>\n<li>S: прерываемый сон, ожидание завершения события, такого как ввод с терминала</li>\n<li>D: непрерываемый сон, процессы, которые нельзя убить или прервать сигналом, обычно для их завершения вам придется перезагрузить систему или устранить проблему</li>\n<li>Z: зомби, мы уже обсуждали в предыдущем уроке, что зомби - это завершенные процессы, ожидающие сбора своих статусов</li>\n<li>T: остановлен, процесс был приостановлен/остановлен</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "Какой код STAT используется для представления непрерываемого сна?",
          "slug": "processstates",
          "title": "Состояния процессов"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 10,
          "lessonContent": "Помните, что в Linux все является файлом, даже процессы. Информация о процессах хранится в специальной файловой системе, известной как файловая система /proc.\n\n<pre>$ ls /proc</pre>\n\nЗдесь вы должны увидеть несколько значений, есть подкаталоги для каждого PID. Если вы посмотрели на PID в выводе ps, вы сможете найти его в каталоге /proc.\n\nПродолжайте и войдите в один из процессов и посмотрите этот файл:\n\n<pre>$ cat /proc/12345/status</pre>\n\nВы должны увидеть информацию о состоянии процесса, а также более подробную информацию. Каталог /proc - это то, как ядро видит систему, поэтому здесь содержится гораздо больше информации, чем вы увидели бы в ps.",
          "quizAnswer": "/proc",
          "quizQuestion": "Какая файловая система хранит информацию о процессах?",
          "slug": "procfilesystem",
          "title": "/proc файловая система"
        },
        {
          "exercise": "Перемещение некоторых заданий между фоновым и передним планом",
          "id": 11,
          "lessonContent": "Предположим, вы работаете в одном терминальном окне и выполняете команду, которая занимает очень много времени. Вы не можете взаимодействовать с оболочкой, пока она не завершится, однако мы хотим продолжать работать на наших машинах, поэтому нам нужно, чтобы эта оболочка оставалась открытой. К счастью, мы можем контролировать, как выполняются наши процессы с помощью заданий: \n\n<b>Отправка задания в фоновый режим</b>\n\nДобавление амперсанда (&) к команде запустит ее в фоновом режиме, чтобы вы могли продолжать использовать вашу оболочку. Давайте посмотрим на пример:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Просмотр всех фоновых заданий</b>\n\nТеперь вы можете просмотреть задания, которые вы только что отправили в фоновый режим.\n\n<pre>$ jobs\n\n[1]    Running     sleep 1000 &\n[2]-   Running     sleep 1001 &\n[3]+   Running     sleep 1002 &\n\n</pre>\n\nЗдесь вы увидите идентификатор задания в первом столбце, затем статус и команду, которая была выполнена. Знак <b>+</b> рядом с идентификатором задания означает, что это самое недавнее фоновое задание, которое было запущено. Задание с знаком <b>-</b> - вторая по времени выполнения команда.\n\n<b>Отправка задания в фоновый режим для существующего задания</b>\n\nЕсли вы уже запустили задание и хотите отправить его в фоновый режим, вам не нужно его завершать и начинать заново. Сначала приостановите задание с помощью Ctrl-Z, затем выполните команду <b>bg</b>, чтобы отправить его в фоновый режим.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Stopped     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Running     sleep 1000 &\n[2]    Running     sleep 1001 &\n[3]-   Running     sleep 1002 &\n[4]+   Running     sleep 1003 &\n</pre>\n\n<b>Перемещение задания из фонового режима в передний план</b>\n\nЧтобы вернуть задание из фонового режима, просто укажите идентификатор задания, которое вы хотите. Если вы запустите fg без каких-либо параметров, он вернет самое недавнее фоновое задание (задание с знаком + рядом с ним)\n\n<pre>$ fg %1</pre>\n\n<b>Удаление фоновых заданий</b>\n\nПодобно перемещению заданий из фонового режима, вы можете использовать ту же форму для завершения процессов, используя их идентификатор задания.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "Какая команда используется для просмотра фоновых заданий?",
          "slug": "jobcontrol",
          "title": "Управление заданиями"
        }
      ],
      "slug": "processes",
      "title": "Процессы"
    },
    {
      "description": "Узнайте все о инструментах управления пакетами dpkg, apt-get, rpm и yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "Ваша система состоит из множества пакетов, таких как интернет-браузеры, текстовые редакторы, медиаплееры и т. д. Эти пакеты управляются с помощью менеджеров пакетов, которые устанавливают и поддерживают программное обеспечение на вашей системе. Однако не все пакеты устанавливаются через менеджеры пакетов, вы также можете устанавливать пакеты напрямую из исходного кода (мы скоро к этому вернемся). Тем не менее, большую часть времени вы будете использовать менеджер пакетов для установки программного обеспечения, наиболее распространенными видами пакетов являются Debian (.deb) и Red Hat (.rpm). Пакеты в стиле Debian используются в дистрибутивах, таких как Debian, Ubuntu, LinuxMint и т. д. Пакеты в стиле Red Hat встречаются в Red Hat Enterprise Linux, Fedora, CentOS и т. д.\n\nЧто такое пакеты? Вы можете знать их как Chrome, Photoshop и т. д., и это так, но на самом деле это просто множество файлов, скомпилированных в один. Люди (или иногда один человек), которые пишут это программное обеспечение, известны как <b>поставщики исходного кода</b>, они компилируют свой код и описывают, как его установить. Эти поставщики исходного кода работают над выпуском нового программного обеспечения и обновлением существующего. Когда они готовы выпустить его в мир, они отправляют свой пакет <b>содержателям пакетов</b>, которые занимаются тем, чтобы это программное обеспечение попало в руки пользователей. Эти содержатели пакетов проверяют, управляют и распространяют это программное обеспечение в виде пакетов.",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, двигаемся дальше!",
          "slug": "softwaredistribution",
          "title": "Распространение программного обеспечения"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 2,
          "lessonContent": "Как пакеты, загруженные в интернет, попадают на наши компьютеры? Вы заходите на страницу загрузки каждого нужного пакета и нажимаете «скачать и установить»? На самом деле, вы можете так делать, но есть более удобный способ, называемый репозиториями пакетов. Репозитории - это просто центральное хранилище пакетов. Существует множество репозиториев, в которых содержится множество пакетов, и, что самое лучшее, все они находятся в интернете, без глупых установочных дисков. Ваш компьютер не знает, где искать эти репозитории, пока вы явно не укажете ему это.\n\nНапример, предположим, что я хочу установить программное обеспечение WackyWidgets на свой компьютер. WackyWidgets управляет своими собственными репозиториями для своих пакетов виджетов, внутри которых находится 10 пакетов, таких как CoolWidget, SuperWidget и т. д. WackyWidgets размещает этот репозиторий по источнику по ссылке: http://download.widgets/linux/deb/\n\nТеперь вместо того, чтобы идти на их веб-сайт и загружать пакет напрямую, вы можете указать вашему компьютеру найти программное обеспечение WackyWidgets по этой ссылке.\n\nВаша дистрибутив уже поставляется с предварительно утвержденными источниками для загрузки пакетов, именно так устанавливаются все базовые пакеты, которые вы видите на своей системе. На системе Debian этот файл источников - это файл <b>/etc/apt/sources.list</b>. Ваш компьютер будет знать, что нужно искать там и проверять, есть ли добавленные вами источники репозиториев.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Где находится файл источников в системе Debian?",
          "slug": "packagerepositories",
          "title": "Репозитории пакетов"
        },
        {
          "exercise": "Ознакомьтесь с документацией по tar и изучите другие доступные опции в man-странице.",
          "id": 3,
          "lessonContent": "Прежде чем мы перейдем к установке пакетов и различным менеджерам, нам нужно обсудить архивацию и сжатие файлов, потому что вы скорее всего столкнетесь с этими процессами, когда будете искать программное обеспечение в интернете. \n\nВероятно, вы уже знаете, что такое файловый архив, вам, скорее всего, встречались файлы с расширениями .rar и .zip. Это архив файлов, они содержат в себе множество файлов, но представлены в виде одного аккуратного файла, известного как архив.\n\n<b>Сжатие файлов с помощью gzip</b>\n\ngzip - программа, используемая для сжатия файлов в Linux, они имеют расширение .gz. \n\nДля сжатия файла:\n<pre>$ gzip mycoolfile</pre>\n\nДля разжатия файла:\n<pre>$ gunzip mycoolfile.gz</pre>\n\n<b>Создание архивов с помощью tar</b>\nК сожалению, gzip не может добавить несколько файлов в один архив для нас. К счастью, у нас есть программа tar, которая это делает. При создании архива с использованием tar, у него будет расширение .tar. \n\n<pre>$ tar cvf mytarfile.tar mycoolfile1 mycoolfile 2</pre>\n\n<ul>\n<li>c - создать</li>\n<li>v - сообщить программе быть подробной и показать, что она делает</li>\n<li>f - имя файла tar должно идти после этой опции, если вы создаете файл tar, вам придется придумать имя</li>\n</ul>\n\n<b>Распаковка архивов с помощью tar</b>\n\nДля извлечения содержимого tar-файла используйте: \n\n<pre>$ tar xvf mytarfile.tar</pre>\n\n<ul>\n<li>x - извлечь</li>\n<li>v - сообщить программе быть подробной и показать, что она делает</li>\n<li>f - файл, который вы хотите извлечь</li>\n</ul>\n\n<b>Сжатие/распаковка архивов с помощью tar и gzip</b>\n\nЧасто вы увидите tar-файл, который был сжат, например: mycompressedarchive.tar.gz, все, что вам нужно сделать, это работать снаружи внутрь, сначала удалить сжатие с помощью gunzip, а затем извлечь tar-файл. Или вы можете использовать опцию <b>z</b> с tar, которая просто указывает ему использовать утилиту gzip или gunzip.\n\nСоздать сжатый tar-файл:\n<pre>$ tar czf myfile.tar.gz</pre>\n\nРазархивировать и извлечь: \n<pre>$ tar xzf file.tar</pre>\n\nЕсли вам нужна помощь, запомните это: e<b>X</b>tract all <b>Z</b>ee <b>F</b>iles!\n\ntar - одна из тех команд, которая настолько важна, но вы ее никогда действительно не помните, соответствующий xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Другие утилиты</b>\n\nВ течение вашего пути в Linux вы столкнетесь с другими типами архивов и сжатия, такими как: bzip2, compress, zip, unzip и т. д. Они немного менее распространены, но имейте в виду, что различные утилиты потребуют разных команд.",
          "quizAnswer": "c",
          "quizQuestion": "Какой флаг tar используется для создания архивов?",
          "slug": "compressedarchivestar",
          "title": "tar и gzip"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 4,
          "lessonContent": "Пакеты очень редко работают самостоятельно, они чаще всего сопровождаются зависимостями, чтобы помочь им функционировать. Например, предположим, у нас есть группа ресторанов, все они готовят разные блюда, однако все они получают ингредиенты из одной и той же фермы. Их еда зависит от поставок фермы, если бы ферма вдруг перестала поставлять продукты, то рестораны оказались бы в довольно плохом состоянии. \n\nВ Linux эти зависимости часто являются другими пакетами или общими библиотеками. Общие библиотеки - это библиотеки кода, которые другие программы хотят использовать и не хотят переписывать для себя. Представьте ресторан снова, сколько работы было бы, если бы каждый ресторан также занимался сельским хозяйством? Слишком много.\n\nМы более подробно рассмотрим общие библиотеки в курсе о файловой системе, так что пока просто помните, что у пакетов есть зависимости, которые помогают им функционировать, будь то другие пакеты или библиотеки, и если эти зависимости отсутствуют, пакет окажется в неисправном состоянии и, как правило, даже не установится.",
          "quizAnswer": "",
          "quizQuestion": "Вопросов нет, двигайтесь дальше!",
          "slug": "packagedependencies",
          "title": "Зависимости пакетов"
        },
        {
          "exercise": "Найдите программу, которую хотите установить на свою систему, например, Google Chrome, и установите ее с помощью одной из этих команд.",
          "id": 5,
          "lessonContent": "Хотя большая часть этого курса посвящена системам управления пакетами (Бэтменам управления пакетами), мы не должны забывать о Робинах. Хотя они очень полезны и надежны, у них нет того сладкого бэтмобиля и универсального пояса.\n\nКак .exe - это одиночный исполняемый файл, такими же являются .deb и .rpm. Обычно вы не увидите их, если используете репозитории пакетов, но если загружаете пакеты напрямую, скорее всего, они будут в этих популярных форматах. Очевидно, что они эксклюзивны для своих дистрибутивов, .deb для основанных на Debian и .rpm для основанных на Red Hat.\n\nДля установки этих прямых пакетов можно использовать команды управления пакетами: rpm и dpkg. Эти инструменты используются для установки файлов пакетов, однако они не устанавливают зависимости пакета, поэтому если у вашего пакета 10 зависимостей, вам придется устанавливать эти пакеты отдельно, а затем их зависимости и так далее. Как видите, именно это послужило причиной появления полноценных систем управления, о которых мы поговорим позже.\n\nИмейте в виду, что вам многократно придется устанавливать, запрашивать или проверять пакет с помощью одного из этих инструментов, так что запомните эти команды. \n\n<b>Установить пакет</b>\n\n<pre>\nDebian: $ dpkg -i some_deb_package.deb\nRPM: $ rpm -i some_rpm_package.rpm\n</pre>\n\n<b>i</b> означает установку. Вы также можете использовать более длинный формат --install. \n\n<b>Удалить пакет</b>\n\n<pre>\nDebian: $ dpkg -r some_deb_package.deb\nRPM: $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian: <b>r</b> для удаления\nRPM: <b>e</b> для стирания\n\n<b>Список установленных пакетов</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> для списка\nRPM: <b>q</b> для запроса и <b>a</b> для всех",
          "quizAnswer": "dpkg",
          "quizQuestion": "Какой инструмент управления пакетами предназначен для файлов .deb?",
          "slug": "packageinstalltools",
          "title": "rpm и dpkg"
        },
        {
          "exercise": "Выполните каждую из этих команд для управления пакетами и посмотрите полученный вывод.",
          "id": 6,
          "lessonContent": "Ах, Бэтмены управления пакетами, эти системы поставляются со всем необходимым для упрощения установки, удаления и изменения пакетов, включая установку зависимостей пакетов. Две из самых популярных систем управления - <b>yum</b> и <b>apt</b>. Yum эксклюзивен для семьи Red Hat, а apt - исключительно для семьи Debian.\n\n<b>Установка пакета из репозитория</b>\n\n<pre>\nDebian: $ apt install package_name\nRPM: $ yum install package_name\n</pre>\n\n<b>Удаление пакета</b>\n\n<pre>\nDebian: $ apt remove package_name\nRPM: $ yum erase package_name\n</pre>\n\n<b>Обновление пакетов для репозитория</b>\n\nВсегда лучше всего обновлять репозитории пакетов, чтобы они были актуальными перед установкой и обновлением пакета.\n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Получение информации о установленном пакете</b>\n\n<pre>\nDebian: apt show package_name\nRPM: yum info package_name\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Какая команда используется для отображения информации о пакете в системе Debian?",
          "slug": "sistemy-upravleniya-paketami",
          "title": "yum и apt"
        },
        {
          "exercise": "Найдите программу с исходным кодом (с доверенного сайта) и установите из исходного кода.",
          "id": 7,
          "lessonContent": "Часто вы столкнетесь с неизвестным пакетом, который представлен только в виде исходного кода. Вам потребуется использовать несколько команд, чтобы скомпилировать и установить этот пакет на вашу систему. \n\nПрежде всего, вам нужно установить программное обеспечение, которое позволит вам компилировать исходный код. \n\n<pre>$ sudo apt install build-essential</pre>\n\nПосле этого извлеките содержимое файла пакета, скорее всего это будет файл .tar.gz. \n\n<pre>$ tar -xzvf package.tar.gz</pre>\n\nПрежде чем что-либо делать, изучите файл README или INSTALL внутри пакета. Иногда там содержатся конкретные инструкции по установке. \n\nВ зависимости от метода компиляции, который использовал разработчик, вам придется использовать разные команды, такие как cmake или что-то еще.\n\nОднако чаще всего вы увидите базовую компиляцию с помощью make, поэтому мы обсудим это:\n\nВнутри содержимого пакета будет скрипт configure, который проверяет зависимости на вашей системе, и если что-то отсутствует, вы увидите ошибку и вам нужно будет исправить эти зависимости. \n\n<pre>$ ./configure</pre>\n\n<b>./</b> позволяет вам выполнить скрипт в текущем каталоге. \n\n<pre>$ make</pre>\n\nВнутри содержимого пакета есть файл Makefile, который содержит правила для сборки программного обеспечения. Когда вы запускаете команду make, она смотрит на этот файл для сборки программного обеспечения.\n\n<pre>$ sudo make install</pre>\n\nЭта команда фактически устанавливает пакет, копируя правильные файлы в правильные места на вашем компьютере.\n\nЕсли вы хотите удалить пакет, используйте:\n\n<pre>$ sudo make uninstall</pre>\n\nБудьте осторожны при использовании make install, вы можете не осознать, что происходит на самом деле. Если вы решите удалить этот пакет, вы можете не удалить все, потому что не понимали, что было добавлено на вашу систему. Вместо этого забудьте все, что я только что объяснил вам о make install, и используйте команду <b>checkinstall</b>. Эта команда создаст для вас файл .deb, который вы легко сможете установить и удалить. \n\n<pre>$ sudo checkinstall</pre> \n\nЭта команда фактически \"make install\" и создаст пакет .deb для установки. Это упростит удаление пакета в дальнейшем.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "Что всегда следует использовать вместо make install?",
          "slug": "compilesourcecode",
          "title": "Компиляция исходного кода"
        }
      ],
      "slug": "packages",
      "title": "Пакеты"
    },
    {
      "description": "Узнайте о устройствах Linux и о том, как они взаимодействуют с ядром и пользовательским пространством.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Посмотрите содержимое каталога /dev, узнаете ли вы какие-либо знакомые устройства?",
          "id": 1,
          "lessonContent": "Когда вы подключаете устройство к своей машине, ему обычно требуется драйвер устройства для правильной работы. Вы можете взаимодействовать с драйверами устройств через файлы устройств или узлы устройств, которые являются специальными файлами, похожими на обычные файлы. Поскольку эти файлы устройств такие же, как обычные файлы, вы можете использовать программы, такие как ls, cat и т. д., для взаимодействия с ними. Эти файлы устройств обычно хранятся в каталоге /dev. Перейдите и выполните ls в каталоге /dev на вашей системе, вы увидите большое количество файлов устройств на вашей системе. \n\n<pre>$ ls /dev </pre>\n\nНекоторые из этих устройств вы уже использовали и взаимодействовали с ними, например, /dev/null. Помните, когда мы отправляем вывод в /dev/null, ядро знает, что это устройство принимает всё наше ввод и просто отбрасывает его, поэтому ничего не возвращается.\n\nВ старые дни, если вы хотели добавить устройство в вашу систему, вы добавляли файл устройства в /dev, а затем, вероятно, забывали об этом. Повторите это несколько раз, и вы увидите, где была проблема. Каталог /dev засорялся статическими файлами устройств устройств, которые вы давно обновили, перестали использовать и т. д. Устройствам также назначаются файлы устройств в порядке, в котором ядро их находит. Так что если каждый раз, когда вы перезагружали систему, устройства могли иметь разные файлы устройств в зависимости от того, когда они были обнаружены.\n\nК счастью, мы больше не используем этот метод, теперь у нас есть что-то, что мы используем для динамического добавления и удаления устройств, которые в настоящее время используются в системе, и мы обсудим это в следующих уроках.",
          "quizAnswer": "/dev",
          "quizQuestion": "Где хранятся файлы устройств в системе?",
          "slug": "devdirectory",
          "title": "/dev каталог"
        },
        {
          "exercise": "Посмотрите на ваш каталог /dev и определите, какие типы устройств вы видите.",
          "id": 2,
          "lessonContent": "Прежде чем мы поговорим о том, как управляются устройства, давайте посмотрим на некоторые устройства.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nСтолбцы следуют слева направо:\n\n<ul>\n<li>Разрешения</li>\n<li>Владелец</li>\n<li>Группа</li>\n<li>Основной номер устройства</li>\n<li>Дополнительный номер устройства</li>\n<li>Отметка времени</li>\n<li>Имя устройства</li>\n</ul>\n\nПомните, что в команде ls вы можете увидеть тип файла с первым битом в каждой строке. Файлы устройств обозначаются следующим образом: \n\n<ul>\n<li>c - символьное устройство</li>\n<li>b - блочное устройство</li>\n<li>p - канал</li>\n<li>s - сокет</li>\n</ul>\n\n<b>Символьное устройство</b>\n\nЭти устройства передают данные, но по одному символу за раз. Вы увидите много псевдоустройств (/dev/null) как символьные устройства, эти устройства фактически не физически подключены к машине, но позволяют операционной системе больше функциональности. \n\n<b>Блочное устройство</b>\n\nЭти устройства передают данные блоками фиксированного размера. Вы чаще всего увидите устройства, которые используют блоки данных как блочные устройства, такие как жесткие диски, файловые системы и т. д. \n\n<b>Канальное устройство</b>\n\nИменованные каналы позволяют двум или более процессам общаться друг с другом, они похожи на символьные устройства, но вместо вывода на устройство данные отправляются другому процессу. \n\n<b>Сокетное устройство</b>\n\nСокетные устройства облегчают общение между процессами, аналогично канальным устройствам, но они могут общаться сразу с несколькими процессами. \n\n<b>Характеристика устройства</b>\n\nУстройства характеризуются двумя числами, <b>основным номером устройства</b> и <b>дополнительным номером устройства</b>. Вы можете увидеть эти числа в приведенном выше примере ls, они разделены запятой. Например, предположим, что у устройства номера: <b>8, 0</b>:\n\nОсновной номер устройства представляет собой драйвер устройства, который используется, в данном случае 8, который часто является основным номером для блочных устройств sd. Дополнительный номер сообщает ядру, какое уникальное устройство в этом классе драйверов, в данном случае 0 используется для представления первого устройства (a).",
          "quizAnswer": "c",
          "quizQuestion": "Какой символ обозначает символьные устройства в команде ls -l?",
          "slug": "типыустройств",
          "title": "типы устройств"
        },
        {
          "exercise": "Запишите в псевдоустройства и посмотрите, что произойдет, будьте осторожны, не пишите на ваши диски в эти устройства!",
          "id": 3,
          "lessonContent": "Вот наиболее распространенные имена устройств, с которыми вы столкнетесь: \n\n<b>Устройства SCSI</b>\n\nЕсли у вас есть какое-либо массовое хранилище на вашем компьютере, скорее всего оно использует протокол SCSI (произносится \"скадзи\"). SCSI означает Small Computer System Interface, это протокол, используемый для обеспечения связи между дисками, принтерами, сканерами и другими периферийными устройствами и вашей системой. Вы могли слышать о устройствах SCSI, которые фактически не используются в современных системах, однако наши системы Linux соотносят SCSI-диски с жесткими дисками в /dev. Они представлены префиксом sd (SCSI-диск):\n\nОбщие файлы устройств SCSI:\n\n<ul>\n<li>/dev/sda - Первый жесткий диск</li>\n<li>/dev/sdb - Второй жесткий диск</li>\n<li>/dev/sda3 - Третий раздел на первом жестком диске</li>\n</ul>\n\n<b>Псевдоустройства</b>\n\nКак мы уже обсуждали ранее, псевдоустройства фактически не физически подключены к вашей системе, наиболее распространенные псевдоустройства - символьные устройства: \n\n<ul>\n<li>/dev/zero - принимает и отбрасывает весь ввод, создает непрерывный поток байтов NULL (нулевое значение)</li>\n<li>/dev/null - принимает и отбрасывает весь ввод, не создает вывод</li>\n<li>/dev/random - создает случайные числа</li>\n</ul>\n\n<b>Устройства PATA</b>\n\nИногда в старых системах вы можете видеть, что жесткие диски обозначаются с префиксом hd: \n\n<ul>\n<li>/dev/hda - Первый жесткий диск</li>\n<li>/dev/hdd2 - Второй раздел на четвертом жестком диске</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "Какое устройство обычно будет именем для первого раздела на втором SCSI-диске?",
          "slug": "devicenames",
          "title": "Имена устройств"
        },
        {
          "exercise": "Ознакомьтесь с содержимым каталога /sys и посмотрите, какие файлы находятся там.",
          "id": 4,
          "lessonContent": "Sysfs был создан давно для более эффективного управления устройствами на нашей системе, которое не удавалось сделать в каталоге /dev. Sysfs - это виртуальная файловая система, чаще всего монтируемая в каталог /sys. Она предоставляет нам более подробную информацию, чем мы могли бы видеть в каталоге /dev. Оба каталога /sys и /dev кажутся очень похожими и в некотором смысле они таковы, но у них есть существенные различия. В основном, каталог /dev прост, он позволяет другим программам получать доступ к устройствам сами по себе, в то время как файловая система /sys используется для просмотра информации и управления устройством. \n\nФайловая система /sys в основном содержит всю информацию обо всех устройствах на вашей системе, такую как производитель и модель, место подключения устройства, состояние устройства, иерархию устройств и многое другое. Файлы, которые вы видите здесь, не являются узлами устройств, поэтому вы не взаимодействуете с устройствами из каталога /sys, а скорее управляете ими. \n\nВзгляните на содержимое каталога /sys:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "Какой каталог используется для просмотра подробной информации об устройствах?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Запустите предложенную команду udevadm и ознакомьтесь с вводом.",
          "id": 5,
          "lessonContent": "Еще в старые времена и на самом деле и сегодня, если вам действительно захочется, вы можете создать узлы устройств с помощью команды, например: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nЭта команда создаст узел устройства /dev/sdb1 и сделает его блочным устройством (b) с основным номером 8 и вторичным номером 3.\n\nЧтобы удалить устройство, просто нужно <b>удалить</b> файл устройства в каталоге /dev. \n\nК счастью, нам действительно больше не нужно этого делать из-за udev. Система udev динамически создает и удаляет файлы устройств для нас в зависимости от их подключения. На системе работает демон udevd, который прослушивает сообщения от ядра о подключенных к системе устройствах. Udevd будет анализировать эту информацию и сопоставлять данные с правилами, указанными в /etc/udev/rules.d, в зависимости от этих правил, скорее всего, будут созданы узлы устройств и символические ссылки для устройств. Вы можете написать собственные правила udev, но это выходит за рамки этого урока. К счастью, ваша система уже поставляется с множеством правил udev, так что вам, возможно, никогда не придется писать свои собственные.\n\nВы также можете просмотреть базу данных udev и sysfs, используя команду <b>udevadm</b>. Этот инструмент очень полезен, но иногда может стать очень запутанным, простая команда для просмотра информации об устройстве выглядит так:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "Что динамически добавляет и удаляет устройства?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Попробуйте каждую из этих команд и посмотрите вывод, который вы получите.",
          "id": 6,
          "lessonContent": "Как и при использовании команды ls для перечисления файлов и каталогов, мы можем использовать аналогичные инструменты, которые перечисляют информацию об устройствах.\n\n<b>Перечисление USB-устройств</b>\n\n<pre>$ lsusb </pre>\n\n<b>Перечисление устройств PCI</b>\n\n<pre>$ lspci </pre>\n\n<b>Перечисление устройств SCSI</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "Какая команда используется для просмотра usb-устройств?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Используйте команду dd для создания резервной копии вашего диска и установите вывод в файл .img.",
          "id": 7,
          "lessonContent": "Инструмент dd чрезвычайно полезен для преобразования и копирования данных. Он считывает ввод из файла или потока данных и записывает его в файл или поток данных. \n\nРассмотрим следующую команду: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nЭта команда копирует содержимое backup.img в /dev/sdb. Она будет копировать данные блоками по 1024 байта, пока не останется больше данных для копирования. \n\n<ul>\n<li>if=file - Входной файл, читать из файла вместо стандартного ввода</li>\n<li>of=file - Выходной файл, записывать в файл вместо стандартного вывода</li>\n<li>bs=bytes - Размер блока, считывает и записывает такое количество байт данных за раз. Вы можете использовать различные размеры, обозначая размер буквой k для килобайта, m для мегабайта и т. д., поэтому 1024 байта - это 1k</li>\n<li>count=number - Количество блоков для копирования.</li>\n</ul>\n\nВы увидите некоторые команды dd, которые используют опцию count, обычно с dd if, если вы хотите скопировать файл размером 1 мегабайт, вы обычно хотите видеть этот файл как 1 мегабайт после завершения копирования. Допустим, вы выполняете следующую команду: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nНаш файл backup.img имеет размер 10M, однако в этой команде мы говорим скопировать 1M 2 раза, поэтому копируется только 2M, оставляя наши скопированные данные неполными. Опция count может пригодиться во многих ситуациях, но если вы просто копируете данные, вы можете практически опустить count и даже bs. Если вы действительно хотите оптимизировать передачу данных, вам стоит начать использовать эти параметры.\n\ndd чрезвычайно мощный инструмент, вы можете использовать его для создания резервных копий всего, включая целые дисковые накопители, восстановление образов дисков и многое другое. Будьте осторожны, этот мощный инструмент может иметь свою цену, если вы не уверены в том, что делаете.",
          "quizAnswer": "bs",
          "quizQuestion": "Какая опция dd отвечает за размер блока?",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Устройства"
    },
    {
      "description": "Узнайте о файловой системе Linux, различных типах файловых систем, разделении и многом другом.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Посмотрите внутрь вашего каталога /usr, какая информация там находится?",
          "id": 1,
          "lessonContent": "На данном этапе вы, вероятно, уже хорошо знакомы с структурой каталогов вашей системы, если нет, то скоро будете. Файловые системы могут различаться по структуре, но в большинстве случаев они должны соответствовать стандарту иерархии файловой системы. \n\nВыполните команду <b>ls -l /</b>, чтобы увидеть перечень каталогов, перечень на вашем компьютере может отличаться от моего, но каталоги в основном должны выглядеть следующим образом:\n\n<ul>\n<li>/ - Корневой каталог всей иерархии файловой системы, все находится внутри этого каталога.</li>\n<li>/bin - Основные готовые к запуску программы (бинарники), включает в себя самые базовые команды, такие как ls и cp.</li>\n<li>/boot - Содержит файлы загрузчика ядра.</li>\n<li>/dev - Файлы устройств.</li>\n<li>/etc - Основной каталог конфигурации системы, должен содержать только файлы конфигурации, но не бинарные файлы.</li>\n<li>/home - Личные каталоги пользователей, содержит ваши документы, файлы, настройки и т. д.</li>\n<li>/lib - Содержит библиотечные файлы, которые могут использовать бинарники.</li>\n<li>/media - Используется как точка подключения для съемных носителей, таких как USB-накопители.</li>\n<li>/mnt - Временно подключаемые файловые системы.</li>\n<li>/opt - Дополнительные пакеты прикладного программного обеспечения.</li>\n<li>/proc - Информация о текущих запущенных процессах.</li>\n<li>/root - Домашний каталог пользователя root.</li>\n<li>/run - Информация о работающей системе с момента последней загрузки.</li>\n<li>/sbin - Содержит основные системные бинарники, обычно могут быть запущены только root-пользователем.</li>\n<li>/srv - Данные, специфичные для сайта, обслуживаемые системой.</li>\n<li>/tmp - Хранилище для временных файлов</li>\n<li>/usr - К сожалению, этот каталог имеет неудачное название, в большинстве случаев он не содержит пользовательских файлов в смысле домашнего каталога. Здесь размещаются установленные пользователем программное обеспечение и утилиты, однако это не означает, что нельзя добавлять личные каталоги. Внутри этого каталога находятся подкаталоги /usr/bin, /usr/local и т. д.</li>\n<li>/var - Каталог переменных, используется для системного журналирования, отслеживания пользователей, кэширования и т. д. Практически все, что подвержено постоянным изменениям.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "В каком каталоге хранятся журналы?",
          "slug": "filesystemhierarchy",
          "title": "Иерархия файловой системы"
        },
        {
          "exercise": "Проведите небольшое исследование в Интернете о других типах файловых систем: ReiserFS, ZFS, JFS и других, которые вы можете найти.",
          "id": 2,
          "lessonContent": "Существует множество различных реализаций файловых систем. Некоторые работают быстрее, чем другие, некоторые поддерживают более крупные накопители, а другие работают только с небольшими накопителями. Различные файловые системы имеют разные способы организации своих данных, и мы подробно рассмотрим, какие существуют типы файловых систем. Поскольку существует множество различных реализаций, приложениям необходим способ работы с различными операциями. Для этого существует так называемый уровень абстракции виртуальной файловой системы (VFS). Это слой между приложениями и различными типами файловых систем, поэтому независимо от того, какая файловая система у вас есть, ваши приложения смогут с ней работать. \n\nНа ваших дисках может быть много файловых систем, в зависимости от того, как они разделены, и мы рассмотрим это в следующем уроке.\n\n<b>Журналирование</b>\n\nЖурналирование по умолчанию присутствует в большинстве типов файловых систем, но на всякий случай, если его нет, вам следует знать, что оно делает. Допустим, вы копируете большой файл, и вдруг теряете питание. Ну, если вы используете файловую систему без журналирования, файл окажется поврежденным, ваша файловая система будет несогласованной, и затем при повторном включении вашей системы будет выполнена проверка файловой системы, чтобы убедиться, что все в порядке. Однако ремонт может занять некоторое время в зависимости от размера вашей файловой системы. \n\nТеперь, если вы используете систему с журналированием, перед тем как ваш компьютер начнет копировать файл, он запишет в журнал (журнал) то, что вы собираетесь делать. Теперь, когда вы действительно скопируете файл, по завершении операции журнал отметит эту задачу как завершенную. Файловая система всегда находится в согласованном состоянии благодаря этому, поэтому она точно знает, где вы остановились, если ваш компьютер внезапно выключится. Это также уменьшает время загрузки, потому что вместо проверки всей файловой системы она просто просматривает ваш журнал.\n\n<b>Общие типы файловых систем для настольных компьютеров</b>\n\n<ul>\n<li>ext4 - Это самая актуальная версия нативных файловых систем Linux. Она совместима с более старыми версиями ext2 и ext3. Поддерживает дисковые тома до 1 эксабайта и размеры файлов до 16 терабайт и многое другое. Это стандартный выбор для файловых систем Linux.</li>\n<li>Btrfs - \"Better or Butter FS\", это новая файловая система для Linux, которая поставляется со снимками, инкрементными резервными копиями, увеличением производительности и многое другое. Она широко доступна, но еще не совсем стабильна и совместима.</li>\n<li>XFS - Высокопроизводительная журналирующая файловая система, отлично подходит для систем с большими файлами, таких как медиасервер.</li>\n<li>NTFS и FAT - Файловые системы Windows</li>\n<li>HFS+ - Файловая система Macintosh</li>\n</ul>\n\nПроверьте, какие файловые системы есть на вашем компьютере: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nКоманда <b>df</b> сообщает об использовании дискового пространства файловой системы и других деталях о вашем диске, о котором мы поговорим позже.",
          "quizAnswer": "ext4",
          "quizQuestion": "Какой общий тип файловой системы используется в Linux?",
          "slug": "filesystemtypes",
          "title": "Типы файловых систем"
        },
        {
          "exercise": "Запустите <b>parted -l</b> на своей машине и оцените результаты.",
          "id": 3,
          "lessonContent": "Жесткие диски могут быть разделены на разделы, фактически создавая несколько блочных устройств. Например, /dev/sda1 и /dev/sda2, где /dev/sda - весь диск, а /dev/sda1 - первый раздел на этом диске. Разделы чрезвычайно полезны для разделения данных, и если вам нужна определенная файловая система, вы легко можете создать раздел вместо того, чтобы делать весь диск одним типом файловой системы.\n\n<b>Таблица разделов</b>\n\nНа каждом диске есть таблица разделов, которая сообщает системе, как диск разделен. Эта таблица указывает, где начинаются и заканчиваются разделы, какие разделы загружаемые, какие сектора диска выделены для какого раздела и т. д. Существует две основные схемы таблиц разделов: Master Boot Record (MBR) и GUID Partition Table (GPT).\n\n<b>Раздел</b>\n\nДиски состоят из разделов, которые помогают нам организовывать наши данные. На диске может быть несколько разделов, которые не могут перекрываться. Если есть пространство, которое не выделено под раздел, то оно называется свободным пространством. Типы разделов зависят от вашей таблицы разделов. Внутри раздела можно иметь файловую систему или выделить раздел под другие вещи, такие как подкачка (мы скоро к этому вернемся).\n\n<i>MBR</i>\n\n<ul>\n<li>Традиционная таблица разделов, использовалась как стандарт</li>\n<li>Может иметь основные, расширенные и логические разделы</li>\n<li>MBR имеет ограничение в четыре основных раздела</li>\n<li>Дополнительные разделы можно создать, превратив основной раздел в расширенный раздел (на диске может быть только один расширенный раздел). Затем внутри расширенного раздела добавляются логические разделы. Логические разделы используются так же, как и любой другой раздел. Смешно, я знаю.</li>\n<li>Поддерживает диски до 2 терабайт</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>GUID Partition Table (GPT) становится новым стандартом для разделения дисков</li>\n<li>Имеет только один тип раздела, и их можно создавать много</li>\n<li>Каждый раздел имеет глобально уникальный идентификатор (GUID)</li>\n<li>В основном используется с загрузкой на основе UEFI (мы рассмотрим детали в другом курсе)</li>\n</ul>\n\n<b>Структура файловой системы</b>\n\nМы знаем из предыдущего урока, что файловая система - это организованная коллекция файлов и каталогов. В простейшей форме она состоит из базы данных для управления файлами и самих файлов, но мы пойдем немного глубже.\n\n<ul>\n<li>Загрузочный блок - он находится в первых нескольких секторах файловой системы и на самом деле не используется файловой системой. Он содержит информацию, используемую для загрузки операционной системы. Операционной системе нужен только один загрузочный блок. Если у вас несколько разделов, у них будет загрузочные блоки, но многие из них не используются.</li>\n<li>Суперблок - это один блок, который следует за загрузочным блоком, и он содержит информацию о файловой системе, такую как размер таблицы инодов, размер логических блоков и размер файловой системы.</li>\n<li>Таблица инодов - представьте себе это как базу данных, управляющую нашими файлами (у нас есть целый урок об инодах, так что не волнуйтесь). У каждого файла или каталога есть уникальная запись в таблице инодов, и в ней содержится различная информация о файле.</li>\n<li>Блоки данных - это фактические данные для файлов и каталогов.</li>\n</ul>\n\nДавайте посмотрим на различные таблицы разделов. Ниже приведен пример раздела, использующего таблицу разделов MBR (msdos). Вы можете увидеть основные, расширенные и логические разделы на машине.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\n\nЭтот пример GPT, использующий только уникальный идентификатор для разделов.\n\n<pre>\nModel: Thumb Drive (scsi)\nDisk /dev/sdb: 4041MB\nSector size (logical/physical): 512B/512B\nPartition Table: gpt\n\nNumber  Start   End     Size     File system  Name        Flags\n 1      17.4kB  1000MB  1000MB                first\n 2      1000MB  4040MB  3040MB                second\n</pre>",
          "quizAnswer": "расширенный",
          "quizQuestion": "Какой тип раздела используется для создания более чем 4 разделов в схеме разделения MBR?",
          "slug": "anatomyofadisk",
          "title": "Анатомия диска"
        },
        {
          "exercise": "Разбить USB-накопитель так, чтобы половина диска была ext4, а другая половина - свободным местом.",
          "id": 4,
          "lessonContent": "Давайте проведем практические действия с файловыми системами, работая через процесс на USB-накопителе. Если у вас его нет, не беспокойтесь, вы все равно можете следовать за этими следующими уроками. \n\nСначала нам нужно разбить наш диск на разделы. Для этого существует много инструментов: \n\n<ul>\n<li>fdisk - базовый инструмент разбиения командной строки, не поддерживает GPT</li>\n<li>parted - это инструмент командной строки, который поддерживает как MBR, так и GPT разбиение</li>\n<li>gparted - это графическая версия parted</li>\n<li>gdisk - fdisk, но не поддерживает MBR, только GPT</li>\n</ul>\n\nДавайте используем parted для разбиения наших разделов. Допустим, я подключаю USB-устройство, и мы видим, что имя устройства - /dev/sdb2. \n\n<b>Запуск parted</b>\n\n<pre>$ sudo parted</pre>\n\nВы войдете в инструмент parted, здесь вы можете выполнять команды для разбиения вашего устройства. \n\n<b>Выбор устройства</b>\n\n<pre>select /dev/sdb2</pre>\n\nДля выбора устройства, с которым вы будете работать, выберите его по имени устройства.\n\n<b>Просмотр текущей таблицы разделов</b>\n\n<pre>\n(parted) print                                                            \nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\nЗдесь вы увидите доступные разделы на устройстве. <b>Начало</b> и <b>конец</b> - это места, где разделы занимают место на жестком диске, вам нужно найти хорошее начальное и конечное местоположение для ваших разделов. \n\n<b>Разбиение устройства</b>\n\n<pre>mkpart primary 123 4567</pre>\n\nПросто выберите начальную и конечную точку и создайте раздел, вам нужно указать тип раздела в зависимости от используемой таблицы. \n\n<b>Изменение размера раздела</b>\n\nВы также можете изменить размер раздела, если у вас нет свободного места. \n\n<pre>resize 2 1245 3456</pre>\n\nВыберите номер раздела, а затем начальную и конечную точки, куда вы хотите изменить его размер. \n\nParted - очень мощный инструмент, и вам следует быть осторожным при разбиении ваших дисков.",
          "quizAnswer": "mkpart",
          "quizQuestion": "Какая команда parted используется для создания раздела?",
          "slug": "diskpartitioning",
          "title": "Разбиение диска"
        },
        {
          "exercise": "Создайте файловую систему ext4 на USB-накопителе.",
          "id": 5,
          "lessonContent": "Теперь, когда вы фактически разбили диск, давайте создадим файловую систему!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nПросто так! Инструмент <b>mkfs</b> (make filesystem) позволяет нам указать тип файловой системы, которую мы хотим, и где мы хотим её создать. Вы захотите создать файловую систему только на вновь разбитом диске или если вы переразбиваете старый. Вероятнее всего, вы оставите вашу файловую систему в поврежденном состоянии, если попытаетесь создать её поверх существующей.",
          "quizAnswer": "mkfs",
          "quizQuestion": "Какая команда используется для создания файловой системы?",
          "slug": "creatingfilesystems",
          "title": "Создание файловых систем"
        },
        {
          "exercise": "Посмотрите страницу руководства для mount и umount и посмотрите, какие другие опции вы можете использовать.",
          "id": 6,
          "lessonContent": "Прежде чем вы сможете просмотреть содержимое вашей файловой системы, вам нужно будет ее примонтировать. Для этого мне понадобится местоположение устройства, тип файловой системы и точка монтирования, которая является каталогом в системе, куда будет присоединена файловая система. Таким образом, мы хотим примонтировать наше устройство к точке монтирования. \n\nСначала создайте точку монтирования, в нашем случае <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nПросто так! Теперь, когда мы перейдем в /mydrive, мы сможем увидеть содержимое нашей файловой системы, <b>-t</b> указывает тип файловой системы, затем у нас есть местоположение устройства, а затем точка монтирования. \n\nЧтобы отмонтировать устройство с точки монтирования: \n\n<pre>$ sudo umount /mydrive \nили \n$ sudo umount /dev/sdb2</pre>\n\nПомните, что ядро именует устройства в порядке их обнаружения. Что если имя нашего устройства изменится по какой-то причине после его монтирования? Что ж, к счастью, вы можете использовать уникальный идентификатор устройства (UUID) вместо имени.\n\nЧтобы просмотреть UUID на вашей системе для блочных устройств:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nМы видим имена наших устройств, их соответствующие типы файловых систем и их UUID. Теперь, когда мы хотим что-то примонтировать, мы можем использовать:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nБольшую часть времени вам не понадобится монтировать устройства по их UUID, гораздо проще использовать имя устройства, и часто операционная система сама знает, как монтировать обычные устройства, такие как USB-накопители. Однако, если вам нужно автоматически монтировать файловую систему при запуске, например, если вы добавили второй жесткий диск, вам следует использовать UUID, и мы рассмотрим это в следующем уроке.",
          "quizAnswer": "mount",
          "quizQuestion": "Какая команда используется для присоединения файловой системы?",
          "slug": "mountingandunmountingfilesystems",
          "title": "mount и umount"
        },
        {
          "exercise": "Добавьте USB-накопитель, над которым мы работали, как запись в /etc/fstab, после перезагрузки вы должны увидеть его смонтированным.",
          "id": 7,
          "lessonContent": "Когда мы хотим автоматически монтировать файловые системы при запуске, мы можем добавить их в файл с именем /etc/fstab (произносится \"эф эс таб\", а не \"эф стаб\"), что означает таблицу файловой системы. Этот файл содержит постоянный список монтируемых файловых систем.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nКаждая строка представляет собой одну файловую систему, поля: \n\n<ul>\n<li>UUID - Идентификатор устройства</li>\n<li>Точка монтирования - Каталог, к которому монтируется файловая система</li>\n<li>Тип файловой системы</li>\n<li>Опции - другие опции монтирования, см. страницу справки для получения более подробной информации</li>\n<li>Dump - используется службой резервного копирования для определения момента создания резервной копии, по умолчанию следует использовать 0</li>\n<li>Pass - Используется fsck для определения порядка проверки файловых систем, если значение равно 0, то проверка не будет выполнена</li>\n</ul>\n\nЧтобы добавить запись, просто непосредственно измените файл /etc/fstab, используя синтаксис записи выше. Будьте осторожны при изменении этого файла, вы можете усложнить свою жизнь, если что-то пойдет не так.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "Какой файл используется для определения способа монтирования файловых систем?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Разделите свободное место на USB-накопителе для пространства подкачки.",
          "id": 8,
          "lessonContent": "В нашем предыдущем примере я показал вам, как просмотреть таблицу разделов, давайте вернемся к этому примеру, более конкретно к этой строке:\n\n<pre>\nNumber  Start   End     Size    Type      File system     Flags\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n</pre>\n\nЧто такое этот раздел подкачки? Ну, подкачка - это то, что мы используем для выделения виртуальной памяти нашей системе. Если у вас мало памяти, система использует этот раздел для \"подкачки\" кусков памяти неактивных процессов на диск, чтобы вы не испытывали нехватку памяти.\n\n<b>Использование раздела для подкачки</b>\n\nДопустим, мы хотим назначить наш раздел /dev/sdb2 для использования в качестве пространства подкачки. \n\n<ol>\n<li>Сначала убедитесь, что на разделе ничего нет</li>\n<li>Выполните: mkswap /dev/sdb2 для инициализации областей подкачки</li>\n<li>Выполните: swapon /dev/sdb2, это активирует устройство подкачки</li>\n<li>Если вы хотите, чтобы раздел подкачки сохранялся при загрузке, вам нужно добавить запись в файл /etc/fstab. sw - это тип файловой системы, который вы будете использовать.</li>\n<li>Для удаления подкачки: swapoff /dev/sdb2</li>\n</ol>\n\nОбычно вы должны выделять примерно в два раза больше места подкачки, чем у вас есть памяти. Но современные системы обычно достаточно мощные и имеют достаточно ОЗУ, как есть.",
          "quizAnswer": "swapon",
          "quizQuestion": "Какая команда используется для активации пространства подкачки на устройстве?",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "Посмотрите на использование диска и свободное пространство с помощью du и df.",
          "id": 9,
          "lessonContent": "Есть несколько инструментов, которые вы можете использовать для просмотра использования ваших дисков: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocks    Used Available Use% Mounted on\n/dev/sda1       6.2G  2.3G  3.6G  40% /\n</pre>\n\nКоманда df показывает вам использование ваших текущих примонтированных файловых систем. Флаг -h дает вам удобочитаемый формат. Вы можете увидеть, что это за устройство, и сколько места используется и доступно. \n\nПредположим, что ваш диск заполняется, и вы хотите знать, какие файлы или каталоги занимают это пространство, для этого вы можете использовать команду <b>du</b>. \n\n<pre>$ du -h</pre>\n\nЭто показывает вам использование диска в текущем каталоге, вы можете взглянуть на корневой каталог с помощью <b>du -h /</b>, но там может быть немного беспорядка.\n\nОбе эти команды настолько похожи по синтаксису, что иногда трудно запомнить, какую использовать, чтобы проверить, сколько вашего <b>диска</b> <b>свободно</b>, используйте df. Чтобы проверить <b>использование диска</b>, используйте du.",
          "quizAnswer": "df",
          "quizQuestion": "Какая команда используется для отображения количества свободного места на вашем диске?",
          "slug": "diskusage",
          "title": "Использование диска"
        },
        {
          "exercise": "Посмотрите страницу руководства для fsck, чтобы узнать, что еще он может делать.",
          "id": 10,
          "lessonContent": "Иногда наша файловая система не находится в лучшем состоянии, если происходит внезапное отключение, наши данные могут быть повреждены. Это зависит от системы, чтобы попытаться вернуть нас в рабочее состояние (хотя мы, конечно, можем попробовать сами). \n\nКоманда <b>fsck</b> (проверка файловой системы) используется для проверки согласованности файловой системы и даже может попытаться восстановить ее для нас. Обычно при загрузке диска fsck запускается до монтирования вашего диска, чтобы убедиться, что все в порядке. Иногда, однако, ваш диск настолько плох, что вам придется сделать это вручную. Однако убедитесь, что делаете это, находясь на спасательном диске или где-то, где вы можете получить доступ к вашей файловой системе, не монтируя ее.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "Какая команда используется для проверки целостности файловой системы?",
          "slug": "восстановлениесистемыфайлов",
          "title": "Восстановление файловой системы"
        },
        {
          "exercise": "Наблюдайте за некоторыми номерами индексов для разных файлов, какие обычно создаются первыми?",
          "id": 11,
          "lessonContent": "Помните, что наша файловая система состоит из всех наших фактических файлов и базы данных, которая управляет этими файлами? База данных известна как таблица индексных узлов.\n\n<b>Что такое индексный узел?</b>\n\nИндексный узел (inode) - это запись в этой таблице, и для каждого файла есть свой индексный узел. Он описывает все о файле, такие как:\n\n<ul>\n<li>Тип файла - обычный файл, каталог, символьное устройство и т. д.</li>\n<li>Владелец</li>\n<li>Группа</li>\n<li>Права доступа</li>\n<li>Временные метки - mtime (время последнего изменения файла), ctime (время последнего изменения атрибута), atime (время последнего доступа)</li>\n<li>Количество жестких ссылок на файл</li>\n<li>Размер файла</li>\n<li>Количество выделенных блоков для файла</li>\n<li>Указатели на блоки данных файла - самое важное!</li>\n</ul>\n\nПо сути, индексные узлы хранят всю информацию о файле, за исключением имени файла и самого файла!\n\n<b>Когда создаются индексные узлы?</b>\n\nПри создании файловой системы также выделяется место для индексных узлов. Существуют алгоритмы, которые определяют, сколько места для индексных узлов вам нужно в зависимости от объема диска и других параметров. Вероятно, вы когда-то в жизни видели сообщения об ошибке из-за нехватки места на диске. То же самое может произойти и с индексными узлами (хотя реже) - вы можете исчерпать индексы и, следовательно, не сможете создавать больше файлов. Помните, что хранение данных зависит как от данных, так и от базы данных (индексов).\n\nЧтобы узнать, сколько индексов осталось на вашей системе, используйте команду <b>df -i</b>\n\n<b>Информация об индексах</b>\n\nИндексы идентифицируются по номерам, при создании файла ему присваивается номер индекса, номер присваивается последовательно. Однако иногда вы можете заметить, что при создании нового файла ему присваивается номер индекса, который меньше, чем у других, это происходит потому, что удаленные индексы могут быть использованы повторно другими файлами. Для просмотра номеров индексов используйте <b>ls -li</b>:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nПервое поле в этой команде показывает номер индекса.\n\nВы также можете увидеть подробную информацию о файле с помощью команды stat, она также сообщает вам информацию об индексе.\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  File: ‘/home/pete/Desktop/’\n  Size: 6               Blocks: 0          IO Block: 4096   directory\nDevice: 806h/2054d      Inode: 140         Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAccess: 2016-01-20 20:13:50.647435982 -0800\nModify: 2016-01-20 20:13:06.191675843 -0800\nChange: 2016-01-20 20:13:06.191675843 -0800\n Birth: -\n</pre>\n\n\n<b>Как индексы находят файлы?</b>\n\nМы знаем, что наши данные где-то на диске, к сожалению, вероятно, они не были сохранены последовательно, поэтому нам нужно использовать индексы. Индексы указывают на фактические блоки данных ваших файлов. В типичной файловой системе (не все работают одинаково), каждый индекс содержит 15 указателей, первые 12 указателей указывают прямо на блоки данных. 13-й указатель указывает на блок, содержащий указатели на другие блоки, 14-й указатель указывает на другой вложенный блок указателей, а 15-й указатель снова указывает на другой блок указателей! Запутано, я знаю! Это делается для того, чтобы структура индекса оставалась одинаковой для каждого индекса, но при этом можно ссылаться на файлы разного размера. Если у вас небольшой файл, вы можете быстрее найти его с помощью первых 12 прямых указателей, более крупные файлы могут быть найдены с помощью вложенных указателей. В любом случае структура индекса остается такой же.",
          "quizAnswer": "df -i",
          "quizQuestion": "Как узнать, сколько индексов осталось на вашей системе?",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "Поиграйтесь с созданием символических и жёстких ссылок, удалите несколько и посмотрите, что произойдет.",
          "id": 12,
          "lessonContent": "Давайте воспользуемся предыдущим примером информации об инодах: \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nВозможно, вы заметили, что мы пропускали третье поле в команде ls, это поле - количество ссылок. Количество ссылок - это общее количество жёстких ссылок на файл, что сейчас для вас ничего не значит. Поэтому давайте сначала обсудим ссылки. \n\n<b>Символические ссылки</b>\n\nВ операционной системе Windows существуют ярлыки, которые являются псевдонимами для других файлов. Если вы что-то делаете с оригинальным файлом, вы потенциально можете нарушить ярлык. В Linux аналогом ярлыков являются символические ссылки (или мягкие ссылки или симлинки). Симлинки позволяют нам ссылаться на другой файл по его имени файла. Еще один тип ссылок, найденных в Linux, - это жёсткие ссылки, которые на самом деле являются другим файлом с ссылкой на инод. Давайте посмотрим, что я имею в виду на практике, начиная с символических ссылок.\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n</pre>\n\nВы видите, что я создал символическую ссылку с именем myfilelink, которая указывает на myfile. Символические ссылки обозначаются ->. Обратите внимание, что у меня появился новый номер инода, симлинки - это просто файлы, которые указывают на имена файлов. Когда вы изменяете символическую ссылку, изменяется и файл. Номера инодов уникальны для файловых систем, вы не можете иметь два одинаковых номера инода в одной файловой системе, что означает, что вы не можете ссылаться на файл в другой файловой системе по его номеру инода. Однако, если вы используете символические ссылки, они не используют номера инодов, они используют имена файлов, поэтому их можно ссылаться на разные файловые системы. \n\n<b>Жёсткие ссылки</b>\n\nДавайте посмотрим пример жёсткой ссылки:\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myhardlink\n</pre>\n\nЖёсткая ссылка просто создает другой файл с ссылкой на тот же инод. Поэтому если я изменил содержимое myfile2 или myhardlink, изменения будут видны в обоих, но если я удалю myfile2, файл по-прежнему будет доступен через myhardlink. Здесь и вступает в игру количество ссылок в команде ls. Количество ссылок - это количество жёстких ссылок на инод, когда вы удаляете файл, это уменьшит это количество ссылок. Инод удаляется только тогда, когда все жёсткие ссылки на инод удалены. Когда вы создаете файл, его количество ссылок равно 1, потому что это единственный файл, который указывает на этот инод. В отличие от символических ссылок, жёсткие ссылки не распространяются на файловые системы, потому что иноды уникальны для файловой системы. \n\n<b>Создание символической ссылки</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nДля создания символической ссылки используйте команду ln с -s для символической ссылки, указываете целевой файл и затем имя ссылки. \n\n<b>Создание жёсткой ссылки</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nАналогично созданию символической ссылки, за исключением того, что на этот раз вы не указываете -s.",
          "quizAnswer": "ln -s",
          "quizQuestion": "Какая команда используется для создания символической ссылки?",
          "slug": "symlinks",
          "title": "symlinks"
        }
      ],
      "slug": "thefilesystem",
      "title": "Файловая система"
    },
    {
      "description": "Узнайте о этапах процесса загрузки Linux.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Перезагрузите вашу систему и посмотрите, сможете ли вы определить каждый этап во время загрузки вашего устройства.",
          "id": 1,
          "lessonContent": "Теперь, когда мы довольно хорошо разобрались в некоторых важных компонентах Linux, давайте соберем их все вместе, изучив, как система загружается. Когда вы включаете ваше устройство, происходят интересные вещи, такие как отображение экрана с логотипом, прохождение различных сообщений, после чего вы увидите окно входа в систему. На самом деле между моментом нажатия кнопки питания и моментом входа в систему происходит множество действий, и мы обсудим их в этом курсе. \n\nПроцесс загрузки Linux можно разбить на 4 простых этапа: \n\n<b>1. BIOS</b>\n\nBIOS (Basic Input/Output System) инициализирует аппаратное обеспечение и с помощью POST (Power-on self test) проверяет, что все оборудование работает исправно. Основная задача BIOS - загрузить загрузчик.\n\n<b>2. Загрузчик</b>\n\nЗагрузчик загружает ядро в память, а затем запускает его с набором параметров ядра. Один из наиболее распространенных загрузчиков - GRUB, который является универсальным стандартом для Linux. \n\n<b>3. Ядро</b>\n\nКогда ядро загружено, оно сразу инициализирует устройства и память. Основная задача ядра - загрузить процесс init. \n\n<b>4. Init</b>\n\nПомните, что процесс init - это первый процесс, который запускается, init запускает и останавливает важные служебные процессы в системе. Существует три основных реализации init в дистрибутивах Linux. Мы кратко рассмотрим их, а затем более подробно изучим их в другом курсе.\n\nВот (очень) простое объяснение процесса загрузки Linux. Мы подробнее рассмотрим эти этапы в следующих уроках.",
          "quizAnswer": "init",
          "quizQuestion": "Какой последний этап в процессе загрузки Linux?",
          "slug": "bootprocessoverview",
          "title": "Обзор процесса загрузки"
        },
        {
          "exercise": "Зайдите в меню BIOS и проверьте, включена ли загрузка через UEFI.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nПервый этап процесса загрузки Linux - это BIOS, который выполняет проверку целостности системы. BIOS - это прошивка, которая наиболее распространена в совместимых с IBM PC компьютерах, доминирующем типе компьютеров на сегодняшний день. Вероятно, вы использовали прошивку BIOS для изменения порядка загрузки ваших жестких дисков, проверки системного времени, MAC-адреса вашего устройства и т. д. Основная цель BIOS - найти загрузчик системы.\n\nИтак, когда BIOS загружает жесткий диск, он ищет загрузочный блок, чтобы определить, как загрузить систему. В зависимости от того, как вы разбили свой диск, он будет искать загрузочную запись мастер-загрузчика (MBR) или GPT. MBR находится в первом секторе жесткого диска, первые 512 байт. MBR содержит код для загрузки другой программы где-то на диске, которая, в свою очередь, фактически загружает наш загрузчик.\n\nТеперь, если вы разбили свой диск с использованием GPT, местоположение загрузчика немного изменится.\n\n<b>UEFI</b>\n\nСуществует еще один способ загрузки вашей системы, помимо использования BIOS, и это UEFI (расшифровывается как \"Унифицированный расширяемый интерфейс прошивки\"). UEFI был разработан как преемник BIOS, большинство современного оборудования поставляется с встроенной прошивкой UEFI. Компьютеры Macintosh уже много лет используют загрузку через EFI, а Windows в основном перешли на загрузку через UEFI. Формат GPT предназначен для использования с EFI. Вам не обязательно нужен EFI, если вы загружаете диск GPT. Первый сектор диска GPT зарезервирован для \"защитного MBR\", чтобы можно было загрузить машину на основе BIOS.\n\nUEFI хранит всю информацию о запуске в файле .efi. Этот файл хранится на специальном разделе, называемом разделом системы EFI на оборудовании. Внутри этого раздела он будет содержать загрузчик. UEFI поставляется с множеством улучшений по сравнению с традиционной прошивкой BIOS. Однако, поскольку мы используем Linux, большинство из нас используют BIOS. Поэтому все эти уроки будут продолжаться с этим предположением.",
          "quizAnswer": "загрузчик",
          "quizQuestion": "Что загружает BIOS?",
          "slug": "bootprocessbios",
          "title": "Процесс загрузки: BIOS"
        },
        {
          "exercise": "Если у вас установлен GRUB в качестве загрузчика, зайдите в меню GRUB с помощью 'e' и посмотрите настройки.",
          "id": 3,
          "lessonContent": "Основные обязанности загрузчика:\n\n<ul>\n<li>Загрузка операционной системы, также может использоваться для загрузки не-Linux операционных систем</li>\n<li>Выбор ядра для использования</li>\n<li>Указание параметров ядра</li>\n</ul>\n\nСамым распространенным загрузчиком для Linux является GRUB, скорее всего, вы используете его на своей системе. Есть множество других загрузчиков, которые можно использовать, таких как LILO, efilinux, coreboot, SYSLINUX и другие. Однако мы будем работать только с GRUB в качестве нашего загрузчика. \n\nТаким образом, мы знаем, что основная цель загрузчика - загрузить ядро, но где он находит ядро? Чтобы найти его, нам нужно посмотреть на параметры ядра. Параметры можно найти, зайдя в меню GRUB при запуске, используя клавишу 'e'. Если у вас нет GRUB, не волнуйтесь, мы рассмотрим параметры загрузки, которые вы увидите:\n\n<ul>\n<li>initrd - Указывает местоположение начального RAM-диска (о чем мы поговорим подробнее в следующем уроке).</li>\n<li>BOOT_IMAGE - Здесь находится образ ядра</li>\n<li>root - Местоположение корневой файловой системы, ядро ищет внутри этого местоположения для поиска init. Обычно представлено его UUID или именем устройства, таким как /dev/sda1.</li>\n<li>ro - Этот параметр довольно стандартен, он монтирует файловую систему в режиме только для чтения.</li>\n<li>quiet - Это добавляется, чтобы вы не видели сообщения, которые происходят на заднем плане во время загрузки.</li>\n<li>splash - Это позволяет показывать заставку.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "Какой параметр ядра делает так, чтобы вы не видели сообщений загрузки?",
          "slug": "bootprocessbootloader",
          "title": "Процесс загрузки: Загрузчик"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 4,
          "lessonContent": "Итак, теперь, когда наш загрузчик передал необходимые параметры, давайте посмотрим, как он запускается:\n\n<b>Initrd против Initramfs</b>\n\nЕсть некоторая проблема типа курица-и-яйцо, когда мы говорим о загрузке ядра. Ядро управляет аппаратными средствами нашей системы, однако не все драйверы доступны ядру во время загрузки. Поэтому мы зависим от временной корневой файловой системы, которая содержит только необходимые модули, которые ядру нужны для доступа к остальному оборудованию. В старых версиях Linux эту задачу выполнял initrd (initial ram disk). Ядро монтировало initrd, получал необходимые драйверы для загрузки, а затем, когда загрузило все необходимое, заменяло initrd на фактическую корневую файловую систему. В наши дни у нас есть так называемый initramfs, это временная корневая файловая система, встроенная непосредственно в само ядро для загрузки всех необходимых драйверов для реальной корневой файловой системы, так что больше нет необходимости в поиске файла initrd. \n\n<b>Монтирование корневой файловой системы</b>\n\nТеперь у ядра есть все модули, необходимые для создания устройства корня и монтирования корневого раздела. Прежде чем продолжить, корневой раздел фактически смонтирован сначала в режиме только для чтения, чтобы fsck мог работать безопасно и проверить целостность системы. После этого корневая файловая система повторно монтируется в режиме чтения и записи. Затем ядро находит программу init и запускает ее.",
          "quizAnswer": "initramfs",
          "quizQuestion": "Что используется в современных системах для загрузки временной корневой файловой системы?",
          "slug": "bootprocesskernel",
          "title": "Процесс загрузки: Ядро"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 5,
          "lessonContent": "Мы обсудили init в предыдущих уроках и знаем, что это первый процесс, который запускается, и он запускает все остальные необходимые службы в нашей системе. Но как?\n\nФактически, существует три основных реализации init в Linux: \n\n<b>System V init (sysv)</b>\n\nЭто традиционная система init. Он последовательно запускает и останавливает процессы на основе скриптов запуска. Состояние машины обозначается уровнями запуска, каждый уровень запускает или останавливает машину по-разному. \n\n<b>Upstart</b>\n\nЭто init, который вы найдете в старых установках Ubuntu. Upstart использует идею задач и событий и работает, запуская задачи, которые выполняют определенные действия в ответ на события. \n\n<b>Systemd</b>\n\nЭто новый стандарт для init, он ориентирован на цели. В основном у вас есть цель, которую вы хотите достичь, и systemd пытается удовлетворить зависимости цели, чтобы завершить ее. \n\nУ нас есть целый курс по системам Init, где мы более подробно рассмотрим каждую из этих систем.",
          "quizAnswer": "systemd",
          "quizQuestion": "Какой самый новый стандарт для init?",
          "slug": "bootprocessinit",
          "title": "Процесс загрузки: Init"
        }
      ],
      "slug": "bootthesystem",
      "title": "Загрузка системы"
    },
    {
      "description": "Самая важная часть системы Linux, узнайте, как оно работает и как его настраивать.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "Как вы узнали до этого момента, ядро является основой операционной системы. Мы говорили о других частях операционной системы, но еще не показали, как они все взаимодействуют. Операционная система Linux может быть организована на три разных уровня абстракции.\n\nСамый базовый уровень - это аппаратное обеспечение, к нему относятся наш ЦП, память, жесткие диски, сетевые порты и т. д. Физический уровень, который фактически вычисляет, что делает наша машина.\n\nСледующий уровень - это ядро, которое управляет управлением процессами и памятью, обменом данными с устройствами, системными вызовами, настраивает нашу файловую систему и т. д. Задача ядра - общаться с аппаратным обеспечением, чтобы убедиться, что оно делает то, что мы хотим, чтобы делали наши процессы.\n\nИ уровень, с которым вы знакомы, - это пользовательское пространство, включающее оболочку, программы, которые вы запускаете, графику и т. д.\n\nВ этом курсе мы сосредоточимся на ядре и изучим его тонкости.",
          "quizAnswer": "ядро",
          "quizQuestion": "Какой уровень операционной системы управляет устройствами?",
          "slug": "kerneloverview",
          "title": "Обзор ядра"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 2,
          "lessonContent": "Следующие несколько уроков довольно теоретические, поэтому, если вы ищете что-то практическое, можете пропустить и вернуться позже.\n\nПочему у нас есть различные уровни абстракции для пользовательского пространства и ядра? Почему нельзя объединить обе функции в один уровень? Есть очень веская причина, почему эти два уровня существуют отдельно. Они работают в разных режимах: ядро работает в режиме ядра, а пользовательское пространство - в режиме пользователя.\n\nВ режиме ядра ядро имеет полный доступ к аппаратному обеспечению, контролирует все. В режиме пользовательского пространства есть очень небольшое количество безопасной памяти и ЦП, к которым у вас есть доступ. По сути, когда нам нужно что-то сделать, что включает в себя аппаратное обеспечение, чтение данных с наших дисков, запись данных на наши диски, управление нашей сетью и т. д., все это делается в режиме ядра. Зачем это нужно? Представьте, что ваш компьютер заражен шпионским ПО, вы бы не хотели, чтобы у него был прямой доступ к аппаратуре вашей системы. Он может получить доступ ко всем вашим данным, вашей веб-камере и т. д., и это нехорошо.\n\nЭти различные режимы называются уровнями привилегий (названы соответственно уровням привилегий, которые вы получаете) и часто описываются как кольца защиты. Чтобы лучше представить себе эту картину, давайте скажем, что вы узнали, что Бритни Спирс находится в вашем городе в местном клубе, она защищена своими поклонниками, затем ее личными охранниками, затем швейцаром за пределами клуба. Вы хотите получить ее автограф (почему бы и нет?), но не можете к ней подойти, потому что она находится под крепкой защитой. Кольца работают так же, самое внутреннее кольцо соответствует наивысшему уровню привилегий. Существуют два основных уровня или режима в архитектуре компьютера x86. Кольцо №3 - это привилегия, в которой работают приложения в режиме пользователя, кольцо №0 - это привилегия, в которой работает ядро. Кольцо №0 может выполнять любую системную инструкцию и имеет полное доверие. Теперь, когда мы знаем, как работают эти уровни привилегий, как мы можем записать что-либо в наше аппаратное обеспечение? Разве мы всегда будем находиться в другом режиме, чем ядро?\n\nОтвет - с помощью системных вызовов, они позволяют нам выполнять привилегированную инструкцию в режиме ядра, а затем переключаться обратно в режим пользователя.",
          "quizAnswer": "0",
          "quizQuestion": "Какое кольцо имеет наивысшие привилегии?",
          "slug": "kernelprivilegelevels",
          "title": "Уровни привилегий"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 3,
          "lessonContent": "Помните Бритни из предыдущего урока? Допустим, мы хотим увидеть ее и выпить вместе, как мы можем перейти от стояния снаружи среди толпы людей к нахождению в ее самом близком круге? Мы бы использовали вызовы системы. Вызовы системы похожи на VIP-пропуски, которые позволяют вам попасть к секретной боковой двери, ведущей прямо к Бритни.\n\nВызовы системы (syscall) предоставляют процессам пользовательского пространства способ запросить ядру выполнить что-то для нас. Ядро предоставляет определенные службы через API вызовов системы. Эти службы позволяют нам читать или записывать в файл, изменять использование памяти, изменять нашу сеть и т. д. Количество служб фиксировано, поэтому вы не можете просто добавлять вызовы системы как попало, ваша система уже имеет таблицу существующих вызовов системы, и у каждого вызова системы есть уникальный идентификатор. \n\nЯ не буду вдаваться в детали вызовов системы, так как для этого вам потребуется немного знать C, но основная идея заключается в том, что при вызове программы, например, ls, код внутри этой программы содержит оболочку вызова системы (поэтому это еще не сам вызов системы). Внутри этой оболочки он вызывает вызов системы, который выполняет ловушку, которую затем перехватывает обработчик вызова системы, а затем ссылается на вызов системы в таблице вызовов системы. Допустим, мы пытаемся вызвать вызов системы stat(), он идентифицируется уникальным идентификатором вызова системы, и цель вызова системы stat() - запросить статус файла. Теперь помните, что вы запускали программу ls в непривилегированном режиме. Так что теперь, когда он видит, что вы пытаетесь сделать вызов системы, он переключает вас в режим ядра, где делает много вещей, но самое главное - он ищет ваш номер вызова системы, находит его в таблице на основе идентификатора вызова системы, и затем выполняет функцию, которую вы хотели запустить. После завершения он вернется в режим пользователя, и ваш процесс получит статус возврата, если операция была успешной или если произошла ошибка. Внутренние механизмы вызовов системы становятся очень детальными, я бы порекомендовал посмотреть информацию в Интернете, если вы хотите узнать больше. \n\nВы можете просматривать вызовы системы, которые делает процесс, с помощью команды strace. Команда strace полезна для отладки того, как программа выполняется. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "вызов системы",
          "quizQuestion": "Что используется для перехода из пользовательского режима в режим ядра?",
          "slug": "вызовысистемы",
          "title": "Вызовы системы"
        },
        {
          "exercise": "<ol>\n<li>Узнайте, какая версия ядра у вас установлена.</li>\n<li>Исследуйте различные версии доступных ядер.</li>\n</ol>",
          "id": 4,
          "lessonContent": "Хорошо, теперь, когда мы избавились от всего этого скучного, давайте поговорим о фактической установке и модификации ядер. Вы можете установить несколько ядер на своей системе, помните наш урок о процессе загрузки? В меню GRUB мы можем выбрать, какое ядро загружать. \n\nЧтобы узнать, какая версия ядра у вас установлена в системе, используйте следующую команду:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nКоманда uname выводит информацию о системе, команда -r выведет версию выпуска ядра.\n\nВы можете установить ядро Linux разными способами: загрузить пакет и скомпилировать из исходного кода или установить его с помощью инструментов управления пакетами.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\nи затем просто перезагрузитесь в установленное вами ядро. Просто, верно? Немного сложновато, вам также нужно установить другие пакеты Linux, такие как linux-headers, linux-image-generic и т. д.). Вы также можете указать номер версии, поэтому вышеприведенная команда может выглядеть так: <b>sudo apt install 3.19.0-43-generic</b>\n\nКроме того, если вам нужна обновленная версия ядра, просто используйте dist-upgrade, он выполняет обновления всех пакетов в вашей системе:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nСуществует множество различных версий ядер, некоторые используются как LTS (долгосрочная поддержка), некоторые являются самыми последними и лучшими, совместимость может сильно различаться между версиями ядер, поэтому вам может захотеться попробовать разные ядра.",
          "quizAnswer": "uname -r",
          "quizQuestion": "Как узнать версию ядра вашей системы?",
          "slug": "kernelinstallation",
          "title": "Установка ядра"
        },
        {
          "exercise": "Перейдите в свой каталог /boot и посмотрите, какие файлы находятся там.",
          "id": 5,
          "lessonContent": "Что происходит, когда вы устанавливаете новое ядро? На самом деле оно добавляет несколько файлов в вашу систему, обычно эти файлы добавляются в каталог /boot. \n\nВы увидите несколько файлов для разных версий ядра:\n\n<ul>\n<li>vmlinuz - это фактическое ядро Linux</li>\n<li>initrd - как мы уже обсуждали, initrd используется как временная файловая система перед загрузкой ядра</li>\n<li>System.map - символьная таблица поиска</li>\n<li>config - настройки конфигурации ядра, если вы компилируете собственное ядро, вы можете установить, какие модули могут быть загружены</li>\n</ul>\n\nЕсли вашему каталогу /boot не хватает места, вы всегда можете удалить старые версии этих файлов или просто использовать менеджер пакетов, но будьте осторожны при обслуживании в этом каталоге и не удаляйте случайно используемое вами ядро.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "Как называется образ ядра в каталоге /boot?",
          "slug": "kernellocation",
          "title": "Местоположение ядра"
        },
        {
          "exercise": "Выгрузите свой модуль bluetooth с помощью modprobe и посмотрите, что произойдет. Как вы это исправите?",
          "id": 6,
          "lessonContent": "Предположим, у меня есть классный автомобиль, в который я вложил много времени и денег. Я устанавливаю спойлер, фаркоп, велосипедный багажник и другие случайные вещи. Эти компоненты фактически не изменяют основной функциональности автомобиля, и я могу легко удалять и добавлять их. Ядро использует тот же концепт с ядровыми модулями.\n\nЯдро по сути является монолитным программным обеспечением, когда мы хотим добавить поддержку для нового типа клавиатуры, мы не пишем этот код непосредственно в код ядра. Точно так же, как мы бы не приварили велосипедный багажник к нашему автомобилю (ну, возможно, некоторые люди бы это сделали). Ядровые модули - это куски кода, которые могут быть загружены и выгружены в ядро по требованию. Они позволяют нам расширять функциональность ядра, не добавляя код в основной код ядра. Мы также можем добавлять модули и не перезагружать систему (в большинстве случаев).\n\n<b>Просмотр списка загруженных в данный момент модулей</b>\n\n<pre>$ lsmod</pre>\n\n<b>Загрузка модуля</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe пытается загрузить модуль из <b>/lib/modules/(версия ядра)/kernel/drivers</b>. У ядровых модулей также могут быть зависимости, modprobe загружает зависимости нашего модуля, если они еще не загружены.\n\n<b>Выгрузка модуля</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Загрузка при загрузке системы</b>\n\nВы также можете загружать модули при загрузке системы, вместо временной загрузки их с помощью modprobe (которые будут выгружены при перезагрузке). Просто измените каталог <b>/etc/modprobe.d</b> и добавьте в него файл конфигурации, например так:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\nНемного экстравагантный пример, но если у вас есть модуль с именем peanut_butter и вы хотите добавить параметр ядра для type=almond, вы можете загрузить его при запуске, используя этот файл конфигурации. Также обратите внимание, что у ядровых модулей есть свои собственные параметры ядра, поэтому вам следует прочитать о модуле более подробно, чтобы узнать больше.\n\n<b>Не загружать при загрузке системы</b>\n\nВы также можете убедиться, что модуль не загружается при загрузке системы, добавив файл конфигурации, например так:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "Какая команда используется для выгрузки модуля?",
          "slug": "kernelmodules",
          "title": "Модули ядра"
        }
      ],
      "slug": "kernel",
      "title": "Ядро"
    },
    {
      "description": "Узнайте о различных системах инициализации, SysV, Upstart и systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Если вы используете System V, измените уровень запуска вашей машины на другой и посмотрите, что произойдет.",
          "id": 1,
          "lessonContent": "Основная цель init - запускать и останавливать основные процессы в системе. В Linux существуют три основные реализации init: System V, Upstart и systemd. В этом уроке мы рассмотрим наиболее традиционную версию init - System V init или Sys V (произносится как 'Система Пять'). \n\nЧтобы узнать, используете ли вы реализацию Sys V init, проверьте наличие файла /etc/inittab - если он есть, то скорее всего вы используете Sys V. \n\nSys V запускает и останавливает процессы последовательно, так что, например, если вы хотите запустить службу с именем foo-a, то перед тем, как сможет работать foo-b, вы должны убедиться, что foo-a уже запущен. Sys V делает это с помощью скриптов, которые запускают и останавливают службы для нас. Мы можем написать собственные скрипты или, в большинстве случаев, использовать те, которые уже встроены в операционную систему и используются для загрузки основных служб. \n\nПреимуществом использования этой реализации init является относительная легкость разрешения зависимостей, поскольку вы знаете, что foo-a идет перед foo-b, однако производительность не так хороша, потому что обычно одно действие запускается или останавливается за раз. \n\nПри использовании Sys V состояние машины определяется уровнями запуска, которые устанавливаются от 0 до 6. Эти различные режимы будут различаться в зависимости от дистрибутива, но большинство времени будут выглядеть примерно следующим образом: \n\n<ul>\n<li>0: Выключение</li>\n<li>1: Режим одного пользователя</li>\n<li>2: Многопользовательский режим без сети</li>\n<li>3: Многопользовательский режим с сетью</li>\n<li>4: Не используется</li>\n<li>5: Многопользовательский режим с сетью и графическим интерфейсом</li>\n<li>6: Перезагрузка</li>\n</ul>\n\nПри запуске системы она проверяет, в каком уровне запуска вы находитесь, и выполняет скрипты, находящиеся в этой конфигурации уровня запуска. Скрипты находятся в <b>/etc/rc.d/rc[номер уровня запуска].d/</b> или <b>/etc/init.d</b>. Скрипты, начинающиеся с S (start) или K (kill), будут запускаться при загрузке и остановке соответственно. Числа рядом с этими символами указывают на последовательность их выполнения. \n\nНапример:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nМы видим, что при переключении в уровень запуска 0 или режим выключения наша машина попытается выполнить скрипт для остановки служб обновлений, а затем openvpn. Чтобы узнать, в какой уровень запуска загружается ваша машина, вы можете увидеть уровень запуска по умолчанию в файле /etc/inittab. Вы также можете изменить уровень запуска по умолчанию в этом файле. \n\nСледует отметить, что System V медленно устаревает, возможно, не сегодня и даже не через несколько лет. Однако вы можете увидеть уровни запуска в других реализациях init, это в первую очередь для поддержки тех служб, которые запускаются или останавливаются только с помощью скриптов System V init.",
          "quizAnswer": "0",
          "quizQuestion": "Какой уровень запуска обычно используется для выключения?",
          "slug": "sysvoverview",
          "title": "Обзор System V"
        },
        {
          "exercise": "Управляйте несколькими службами и изменяйте их состояния, что вы замечаете?",
          "id": 2,
          "lessonContent": "Существует множество инструментов командной строки, которые можно использовать для управления службами Sys V. \n\n<b>Список служб</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Запуск службы</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Остановка службы</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Перезапуск службы</b>\n\n<pre>$ sudo service networking restart</pre>\n\nЭти команды не являются специфичными для систем инициализации Sys V, вы также можете использовать эти команды для управления службами Upstart. Поскольку Linux пытается отойти от более традиционных сценариев инициализации Sys V, все еще есть механизмы, которые помогают в этом переходе.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Какая команда остановит службу с именем peanut с помощью Sys V?",
          "slug": "sysvservices",
          "title": "Служба System V"
        },
        {
          "exercise": "Если вы используете Upstart, попробуйте понять конфигурации задач в /etc/init.",
          "id": 3,
          "lessonContent": "Upstart был разработан Canonical, поэтому он был реализацией init в Ubuntu некоторое время, однако в современных установках Ubuntu теперь используется systemd. Upstart был создан для улучшения проблем с Sys V, таких как строгие процессы запуска, блокировка задач и т. д. Модель событий и задач Upstart позволяет ему реагировать на события по мере их возникновения. \n\nЧтобы узнать, используете ли вы Upstart, если у вас есть каталог /usr/share/upstart, это довольно неплохой показатель. \n\nЗадачи - это действия, которые выполняет Upstart, а события - это сообщения, полученные от других процессов для запуска задач. Чтобы увидеть список задач и их конфигурацию:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nВ этих конфигурациях задач будет указана информация о том, как запускать задачи и когда их запускать.\n\nНапример, в файле networking.conf может быть написано что-то простое, например:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nЭто означает, что сеть будет настраиваться при запуске на уровне выполнения 2, 3 или 5 и сеть будет остановлена при запуске на уровне выполнения 0. Существует множество способов написания файла конфигурации, и вы обнаружите это, когда посмотрите на различные доступные конфигурации задач. \n\nПринцип работы Upstart заключается в следующем: \n\n<ol>\n<li>Сначала он загружает конфигурации задач из /etc/init</li>\n<li>Как только происходит событие запуска, он запускает задачи, вызванные этим событием.</li>\n<li>Эти задачи создадут новые события, и затем эти события вызовут еще задачи</li>\n<li>Upstart продолжает делать это, пока не завершит все необходимые задачи</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Какая реализация init используется в Ubuntu?",
          "slug": "upstartoverview",
          "title": "Обзор Upstart"
        },
        {
          "exercise": "Посмотрите список ваших заданий Upstart, затем измените состояние задания одной из команд, которые мы изучили сегодня. Что вы заметите после этого?",
          "id": 4,
          "lessonContent": "Upstart может запускать множество событий и заданий, но, к сожалению, нет простого способа узнать, откуда происходит событие или задание, поэтому вам придется исследовать конфигурации заданий в /etc/init. Большую часть времени вам никогда не понадобится просматривать файлы конфигурации заданий Upstart, но вам захочется более легко управлять некоторыми конкретными заданиями. В системе Upstart можно использовать множество полезных команд. \n\n<b>Просмотр заданий</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nВы увидите список заданий Upstart с различными примененными к ним статусами. В каждой строке имя задания является первым значением, второе поле (перед /) на самом деле является целью задания, третье значение (после /) - текущим статусом. Таким образом, мы видим, что наше задание на выключение в конечном итоге хочет остановиться, но в настоящее время находится в состоянии ожидания. Статус и цели задания будут меняться при запуске или остановке заданий. \n\n<b>Просмотр конкретного задания</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nМы не будем углубляться в детали написания конфигурации задания Upstart, однако мы уже знаем, что задания останавливаются, запускаются и перезапускаются в этих конфигурациях. Эти задания также генерируют события, поэтому они могут запускать другие задания. Мы рассмотрим ручные команды операций Upstart, но если вас это интересует, вам следует более детально изучить файлы .conf.\n\n<b>Ручной запуск задания</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Ручная остановка задания</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Ручной перезапуск задания</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Ручная генерация события</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Как я могу вручную перезапустить задание Upstart с именем peanuts?",
          "slug": "upstartjobs",
          "title": "Работа с заданиями Upstart"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 5,
          "lessonContent": "Systemd медленно становится стандартом для инициализации. Если у вас есть каталог /usr/lib/systemd, скорее всего вы используете systemd.\n\nSystemd использует цели для запуска вашей системы. В основном у вас есть цель, которую вы хотите достичь, и у этой цели также есть зависимости, которые нам нужно достичь. Systemd чрезвычайно гибок и надежен, он не следует строгой последовательности для запуска процессов. Вот что происходит во время типичной загрузки systemd:\n\n<ol>\n<li>Сначала systemd загружает свои файлы конфигурации, обычно расположенные в /etc/systemd/system или /usr/lib/systemd/system</li>\n<li>Затем он определяет свою цель загрузки, которая обычно является default.target</li>\n<li>Systemd определяет зависимости цели загрузки и активирует их</l>\n</ol>\n\nАналогично уровням запуска Sys V, systemd загружается в различные цели:\n\n<ul>\n<li>poweroff.target - выключение системы</li>\n<li>rescue.target - однопользовательский режим</li>\n<li>multi-user.target - многопользовательский режим с сетью</li>\n<li>graphical.target - многопользовательский режим с сетью и графическим интерфейсом</li>\n<li>reboot.target - перезагрузка</li>\n</ul>\n\nЦель загрузки по умолчанию default.target обычно указывает на graphical.target. \n\nОсновными объектами, с которыми работает systemd, являются известные как юниты. Systemd не просто останавливает и запускает службы, он может монтировать файловые системы, отслеживать сетевые сокеты и т. д., и из-за этой надежности у него есть различные типы юнитов, с которыми он работает. Самые распространенные юниты:\n\n<ul>\n<li>Service units - это службы, которые мы запускаем и останавливаем, файлы этих юнитов заканчиваются на .service</li>\n<li>Mount units - Эти монтируют файловые системы, файлы этих юнитов заканчиваются на .mount</li>\n<li>Target units - Эти группируют другие юниты, файлы заканчиваются на .target</li>\n</ul>\n\nНапример, предположим, что мы загружаемся в наш default.target, так вот, эта цель группирует вместе юниты networking.service, crond.service и т. д., поэтому после активации одного юнита активируется все, что находится ниже этого юнита.",
          "quizAnswer": "target",
          "quizQuestion": "Какой юнит используется для группировки других юнитов?",
          "slug": "systemdoverview",
          "title": "Обзор Systemd"
        },
        {
          "exercise": "Просмотрите статусы юнитов и запустите и остановите несколько служб. Что вы заметили?",
          "id": 6,
          "lessonContent": "Мы не будем вдаваться в детали написания файлов юнитов systemd. Однако мы рассмотрим краткий обзор файла юнита и способы ручного управления юнитами. \n\nВот базовый файл юнита службы: foobar.service\n\n<pre>\n[Unit]\nDescription=My Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nЭто простая целевая служба, в начале файла мы видим раздел [Unit], который позволяет нам дать нашему файлу юнита описание, а также контролировать порядок активации юнита. Следующая часть - раздел [Service], здесь мы можем запускать, останавливать или перезагружать службу. Раздел [Install] используется для зависимостей. Это только верхушка айсберга при написании файлов systemd, поэтому я настоятельно рекомендую вам изучить эту тему, если хотите узнать больше. \n\nТеперь давайте рассмотрим некоторые команды, которые можно использовать с юнитами systemd: \n\n<b>Список юнитов</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Просмотр статуса юнита</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Запуск службы</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Остановка службы</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Перезапуск службы</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Включение юнита</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Отключение юнита</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nОпять же, вы еще не видели всей глубины systemd, поэтому изучите эту тему, если хотите узнать больше.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "Какая команда для запуска службы с именем peanut.service?",
          "slug": "systemdgoals",
          "title": "Цели systemd"
        },
        {
          "exercise": "Что, по вашему мнению, происходит с init при выключении вашего компьютера?",
          "id": 7,
          "lessonContent": "Трудно поверить, что мы фактически не обсуждали способы управления состоянием вашей системы через командную строку, но когда речь идет о init, мы говорим не только о режимах, которые позволяют нам запускать нашу систему, но и о тех, которые останавливают нашу систему.\n\nЧтобы выключить вашу систему:\n\n<pre>$ sudo shutdown -h now</pre>\n\nЭто остановит систему (выключит ее), вы также должны указать время, когда вы хотите, чтобы это произошло. Вы можете добавить время в минутах, которое выключит систему через указанное количество времени.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nЭто выключит вашу систему через две минуты. Вы также можете перезагрузить систему с помощью команды shutdown: \n\n<pre>$ sudo shutdown -r now</pre>\n\nИли просто используйте команду reboot:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "Какая команда позволяет выключить вашу систему через 4 минуты?",
          "slug": "powerstates",
          "title": "Состояния питания"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Изучите мониторинг ресурсов с помощью top, средних нагрузок, iostat и многого другого!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Поиграйтесь с командой top и посмотрите, какие процессы используют больше всего ресурсов.",
          "id": 1,
          "lessonContent": "В этом курсе мы рассмотрим, как читать и анализировать использование ресурсов на вашей системе, эта урок показывает некоторые отличные инструменты, которые можно использовать, когда вам нужно отследить, что делает процесс. \n\n<b>top</b>\n\nМы уже обсуждали top ранее, но сейчас мы углубимся в детали того, что он фактически отображает. Помните, что top - это инструмент, который мы использовали для получения реального времени использования системы нашими процессами:\n\n<pre>\ntop - 18:06:26 up 6 days,  4:07,  2 users,  load average: 0.92, 0.62, 0.59\nTasks: 389 total,   1 running, 387 sleeping,   0 stopped,   1 zombie\n%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  32870888 total, 27467976 used,  5402912 free,   518808 buffers\nKiB Swap: 33480700 total,    39892 used, 33440808 free. 19454152 cached Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nДавайте разберем, что означает этот вывод, вам не нужно запоминать это, но вернитесь к этому, когда вам понадобится справка.\n\n<b>1-я строка: Это та же информация, которую вы увидели бы, если бы выполнили команду uptime (больше информации будет далее)</b>\n\nПоля идут слева направо:\n<ol>\n<li>Текущее время</li>\n<li>Как долго система работает</li>\n<li>Сколько пользователей в настоящее время вошло в систему</li>\n<li>Средняя загрузка системы (больше информации будет далее)</li>\n</ol>\n\n<b>2-я строка: Задачи, которые выполняются, спят, остановлены и зомбированы</b>\n\n<b>3-я строка: Информация о процессоре</b>\n\n<ol>\n<li>us: время использования процессора - процент времени процессора, затраченного на выполнение процессов пользователей, которые не являются nice</li>\n<li>sy: время использования системы процессора - процент времени процессора, затраченного на выполнение ядра и процессов ядра</li>\n<li>ni: время использования процессора nice - процент времени процессора, затраченного на выполнение процессов nice</li>\n<li>id: простой процессора - процент времени процессора, затраченного на простой</li>\n<li>wa: ожидание ввода-вывода - процент времени процессора, затраченного на ожидание ввода-вывода. Если это значение низкое, проблема, вероятно, не ввод-вывод диска или сети</li> \n<li>hi: аппаратные прерывания - процент времени процессора, затраченного на обслуживание аппаратных прерываний</li>\n<li>si: программные прерывания - процент времени процессора, затраченного на обслуживание программных прерываний</li>\n<li>st: время украденного процессора - если вы запускаете виртуальные машины, это процент времени процессора, который был украден у вас для других задач</li>\n</ol>\n\n<b>4-я и 5-я строка: Использование памяти и использование подкачки</b>\n\n<b>Список процессов, которые в настоящее время используются</b>\n\n<ol>\n<li>PID: Идентификатор процесса</li>\n<li>USER: пользователь, владелец процесса</li>\n<li>PR: Приоритет процесса</li>\n<li>NI: Значение nice</li>\n<li>VIRT: Виртуальная память, используемая процессом</li>\n<li>RES: Физическая память, используемая процессом</li>\n<li>SHR: Общая память процесса</li>\n<li>S: Указывает статус процесса: S=спящий, R=работающий, Z=зомби, D=непрерываемый, T=остановленный</li>\n<li>%CPU - это процент использования ЦП этим процессом</li>\n<li>%MEM - процент использования ОЗУ этим процессом</li>\n<li>TIME+ - общее время активности этого процесса</li>\n<li>COMMAND - имя процесса</li>\n</ol>\n\nВы также можете указать идентификатор процесса, если вы хотите отслеживать определенные процессы:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "Какая команда отображает ту же информацию, что и первая строка в top?",
          "slug": "trackingprocessestop",
          "title": "Отслеживание процессов: top"
        },
        {
          "exercise": "Прочтите страницы руководства для lsof и fuser, там содержится много информации, которую мы не рассмотрели, что позволит вам иметь большую гибкость при использовании этих инструментов.",
          "id": 2,
          "lessonContent": "Предположим, вы подключили USB-накопитель и начали работать с некоторыми файлами, после завершения работы вы отключаете USB-устройство и получаете ошибку \"Устройство или ресурс занято\". Как узнать, какие файлы на USB-накопителе все еще используются? На самом деле есть два инструмента, которые вы можете использовать для этого: \n\n<b>lsof</b>\n\nПомните, что файлы - это не только текстовые файлы, изображения и т. д., это все на системе, диски, каналы, сетевые сокеты, устройства и т. д. Чтобы увидеть, что используется процессом, вы можете использовать команду lsof (сокращение от \"list open files\"), это покажет вам список всех открытых файлов и их ассоциированный процесс. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nТеперь я могу увидеть, какие процессы в данный момент удерживают устройство/файл открытым. В нашем примере с USB вы также можете завершить эти процессы, чтобы отключить этот надоедливый накопитель.\n\n<b>fuser</b>\n\nДругой способ отслеживания процесса - использовать команду fuser (сокращение от \"file user\"), это покажет вам информацию о процессе, который использует файл или пользователя файла. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nМы можем увидеть, какие процессы в данный момент используют наш каталог /home/pete. Инструменты lsof и fuser очень похожи, ознакомьтесь с ними и попробуйте использовать их, когда вам нужно отследить файл или процесс.",
          "quizAnswer": "lsof",
          "quizQuestion": "Какая команда используется для отображения открытых файлов и информации о процессе?",
          "slug": "отслеживаниепроцессовlsoffuser",
          "title": "lsof и fuser"
        },
        {
          "exercise": "Запустите команду <b>ps m</b> и посмотрите, какие процессы у вас запущены многопоточными.",
          "id": 3,
          "lessonContent": "Возможно, вы слышали термины однопоточные и многопоточные процессы. Потоки очень похожи на процессы, поскольку они используются для выполнения одной и той же программы, и их часто называют легковесными процессами. Если у процесса есть один поток, то он однопоточный, а если у процесса более одного потока, то он многопоточный. Тем не менее, у всех процессов есть как минимум один поток. \n\nПроцессы работают с собственными изолированными ресурсами системы, однако потоки могут легко делить эти ресурсы между собой, что упрощает коммуникацию между ними, и иногда более эффективно иметь многопоточное приложение, чем многопроцессное приложение.\n\nВ общем, предположим, что вы открыли LibreOffice Writer и Chrome, каждый из них - свой собственный процесс. Теперь вы заходите в Writer и начинаете редактировать текст, когда вы редактируете текст, он автоматически сохраняется. Эти два параллельных \"легковесных процесса\" сохранения и редактирования являются потоками. \n\nЧтобы просмотреть потоки процесса, вы можете использовать: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nПроцессы обозначаются каждым PID, и под процессами находятся их потоки (обозначенные --). Таким образом, вы можете видеть, что вышеуказанные процессы оба однопоточные.",
          "quizAnswer": "Истина",
          "quizQuestion": "Истина или ложь, все процессы начинаются однопоточными.",
          "slug": "processthreads",
          "title": "Потоки процесса"
        },
        {
          "exercise": "Проверьте среднюю нагрузку вашей системы и посмотрите, что происходит.",
          "id": 4,
          "lessonContent": "Давайте рассмотрим полезную команду, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 up 1 day,  5:59,  2 users,  load average: 0.00, 0.02, 0.05\n</pre>\n\nМы говорили о времени работы системы в первом уроке этого курса, но мы не обсуждали поле load average. Средние нагрузки - это хороший способ увидеть нагрузку ЦП на вашей системе. Эти числа представляют среднюю нагрузку ЦП за интервалы 1, 5 и 15 минут. Что я имею в виду под нагрузкой ЦП, нагрузка ЦП - это среднее количество процессов, ожидающих выполнения ЦП.\n\nПредставьте, что у вас одноядерный ЦП, думайте об этом ядре как о однополосной дороге. Если на фривее час пик, эта полоса будет очень занята, и трафик будет на 100% или нагрузка 1. Теперь трафик стал настолько плохим, что он заторяет фривей и делает обычные дороги занятыми вдвое большим количеством машин, мы можем сказать, что ваша нагрузка 200% или нагрузка 2. Теперь предположим, что немного разгрузится, и на полосе фривея останется только половина машин, мы можем сказать, что нагрузка полосы составляет 0,5. Когда трафика нет, и мы можем быстро добраться домой, нагрузка должна быть очень низкой, как в 2 часа ночи. Машины в этом случае - это процессы, и эти процессы просто ждут, чтобы съехать с фривея и добраться домой.\n\nПросто потому, что у вас средняя нагрузка 1, не означает, что ваш компьютер тащится. Большинство современных машин сегодня имеют несколько ядер. Если у вас процессор с четырьмя ядрами (4 ядра) и ваша средняя нагрузка 1, это действительно влияет только на 25% вашего ЦП. Представьте каждое ядро как полосу на дороге. Вы можете узнать количество ядер на вашей системе с помощью <b>cat /proc/cpuinfo</b>.\n\nПри наблюдении за средней нагрузкой, вы должны учитывать количество ядер, если вы обнаружите, что ваша машина всегда использует выше средней нагрузки, что-то может быть не так.",
          "quizAnswer": "uptime",
          "quizQuestion": "Какую команду можно использовать, чтобы увидеть среднюю нагрузку?",
          "slug": "cpumonitoring",
          "title": "Мониторинг ЦП"
        },
        {
          "exercise": "Используйте iostat для просмотра использования диска.",
          "id": 5,
          "lessonContent": "Мы также можем отслеживать использование ЦП и использование диска с помощью удобного инструмента, известного как <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nПервая часть - информация о ЦП:\n\n<ul>\n<li>%user - Показывает процент использования ЦП при выполнении на уровне пользователя (приложение)</li>\n<li>%nice - Показывает процент использования ЦП при выполнении на уровне пользователя с приоритетом nice.</li>\n<li>%system - Показывает процент использования ЦП при выполнении на уровне системы (ядра).</li>\n<li>%iowait - Показывает процент времени, в течение которого ЦП или ЦП были бездействующими во время ожидания системы запроса ввода-вывода с диска.</li>\n<li>%steal - Показывает процент времени, проведенного в невольном ожидании виртуальным ЦП или ЦП, пока гипервизор обслуживал другой виртуальный процессор.</li>\n<li>%idle - Показывает процент времени, в течение которого ЦП или ЦП были бездействующими и система не имела ожидающего запроса ввода-вывода с диска.</li>\n</ul>\n\nВторая часть - использование диска:\n\n<ul>\n<li>tps - Указывает количество передач в секунду, которые были отправлены на устройство. Передача - это запрос ввода-вывода на устройство. Несколько логических запросов могут быть объединены в один запрос ввода-вывода на устройство. Размер передачи неопределен.</li>\n<li>kB_read/s - Указывает количество данных, прочитанных с устройства, выраженное в килобайтах в секунду.</li>\n<li>kB_wrtn/s - Указывает количество данных, записанных на устройство, выраженное в килобайтах в секунду.</li>\n<li>kB_read - Общее количество килобайт, прочитанных.</li>\n<li>kB_wrtn - Общее количество килобайт, записанных.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "Какую команду можно использовать для просмотра использования ввода-вывода и ЦП?",
          "slug": "iomonitoring",
          "title": "Мониторинг ввода-вывода (I/O Monitoring)"
        },
        {
          "exercise": "Посмотрите на использование памяти с помощью vmstat.",
          "id": 6,
          "lessonContent": "Помимо мониторинга ЦП и мониторинга ввода-вывода, вы можете отслеживать использование памяти с помощью <b>vmstat</b>\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nПоля имеют следующие значения:\n\n<b>procs</b>\n<ul>\n<li>r - Количество процессов для выполнения</li>\n<li>b - Количество процессов в невытесняемом сне</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - Количество использованной виртуальной памяти</li>\n<li>free - Количество свободной памяти</li>\n<li>buff - Количество памяти, используемой в качестве буферов</li>\n<li>cache - Количество памяти, используемой в качестве кэша</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Количество памяти, подкачанной с диска</li>\n<li>so - Количество памяти, подкачанной на диск</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Количество блоков, полученных с блочного устройства</li>\n<li>bo - Количество блоков, отправленных на блочное устройство</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - Количество прерываний в секунду</li>\n<li>cs - Количество переключений контекста в секунду</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Время, проведенное в пользовательском режиме</li>\n<li>sy - Время, проведенное в режиме ядра</li>\n<li>id - Время простоя</li>\n<li>wa - Время ожидания ввода-вывода</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "Какой инструмент используется для просмотра использования памяти?",
          "slug": "memorymonitoring",
          "title": "Мониторинг памяти"
        },
        {
          "exercise": "Установите sar на свою систему и начните собирать и анализировать использование ресурсов вашей системы.",
          "id": 7,
          "lessonContent": "Эти инструменты мониторинга полезны, когда ваш компьютер имеет проблемы, но что делать, если проблемы возникают, когда вы не смотрите. Для таких случаев вам понадобится использовать инструмент непрерывного мониторинга, что-то, что будет собирать, отчитывать и сохранять информацию об активности вашей системы. В этом уроке мы рассмотрим отличный инструмент для использования <b>sar</b>.\n\n<b>Установка sar</b>\nSar - это инструмент, который используется для исторического анализа вашей системы, убедитесь, что он установлен, установив пакет sysstat <b>sudo apt install sysstat</b>.\n\n<b>Настройка сбора данных</b>\nОбычно после установки sysstat ваша система автоматически начнет собирать данные, если этого не произошло, вы можете включить это, изменив поле ENABLED в /etc/default/sysstat.\n\n<b>Использование sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nЭта команда выведет детали с начала дня.\n\n<pre>$ sudo sar -r</pre>\n\nЭто выведет детали использования памяти с начала дня.\n\n<pre>$ sudo sar -P</pre>\n\nЭто выведет детали использования ЦП. \n\nЧтобы увидеть данные за другой день, вы можете перейти в /var/log/sysstat/saXX, где XX - это день, который вы хотите просмотреть. \n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "Какой хороший инструмент использовать для мониторинга ресурсов системы?",
          "slug": "continuousmonitoring",
          "title": "Непрерывный мониторинг"
        },
        {
          "exercise": "Создайте cronjob, который вы хотите запускать в запланированное время.",
          "id": 8,
          "lessonContent": "Хотя мы говорили о использовании ресурсов, я думаю, что это хороший момент упомянуть о замечательном инструменте в Linux, который используется для планирования задач с помощью cron. Есть служба, которая запускает программы для вас в то время, которое вы запланировали. Это действительно полезно, если у вас есть скрипт, который вы хотите запустить один раз в день, чтобы выполнить что-то для вас. \n\nНапример, предположим, что у меня есть скрипт, расположенный в /home/pete/scripts/change_wallpaper. Я использую этот скрипт каждое утро, чтобы изменить изображение, которое я использую для рабочего стола, но каждое утро мне приходится выполнять этот скрипт вручную. Вместо этого я могу создать cron job, который выполнит мой скрипт через cron. Я могу указать время, когда я хочу, чтобы этот cron job запускался и выполнял мой скрипт. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nПоля следуют слева направо:\n<ul>\n<li>Минуты - (0-59)</li>\n<li>Часы - (0-23)</li>\n<li>День месяца - (1-31)</li>\n<li>Месяц - (1-12)</li>\n<li>День недели - (0-7). 0 и 7 обозначают воскресенье</li>\n</ul>\n\nЗвездочка в поле означает совпадение со всеми значениями. Таким образом, в моем примере выше я хочу, чтобы это запускалось каждый день в каждом месяце в 8:30 утра.\n\nЧтобы создать cronjob, просто отредактируйте файл crontab:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "Какая команда используется для редактирования ваших cronjobs?",
          "slug": "cronjobs",
          "title": "Cron Jobs"
        }
      ],
      "slug": "processutilization",
      "title": "Использование процесса"
    },
    {
      "description": "Узнайте о системных журналах и каталоге /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Посмотрите файл /var/log/syslog и посмотрите, что еще происходит на вашем компьютере.",
          "id": 1,
          "lessonContent": "Службы, ядро, демоны и т. д. на вашей системе постоянно что-то делают, эти данные фактически отправляются для сохранения на вашей системе в виде журналов. Это позволяет нам иметь читаемый человеком журнал событий, происходящих на нашей системе. Эти данные обычно хранятся в каталоге /var, каталог /var - это место, где мы храним наши переменные данные, такие как журналы!\n\nКак эти сообщения вообще поступают на вашу систему? Существует служба под названием syslog, которая отправляет эту информацию в системный журнал.\n\nSyslog на самом деле содержит множество компонентов, одним из важных является запущенный демон под названием syslogd (в новых дистрибутивах Linux используется rsyslogd), который ожидает возникновения событий и фильтрует те, о которых он хочет знать, и в зависимости от того, что он должен сделать с этим сообщением, он отправит его в файл, на ваш консоль или ничего с ним не сделает.\n\nМожет показаться, что этот системный журнал - централизованное место для управления журналами, но, к сожалению, это не так. Вы увидите множество приложений, которые пишут свои собственные правила ведения журнала и создают различные файлы журналов, однако в общем формат журналов должен включать временную метку и детали события.\n\nВот пример строки из syslog:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nЗдесь мы видим, что 27 января в 07:41:32 наша служба cron запустила задание cron.weekly. Вы можете просмотреть все события, которые собирает syslog, в файле /var/log/syslog.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "Какой демон управляет журналом на новых системах Linux?",
          "slug": "systemlogging",
          "title": "Системное ведение журнала"
        },
        {
          "exercise": "Посмотрите ваш конфигурационный файл /etc/rsyslog.d и посмотрите, что еще регистрируется через системный регистратор.",
          "id": 2,
          "lessonContent": "Служба syslog управляет и отправляет журналы в системный регистратор. Rsyslog - это расширенная версия syslog, большинство дистрибутивов Linux должны использовать эту новую версию. Вывод всех журналов, собранных службой syslog, можно найти в /var/log/syslog (каждое сообщение, кроме сообщений аутентификации).\n\nЧтобы узнать, какие файлы поддерживает наш системный регистратор, посмотрите конфигурационные файлы в /etc/rsyslog.d:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nЭти правила для файлов журналов обозначаются селектором в левом столбце и действием в правом столбце. Действие указывает, куда отправлять информацию журнала, в файл, консоль и т. д. Помните, что не каждое приложение и служба использует rsyslog для управления своими журналами, поэтому, если вы хотите точно знать, что зарегистрировано, вам придется заглянуть в этот каталог.\n\nДавайте действительно увидим журналирование в действии, вы можете вручную отправить журнал с помощью команды logger:\n\n<pre>\nlogger -s Hello\n</pre>\n\nТеперь посмотрите в свой /var/log/syslog, и вы должны увидеть эту запись в ваших журналах!",
          "quizAnswer": "logger",
          "quizQuestion": "Какую команду можно использовать для ручной регистрации сообщения?",
          "slug": "syslog",
          "title": "Сначала некоторые стандартные файлы журналов. Журнал по установке."
        },
        {
          "exercise": "Посмотрите файлы /var/log/messages и /var/log/syslog и посмотрите, в чем разница.",
          "id": 3,
          "lessonContent": "На вашей системе существует множество файлов журналов, многие из них находятся в каталоге /var/log. Мы не будем рассматривать их все, но обсудим несколько основных. \n\nСуществует два общих файла журналов, которые можно просмотреть, чтобы получить представление о том, что делает ваша система:\n\n<b>/var/log/messages</b>\n\nЭтот журнал содержит все не критические и не отладочные сообщения, включая сообщения, зарегистрированные во время загрузки (dmesg), аутентификацию, cron, демона и т. д. Очень полезно, чтобы понять, как работает ваш компьютер. \n\n<b>/var/log/syslog</b>\n\nЭтот журнал регистрирует все, кроме сообщений аутентификации, он чрезвычайно полезен для отладки ошибок на вашем компьютере. \n\nЭти два журнала должны быть более чем достаточными при устранении проблем с вашей системой. Однако, если вам нужно просмотреть конкретный компонент журнала, также существуют отдельные журналы для этого.",
          "quizAnswer": "syslog",
          "quizQuestion": "Какой файл журнала регистрирует все, кроме сообщений аутентификации?",
          "slug": "generallogging",
          "title": "Общее ведение журнала"
        },
        {
          "exercise": "Посмотрите свои журналы dmesg и kern, какие различия вы замечаете?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nПри загрузке ваша система регистрирует информацию о буфере кольца ядра. Это показывает нам информацию о драйверах оборудования, информацию о ядре и статус во время загрузки и многое другое. Этот файл журнала можно найти в /var/log/dmesg и сбрасывается при каждой загрузке, возможно, сейчас вы не увидите в нем никакой пользы, но если у вас когда-нибудь возникнут проблемы с чем-то во время загрузки или проблемы с оборудованием, dmesg - лучшее место для поиска. Вы также можете просмотреть этот журнал, используя команду dmesg. \n\n<b>/var/log/kern.log</b>\nДругой журнал, который можно использовать для просмотра информации о ядре, - это файл /var/log/kern.log, который регистрирует информацию и события ядра на вашей системе, а также регистрирует вывод dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "Какую команду можно использовать для просмотра сообщений загрузки ядра?",
          "slug": "логирование-ядра",
          "title": "Логирование ядра"
        },
        {
          "exercise": "Выполните несколько неудачных попыток входа, а затем успешный вход, посмотрите на ваш /var/log/auth.log и посмотрите, что произошло.",
          "id": 5,
          "lessonContent": "Журналирование аутентификации может быть очень полезным при решении проблем с входом в систему. \n\n<b>/var/log/auth.log</b>\n\nЗдесь содержатся журналы авторизации системы, такие как вход пользователя и используемый метод аутентификации. \n\nПример сниппета:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "Какой журнал используется для аутентификации пользователя?",
          "slug": "authenticationlogging",
          "title": "Журналирование аутентификации"
        },
        {
          "exercise": "Посмотрите на ваш файл конфигурации logrotate и посмотрите, как он управляет некоторыми из ваших журналов.",
          "id": 6,
          "lessonContent": "Журнальные файлы генерируют много данных и хранят эту информацию на ваших жестких дисках, однако с этим связано много проблем. В основном мы хотим видеть более новые журналы и эффективно управлять своим дисковым пространством. Как мы можем это сделать? Ответ - с помощью logrotate. \n\nУтилита logrotate управляет журналами за нас. У нее есть файл конфигурации, который позволяет нам указать, сколько и какие журналы хранить, как сжимать журналы для экономии места и многое другое. Утилита logrotate обычно запускается из cron один раз в день, а файлы конфигурации можно найти в /etc/logrotate.d. \n\nСуществуют и другие инструменты для вращения журналов, которые можно использовать для управления вашими журналами, но logrotate является наиболее распространенным.",
          "quizAnswer": "logrotate",
          "quizQuestion": "Какая утилита используется для управления журналами?",
          "slug": "управление-журнальными-файлами",
          "title": "Управление журнальными файлами"
        }
      ],
      "slug": "logging",
      "title": "Логирование"
    },
    {
      "description": "Узнайте о совместном использовании сети с помощью rsync, scp, nfs и других инструментов.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Попробуйте скопировать файл с помощью scp с одной машины на другую.",
          "id": 1,
          "lessonContent": "Обычно вы не единственный компьютер в вашей сети, особенно если вы работаете в коммерческой среде. Когда мы хотим передать данные с одной машины на другую, иногда проще подключить USB-накопитель и скопировать их вручную. Но в большинстве случаев, если вы работаете с машинами в одной сети, способ передачи данных - это сетевое совместное использование файлов. \n\nВ этом курсе мы рассмотрим несколько различных методов копирования данных с и на разные машины в вашей сети. Мы обсудим некоторые простые копирования файлов, затем поговорим о монтировании целых каталогов на вашей машине, которые действуют как отдельный диск. \n\nОдним из простых инструментов для совместного использования файлов является команда <b>scp</b>. Команда scp означает безопасное копирование, она работает точно так же, как команда cp, но позволяет вам копировать с одного хоста на другой хост в той же сети. Она работает через ssh, поэтому все ваши действия используют ту же аутентификацию и безопасность, что и ssh. \n\n<b>Чтобы скопировать файл с локального хоста на удаленный хост</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>Чтобы скопировать файл с удаленного хоста на ваш локальный хост</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>Чтобы скопировать каталог с вашего локального хоста на удаленный хост</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "Какую команду можно использовать для безопасного копирования файлов с одного хоста на другой?",
          "slug": "networkfilesharing",
          "title": "Обзор совместного использования файлов"
        },
        {
          "exercise": "Используйте rsync для синхронизации каталога с другим каталогом, убедитесь, что не перезаписываете важный каталог!",
          "id": 2,
          "lessonContent": "Другой инструмент, используемый для копирования данных с разных хостов, - rsync (сокращение от удаленной синхронизации). Rsync очень похож на scp, но у него есть одно важное отличие. Rsync использует специальный алгоритм, который заранее проверяет, есть ли уже данные, которые вы копируете, и будет копировать только различия. Например, предположим, что вы копировали файл, и ваша сеть была прервана, поэтому ваша копия остановилась на полпути. Вместо того чтобы снова копировать все с самого начала, rsync будет копировать только те части, которые не были скопированы.\n\nОн также проверяет целостность файла, который вы копируете, с помощью контрольных сумм. Эти небольшие оптимизации обеспечивают большую гибкость при передаче файлов и делают rsync идеальным для удаленной и локальной синхронизации каталогов, резервного копирования данных, передачи больших данных и многого другого.\n\nНекоторые часто используемые параметры rsync:\n\n<ul>\n<li>v - подробный вывод</li>\n<li>r - рекурсивно в каталоги</li>\n<li>h - читаемый для человека вывод</li>\n<li>z - сжатие для упрощенной передачи, отлично подходит для медленных соединений</li>\n</ul>\n\n<b>Копирование/синхронизация файлов на одном хосте</b>\n\n<pre>$ rsync -zvr /мой/локальный/каталог/один /мой/локальный/каталог/два</pre>\n\n<b>Копирование/синхронизация файлов на локальный хост с удаленного хоста</b>\n\n<pre>$ rsync /локальный/каталог имя_пользователя@удаленныйхост.com:/удаленный/каталог</pre>\n\n<b>Копирование/синхронизация файлов на удаленный хост с локального хоста</b>\n\n<pre>$ rsync имя_пользователя@удаленныйхост.com:/удаленный/каталог /локальный/каталог</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "Какая команда будет полезна для резервного копирования данных?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "Попробуйте настроить SimpleHTTPServer!",
          "id": 3,
          "lessonContent": "Python имеет очень полезный инструмент для обслуживания файлов по протоколу HTTP. Это отлично подходит, если вам просто нужно создать быстрый сетевой ресурс, к которому могут обращаться другие компьютеры в вашей сети. Для этого перейдите в каталог, который вы хотите сделать общедоступным, и выполните следующую команду:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nЭто настраивает базовый веб-сервер, к которому можно получить доступ через адрес локального хоста. Получите IP-адрес машины, на которой вы выполнили эту команду, и затем на другой машине откройте его в браузере по адресу: http://IP_ADDRESS:8000. На своей собственной машине вы можете просмотреть доступные файлы, набрав веб-адрес: http://localhost:8000 в вашем веб-браузере.\n\nВы также можете сделать это с помощью node или, если вы используете Python 3, синтаксис будет немного отличаться.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Какой инструмент можно использовать для создания простого HTTP-сервера с помощью Python?",
          "slug": "simplehttpserver",
          "title": "Простой HTTP-сервер"
        },
        {
          "exercise": "Прочтите страницу справки по NFS, чтобы узнать больше.",
          "id": 4,
          "lessonContent": "Самая стандартная сетевая файловая система для Linux - NFS (Network File System). NFS позволяет серверу делиться каталогами и файлами с одним или несколькими клиентами через сеть. \n\nМы не будем углубляться в детали создания сервера NFS, так как это может быть сложно, однако мы обсудим настройку клиентов NFS.\n\n<b>Настройка клиента NFS</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>Автоматическое монтирование</b>\n\nПредположим, что вы часто используете сервер NFS и хотите, чтобы он был постоянно смонтирован. Обычно вы думаете, что нужно отредактировать файл /etc/fstab, но не всегда удается подключиться к серверу, что может вызвать проблемы при загрузке. Вместо этого вам нужно настроить автоматическое монтирование, чтобы подключаться к серверу NFS по мере необходимости. Это делается с помощью инструмента <b>automount</b> или в последних версиях Linux - <b>amd</b>. Когда файл обращается в указанный каталог, automount будет искать удаленный сервер и автоматически монтировать его.",
          "quizAnswer": "automount",
          "quizQuestion": "Какой инструмент используется для автоматического управления точками монтирования?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Настройте общий ресурс Samba, если у вас его нет, откройте smb.conf и ознакомьтесь с параметрами в файле конфигурации.",
          "id": 5,
          "lessonContent": "В ранние дни вычислительной техники стало необходимо, чтобы машины Windows могли обмениваться файлами с машинами Linux, и вот появился протокол Server Message Block (SMB). SMB использовался для обмена файлами между операционными системами Windows (Mac также имеет обмен файлами с помощью SMB), а затем он был очищен и оптимизирован в виде протокола Common Internet File System (CIFS).\n\nSamba - это то, что мы называем утилитами Linux для работы с CIFS на Linux. Помимо обмена файлами, вы также можете делиться ресурсами, такими как принтеры.\n\n<b>Создание сетевого общего ресурса с помощью Samba</b>\n\nДавайте рассмотрим основные шаги для создания сетевого общего ресурса, к которому может получить доступ машина с Windows:\n\n<b>Установка Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Настройка smb.conf</b>\n\nФайл настройки для Samba находится в /etc/samba/smb.conf, этот файл должен указать системе, какие каталоги должны быть общими, их права доступа и другие параметры. В файле smb.conf по умолчанию уже есть много закомментированного кода, который можно использовать в качестве примера для написания собственных конфигураций.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Настройка пароля для Samba</b>\n\n<pre>$ sudo smbpasswd -a [имя_пользователя]</pre>\n\n<b>Создание общего каталога</b>\n\n<pre>$ mkdir /мой/каталог/для/обмена</pre>\n\n<b>Перезапуск службы Samba</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Доступ к общему ресурсу Samba через Windows</b>\n\nВ Windows просто введите сетевое подключение в строке выполнения: \\\\ХОСТ\\имя_общего_ресурса.\n\n<b>Доступ к общему ресурсу Samba/Windows через Linux</b>\n\n<pre>$ smbclient //ХОСТ/каталог -U пользователь</pre>\n\nПакет Samba включает в себя инструмент командной строки под названием <b>smbclient</b>, который можно использовать для доступа к любому серверу Windows или Samba. После подключения к общему ресурсу вы можете перемещаться и передавать файлы.\n\n<b>Подключение общего ресурса Samba к вашей системе</b>\n\nВместо передачи файлов по одному, вы можете просто примонтировать сетевой общий ресурс на своей системе.\n\n<pre>$ sudo mount -t cifs имя_сервера:каталог точка_монтирования -o пользователь=имя_пользователя,пароль=пароль</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Какой последний протокол используется для передачи файлов между Windows и Linux?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Совместное использование сети"
    },
    {
      "description": "Узнайте о основах сетей и модели TCP/IP.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "Урок без упражнений.",
          "id": 1,
          "lessonContent": "Давайте рассмотрим типичную домашнюю сеть, у вас есть несколько различных компонентов. \n\n<ul>\n<li>ISP - Ваш интернет-провайдер, компания, которой вы платите за интернет у себя дома.</li>\n<li>Маршрутизатор - Маршрутизатор позволяет каждой машине в вашей сети подключаться к интернету. В большинстве современных маршрутизаторов можно подключаться через беспроводное соединение или кабель Ethernet.</li>\n<li>WAN - Широкая область сети, это то, что мы называем сетью, которая охватывает все между вашим маршрутизатором и более широкой сетью, такой как Интернет.</li>\n<li>WLAN - Беспроводная локальная сеть, это сеть между вашим маршрутизатором и любыми беспроводными устройствами, такими как ноутбуки.</li>\n<li>LAN - Локальная сеть, это сеть между вашим маршрутизатором и любыми проводными устройствами, такими как настольные ПК.</li>\n<li>Хосты - Каждая машина в сети известна как хост.</li>\n</ul>\n\nДанные и информация, которые передаются по сетям, известны как пакеты, и к концу раздела Networking Nomad вы поймете подробности о том, как пакеты передаются к хостам и от них.",
          "quizAnswer": "LAN",
          "quizQuestion": "Как называется локальная сеть?",
          "slug": "networkbasics",
          "title": "Основы сетей"
        },
        {
          "exercise": "Узнайте больше о модели OSI: <a href=\"https://ru.wikipedia.org/wiki/Модель_OSI\">https://ru.wikipedia.org/wiki/Модель_OSI</a>",
          "id": 2,
          "lessonContent": "Прежде чем мы сможем рассмотреть некоторые практические сетевые вещи, нам нужно изучить некоторый скучный жаргон, который вы, вероятно, уже слышали раньше. Модель OSI (Open Systems Interconnection) - это теоретическая модель сетей. Эта модель показывает нам, как пакет проходит через сеть в семи различных слоях. Я не буду вдаваться в детали этой модели, поскольку большинство курсов по сетевым технологиям будут сосредоточены на модели TCP/IP, но стоит упомянуть, что существует такая теоретическая модель сетевых взаимодействий, которая на самом деле сыграла большую роль в модели сетевого взаимодействия TCP/IP, которую мы используем сегодня.",
          "quizAnswer": "OSI",
          "quizQuestion": "Что используется в качестве теоретической модели сетей?",
          "slug": "osimodel",
          "title": "Модель OSI"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 3,
          "lessonContent": "Модель OSI породила то, что в конечном итоге стало моделью TCP/IP, и именно на этой модели основан Интернет. Это фактическая реализация сетевого взаимодействия. Модель TCP/IP использует набор протоколов TCP/IP, который мы обычно называем просто TCP/IP. Эти протоколы взаимодействуют между собой, чтобы определить, как данные должны быть собраны, адресованы, переданы и маршрутизированы через сеть. Используя модель TCP/IP, мы можем увидеть, как эти протоколы используются для демонстрации пути, по которому пакет проходит через сеть.\n\n<b>Прикладной уровень</b>\n\nВерхний уровень модели TCP/IP. Он определяет, как программы вашего компьютера (например, веб-браузер) взаимодействуют с услугами транспортного уровня для просмотра отправляемых или принимаемых данных.\n\nНа этом уровне используются:\n<ul>\n<li>HTTP (Протокол передачи гипертекста) - используется для веб-страниц в Интернете.</li>\n<li>SMTP (Простой протокол передачи почты) - передача электронной почты</li>\n</ul>\n\n<b>Транспортный уровень</b>\n\nОпределяет, как данные будут передаваться, включая проверку правильных портов, целостность данных и в основном доставку наших пакетов.\n\nНа этом уровне используются:\n<ul>\n<li>TCP (Протокол управления передачей) - надежная доставка данных</li>\n<li>UDP (Протокол пользовательских датаграмм) - ненадежная доставка данных</li>\n</ul>\n\n<b>Сетевой уровень</b>\n\nЭтот уровень определяет, как перемещать пакеты между хостами и через сети.\n\nНа этом уровне используются:\n<ul>\n<li>IP (Протокол интернета) - помогает маршрутизировать пакеты от одной машины к другой.</li>\n<li>ICMP (Протокол управления сообщениями Интернета) - помогает сообщить нам, что происходит, такие как сообщения об ошибках и отладочная информация.</li>\n</ul>\n\n<b>Уровень канала</b>\n\nЭтот уровень определяет, как отправлять данные через физическое оборудование, такое как передача данных через Ethernet, оптоволокно и т. д.\n\nПриведенные выше списки протоколов, используемых каждым уровнем, не исчерпывающи и вы столкнетесь с многими другими протоколами, которые также играют роль.\n\nВ следующих уроках мы рассмотрим каждый из этих уровней и обсудим, как наш пакет проходит через сеть с точки зрения модели TCP/IP (существует много точек зрения на то, как пакет проходит через сети, мы не рассмотрим их все, но будьте в курсе, что они существуют).",
          "quizAnswer": "Прикладной",
          "quizQuestion": "Какой верхний уровень модели TCP/IP?",
          "slug": "tcpipmodel",
          "title": "Модель TCP/IP"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 4,
          "lessonContent": "Прежде чем мы приступим к изучению того, как пакет перемещается по сети, нам необходимо ознакомиться с некоторой терминологией. Когда вы отправляете письмо, вам необходимо знать, кому оно адресовано и откуда оно исходит. Пакеты также требуют этой информации, наши хосты и другие хосты идентифицируются с использованием MAC-адресов (адресов управления доступом к среде) и IP-адресов, для удобства нас, людей, мы используем имена хостов для идентификации хоста.\n\n<b>MAC-адреса</b>\n\nMAC-адрес является уникальным идентификатором, используемым в качестве аппаратного адреса. Этот адрес никогда не изменится. Когда вы хотите получить доступ в Интернет, вашему устройству необходимо иметь устройство под названием сетевая карта. Этот сетевой адаптер имеет свой собственный аппаратный адрес, который используется для идентификации вашего устройства. MAC-адрес для устройства Ethernet выглядит примерно так: 00:C4:B5:45:B2:43. MAC-адреса присваиваются сетевым адаптерам при производстве. У каждого производителя есть уникальный идентификатор организации (OUI), который идентифицирует их как производителя. Этот OUI обозначается первыми 3 байтами MAC-адреса. Например, у Dell есть 00-14-22, поэтому сетевой адаптер от Dell может иметь MAC-адрес, например, такой: 00-14-22-34-B2-C2.\n\n<b>IP-адреса</b>\n\nIP-адрес используется для идентификации устройства в сети, они не зависят от аппаратных средств и могут отличаться по синтаксису в зависимости от того, используете ли вы IPv4 или IPv6 (о чем позже). На данный момент мы предположим, что вы используете IPv4, поэтому типичный IP-адрес будет выглядеть так: 10.24.12.4. IP-адреса используются на программном уровне сетевого взаимодействия. Всякий раз, когда система подключена к Интернету, у нее должен быть IP-адрес. Они также могут изменяться, если меняется ваша сеть, и они уникальны для всего Интернета (это не всегда так, как только мы узнаем о NAT).\n\nПомните, что для перемещения пакетов по сетям требуется как программное, так и аппаратное обеспечение, поэтому у нас есть два идентификатора для каждого, MAC (аппаратный) и IP (программный).\n\n<b>Имена хостов</b>\n\nЕще один способ идентификации ваших устройств - это через имена хостов. Имена хостов берут ваш IP-адрес и позволяют связать этот адрес с понятным для человека именем. Вместо того чтобы запоминать 192.12.41.4, вы можете просто запомнить myhost.com.",
          "quizAnswer": "4",
          "quizQuestion": "Сколько байтов в IPv4-адресе?",
          "slug": "networkaddressing",
          "title": "Сетевое адресование"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 5,
          "lessonContent": "Предположим, я хочу отправить электронное письмо Пэтти. Мы рассмотрим каждый уровень TCP/IP, чтобы увидеть это в действии. \n\nПомните, что для передачи данных по сетям используются пакеты, которые состоят из заголовка и полезной нагрузки. Заголовок содержит информацию о том, куда направляется пакет и откуда он пришел. Полезная нагрузка - это фактические данные, которые передаются. По мере прохождения нашего пакета по сети каждый уровень добавляет немного информации в заголовок пакета. Также имейте в виду, что разные уровни используют разные термины для нашего \"пакета\". На транспортном уровне мы сущность вкладываем наши данные в сегмент, а на канальном уровне мы называем это кадром, но знайте, что термин \"пакет\" может использоваться в отношении одного и того же.\n\nСначала мы начинаем с прикладного уровня. Когда мы отправляем наше письмо через почтовый клиент, прикладной уровень инкапсулирует эти данные. Прикладной уровень общается с транспортным уровнем через указанный порт и через этот порт отправляет свои данные. Мы хотим отправить электронное письмо через протокол прикладного уровня SMTP (простой протокол передачи почты). Данные отправляются через наш транспортный протокол, который открывает соединение с этим портом (порт 25 используется для SMTP), поэтому мы отправляем эти данные через этот порт, и эти данные отправляются на транспортный уровень для инкапсуляции в сегменты.",
          "quizAnswer": "Прикладной",
          "quizQuestion": "Какой уровень используется для представления данных пакета в удобном для пользователя формате?",
          "slug": "applicationlayer",
          "title": "Прикладной уровень"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 6,
          "lessonContent": "Транспортный уровень помогает нам передавать наши данные таким образом, чтобы сети могли их прочитать. Он разбивает наши данные на кусочки, которые будут транспортироваться и собираться в правильном порядке. Эти кусочки известны как сегменты. Сегменты упрощают транспортировку данных по сетям. \n\n<b>Порты</b>\n\nНесмотря на то, что мы знаем, куда отправляем наши данные по IP-адресам, они не достаточно конкретны, чтобы отправить наши данные определенным процессам или службам. Службы, такие как HTTP, используют канал связи через порты. Если мы хотим отправить данные веб-страницы, нам нужно отправить их через порт HTTP (порт 80). Помимо формирования сегментов, транспортный уровень также присоединяет к сегменту исходные и конечные порты, чтобы получатель, получив окончательный пакет, знал, какой порт использовать. \n\n<b>UDP</b>\n\nСуществуют два популярных транспортных протокола: UDP и TCP. Мы кратко обсудим UDP и проведем большую часть времени на TCP, поскольку он наиболее часто используется.\n\nUDP не является надежным методом передачи данных, на самом деле ему не важно, получите ли вы все ваши исходные данные. Это может показаться ужасным, но у него есть свои преимущества, например, для потоковой передачи мультимедиа, нормально, если вы потеряете несколько кадров, зато данные придут немного быстрее. \n\n<b>TCP</b>\n\nTCP обеспечивает надежное соединение, ориентированное на поток данных. TCP использует порты для отправки данных от и к хостам. Приложение открывает соединение с одного порта на своем хосте на другой порт на удаленном хосте. Для установления соединения мы используем рукопожатие TCP. \n\n<ul>\n<li>Клиент (процесс подключения) отправляет серверу сегмент SYN для запроса соединения</li>\n<li>Сервер отправляет клиенту сегмент SYN-ACK для подтверждения запроса клиента на соединение</li>\n<li>Клиент отправляет ACK серверу для подтверждения запроса сервера на соединение</li>\n</ul>\n\nПосле установления этого соединения данные могут обмениваться по TCP-соединению. Данные отправляются различными сегментами и отслеживаются с помощью номеров последовательности TCP, чтобы их можно было упорядочить в правильном порядке при доставке. В нашем примере с электронной почтой транспортный уровень присоединяет конечный порт (25) к исходному порту исходного хоста.",
          "quizAnswer": "TCP",
          "quizQuestion": "Что такое надежный транспортный протокол?",
          "slug": "transportlayer",
          "title": "Транспортный уровень"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 7,
          "lessonContent": "Сетевой уровень определяет маршрутизацию наших пакетов от нашего исходного хоста к хосту назначения. К счастью, в нашем примере наш пакет перемещается только в пределах одной сети, но Интернет состоит из множества сетей. Эти более мелкие сети, из которых состоит Интернет, называются подсетями. Все подсети каким-то образом соединены друг с другом, поэтому мы можем попасть на www.google.com, даже если он находится в своей собственной сети. Я не буду вдаваться в детали, так как у нас есть целый курс, посвященный подсетям, но на данный момент в отношении нашего сетевого уровня знайте, что IP-адреса определяют правила для перемещения по различным подсетям. \n\nНа сетевом уровне он получает сегмент, поступающий из транспортного уровня, и инкапсулирует этот сегмент в IP-пакет, затем прикрепляет IP-адрес исходного хоста и IP-адрес хоста назначения к заголовку пакета. Таким образом, наш пакет содержит информацию о том, куда он идет, и откуда пришел. Теперь он отправляет наш пакет на физический уровень оборудования.",
          "quizAnswer": "подсети",
          "quizQuestion": "Как называются более мелкие сети, из которых состоит Интернет?",
          "slug": "networklayer",
          "title": "Сетевой уровень"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 8,
          "lessonContent": "Внизу модели TCP/IP находится Слой связи. Этот слой является аппаратно-специфическим слоем.\n\nНа уровне связи наш пакет еще раз инкапсулируется во что-то, называемое кадром. Заголовок кадра прикрепляет MAC-адреса источника и назначения наших хостов, контрольные суммы и разделители пакетов, чтобы приемник мог определить, когда заканчивается пакет. \n\nК счастью, мы находимся в одной сети, поэтому наш пакет не должен будет проходить далеко. Сначала на уровне связи прикрепляется мой MAC-адрес источника к заголовку кадра, но ему также нужно знать MAC-адрес Пэтти. Как он это узнает и как я могу его найти, поскольку он не в Интернете? Мы используем ARP!\n\n<b>ARP (Протокол разрешения адресов)</b>\n\nARP находит MAC-адрес, связанный с IP-адресом. ARP используется в пределах одной сети. Если Пэтти не находится в одной сети, мы бы использовали систему маршрутизации для определения следующего маршрутизатора, который получит пакет, и после того, как мы окажемся в одной сети, мы могли бы использовать ARP. \n\nКогда мы находимся в одной сети, системы сначала используют таблицу поиска ARP, которая хранит информацию о том, какие IP-адреса связаны с какими MAC-адресами. Если значения там нет, то используется ARP. Затем система отправит широковещательное сообщение в сеть с использованием протокола ARP, чтобы узнать, какой хост имеет IP-адрес 10.10.1.4. Широковещательное сообщение - это специальное сообщение, которое отправляется всем хостам в сети (удачно названо для отправки широковещания). Любая машина с запрошенным IP-адресом ответит ARP-пакетом, содержащим IP-адрес и MAC-адрес.\n\nТеперь, когда у нас есть все необходимые данные, IP-адрес и MAC-адреса, наш слой связи пересылает этот кадр через нашу сетевую карту, к следующему устройству и находит сеть Пэтти. Этот шаг немного сложнее, чем я только что объяснил, но мы обсудим более подробно в курсе по маршрутизации.\n\nИ вот простой (или не такой уж простой) проход пакета по слоям TCP/IP. Имейте в виду, что пакеты не передаются в одностороннем порядке, как это. Мы даже еще не попали в сеть Пэтти! При прохождении через сети требуется как минимум дважды проходить через модель TCP/IP, прежде чем какие-либо данные будут отправлены или получены. На самом деле, внешний вид этого пакета будет примерно таким: \n\n<b>Прохождение пакета</b>\n\n<ol>\n<li>Пит отправляет Пэтти электронное письмо: эти данные отправляются на транспортный уровень.</li>\n<li>Транспортный уровень инкапсулирует данные в заголовок TCP или UDP для формирования сегмента, сегмент прикрепляет порт назначения и источника TCP или UDP, затем сегмент отправляется на сетевой уровень.</li>\n<li>Сетевой уровень инкапсулирует TCP-сегмент внутри IP-пакета, он прикрепляет исходный и целевой IP-адреса. Затем маршрутизирует пакет на уровень связи.</li>\n<li>Пакет достигает физического оборудования Пита и инкапсулируется в кадр. MAC-адрес источника и назначения добавляются к кадру.</li>\n<li>Пэтти получает этот кадр данных через свой физический уровень и проверяет каждый кадр на целостность данных, затем деинкапсулирует содержимое кадра и отправляет IP-пакет на сетевой уровень.</li>\n<li>Сетевой уровень читает пакет, чтобы найти прикрепленные ранее исходный и целевой IP-адреса. Он проверяет, совпадает ли его IP с целевым IP, что так и есть! Он деинкапсулирует пакет и отправляет сегмент на транспортный уровень.</li>\n<li>Транспортный уровень деинкапсулирует сегменты, проверяет номера портов TCP или UDP и устанавливает соединение с уровнем приложения на основе этих портов.</li>\n<li>Уровень приложения получает данные от транспортного уровня на указанном порту и представляет их Пэтти в виде окончательного электронного письма</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Что используется для нахождения MAC-адреса в одной сети?",
          "slug": "linklayer",
          "title": "Слой связи"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 9,
          "lessonContent": "Важное сетевое понятие, которое мы еще не рассматривали, - это DHCP (Протокол динамической конфигурации хоста)\n\nDHCP назначает IP-адреса, маски подсети и шлюзы для наших машин. Например, предположим, у вас есть мобильный телефон, и вы хотите получить номер телефона, чтобы начать разговаривать с людьми. Вам нужно позвонить своему оператору сотовой связи, и они предоставят вам номер. Пока вы платите счета, вы можете продолжать пользоваться своим телефоном. DHCP является оператором сотовой связи в этом случае, он дает вам IP-адрес, чтобы вы могли общаться с другими IP-адресами. Вам также предоставляется IP-адрес в аренду, который действует определенное время, затем будет продлен в зависимости от настроек аренды. \n\nDHCP отлично подходит по многим причинам, это позволяет сетевому администратору не беспокоиться о назначении IP-адресов, а также предотвращает установку дублирующих IP-адресов. В каждой физической сети должен быть свой DHCP-сервер, чтобы хост мог запросить IP-адрес. В обычной домашней среде маршрутизатор обычно выступает в качестве DHCP-сервера.\n\nСпособ, которым DHCP получает всю вашу динамическую информацию хоста, следующий:\n\n<ol>\n<li>DHCP DISCOVER - Это сообщение транслируется для поиска DHCP-сервера.</li>\n<li>DHCP OFFER - DHCP-сервер в сети отвечает предложением. Предложение содержит пакет с временем аренды DHCP, маской подсети, IP-адресом и т. д.</li>\n<li>DHCP REQUEST - Клиент отправляет еще одно транслируемое сообщение, чтобы все DHCP-серверы узнали, какое предложение он принял.</li>\n<li>DHCP ACK - Подтверждение отправляется сервером.</li>\n</ol>\n\nDHCP становится более сложным, чем просто это, но вот его суть.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "Каковы шаги в запросе DHCP?",
          "slug": "dhcpoverview",
          "title": "Обзор DHCP"
        }
      ],
      "slug": "networkbasics",
      "title": "Основы сетей"
    },
    {
      "description": "Узнайте о подсетях и как выполнять арифметику подсетей!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Найдите свой IP-адрес с помощью ifconfig.",
          "id": 1,
          "lessonContent": "Каждый сетевой хост имеет уникальный адрес, и каждый уникальный адрес можно использовать для определения местоположения хоста в сети. Эти уникальные адреса известны как 'IP-адреса'. IPv4-адрес выглядит примерно так:\n\n<pre>204.23.124.23</pre>\n\nЭтот адрес фактически содержит две части: сетевую часть (которая идентифицирует сеть, в которой он находится) и хост-часть (которая идентифицирует хост). В этом курсе мы в основном будем говорить об IPv4-адресах, которые вы обычно увидите, когда будете обращаться к 'IP-адресам'.\n\nIP-адрес разделяется на октеты точками. В IPv4-адресе 4 октета. Если вы знаете немного информатики, то знаете, что октет состоит из 8 бит, и что 8 бит фактически равны 1 байту. Это означает, что в IPv4-адресе 4 байта. Мы часто используем биты при работе с подсетями и IP-адресами.\n\nВы можете просмотреть свой IP-адрес с помощью команды 'ifconfig -a':\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nКак видите, мой IPv4-адрес: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "Сколько байтов в IPv4-адресе?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Используйте ifconfig для просмотра вашей маски подсети.",
          "id": 2,
          "lessonContent": "Как я могу определить, находлюсь ли я в одной сети с Пэтти? Ну, мы можем просто посмотреть на подсеть, сокращенно от подсетевая сеть. Подсеть - это группа хостов с IP-адресами, которые похожи определенным образом. Эти хосты обычно находятся близко друг к другу, и вы легко можете отправлять данные к хостам в одной подсети и от них. Подумайте о ней как о отправке почты в один и тот же почтовый индекс, это намного проще, чем отправлять почту в другой штат. \n\nНапример, все хосты с IP-адресом, начинающимся с 123.45.67, будут находиться в одной подсети. Мой хост имеет IP-адрес 123.45.67.8, а у Пэтти - 123.45.67.9. Общие цифры - это мой префикс сети, а 8 и 9 - наши хосты, поэтому моя сеть такая же, как у Пэтти. Подсеть делится на префикс сети, такой как 123.45.67.0, и маску подсети.\n\n<b>Маски подсети</b>\n\nМаски подсети определяют, какая часть вашего IP-адреса является сетевой частью, а какая - хостовой. \n\nТипичная маска подсети может выглядеть примерно так:\n\n<pre>255.255.255.0</pre>\n\nЧасть 255 на самом деле является нашей маской. Чтобы сделать это немного понятнее, помните, как мы называем каждый октет 8 битами? В компьютерной науке бит обозначается 0 или 1 в двоичной форме. Когда используются двоичные числа, 1 означает включено, а 0 - выключено. Итак, что означает 8 нулей или единиц?\n\nВбейте в Google \"калькулятор двоичного в десятичный формат\" и преобразуйте 11111111 в десятичную форму. Что у вас получится? 255! Таким образом, октет находится в диапазоне от 0 до 255. Итак, если у нас есть маска подсети 255.255.255.0 и IP-адрес 192.168.1.0, сколько хостов находится в этой подсети? Мы узнаем ответ на этот вопрос в нашем уроке по математике подсети.\n\nТакже, когда мы говорим о нашей подсети, мы обычно обозначаем ее префикс сети, за которым следует маска подсети:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>Почему?</b>\n\nПочему мы создаем подсети? Подсети используются для сегментации сетей и контроля потока трафика внутри этой сети. Таким образом, хост в одной подсети не может взаимодействовать с другим хостом в другой подсети. \n\nНо подождите минутку, а если я хочу подключиться к другим хостам, например, yahoo.com? Тогда вам нужно соединить подсети вместе. Для этого просто найдите хосты, которые подключены к более чем одной подсети. Например, если мой хост на 192.168.1.129 подключен к локальной сети 192.168.1.129/24, он может достичь любых хостов в этой сети. Чтобы достичь хостов в остальной части Интернета, ему нужно общаться через маршрутизатор. Традиционно, в большинстве сетей с маской подсети 255.255.255.0 маршрутизатор обычно находится по адресу 1 в подсети, то есть 192.168.1.1. Теперь у этого маршрутизатора будет порт, который соединяет его с другой подсетью (больше в курсе по маршрутизации). Некоторые IP-адреса (частные сети) не видны в Интернете, и у нас есть такие вещи, как NAT (больше об этом позже).",
          "quizAnswer": "Верно",
          "quizQuestion": "Верно или неверно, подсеть состоит из маски подсети и префикса сети.",
          "slug": "podseti",
          "title": "Подсети"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 3,
          "lessonContent": "Хорошо, мы знаем, что маски подсетей важны для определения количества хостов, которые могут быть на нашей подсети. Так сколько хостов это будет? \n\nДопустим, у меня есть IP-адрес <b>192.168.1.0</b> и маска подсети <b>255.255.255.0</b>, теперь давайте выстроим эти числа в двоичной форме. Пока используйте онлайн-калькулятор для преобразования этих значений из десятичной в двоичную.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nIP-адрес маскируется нашей маской подсети, когда вы видите 1, он маскируется, и мы делаем вид, что его нет. Так что единственные возможные хосты, которые у нас могут быть, находятся в области 00000000. Помните, что 11111111 в двоичной форме равно 255, мы также учитываем 0 как номер хоста, поэтому у нас есть 256 возможных вариантов. Однако, хотя может показаться, что у нас есть 256 возможных вариантов, на самом деле мы вычитаем 2 хоста, потому что мы должны учесть широковещательный адрес и адрес подсети, что оставляет нас с 254 возможными хостами в нашей подсети. Таким образом, мы знаем, что у нас могут быть хосты с IP-адресами в диапазоне от 192.168.1.1 до 192.168.1.254.",
          "quizAnswer": "11111111",
          "quizQuestion": "Каково двоичное эквивалент 255?",
          "slug": "subnetmath",
          "title": "Subnet Math"
        },
        {
          "exercise": "Посмотрите на свой IP-адрес и маску подсети и посчитайте, сколько у вас может быть хостов в вашей подсети.",
          "id": 4,
          "lessonContent": "Мне не хочется добавлять этот раздел, в реальном мире вам скорее всего никогда не придется делать математику подсети вручную, однако если вас спрашивают об этом на собеседовании, вам придется знать, как конвертировать в двоичную форму для подсетей. К счастью, есть несколько арифметических хитростей, которые вы можете запомнить. \n\nСначала запомните ваши вычисления в двоичной системе, просто сделайте это:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Таблица десятичных чисел в двоичной системе</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nЕсть много причин, почему следующая таблица выглядит так, как она выглядит, если вас интересует, как она работает, есть много ресурсов в Интернете.\n\nХорошо, запомнили это? Давайте быстро конвертируем десятичное число в двоичное:\n\n<b>Конвертировать 192.168.23.43 в двоичную систему</b>\n\nПомните: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nДавайте пройдемся по конвертации первого октета в двоичную систему, и вы поймете, как это работает.\n\n<ol>\n<li>Можете ли вы вычесть 192 - 128? Да, поэтому первый бит равен 1</li>\n<li>192 - 128 = 64, следующее число в таблице - 64, можете ли вы вычесть 64 - 64? Да, поэтому второй бит равен 1</li>\n<li>У нас закончились числа для вычитания, поэтому наша двоичная форма числа 192 - 11000000</li>\n</ol>\n\n<b>Конвертировать двоичное число 11000000 в десятичное</b>\n\nДля конвертации двоичного числа в десятичное вы складываете числа, у которых стоит 1, поэтому:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "Каково двоичное представление числа 123?",
          "slug": "шпаргалка-по-подсетям",
          "title": "Шпаргалка по подсетям"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 5,
          "lessonContent": "CIDR (classless inter-domain routing) используется для представления маски подсети более компактным способом. Вы можете видеть подсети, записанные в нотации CIDR, где подсеть, такая как 10.42.3.0/255.255.255.0, записывается как 10.42.3.0/24, что означает, что включает как префикс подсети, так и маску подсети.\n\nПомните, что IP-адрес состоит из 4 байтов или 32 бита, CIDR указывает количество бит, используемых в качестве префикса сети. Таким образом, 123.12.24.0/23 означает, что используется первые 23 бита. Что это означает? Сколько хостов это? \n\nПростой способ - вычесть общее количество битов, которое может иметь IP-адрес (32), из адреса CIDR (23), остаются 9 битов, 2^9 = 512, но мы должны удалить 2 адреса (адрес подсети и широковещательный адрес), поэтому у нас есть 510 используемых хостов.",
          "quizAnswer": "",
          "quizQuestion": "Нет вопросов, двигаемся дальше!",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 6,
          "lessonContent": "Мы уже упоминали NAT (сетевое адресное преобразование), но не касались его подробностей. Когда мы работаем в нашей сети, это означает, что Интернет видит наш IP-адрес? Не совсем.\n\nNAT заставляет устройство, такое как наш маршрутизатор, действовать как посредник между Интернетом и частной сетью. Таким образом, для представления целой группы компьютеров требуется только один уникальный IP-адрес.\n\nПредставьте NAT как рецепциониста в большом офисе: если кто-то хочет связаться с вами, он знает только номер всего офиса, затем рецепционист должен найти ваш внутренний номер и переадресовать звонок вам.\n\n<b>Как это работает?</b>\n\nПростой пример выглядит так:\n\n<ol>\n<li>Пэтти хочет подключиться к www.google.com, поэтому ее устройство отправляет запрос через маршрутизатор</li>\n<li>Маршрутизатор берет этот запрос, открывает свое соединение с google.com и отправляет запрос Пэтти, как только устанавливается соединение</li>\n<li>Маршрутизатор является посредником между Пэтти и www.google.com. Google не знает о Пэтти, вместо этого видит только маршрутизатор.</li>\n</ol>\n\nNAT и маршрутизация пакетов в целом могут быть довольно сложными, но мы не будем вдаваться в детали.",
          "quizAnswer": "NAT",
          "quizQuestion": "Что используется для представления одного частного адреса в Интернете?",
          "slug": "natnetworkaddresstranslation",
          "title": "NAT"
        },
        {
          "exercise": "Проверьте ifconfig, чтобы увидеть, есть ли у вас указанный IPv6-адрес.",
          "id": 7,
          "lessonContent": "Мы слышали термин IPv6 здесь и там, но что это такое? Каждое устройство, подключенное к Интернету, получает свой собственный IP-адрес, но это число ограничено, и мы скоро приближаемся к его пределу в этом цифровом веке. IPv6 был создан для того, чтобы позволить нам подключать больше хостов к Интернету, он предлагает более качественные улучшения IP, однако его принятие довольно медленное. Он не призван заменить IPv4, они должны дополнять друг друга. Два протокола IP очень похожи, и если вы знакомы с IPv4, вы поймете IPv6, основное различие - это способ записи адреса. Вот как выглядит типичный адрес IPv6:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "Какой IP-адрес используется для увеличения количества хостов, которые могут подключаться к Интернету?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Разделение сети на подсети"
    },
    {
      "description": "Узнайте, как пакеты маршрутизируются по сетям!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "Мы уже использовали термин 'маршрутизатор' ранее, надеюсь, вы знаете, что это такое, так как, вероятно, у вас есть один дома. Маршрутизатор позволяет машинам в сети обмениваться данными между собой, а также с другими сетями. На типичном маршрутизаторе есть порты LAN, которые позволяют вашим машинам подключаться к одной локальной сети, а также порт для подключения к Интернету, иногда этот порт могут обозначать как WAN, потому что он фактически соединяет вас с более широкой сетью. Когда мы выполняем какие-либо сетевые действия, они проходят через маршрутизатор. Маршрутизатор определяет, куда направлять наши сетевые пакеты и какие принимать. Он маршрутизирует наши пакеты между несколькими сетями, чтобы они достигли своего исходного и конечного хоста. \n\n<b>Как работает маршрутизатор?</b>\n\nПредставьте себе маршрутизацию так же, как доставку почты: у нас есть адрес, на который мы хотим отправить письмо. Когда мы отправляем его в почтовое отделение, они видят, что это идет в Калифорнию, и отправляют его на грузовик, идущий в Калифорнию (я действительно не знаю, как работает почтовая система). Письмо затем попадает в Сан-Франциско, внутри которого есть разные почтовые индексы, и в этих индексах есть более мелкие адреса, пока, наконец, кто-то не доставит ваше письмо по нужному адресу. С другой стороны, если вы уже живете в Сан-Франциско и в том же почтовом индексе, почтальон, скорее всего, знает, куда точно должно попасть письмо, не передавая его кому-либо еще. \n\nПри маршрутизации пакеты используют аналогичные адресные 'маршруты', например, чтобы попасть в сеть A, отправьте эти пакеты в сеть B. Когда у нас нет установленного маршрута, наши пакеты используют 'маршрут по умолчанию'. Эти маршруты устанавливаются в таблице маршрутизации, которую наша система использует для перемещения по сетям.\n\n<b>Хопы</b>\n\nПо мере передвижения пакетов по сетям они проходят через хопы, хоп - это примерное измерение расстояния, которое должен пройти пакет от источника к месту назначения. Допустим, у меня два маршрутизатора, соединяющих хост A с хостом B, следовательно, мы говорим, что между хостом A и хостом B два хопа. Каждый хоп - это промежуточное устройство, такое как маршрутизаторы, через которые мы должны пройти.\n\n<b>Основные различия между коммутацией, маршрутизацией и затоплением</b>\nКоммутация пакетов - это в основном получение, обработка и пересылка данных на устройство назначения.\nМаршрутизация - это процесс создания таблицы маршрутизации, чтобы мы могли выполнять коммутацию лучше.\nДо внедрения маршрутизации использовалось затопление. Если маршрутизатор не знает, куда отправить пакет, то каждый входящий пакет отправляется через все исходящие соединения, за исключением того, через которое он пришел.",
          "quizAnswer": "хопы",
          "quizQuestion": "Как измеряют расстояние пакеты?",
          "slug": "chto-takoe-marshrutizator",
          "title": "Что такое маршрутизатор?"
        },
        {
          "exercise": "Посмотрите на вашу таблицу маршрутизации и посмотрите, куда могут отправляться ваши пакеты.",
          "id": 2,
          "lessonContent": "Посмотрите на таблицу маршрутизации вашего компьютера:\n\n<pre>\npete@icebox:~$ sudo route -n\nЯдро IP таблицы маршрутизации\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destination</b>\n\nВ первом поле у нас IP-адрес назначения 192.168.224.0, что означает, что любой пакет, который пытается попасть в эту сеть, отправляется через мой Ethernet-кабель (eth0). Если бы я был 192.168.224.5 и хотел попасть на 192.168.224.7, я бы просто использовал сетевой интерфейс eth0 напрямую.\n\nОбратите внимание, что у нас есть адреса <b>0.0.0.0</b>, что означает, что адрес не указан или неизвестен. Так что, например, если я хотел отправить пакет на IP-адрес 151.123.43.6, наша таблица маршрутизации не знает, куда это отправить, поэтому он обозначает это как 0.0.0.0 и, следовательно, направляет наш пакет к шлюзу.\n\n<b>Gateway</b>\n\nЕсли мы отправляем пакет, который не находится в той же сети, он будет отправлен на этот адрес шлюза. Он называется шлюзом в другую сеть.\n\n<b>Genmask</b>\n\nЭто маска подсети, используемая для определения того, какие IP-адреса соответствуют какому назначению.\n\n<b>Flags</b>\n\n<ul>\n<li>UG - Сеть включена и является шлюзом</li>\n<li>U - Сеть включена</li>\n</ul>\n\n<b>Iface</b>\n\nЭто интерфейс, через который будет отправлен наш пакет, eth0 обычно означает первое Ethernet-устройство на вашей системе.",
          "quizAnswer": "Шлюз",
          "quizQuestion": "Куда направляются пакеты, если наша таблица маршрутизации не знает?",
          "slug": "routingtable",
          "title": "Таблица маршрутизации"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 3,
          "lessonContent": "<b>Давайте посмотрим, как пакет передвигается в пределах своей локальной сети</b>\n\n<ol>\n<li>Сначала локальная машина сравнивает IP-адрес назначения, чтобы узнать, находится ли он в той же подсети, посмотрев на маску подсети.</li>\n<li>Когда пакеты отправляются, они должны иметь исходный MAC-адрес, MAC-адрес назначения, исходный IP-адрес и IP-адрес назначения, на данном этапе мы не знаем MAC-адрес назначения.</li>\n<li>Чтобы достичь целевого хоста, мы используем ARP для широковещательного запроса в локальной сети для поиска MAC-адреса целевого хоста.</li>\n<li>Теперь пакет может быть успешно отправлен!</li>\n</ol>\n\n<b>Давайте посмотрим, как пакет передвигается за пределы своей сети</b>\n\n<ol>\n<li>Сначала локальная машина сравнивает IP-адрес назначения, поскольку он находится за пределами нашей сети, она не видит MAC-адрес целевого хоста. И мы не можем использовать ARP, потому что запрос ARP является широковещательным для локально подключенных хостов.</li>\n<li>Таким образом, наш пакет теперь обращается к таблице маршрутизации, он не знает адреса IP назначения, поэтому отправляет его на шлюз по умолчанию (другой маршрутизатор). Теперь наш пакет содержит наш исходный IP, IP назначения и исходный MAC, однако у нас нет MAC-адреса назначения. Помните, что MAC-адреса доступны только в пределах одной сети. Что же делает пакет? Он отправляет запрос ARP, чтобы получить MAC-адрес шлюза по умолчанию.</li>\n<li>Маршрутизатор смотрит на пакет и подтверждает MAC-адрес назначения, но это не конечный IP-адрес назначения, поэтому он продолжает просматривать таблицу маршрутизации, чтобы переслать пакет на другой IP-адрес, который может помочь пакету продвинуться к своему назначению. Каждый раз, когда пакет перемещается, он удаляет старые исходный и целевой MAC-адреса и обновляет пакет новыми исходными и целевыми MAC-адресами.</li>\n<li>Как только пакет пересылается в ту же сеть, мы используем ARP, чтобы найти конечный MAC-адрес назначения</li>\n<li>Во время этого процесса наш пакет не меняет исходный или целевой IP-адрес.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Как мы находим MAC-адрес IP-адреса?",
          "slug": "pathofapacket",
          "title": "Путь пакета"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 4,
          "lessonContent": "Было бы неудобно вручную настраивать маршруты в таблице маршрутизации для каждого устройства в вашей сети, поэтому мы используем так называемые протоколы маршрутизации. Протоколы маршрутизации используются для адаптации нашей системы к изменениям в сети, они узнают различные маршруты, строят их в таблице маршрутизации, а затем направляют наши пакеты через них. Существуют два основных типа протоколов маршрутизации: протоколы вектора расстояния и протоколы состояния канала.\n\n<b>Сходимость</b>\n\nПрежде чем мы поговорим о протоколах, давайте рассмотрим термин, используемый в маршрутизации, известный как сходимость. При использовании протоколов маршрутизации маршрутизаторы общаются с другими маршрутизаторами для сбора и обмена информацией о сети. Когда они согласуют, как должна выглядеть сеть, каждая таблица маршрутизации отображает полную топологию сети, таким образом происходит \"сходимость\". Когда что-то происходит в топологии сети, сходимость временно нарушается, пока все маршрутизаторы не будут осведомлены об этом изменении.",
          "quizAnswer": "сходимость",
          "quizQuestion": "Какой термин используется, когда все таблицы маршрутизации знают топологию сети?",
          "slug": "протоколымаршрутизации",
          "title": "Протоколы маршрутизации"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 5,
          "lessonContent": "Протоколы вектора расстояния определяют путь других сетей, используя количество переходов, которые пакет проходит по сети. Если сеть A находится в 3 переходах и сеть B находится рядом с сетью A, то мы предполагаем, что она находится в 4 переходах. В протоколах вектора расстояния следующим маршрутом будет тот, который имеет наименьшее количество переходов.\n\nПротоколы вектора расстояния отлично подходят для небольших сетей, но когда сети начинают масштабироваться, роутерам требуется больше времени на сходимость, потому что периодически отправляется вся таблица маршрутизации ко всем роутерам. Еще один недостаток протоколов вектора расстояния - это эффективность, они выбирают маршруты, близкие по переходам, но это не всегда означает выбор наиболее эффективного маршрута.\n\nОдин из распространенных протоколов вектора расстояния - RIP (Routing Information Protocol), который транслирует таблицу маршрутизации ко всем роутерам в сети каждые 30 секунд. Для большой сети это может потребовать значительных ресурсов, поэтому RIP ограничивает количество переходов до 15.",
          "quizAnswer": "неверно",
          "quizQuestion": "Верно или неверно, протоколы расстояния используют маршрут с наименьшим количеством полос пропускания?",
          "slug": "протоколывекторарасстояния",
          "title": "Протоколы вектора расстояния"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 6,
          "lessonContent": "Протоколы состояния канала отлично подходят для крупных сетей, они более сложные, чем протоколы дистанционного вектора, однако их большим плюсом является способность быстро сходиться, потому что вместо периодической отправки всей таблицы маршрутизации они отправляют обновления только соседним маршрутам. Они используют другой алгоритм для вычисления кратчайшего пути и строят топологию своей сети в виде графа, чтобы показать, какие маршрутизаторы подключены к другим маршрутизаторам.\n\nОдин из распространенных протоколов состояния канала - OSPF (Open Shortest Path First), он обновляет таблицы маршрутизации только в случае изменения сети. У него нет ограничения на количество переходов.",
          "quizAnswer": "OSPF",
          "quizQuestion": "Какой из протоколов состояния канала является одним из самых распространенных?",
          "slug": "linkstateprotocols",
          "title": "Протоколы состояния канала"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 7,
          "lessonContent": "Последний важный протокол, о котором мы поговорим, - это BGP. BGP в основном определяет работу Интернета. Он используется для сбора и обмена информацией о маршрутизации между автономными системами. Представьте автономную систему как поставщика интернет-услуг, компанию, университет, любую организацию и т. д. Без BGP эти системы не знали бы, как общаться друг с другом, они были бы изолированы. Вместо того, чтобы маршрутизировать внутри этих автономных систем, BGP маршрутизирует между ними.\n\nПредположим, вы находитесь в своей домашней сети, а я работаю из Starbucks. Я хочу иметь возможность общаться с вами, поэтому отправляю электронное письмо, и сетевой пакет проходит через сеть Starbucks, отскакивает там и проходит через таблицы маршрутизации в сети Starbucks, пока наконец не достигает точки на границе сети Starbucks и передается маршрутизатору граничного шлюза. Этот маршрутизатор содержит информацию для моего пакета, чтобы покинуть сеть Starbucks и пройти через другие сети.",
          "quizAnswer": "BGP",
          "quizQuestion": "Какой протокол в основном обеспечивает работу Интернета?",
          "slug": "bgpbordergatewayprotocol",
          "title": "Протокол маршрутизации между сетями"
        }
      ],
      "slug": "routing",
      "title": "Маршрутизация"
    },
    {
      "description": "Узнайте о настройке сети с использованием инструментов Linux!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Попробуйте изменить состояние ваших сетевых интерфейсов на активное или неактивное и наблюдайте, что происходит.\n\nМожете ли вы изменить состояние сетевых интерфейсов с помощью команд ifconfig и ip?",
          "id": 1,
          "lessonContent": "Сетевой интерфейс - это то, как ядро связывает программную часть сетевого взаимодействия с аппаратной частью. Мы уже видели пример этого:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> Команда ifconfig</b>\n\nИнструмент <b>ifconfig</b> позволяет нам настраивать наши сетевые интерфейсы. Если сетевые интерфейсы не настроены, драйверы устройств ядра и сеть не смогут взаимодействовать. Ifconfig запускается при загрузке и настраивает наши интерфейсы через файлы конфигурации, но мы также можем их изменять вручную. Вывод ifconfig показывает имя интерфейса слева, а справа - подробную информацию. Чаще всего вы увидите интерфейсы с именами eth0 (первая сетевая карта в устройстве), wlan0 (беспроводной интерфейс), lo (петлевой интерфейс). Петлевой интерфейс используется для представления вашего компьютера, он просто возвращает вас к себе. Это полезно для отладки или подключения к серверам, работающим локально.\n\nСостояние интерфейсов может быть активным (up) или неактивным (down), если вы хотите \"выключить\" интерфейс, вы можете установить его в неактивное состояние. В выводе ifconfig вы обычно будете смотреть на HWaddr (MAC-адрес интерфейса), inet address (IPv4-адрес) и inet6 (IPv6-адрес). Конечно же, там же указаны маска подсети и широковещательный адрес. Вы также можете просматривать информацию об интерфейсе в /etc/network/interfaces.\n\n<b>Для создания интерфейса и активации его</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nЭто назначает IP-адрес и маску подсети интерфейсу eth0 и активирует его.\n\n<b>Для активации или деактивации интерфейса</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> Команда ip </b>\n\nКоманда <b>ip</b> также позволяет нам управлять сетевым стеком системы. В зависимости от используемого дистрибутива, это может быть предпочтительным методом настройки сети. \n\nВот некоторые примеры ее использования:\n\n<b>Для отображения информации об интерфейсах</b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Для отображения статистики интерфейса</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n<b>Для отображения назначенных IP-адресов интерфейсам</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>Для активации и деактивации интерфейсов</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Для добавления IP-адреса к интерфейсу</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "Какая команда используется для настройки наших сетевых интерфейсов?",
          "slug": "networkinterfaces",
          "title": "Сетевые интерфейсы"
        },
        {
          "exercise": "В этом уроке нет упражнений, но вы можете прочитать больше информации о командах, обсужденных здесь, в страницах справки man\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Мы уже обсудили просмотр наших таблиц маршрутизации с помощью команды route, если вы хотите добавить или удалить маршруты, вы можете сделать это вручную.\n\n<b>Добавление нового маршрута</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Удаление маршрута</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nВы также можете выполнить эти изменения с помощью команды <b>ip</b>:\n\n<b>Для добавления маршрута</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Для удаления маршрута</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\nили\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "Какой флаг команды используется для удаления маршрута?",
          "slug": "маршрут",
          "title": "маршрут"
        },
        {
          "exercise": "No exercises for this lesson.",
          "id": 3,
          "lessonContent": "Мы уже обсудили DHCP ранее, и в большинстве случаев вам никогда не понадобится устанавливать статические IP-адреса, маски подсети и т. д. Вместо этого вы будете использовать DHCP! Dhclient запускается при загрузке и получает список сетевых интерфейсов из файла dhclient.conf. Для каждого перечисленного интерфейса он пытается настроить интерфейс с использованием протокола DHCP.\n\nВ файле dhclient.leases dhclient отслеживает список аренды через перезагрузки системы, после чтения dhclient.conf файл dhclient.leases считывается, чтобы узнать, какие аренды уже назначены.\n\n<b>Для получения нового IP-адреса</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "Какая программа пытается назначить IP-адреса с использованием протокола DHCP?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 4,
          "lessonContent": "Конечно, если вы хотите, чтобы сетевое подключение вашей системы запускалось автоматически, для этого уже есть готовое решение. Большинство дистрибутивов используют демон NetworkManager для автоматической настройки сетей.\n\nВы заметите NetworkManager в виде плагина где-то на панели задач вашего рабочего стола, если вы используете графический интерфейс. Как видите, он управляет аппаратными средствами вашей сети и информацией о подключении. Например, при запуске NetworkManager собирает информацию об аппаратных средствах сети, ищет подключения к беспроводным, проводным и т. д. сетям, а затем активирует их.\n\nТакже есть инструменты командной строки для взаимодействия с NetworkManager:\n\n<b>nm-tool</b>\n\nnm-tool отображает состояние NetworkManager и его устройства\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nState: connected (global)\n\n- Device: eth0  [Wired connection 1] -------------------------------------------\n  Type:              Wired\n  Driver:            pcnet32\n  State:             connected\n  Default:           yes\n  HW Address:        12:3D:45:56:7D:CC\n\n  Способности:\n    Обнаружение носителя:  да\n\n  Свойства проводного подключения:\n    Носитель:         вкл\n\n  Настройки IPv4:\n    Адрес:         192.168.22.1\n    Префикс:          24 (255.255.255.0)\n    Шлюз:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nКоманда nmcli позволяет управлять и изменять NetworkManager, см. страницу руководства для получения более подробной информации.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "Какая команда используется для просмотра информации о NetworkManager?",
          "slug": "networkmanager",
          "title": "Менеджер сети"
        },
        {
          "exercise": "Наблюдайте, что происходит с вашим кешем ARP, когда вы перезагружаете свою машину, а затем выполняете какие-то действия в сети.",
          "id": 5,
          "lessonContent": "Помните, когда мы ищем MAC-адрес с помощью ARP, сначала происходит проверка локально хранимого кеша ARP на нашей системе, вы можете фактически просмотреть этот кеш:\n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nКеш ARP фактически пуст при запуске машины, он заполняется по мере отправки пакетов другим хостам. Если мы отправляем пакет на пункт назначения, который отсутствует в кеше ARP, происходит следующее:\n\n<ol>\n<li>Исходный хост создает Ethernet-фрейм с пакетом запроса ARP</li>\n<li>Исходный хост транслирует этот фрейм на всю сеть</li>\n<li>Если один из хостов в сети знает правильный MAC-адрес, он отправит ответный пакет и фрейм, содержащий MAC-адрес</li>\n<li>Исходный хост добавляет отображение IP на MAC-адрес в кеш ARP и затем продолжает отправку пакета</li>\n</ol>\n\nВы также можете просмотреть свой кеш arp с помощью команды ip:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "Какую команду можно использовать для просмотра вашего кеша ARP?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Настройка сети"
    },
    {
      "description": "Узнайте о распространенных сетевых инструментах, которые помогут вам диагностировать и устранять проблемы!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "Протокол управления сообщениями Интернета (ICMP) является частью набора протоколов TCP/IP, используется для отправки обновлений и сообщений об ошибках, и является чрезвычайно полезным протоколом, используемым для отладки проблем сети, таких как неудачная доставка пакета.\n\nКаждое сообщение ICMP содержит поля типа, кода и контрольной суммы. Поле типа - это тип сообщения ICMP, код - подтип, который содержит дополнительную информацию о сообщении, а контрольная сумма используется для обнаружения любых проблем с целостностью сообщения.\n\nДавайте рассмотрим некоторые распространенные типы ICMP:\n\n<ul>\n<li>Тип 0 - Echo Reply</li>\n<li>Тип 3 - Недостижимый пункт назначения</li>\n<li>Тип 8 - Echo Request</li>\n<li>Тип 11 - Превышено время</li>\n</ul>\n\nКогда пакет не может достичь пункта назначения, генерируется сообщение ICMP типа 3, внутри типа 3 есть 16 значений кода, которые дополнительно описывают причину, почему пакет не может достичь пункта назначения: \n\n<ul>\n<li>Код 0 - Сеть недоступна</li>\n<li>Код 1 - Хост недоступен</li>\nи т. д..\n</ul>\n\nЭти сообщения станут более понятными, когда мы будем использовать некоторые инструменты для устранения неполадок в сети.",
          "quizAnswer": "8",
          "quizQuestion": "Какой тип ICMP используется для запроса эхо?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Выполните ping на веб-сайт и посмотрите на вывод, который вы получите.",
          "id": 2,
          "lessonContent": "Один из самых простых сетевых инструментов <b>ping</b>, используется для проверки того, может ли пакет достичь хоста. Он работает путем отправки пакетов ICMP echo request (тип 8) на целевой хост и ожидания ICMP echo reply (тип 0). Ping успешен, когда хост отправляет запрос и получает ответ от цели. Давайте рассмотрим пример: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) байт данных.\n64 байта от nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 мс\n64 байта от nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 мс\n64 байта от nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 мс\n</pre>\n\nВ этом примере мы используем ping для проверки доступности www.google.com. Флаг -c (count) используется для остановки отправки пакетов echo request после достижения счетчика. \n\nПервая часть говорит о том, что мы отправляем 64-байтные пакеты на 74.125.239.112 (google.com), а остальное показывает нам детали поездки. По умолчанию отправляется один пакет в секунду.\n\n<b>icmp_seq</b>\n\nПоле icmp_seq используется для отображения номера последовательности отправленных пакетов, так что в этом случае я отправил 3 пакета, и мы видим, что 3 пакета вернулись. Если вы выполняете ping и видите пропущенные номера последовательности, это означает, что возникают проблемы с подключением, и не все ваши пакеты проходят. Если номер последовательности находится вне порядка, ваше подключение, вероятно, очень медленное, так как ваши пакеты превышают односекундный интервал по умолчанию. \n\n<b>ttl</b>\n\nПоле Time To Live (ttl) используется как счетчик переходов, по мере прохождения хопов счетчик уменьшается на один, и когда счетчик хопов достигает 0, наш пакет умирает. Это предназначено для того, чтобы дать пакету срок жизни, мы не хотим, чтобы наши пакеты бесконечно путешествовали. \n\n<b>time</b>\n\nВремя туда и обратно, которое потребовалось от отправки вами пакета echo request до получения ответа echo reply.",
          "quizAnswer": "мс",
          "quizQuestion": "Какая единица измерения времени туда и обратно?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Запустите команду traceroute на своей машине и изучите вывод.",
          "id": 3,
          "lessonContent": "Команда traceroute используется для просмотра маршрутизации пакетов. Она работает путем отправки пакетов с увеличением значений TTL, начиная с 1. Таким образом, первый маршрутизатор получает пакет и уменьшает значение TTL на единицу, что приводит к отбрасыванию пакета. Маршрутизатор отправляет нам обратно сообщение ICMP Time Exceeded. Затем следующий пакет получает TTL равный 2, проходит первый маршрутизатор, но когда он достигает второго маршрутизатора, TTL равен 0, и возвращается еще одно сообщение ICMP Time Exceeded. Traceroute работает таким образом, потому что по мере отправки и отбрасывания пакетов он создает список маршрутизаторов, через которые проходят пакеты, пока наконец не достигнет своего пункта назначения и не получит сообщение ICMP Echo Reply. \n\nВот небольшой отрывок из traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute до google.com (216.58.216.174), максимум 30 переходов, пакеты размером 60 байт                          \n 1  192.168.4.254 (192.168.4.254)  0.028 мс  0.009 мс  0.008 мс                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 мс  1.226 мс 0.920 мс\n 3  100.64.0.20 (100.64.0.20)  1.501 мс 1.556 мс  0.855 мс                                                                                 \n</pre>\n\nКаждая строка представляет собой маршрутизатор или машину, находящуюся между мной и целью. Она показывает имя цели, ее IP-адрес, и последние три столбца соответствуют времени двойного прохождения пакета к этому маршрутизатору. По умолчанию мы отправляем три пакета по маршруту.",
          "quizAnswer": "ttl",
          "quizQuestion": "Что уменьшается на единицу при переходе через сеть?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Посмотрите страницу руководства для netstat и изучите все функции, которые он предлагает.",
          "id": 4,
          "lessonContent": "<b>Известные порты</b>\n\nМы обсудили передачу данных через порты на нашей машине, давайте посмотрим на некоторые известные порты.\n\nВы можете получить список известных портов, посмотрев файл <b>/etc/services</b>: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..и так далее..\n</pre>\n\nПервый столбец - это название службы, затем номер порта и используемый протокол транспортного уровня.\n\n<b>netstat</b>\n\nЧрезвычайно полезный инструмент для получения подробной информации о вашей сети - это <b>netstat</b>. Netstat отображает различную информацию, связанную с сетью, такую как сетевые соединения, таблицы маршрутизации, информацию о сетевых интерфейсах и многое другое, это швейцарский нож сетевых инструментов. Мы сосредоточимся в основном на одной функции, которую предлагает netstat, и это состояние сетевых соединений. Прежде чем мы рассмотрим пример, давайте сначала поговорим о сокетах и портах. Сокет - это интерфейс, который позволяет программам отправлять и получать данные, в то время как порт используется для идентификации того, какое приложение должно отправлять или получать данные. Адрес сокета - это комбинация IP-адреса и порта. Для каждого соединения между хостом и местом назначения требуется уникальный сокет. Например, HTTP - это служба, которая работает на порту 80, однако у нас может быть много соединений HTTP, и для поддержания каждого соединения создается сокет.\n\n<pre>\npete@icebox:~$ netstat -at\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nКоманда netstat -a показывает прослушивающие и непрослушивающие сокеты для сетевых соединений, флаг -t показывает только tcp-соединения. \n\nСтолбцы следующие слева направо:\n\n<ul>\n<li>Proto: Используемый протокол, TCP или UDP.</li>\n<li>Recv-Q: Данные, ожидающие получения</li>\n<li>Send-Q: Данные, ожидающие отправки</li>\n<li>Local Address: Локально подключенный хост</li>\n<li>Foreign Address: Удаленно подключенный хост</li>\n<li>State: Состояние сокета</li>\n</ul>\n\nСмотрите страницу руководства для списка состояний сокетов, но вот некоторые из них:\n\n<ul>\n<li>LISTENING: Сокет прослушивает входящие соединения, помните, что когда мы устанавливаем TCP-соединение, наш пункт назначения должен слушать нас, прежде чем мы сможем подключиться.</li>\n<li>SYN_SENT: Сокет активно пытается установить соединение.</li>\n<li>ESTABLISHED: Сокет имеет установленное соединение</li>\n<li>CLOSE_WAIT: Удаленный хост завершил работу, и мы ждем закрытия сокета</li>\n<li>TIME_WAIT: Сокет ожидает после закрытия обработки пакетов, которые все еще находятся в сети</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "Какой порт используется для HTTPS?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Скачайте и установите инструмент Wireshark и поиграйтесь с интерфейсом.",
          "id": 5,
          "lessonContent": "Тема анализа пакетов может заполнить целый курс, и существует много книг, написанных исключительно о анализе пакетов. Однако сегодня мы просто изучим основы. Существуют две чрезвычайно популярные программы для анализа пакетов: Wireshark и tcpdump. Эти инструменты сканируют ваши сетевые интерфейсы, захватывают активность пакетов, разбирают пакеты и выводят информацию для нас. Они позволяют нам погрузиться в детали анализа сети и изучить низкоуровневые вещи. Мы будем использовать tcpdump, поскольку у него более простой интерфейс, однако если вы решите освоить анализ пакетов, я бы порекомендовал обратить внимание на Wireshark.\n\n<b>Установите tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Захват данных пакетов на интерфейсе</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 3, length 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 3, length 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 4, length 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 4, length 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 5, length 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 5, length 64\n11:28:30.674953 ARP, Request who-has 172.254.1.0 tell ThePickleParty.lan, length 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, length 306\n</pre>\n\nВы заметите много событий при выполнении захвата пакетов, это ожидаемо, так как в фоновом режиме происходит много сетевой активности. В моем примере выше я взял только фрагмент моего захвата, а именно время, когда я решил выполнить ping www.google.com.\n\n<b>Понимание вывода</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n</pre>\n\n<ul>\n<li>Первое поле - временная метка сетевой активности</li>\n<li>IP, содержит информацию о протоколе</li>\n<li>Далее вы увидите адрес источника и адрес назначения: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq - это начальный и конечный номер последовательности TCP-пакетов</li>\n<li>length - длина в байтах</li>\n</ul>\n\nКак видно из вывода tcpdump, мы отправляем пакет запроса ICMP echo на www.google.com и получаем в ответ пакет ответа ICMP echo! Также обратите внимание, что разные пакеты будут выводить разную информацию, обратитесь к man-странице, чтобы узнать, что это за пакеты.\n\n<b>Запись вывода tcpdump в файл</b>\n\n<pre>\n$ sudo tcpdump -w /some/file\n</pre>\n\n\nНекоторые заключительные мысли: мы только коснулись поверхности темы анализа пакетов. Есть так много, на что можно посмотреть, и мы даже не затронули более глубокий анализ с выводом в шестнадцатеричном и ASCII форматах. Существует множество ресурсов в Интернете, которые помогут вам узнать больше о анализаторах пакетов, и я настоятельно рекомендую вам их найти!",
          "quizAnswer": "-i",
          "quizQuestion": "Какой флаг использовать для захвата конкретного интерфейса с помощью tcpdump?",
          "slug": "packetanalysis",
          "title": "Анализ пакетов"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Устранение неполадок"
    },
    {
      "description": "Все и даже больше, что вы хотели знать о DNS.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 1,
          "lessonContent": "Представьте, что каждый раз, когда вы хотите выполнить поиск в Google, вам приходится вводить http://192.78.12.4 вместо www.google.com. Без DNS (\"Система доменных имен\") именно так бы и происходило. Низкоуровневые сети понимают только сырой IP-адрес для идентификации хоста. DNS позволяет нам, людям, отслеживать веб-сайты и хосты по именам, а не по IP-адресам. Это похоже на список контактов для Интернета. Если вы знаете имя человека, но не знаете его номер телефона, вы можете просто найти это в своем списке контактов.\n\nDNS в основном является распределенной базой данных имен хостов и IP-адресов, мы управляем нашей базой данных, чтобы люди знали, как попасть на наш сайт/домен, и где-то еще другой человек управляет своей базой данных, чтобы другие могли попасть на его домен. Эти домены затем могут общаться друг с другом и создавать огромный список контактов Интернета.\n\nВ этом курсе мы рассмотрим некоторые основы DNS, но имейте в виду, что DNS - это исчерпывающая тема, и если вы действительно хотите погрузиться в нее, вам придется провести дополнительные исследования.",
          "quizAnswer": "неверно",
          "quizQuestion": "Верно или неверно, DNS помогает нам находить MAC-адреса для имен хостов?",
          "slug": "chto-takoe-dns",
          "title": "Что такое DNS?"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 2,
          "lessonContent": "База данных DNS Интернета зависит от сайтов и организаций, предоставляющих часть этой базы данных. Для этого им необходимо:\n\n<b>Сервер имен</b>\n\nМы настраиваем DNS с помощью \"серверов имен\", которые загружают наши настройки и конфигурации DNS и отвечают на любые вопросы от клиентов или других серверов, которые хотят знать такие вещи, как \"Кто такой google.com?\". Если сервер имен не знает ответ на этот запрос, он перенаправит запрос на другие серверы имен. Серверы имен могут быть \"авторитетными\", что означает, что они содержат фактические DNS-записи, которые вам нужны, или \"рекурсивными\", что означает, что они будут запрашивать другие серверы, и эти серверы будут запрашивать другие серверы, пока не найдут авторитетный сервер, который содержит DNS-записи. Рекурсивные серверы также могут кэшировать информацию, которую мы хотим, вместо того чтобы обращаться к авторитетному серверу.\n\n<b>Файл зоны</b>\n\nВнутри сервера имен находится так называемый файл зоны. Файлы зон - это то, как сервер имен хранит информацию о домене или о том, как к нему попасть, если он не знает.\n\n<b>Записи ресурсов</b>\n\nФайл зоны состоит из записей ресурсов. Каждая строка - это запись и содержит информацию о хостах, серверах имен, других ресурсах и т. д. Поля состоят из следующего: \n\n<ul>\n<li>Имя записи</li>\n<li>TTL - Время, через которое мы удаляем запись и получаем новую, в DNS TTL обозначается временем, поэтому записи могут иметь TTL в один час. Мы делаем это потому, что Интернет постоянно меняется, одну минуту хост может быть сопоставлен с IP-адресом X, а следующую - с IP-адресом Y</li>\n<li>Класс - Пространство имен информации записи, наиболее часто используется IN для Интернета</li>\n<li>Тип - Тип информации, хранящейся в данных записи. Мы не будем вдаваться в типы записей, но вы, вероятно, видели обычные, такие как A для адреса, MX или почтовый обменник и т. д.</li>\n<li>Данные - Это поле может содержать IP-адрес, если это запись A, или что-то другое в зависимости от типа записи.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "Какой тип записи ресурса используется для почтовых обменников?",
          "slug": "компоненты-dns",
          "title": "Компоненты DNS"
        },
        {
          "exercise": "Урок без упражнений.",
          "id": 3,
          "lessonContent": "Давайте рассмотрим пример того, как ваш хост находит домен (catzontheinterwebz.com) с помощью DNS. По сути, мы просачиваемся вниз, пока не достигнем DNS-сервера, который знает об этом домене.\n\n<b>Локальный DNS-сервер</b>\n\nСначала наш хост спрашивает: \"Где находится catzontheinterwebz.com?\", наш локальный DNS-сервер не знает, поэтому он начинает с верхушки воронки, чтобы спросить Корневые серверы. Имейте в виду, что наш хост не делает эти запросы напрямую для поиска catzontheinterwebz.com, большинство пользователей общаются с рекурсивным DNS-сервером, предоставляемым своими поставщиками услуг Интернета, и этот сервер затем получает задачу найти местоположение catzontheinterwebz.com.\n\n<b>Корневые серверы</b>\n\nСуществует 13 Корневых серверов для Интернета, они зеркалируются и распределяются по всему миру для обработки DNS-запросов для Интернета, поэтому на самом деле существует сотни серверов, которые работают, они контролируются различными организациями и содержат информацию о доменах верхнего уровня. Домены верхнего уровня - это то, что вы знаете как адреса .org, .com, .net и т. д. Таким образом, Корневой сервер не знает, где находится catzontheinterwebz.com, поэтому он говорит нам спросить DNS-сервер домена верхнего уровня .com по IP-адресу, который он нам дает.\n\n<b>Домен верхнего уровня</b>\n\nИтак, теперь мы отправляем еще один запрос к серверу имен, который знает о доменах \".com\" и спрашиваем, знает ли он, где находится catzontheinterwebz.com? Домен верхнего уровня не имеет catzontheinterwebz.com в своих зонных файлах, но видит запись для сервера имен для catzontheinterwebz.com. Поэтому он дает нам IP-адрес этого сервера имен и говорит нам посмотреть туда.\n\n<b>Авторитетный DNS-сервер</b>\n\nТеперь мы отправляем последний запрос к DNS-серверу, который действительно имеет запись, которую мы хотим. Сервер имен видит, что у него есть зонный файл для catzontheinterwebz.com и есть ресурсная запись для 'www' для этого хоста. Затем он дает нам IP-адрес этого хоста, и мы наконец можем увидеть некоторых котов в Интернете.",
          "quizAnswer": "ДВУ",
          "quizQuestion": "Какое сокращение для серверов имен, где находятся адреса .com, .net, .org и т. д.?",
          "slug": "dnsprocess",
          "title": "Процесс DNS"
        },
        {
          "exercise": "Нет упражнений для этого урока.",
          "id": 4,
          "lessonContent": "<p>Перед тем как наш компьютер обратится к DNS для выполнения запроса, он сначала смотрит локально на наши машины.</p><br><p><b>/etc/hosts</b></p><p>Файл /etc/hosts содержит отображения некоторых имен хостов на IP-адреса. Поля довольно самообъясняющиеся: есть одно для IP-адреса, имя хоста, а затем любые псевдонимы для хоста.</p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>Обычно вы увидите адрес вашего локального хоста в этом файле по умолчанию. Вы также можете управлять доступом к хостам, изменяя файлы /etc/hosts.deny или /etc/hosts.allow. Однако, если вы обеспокоены безопасностью, это не самый лучший способ, и вам следует вместо этого изменять правила вашего брандмауэра.</p><p>Давайте рассмотрим интересный пример /etc/hosts. Измените файл и добавьте строку для:</p><pre>123.45.6.7  www.google.com</pre><p>Сохраните файл и теперь перейдите на www.google.com. У вас возникли проблемы, не так ли? Это потому, что мы только что сопоставили www.google.com с совершенно неправильным IP-адресом. Поскольку наши хосты сначала ищут локальные отображения IP-адресов, они никогда не обращаются к DNS для поиска google.com.</p><p><b>/etc/resolv.conf</b></p><p>Традиционно мы использовали файл под названием /etc/resolv.conf для сопоставления DNS-серверов для более эффективного поиска, однако с улучшениями, внесенными в DNS, этот файл довольно часто неактуален. Фактически, вы можете видеть в моем примере ниже, что /etc/resolv.conf не управляется вручную. Обратитесь к настройкам вашего дистрибутива для управления сопоставлением DNS-серверов.</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "Какой файл используется для сопоставления имен хостов с IP-адресами на наших машинах?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "Урок не содержит упражнений.",
          "id": 5,
          "lessonContent": "Мы не будем рассматривать настройку DNS-сервера, так как это будет довольно длительное руководство. Вместо этого вот краткий список популярных DNS-серверов для использования с Linux.\n\n<b>BIND</b>\n\nСамый популярный DNS-сервер в Интернете, это стандарт, используемый в дистрибутивах Linux. Он был изначально разработан в Университете Калифорнии в Беркли, отсюда и название BIND (Berkeley Internet Name Domain). Если вам нужна полнофункциональная мощь и гибкость, вы не ошибетесь, выбрав BIND.\n\n<b>DNSmasq</b>\n\nЛегкий и намного проще настраивать, чем BIND. Если вам нужна простота и вам не нужны все функции BIND, используйте DNSmasq. Он поставляется со всеми необходимыми инструментами для настройки DHCP и DNS, рекомендуется для небольших сетей.\n\n<b>PowerDNS</b>\n\nПолнофункциональный и аналогичный BIND, он предлагает вам немного больше гибкости с опциями. Он читает информацию из нескольких баз данных, таких как MySQL, PostgreSQL и т. д., для более простого администрирования. Просто потому, что BIND был способом, как мы делаем вещи, не означает, что это должно оставаться так.\n\nЭто не полный список, но он должен дать вам представление о том, куда смотреть, если вы настраиваете свой собственный DNS-сервер.",
          "quizAnswer": "BIND",
          "quizQuestion": "Какой является фактическим DNS-сервером для Linux?",
          "slug": "dnssetup",
          "title": "Настройка DNS"
        },
        {
          "exercise": "Ознакомьтесь с man-страницей для dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nИнструмент \"поиска сервера имен\" используется для запроса серверов имен для получения информации о ресурсных записях. Давайте узнаем, где находится сервер имен для google.com:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nNon-authoritative answer:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (domain information groper) - мощный инструмент для получения информации о серверах имен DNS, он более гибок, чем nslookup, и отлично подходит для устранения проблем с DNS.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; QUESTION SECTION:\n;www.google.com.                        IN      A\n\n;; ANSWER SECTION:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Query time: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; WHEN: Sun Feb 07 10:14:00 PST 2016\n;; MSG SIZE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "Какой инструмент используется для получения подробной информации о серверах имен DNS?",
          "slug": "dnstools",
          "title": "DNS Tools"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Содержание",
      "exerciseAndQuiz": "Упражнения и викторина"
    },
    "exerciseBox": {
      "exercise": "Упражнение"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Новая жизнь для LinuxJourney, которая помогла так многим людям сделать первые шаги в мир Linux.",
      "title": "Разблокируйте мощь Linux"
    },
    "navbar": {
      "home": "Главная",
      "language": "Язык",
      "lessons": "Уроки",
      "resources": "Ресурсы",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Вернуться к главам",
      "checkAnswer": "Проверить ответ",
      "correctAnswer": "Правильный ответ: ",
      "nextLesson": "Следующий урок",
      "placeholderAnswer": "Введите ваш ответ здесь",
      "quiz": "Викторина",
      "showCorrectAnswer": "Показать правильный ответ"
    },
    "resources": {
      "data": [
        {
          "description": "Пошаговое руководство для начинающих, объясняющее историю терминала и основные команды",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Официальное руководство Ubuntu"
        },
        {
          "description": "Ясный обзор того, как работает терминал, как выполнять команды и перемещаться по файловой системе.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "Одна из самых рекомендуемых книг!",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "Как работает Linux"
        },
        {
          "description": "Чрезвычайно полезная книга для каждого системного администратора.",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "Справочник администратора систем UNIX и Linux"
        },
        {
          "description": "Отличное комплексное руководство по написанию сценариев оболочки.",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Библия команд Linux"
        },
        {
          "description": "Для серьезных пользователей Linux, отличное начало в ядро программирования.",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "Интерфейс программирования Linux: Linux и UNIX System"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Откройте для себя отобранные книги, учебники и инструменты для углубления знаний о Linux.",
        "title": "Ресурсы"
      },
      "title": "Ресурсы"
    }
  }
}