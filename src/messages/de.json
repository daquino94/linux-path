{
  "chapters": [
    {
      "description": "Was ist Linux? Beginnen Sie mit der Auswahl einer Distribution und der Installation.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Zusätzliche Lektüre:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "Hey Anfänger! Du hast also beschlossen, in diese wunderbare Welt namens Linux einzutauchen? Nun, du solltest dich besser festhalten, denn es wird ein langer und harter Weg sein. Mein Name ist Pinguin Pete und ich bin hier, um dich auf dieser Reise zu begleiten. Lass uns mit ein wenig Hintergrundwissen über Linux beginnen. \n\nUm zu erfahren, wie Linux entstanden ist, gehen wir zurück zum Anfang des Jahres 1969, als Ken Thompson und Dennis Ritchie von den Bell Laboratories das UNIX-Betriebssystem entwickelten. Es wurde später in C neu geschrieben, um es portabler zu machen, und wurde schließlich zu einem weit verbreiteten Betriebssystem. \n\nEin Jahrzehnt später begann Richard Stallman mit der Arbeit am GNU (GNU ist kein UNIX)-Projekt, dem GNU-Kernel namens Hurd, der leider nie fertiggestellt wurde. Als Ergebnis davon wurde auch die GNU General Public License (GPL), eine freie Softwarelizenz, erstellt. \n\nDer Kernel ist das wichtigste Stück im Betriebssystem. Er ermöglicht es der Hardware, mit der Software zu kommunizieren. Er erledigt auch noch eine ganze Menge anderer Dinge, aber darauf werden wir in einem anderen Kurs eingehen. Vorläufig sei nur gesagt, dass der Kernel praktisch alles kontrolliert, was auf deinem System passiert. \n\nWährend dieser Zeit wurden auch andere Bemühungen wie BSD, MINIX usw. entwickelt, um UNIX-ähnliche Systeme zu sein. Eines hatten jedoch alle diese UNIX-ähnlichen Systeme gemeinsam: das Fehlen eines vereinheitlichten Kernels. \n\nDann, im Jahr 1991, begann ein junger Mann namens Linus Torvalds mit der Entwicklung dessen, was wir heute als den Linux-Kernel kennen.",
          "quizAnswer": "Linus Torvalds",
          "quizQuestion": "Wer hat den Linux-Kernel entwickelt?",
          "slug": "linuxhistory",
          "title": "Geschichte"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 2,
          "lessonContent": "Im vorherigen Lektion haben wir über den Linux-Kernel gelernt, der täglich Millionen von Geräten antreibt. Etwas, bevor wir weitermachen, der Begriff Linux ist tatsächlich ein Missverständnis, da er sich eigentlich auf den Linux-Kernel bezieht. Viele Distributionen verwenden jedoch den Linux-Kernel und sind daher allgemein als Linux-Betriebssysteme bekannt. \n\nEin Linux-System ist in drei Hauptteile unterteilt:\n\n<ul>\n<li>Hardware - Dies umfasst alle Hardware, auf der Ihr System läuft, sowie Speicher, CPU, Festplatten usw.</li>\n<li>Linux-Kernel - Wie bereits erwähnt, ist der Kernel das Herzstück des Betriebssystems. Er verwaltet die Hardware und sagt ihr, wie sie mit dem System interagieren soll.</li>\n<li>User Space - Hier werden Benutzer wie Sie direkt mit dem System interagieren.</li>\n</ul>\n\nDer erste Schritt, den wir unternehmen müssen, ist die Installation von Linux auf Ihrem Rechner. Sie haben viele Optionen zur Auswahl, und dieser Kurs wird Sie informieren und Ihnen helfen, bei der Auswahl einer Linux-Distribution zu beginnen. \n\nEs gibt viele Linux-Distributionen zur Auswahl, wir werden nur die beliebtesten Optionen durchgehen.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, überspringen!",
          "slug": "auswahleinerlinuxdistribution",
          "title": "Die Auswahl einer Linux-Distribution"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Debian als Ihr Betriebssystem zu haben, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Übersicht</b>\nDebian ist ein Betriebssystem, das ausschließlich aus freier und quelloffener Software besteht. Es ist weit verbreitet und wird seit über 20 Jahren entwickelt. Es gibt drei Zweige, die Sie verwenden können: Stabil, Testen und Unstabil. \n\nStabil ist insgesamt ein guter Zweig, auf dem man sich befinden kann. Testen und Unstabil sind Rolling Releases. Das bedeutet, dass alle inkrementellen Änderungen in diesen Zweigen letztendlich stabil werden. Wenn Sie beispielsweise von Windows 8 auf Windows 10 aktualisieren möchten, müssen Sie eine vollständige Windows 10-Installation durchführen. Wenn Sie jedoch auf der Testversion sind, erhalten Sie automatisch Updates, bis es zur nächsten Betriebssystemversion wird, ohne eine vollständige Installation durchführen zu müssen. \n\n<b>Paketverwaltung</b>\nDebian verwendet auch Debian-Paketverwaltungstools. Jede Linux-Distribution installiert und verwaltet Pakete auf unterschiedliche Weise und verwendet unterschiedliche Paketverwaltungstools. Darauf werden wir in einem späteren Kurs genauer eingehen. \n\n<b>Konfigurierbarkeit</b>\nDebian erhält möglicherweise nicht die neuesten Updates, ist jedoch äußerst stabil. Wenn Sie ein gutes \"Kern\"-Betriebssystem möchten, ist dies das Richtige für Sie.\n\n<b>Verwendungszwecke</b>\nDebian ist insgesamt ein großartiges Betriebssystem für jede Plattform.",
          "quizAnswer": "Rolling",
          "quizQuestion": "Welche Art von Release haben Testen und Unstabil?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, RHEL als Ihr Betriebssystem zu haben, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Überblick</b>\nRed Hat Enterprise Linux, häufig als RHEL bezeichnet, wird von Red Hat entwickelt. RHEL hat strenge Regeln, um die kostenlose Weiterverteilung einzuschränken, obwohl es den Quellcode immer noch kostenlos zur Verfügung stellt.\n\n<b>Paketverwaltung</b>\nRHEL verwendet einen anderen Paketmanager als Debian, den RPM-Paketmanager, den wir schließlich auch kennenlernen werden.\n\n<b>Konfigurierbarkeit</b>\nRHEL-basierte Betriebssysteme werden sich geringfügig von den auf Debian basierenden Betriebssystemen unterscheiden, am deutlichsten bei der Paketverwaltung. Wenn Sie sich für RHEL entscheiden, ist es wahrscheinlich am besten, wenn Sie wissen, dass Sie damit arbeiten werden.\n\n<b>Verwendung</b>\nWie der Name schon sagt, wird es hauptsächlich in Unternehmen verwendet. Wenn Sie also ein solides Server-Betriebssystem benötigen, wäre dies eine gute Wahl.",
          "quizAnswer": "RPM",
          "quizQuestion": "Welchen Paketmanager verwendet RHEL?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Ubuntu als Ihr Betriebssystem zu haben, gehen Sie zum Installationsabschnitt und probieren Sie es aus: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Überblick</b>\nEine der beliebtesten Linux-Distributionen für persönliche Computer ist Ubuntu. Ubuntu veröffentlicht auch standardmäßig seinen eigenen Desktop-Umgebung-Manager Unity. \n\n<b>Paketverwaltung</b>\nUbuntu ist ein auf Debian basierendes Betriebssystem, das von Canonical entwickelt wurde. Es verwendet daher ein Kern-Debian-Paketverwaltungssystem.\n\n<b>Konfigurierbarkeit</b>\nUbuntu ist eine großartige Wahl für Anfänger, die in Linux einsteigen möchten. Ubuntu bietet Benutzerfreundlichkeit und eine großartige Benutzeroberfläche, was zu seiner weiten Verbreitung geführt hat. Es wird weit verbreitet und unterstützt und ist in Bezug auf die Benutzerfreundlichkeit den meisten anderen Betriebssystemen wie OSX und Windows ähnlich.\n\n<b>Verwendungen</b>\nGroßartig für jede Plattform, Desktop, Laptop und Server.",
          "quizAnswer": "Debian",
          "quizQuestion": "Worin basiert das Betriebssystem Ubuntu?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Fedora als Ihr Betriebssystem zu haben, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Überblick</b>\nUnterstützt von Red Hat ist das Fedora-Projekt communitygetrieben und enthält Open-Source- und kostenlose Software. Red Hat Enterprise Linux verzweigt sich von Fedora ab, daher kann man Fedora als ein Upstream-RHEL-Betriebssystem betrachten. Letztendlich erhält RHEL nach gründlichen Tests und Qualitätssicherung Updates von Fedora. Denken Sie bei Fedora an eine Ubuntu-Äquivalente, die anstelle von Debian ein Red-Hat-Backend verwendet.\n\n<b>Paketverwaltung</b>\nVerwendet den Red Hat Paketmanager.\n\n<b>Konfigurierbarkeit</b>\nWenn Sie ein auf Red Hat basierendes Betriebssystem verwenden möchten, ist dies eine benutzerfreundliche Version.\n\n<b>Verwendung</b>\nFedora ist großartig, wenn Sie ein auf Red Hat basierendes Betriebssystem ohne Preisschild möchten. Empfohlen für Desktop und Laptop.",
          "quizAnswer": "Fedora",
          "quizQuestion": "Wovon verzweigt sich RHEL ab?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Linux Mint als Ihr Betriebssystem zu verwenden, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Überblick</b>\nLinux Mint basiert auf Ubuntu. Es verwendet Ubuntus Software-Repositories, sodass dieselben Pakete in beiden Distributionen verfügbar sind. Linux Mint wird von anderen bevorzugt gegenüber Ubuntu, da es nicht mit einigen proprietären Softwareanwendungen geliefert wird, die Ubuntu enthält, wie z.B. Unity.\n\n<b>Paketverwaltung</b>\nDa Linux Mint auf Ubuntu basiert, verwendet es den Debian-Paketmanager.\n\n<b>Konfigurierbarkeit</b>\nGroßartige Benutzeroberfläche, ideal für Anfänger und weniger aufgebläht als Ubuntu. In diesem Kurs werde ich Linux Mint verwenden, aber jede andere Distribution kann ebenfalls verwendet werden.\n\n<b>Verwendung</b>\nIdeal für Desktop und Laptop.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "Worauf basiert Linux Mint?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Gentoo als Ihr Betriebssystem zu haben, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Übersicht</b>\nGentoo bietet eine unglaubliche Flexibilität beim Betriebssystem zu einem Preis. Es ist für fortgeschrittene Benutzer gemacht, die keine Angst davor haben, sich die Hände schmutzig zu machen.\n\n<b>Paketverwaltung</b>\nGentoo verwendet seine eigene Paketverwaltung, Portage. Die Portage-Paketverwaltung ist sehr modular und einfach zu pflegen, was einen großen Teil der Gesamtflexibilität des Betriebssystems ausmacht.\n\n<b>Anpassbarkeit</b>\nWenn Sie gerade erst mit Linux anfangen und einen schwierigeren Weg einschlagen möchten, würde ich Gentoo oder Arch Linux als Ihre Distribution wählen.\n\n<b>Verwendungszwecke</b>\nHervorragend für Desktop und Laptop.",
          "quizAnswer": "Portage",
          "quizQuestion": "Welches Paketverwaltungssystem verwendet Gentoo?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Wenn Sie daran interessiert sind, Arch als Ihr Betriebssystem zu verwenden, gehen Sie zum Installationsabschnitt und probieren Sie es aus: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Übersicht</b>\nArch ist eine leichte und flexible Linux-Distribution, die zu 100% von der Community getrieben wird. Ähnlich wie Debian verwendet Arch ein Rolling-Release-Modell, sodass inkrementelle Updates schließlich zur stabilen Version werden. Sie müssen wirklich selbst Hand anlegen, um das System und seine Funktionen zu verstehen, erhalten aber dafür vollständige Kontrolle über Ihr System.\n\n<b>Paketverwaltung</b>\nEs verwendet seinen eigenen Paketmanager, Pacman, um Pakete zu installieren, zu aktualisieren und zu verwalten.\n\n<b>Anpassungsfähigkeit</b>\nWenn Sie ein leichtgewichtiges Betriebssystem möchten und Linux wirklich verstehen wollen, nutzen Sie Arch! Es gibt eine gewisse Lernkurve, aber für die Hardcore-Linux-Benutzer ist dies eine großartige Wahl.\n\n<b>Verwendungszwecke</b>\nIdeal für Desktops und Laptops. Wenn Sie auch ein kleines Gerät wie einen Raspberry Pi haben und ein leichtgewichtiges Betriebssystem darauf installieren müssen, machen Sie mit Arch nichts falsch.",
          "quizAnswer": "Pacman",
          "quizQuestion": "Welchen Paketmanager verwendet Arch Linux?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Wenn Sie openSUSE als Ihr Betriebssystem verwenden möchten, besuchen Sie die Download-Seite und probieren Sie es aus: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Übersicht</b>\nopenSUSE Linux wird vom openSUSE-Projekt erstellt. Eine Gemeinschaft, die die Verwendung von Linux überall fördert, zusammenarbeitet in offener, transparenter und freundlicher Weise als Teil der weltweiten Gemeinschaft für freie und Open-Source-Software. openSUSE ist die zweitälteste noch laufende Linux-Distribution und teilt das Basissystem mit den preisgekrönten SUSE Linux Enterprise-Produkten.\n\n<b>Paketverwaltung</b>\nVerwendet den RPM-Paketmanager.\n\n<b>Anpassungsfähigkeit</b>\nopenSUSE ist eine großartige Wahl für einen neuen Linux-Benutzer. Es bietet eine benutzerfreundliche grafische Installations-/Verwaltungsanwendung (<a href=\"http://yast.github.io/\">YaST</a>) und ein aufgeräumtes Basissystem, das einfach zu bearbeiten ist. openSUSE enthält alles, was Sie benötigen, um das Internet sorgenfrei vor Viren/Spyware zu genießen und Ihre Kreativität auszuleben, sei es mit Ihren Fotos, Videos, Musik oder Code.\n\n<b>Verwendung</b>\nopenSUSE Leap ist vollständig geeignet für die Verwendung auf einem Desktop-PC und Laptop.",
          "quizAnswer": "yast",
          "quizQuestion": "Wie lautet der Name des Administrations-/Installationswerkzeugs von openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Erste Schritte"
    },
    {
      "description": "Lernen Sie die Grundlagen der Befehlszeile, navigieren Sie durch Dateien, Verzeichnisse und mehr.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Probiere einige andere Linux-Befehle aus und sieh dir an, was sie ausgeben:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "Die Welt steht dir offen, oder genauer gesagt, die Shell steht dir offen. Was ist die Shell? Die Shell ist im Grunde ein Programm, das deine Befehle von der Tastatur entgegennimmt und sie an das Betriebssystem weiterleitet, um sie auszuführen. Wenn du jemals eine GUI verwendet hast, hast du wahrscheinlich Programme wie \"Terminal\" oder \"Konsole\" gesehen, dies sind nur Programme, die eine Shell für dich starten. Im Verlauf dieses gesamten Kurses werden wir die Wunder der Shell kennenlernen. \n\nIn diesem Kurs werden wir das Shell-Programm bash (Bourne Again Shell) verwenden, fast alle Linux-Distributionen werden standardmäßig zur bash-Shell wechseln. Es gibt andere Shells wie ksh, zsh, tsch, aber wir werden uns nicht mit diesen beschäftigen. \n\nLass uns gleich loslegen! Je nach Distribution kann sich dein Shell-Prompt ändern, aber größtenteils sollte er dem folgenden Format entsprechen:\n<pre>benutzername@rechnername:aktueller_ordner\npete@icebox:/home/pete $</pre>\n\nHast du das $ am Ende des Prompts bemerkt? Unterschiedliche Shells haben unterschiedliche Prompts, in unserem Fall steht das $ für einen normalen Benutzer, der Bash, Bourne oder Korn Shell verwendet. Du fügst das Prompt-Symbol nicht hinzu, wenn du den Befehl eingibst, du solltest nur wissen, dass es da ist.\n\nLass uns mit einem einfachen Befehl beginnen, echo. Der echo-Befehl gibt einfach die Textargumente auf dem Bildschirm aus.\n\n<pre>$ echo Hallo Welt</pre>",
          "quizAnswer": "Hallo Welt",
          "quizQuestion": "Was sollte auf dem Bildschirm ausgegeben werden, wenn du echo Hallo Welt eingibst?",
          "slug": "die-shell",
          "title": "Die Shell"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 2,
          "lessonContent": "Alles in Linux ist eine Datei. Wenn Sie tiefer in Linux eintauchen, werden Sie dies verstehen, aber behalten Sie es vorerst im Hinterkopf. Jede Datei ist innerhalb eines hierarchischen Verzeichnisbaums organisiert. Das erste Verzeichnis im Dateisystem trägt passenderweise den Namen 'Stammverzeichnis'. Das Stammverzeichnis enthält viele Ordner und Dateien, in denen Sie weitere Ordner und Dateien speichern können, und so weiter. Hier ist ein Beispiel, wie der Verzeichnisbaum aussieht: \n\n<pre>/\n|-- bin\n|   |-- file1\n|   |-- file2\n|-- etc\n|   |-- file3\n|   `-- directory1\n|       |-- file4\n|       `-- file5\n|-- home\n|-- var\n</pre>\n\nDie Positionen dieser Dateien und Verzeichnisse werden als 'Pfade' bezeichnet. Wenn Sie einen Ordner namens 'home' hätten, der einen Ordner namens 'pete' und einen weiteren Ordner in diesem Ordner namens 'Movies' enthält, würde dieser Pfad so aussehen: '/home/pete/Movies'. Ziemlich einfach, oder?\n\nDas Navigieren im Dateisystem, ähnlich wie im echten Leben, ist einfacher, wenn Sie wissen, wo Sie sind und wohin Sie gehen. Um zu sehen, wo Sie sich befinden, können Sie den Befehl 'pwd' verwenden. Dieser Befehl bedeutet 'Arbeitsverzeichnis drucken' und zeigt Ihnen, in welchem Verzeichnis Sie sich befinden. Beachten Sie, dass der Pfad vom Stammverzeichnis ausgeht.\n\n<pre>$ pwd</pre>\n\nWo bist du? Wo bin ich? Probieren Sie es aus.",
          "quizAnswer": "pwd",
          "quizQuestion": "Wie finde ich heraus, in welchem Verzeichnis Sie sich gerade befinden?",
          "slug": "printworkingdirectorypwdcommand",
          "title": "pwd (Print Working Directory)"
        },
        {
          "exercise": "<ol>\n<li>Führen Sie den cd-Befehl ohne Flags aus, wohin führt er Sie?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Jetzt, da Sie wissen, wo Sie sich befinden, schauen wir, ob wir uns im Dateisystem etwas bewegen können. Denken Sie daran, dass wir uns mithilfe von Pfaden navigieren müssen. Es gibt zwei verschiedene Möglichkeiten, einen Pfad anzugeben, mit absoluten und relativen Pfaden. \n\n<ul>\n<li>Absoluter Pfad: Dies ist der Pfad vom Wurzelverzeichnis aus. Die Wurzel ist der Chef. Das Wurzelverzeichnis wird normalerweise als Schrägstrich dargestellt. Jedes Mal, wenn Ihr Pfad mit / beginnt, bedeutet dies, dass Sie vom Wurzelverzeichnis aus starten. Zum Beispiel: /home/pete/Desktop.</li>\n\n<li>Relativer Pfad: Dies ist der Pfad von Ihrem aktuellen Standort im Dateisystem aus. Wenn ich mich zum Beispiel im Verzeichnis /home/pete/Documents befinde und in ein Verzeichnis namens taxes innerhalb von Documents wechseln möchte, muss ich nicht den gesamten Pfad von der Wurzel aus wie /home/pete/Documents/taxes angeben, sondern ich kann einfach zu taxes/ wechseln.</li>\n</ul>\n\nJetzt, da Sie wissen, wie Pfade funktionieren, brauchen wir nur etwas, um uns in das Verzeichnis zu wechseln, in das wir möchten. Glücklicherweise haben wir cd oder „change directory“, um das zu tun. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nJetzt habe ich meinen Verzeichnisstandort auf /home/pete/Pictures geändert.\n\nVon diesem Verzeichnis aus habe ich einen Ordner namens Hawaii, zu dem ich mit folgendem Befehl navigieren kann:\n\n<pre>$ cd Hawaii</pre>\n\nBeachten Sie, wie ich einfach den Namen des Ordners verwendet habe? Das liegt daran, dass ich bereits in /home/pete/Pictures war.\n\nEs kann ziemlich anstrengend sein, die ganze Zeit mit absoluten und relativen Pfaden zu navigieren, zum Glück gibt es einige Abkürzungen, die Ihnen helfen können. \n\n<ul>\n<li>. (aktuelles Verzeichnis). Dies ist das Verzeichnis, in dem Sie sich gerade befinden.</li>\n<li>.. (vorheriges Verzeichnis). Bringt Sie in das übergeordnete Verzeichnis Ihres aktuellen Verzeichnisses.</li>\n<li>~ (Home-Verzeichnis). Dieses Verzeichnis entspricht standardmäßig Ihrem „Home-Verzeichnis“. Zum Beispiel: /home/pete.</li>\n<li>- (vorheriges Verzeichnis). Dies bringt Sie in das vorherige Verzeichnis, in dem Sie gerade waren.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nProbieren Sie sie aus!",
          "quizAnswer": "cd ..",
          "quizQuestion": "Wenn Sie sich in /home/pete/Pictures befinden und nach /home/pete wechseln möchten, welche Abkürzung ist nützlich?",
          "slug": "changedirectorycdcommand",
          "title": "cd (Change Directory)"
        },
        {
          "exercise": "Führen Sie ls mit verschiedenen Flags aus und sehen Sie die Ausgabe, die Sie erhalten.",
          "id": 4,
          "lessonContent": "Jetzt, da wir wissen, wie wir uns im System bewegen, wie finden wir heraus, was uns zur Verfügung steht? Im Moment ist es, als würden wir im Dunkeln herumirren. Nun, wir können den wunderbaren ls-Befehl verwenden, um den Inhalt von Verzeichnissen aufzulisten. Der ls-Befehl listet standardmäßig Verzeichnisse und Dateien im aktuellen Verzeichnis auf, jedoch können Sie angeben, welchen Pfad Sie auflisten möchten.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls ist ein ziemlich nützliches Werkzeug, es zeigt Ihnen auch detaillierte Informationen über die Dateien und Verzeichnisse, die Sie betrachten.\n\nBeachten Sie auch, dass nicht alle Dateien in einem Verzeichnis sichtbar sind. Dateinamen, die mit . beginnen, sind versteckt, Sie können sie jedoch mit dem ls-Befehl anzeigen und das -a-Flag (a für alle) übergeben.\n\n<pre>$ ls -a</pre>\n\nEs gibt auch noch ein weiteres nützliches ls-Flag, -l für lang, das zeigt eine detaillierte Liste von Dateien im Langformat an. Dies zeigt Ihnen detaillierte Informationen, beginnend von links: Dateiberechtigungen, Anzahl der Verknüpfungen, Besitzername, Besitzergruppe, Dateigröße, Zeitstempel der letzten Änderung und Datei-/Verzeichnisname.\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ngesamt 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Okt 19 10:46  Dokumente\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Okt  7 13:13   Musik\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Bilder\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Öffentlich\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Vorlagen\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nBefehle haben sogenannte Flags (oder Argumente oder Optionen, wie auch immer Sie es nennen möchten), um mehr Funktionalität hinzuzufügen. Sehen Sie, wie wir -a und -l hinzugefügt haben, nun, Sie können sie beide zusammen mit -la hinzufügen. Die Reihenfolge der Flags bestimmt, in welcher Reihenfolge sie erscheinen, meistens spielt dies keine Rolle, sodass Sie auch ls -al ausführen können und es würde trotzdem funktionieren.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "Welchen Befehl würden Sie verwenden, um versteckte Dateien zu sehen?",
          "slug": "verzeichnisselsbefehl",
          "title": "ls (Verzeichnisse auflisten)"
        },
        {
          "exercise": "<ol>\n<li>Erstelle eine neue Datei</li>\n<li>Notiere den Zeitstempel</li>\n<li>Touch die Datei und überprüfe erneut den Zeitstempel</li>\n</ol>",
          "id": 5,
          "lessonContent": "Lass uns lernen, wie man einige Dateien erstellt. Ein sehr einfacher Weg ist die Verwendung des touch-Befehls. Touch ermöglicht es, neue leere Dateien zu erstellen.\n\n<pre>$ touch mysuperduperfile</pre>\n\nUnd zack, neue Datei!\n\nTouch wird auch verwendet, um Zeitstempel auf vorhandenen Dateien und Verzeichnissen zu ändern. Probier es aus, führe ein ls -l auf einer Datei durch und notiere den Zeitstempel, dann touch diese Datei und der Zeitstempel wird aktualisiert.\n\nEs gibt viele andere Möglichkeiten, Dateien zu erstellen, die andere Dinge wie Umleitung und Texteditoren beinhalten, aber darauf werden wir im Kurs zur Textmanipulation eingehen.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "Wie erstellt man eine Datei namens myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Führen Sie den Befehl file in einigen verschiedenen Verzeichnissen und Dateien aus und notieren Sie die Ausgabe.",
          "id": 6,
          "lessonContent": "In der vorherigen Lektion haben wir über touch gelernt, lassen Sie uns kurz darauf zurückkommen. Haben Sie bemerkt, dass der Dateiname nicht dem Standardnamensschema entsprach, wie Sie es wahrscheinlich von anderen Betriebssystemen wie Windows kennen? Normalerweise würden Sie erwarten, dass eine Datei namens banana.jpeg vorliegt und eine JPEG-Bilddatei erwarten. \n\nIn Linux müssen Dateinamen nicht den Inhalt der Datei repräsentieren. Sie können eine Datei namens funny.gif erstellen, die tatsächlich kein GIF ist. \n\nUm herauszufinden, um welche Art von Datei es sich handelt, können Sie den Befehl file verwenden. Er zeigt Ihnen eine Beschreibung des Dateiinhalts an.\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um den Dateityp einer Datei zu finden?",
          "slug": "filecommand",
          "title": "Datei"
        },
        {
          "exercise": "Führen Sie cat auf verschiedenen Dateien und Verzeichnissen aus. Versuchen Sie dann, mehrere Dateien zu caten.",
          "id": 7,
          "lessonContent": "Wir sind fast fertig mit der Navigation durch Dateien, aber zuerst lernen wir, wie man eine Datei liest. Ein einfacher Befehl, den man verwenden kann, ist der Katzenbefehl, kurz für verketten. Er zeigt nicht nur den Dateiinhalt an, sondern kann auch mehrere Dateien kombinieren und dir deren Ausgabe anzeigen. \n\n<pre>$ cat hunddatei vogeldatei</pre>\n\nEr eignet sich nicht gut zum Anzeigen großer Dateien und ist nur für kurze Inhalte gedacht. Es gibt viele andere Tools, die wir verwenden, um größere Textdateien anzuzeigen, über die wir im nächsten Lektion sprechen werden.",
          "quizAnswer": "cat",
          "quizQuestion": "Was ist eine gute Möglichkeit, den Inhalt einer Datei zu sehen?",
          "slug": "catcommand",
          "title": "Katze"
        },
        {
          "exercise": "Führen Sie less auf einer Datei aus, blättern Sie dann im Dokument nach oben und unten. Versuchen Sie, nach einem bestimmten Wort zu suchen. Navigieren Sie schnell zum Anfang oder zum Ende der Datei.",
          "id": 8,
          "lessonContent": "Wenn Sie Textdateien anzeigen, die größer sind als eine einfache Ausgabe, ist less mehr. (Es gibt tatsächlich einen Befehl namens more, der etwas Ähnliches tut, daher ist dies ironisch.) Der Text wird seitenweise angezeigt, sodass Sie durch eine Textdatei Seite für Seite navigieren können. \n\nSchauen Sie sich den Inhalt einer Datei mit less an. Sobald Sie im less-Befehl sind, können Sie tatsächlich andere Tastaturbefehle verwenden, um in der Datei zu navigieren. \n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nVerwenden Sie den folgenden Befehl, um durch less zu navigieren: \n\n<ul>\n<li>q - Wird verwendet, um less zu beenden und zum Shell zurückzukehren.</li>\n<li>Seite nach oben, Seite nach unten, Hoch und Runter - Navigation mit den Pfeiltasten und Seitentasten.</li>\n<li>g - Bewegt sich zum Anfang der Textdatei.</li>\n<li>G - Bewegt sich zum Ende der Textdatei.</li>\n<li>/Suche - Sie können nach einem bestimmten Text innerhalb des Textdokuments suchen. Voranstellen der Wörter, nach denen Sie suchen möchten, mit /</li>\n<li>h - Wenn Sie während der Verwendung von less etwas Hilfe benötigen, verwenden Sie help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "Wie beenden Sie einen less-Befehl?",
          "slug": "lesscommand",
          "title": "less"
        },
        {
          "exercise": "Navigieren Sie mit den Pfeiltasten nach oben und unten durch Ihren vorherigen Befehlsverlauf. Probieren Sie die Strg-R-Rückwärtssuche aus.",
          "id": 9,
          "lessonContent": "In Ihrer Shell gibt es einen Verlauf der Befehle, die Sie zuvor eingegeben haben. Sie können tatsächlich durch diese Befehle blättern. Dies ist sehr nützlich, wenn Sie einen zuvor verwendeten Befehl finden und ausführen möchten, ohne ihn erneut eingeben zu müssen.\n\n<pre>$ history</pre>\n\nMöchten Sie denselben Befehl ausführen, den Sie zuvor ausgeführt haben? Drücken Sie einfach den Pfeil nach oben.\n\nMöchten Sie den vorherigen Befehl ohne erneute Eingabe ausführen? Verwenden Sie !!. Wenn Sie z. B. cat file1 eingegeben haben und ihn erneut ausführen möchten, können Sie einfach !! eingeben und der zuletzt ausgeführte Befehl wird ausgeführt.\n\nEine weitere Verlauf-Verknüpfung ist Strg-R, dies ist der Rückwärtssuchbefehl. Wenn Sie Strg-R drücken und mit der Eingabe des Befehls beginnen, den Sie möchten, werden Übereinstimmungen angezeigt und Sie können durch Drücken der Strg-R-Taste erneut durch sie navigieren. Sobald Sie den Befehl gefunden haben, den Sie erneut verwenden möchten, drücken Sie einfach die Eingabetaste.\n\nUnser Terminal wird ein wenig unübersichtlich, oder? Lassen Sie uns aufräumen, verwenden Sie den Befehl clear, um Ihren Bildschirm aufzuräumen.\n\n<pre>$ clear</pre>\n\nSieht das nicht besser aus? \n\nWährend wir über nützliche Dinge sprechen, ist eine der nützlichsten Funktionen in jeder Befehlszeilenumgebung die Tab-Vervollständigung. Wenn Sie mit der Eingabe eines Befehls, einer Datei, eines Verzeichnisses usw. beginnen und die Tab-Taste drücken, wird basierend auf dem gefundenen Inhalt im Verzeichnis, das Sie durchsuchen, automatisch vervollständigt, solange Sie keine anderen Dateien haben, die mit diesen Buchstaben beginnen. Wenn Sie z. B. versuchen, den Befehl chrome auszuführen, können Sie chr eingeben und die Tab-Taste drücken, um chrome automatisch zu vervollständigen.",
          "quizAnswer": "clear",
          "quizQuestion": "Wie lautet der Befehl, um das Terminal zu leeren?",
          "slug": "historycommand",
          "title": "Verlauf"
        },
        {
          "exercise": "Kopieren Sie ein paar Dateien, achten Sie darauf, nichts Wichtiges zu überschreiben.",
          "id": 10,
          "lessonContent": "Lassen Sie uns damit beginnen, einige Kopien dieser Dateien zu erstellen. Ähnlich wie beim Kopieren und Einfügen von Dateien in anderen Betriebssystemen bietet die Shell uns eine noch einfachere Möglichkeit, dies zu tun. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile ist die Datei, die Sie kopieren möchten, und /home/pete/Documents/cooldocs ist der Zielort der Kopie.\n\nSie können auch mehrere Dateien und Verzeichnisse kopieren sowie Platzhalter verwenden. Ein Platzhalter ist ein Zeichen, das für eine Muster-basierte Auswahl eingesetzt werden kann und Ihnen mehr Flexibilität bei Suchvorgängen bietet. Sie können Platzhalter in jedem Befehl verwenden, um flexibler zu sein.\n\n<ul>\n<li>* der Platzhalter der Platzhalter, er wird verwendet, um alle einzelnen Zeichen oder beliebige Zeichenfolgen darzustellen.</li>\n<li>? wird verwendet, um ein Zeichen darzustellen</li>\n<li>[] wird verwendet, um jedes Zeichen innerhalb der Klammern darzustellen</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nDies kopiert alle Dateien mit der Erweiterung .jpg in Ihrem aktuellen Verzeichnis in das Verzeichnis Pictures.\n\nEin nützlicher Befehl ist die Verwendung des -r Flags, dies kopiert die Dateien und Verzeichnisse innerhalb eines Verzeichnisses rekursiv. \n\nVersuchen Sie, ein cp auf ein Verzeichnis durchzuführen, das ein paar Dateien enthält, in Ihr Documents-Verzeichnis. Hat nicht funktioniert, oder? Nun, das liegt daran, dass Sie die Dateien und Verzeichnisse darin auch mit dem -r Befehl kopieren müssen.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nEine Sache ist zu beachten: Wenn Sie eine Datei in ein Verzeichnis kopieren, das denselben Dateinamen hat, wird die Datei mit dem überschrieben, was Sie gerade kopieren. Das ist nicht gut, wenn Sie eine Datei haben, die Sie nicht versehentlich überschreiben möchten. Sie können das -i Flag (interaktiv) verwenden, um vor dem Überschreiben einer Datei eine Abfrage zu erhalten. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Welches Flag müssen Sie angeben, um ein Verzeichnis zu kopieren?",
          "slug": "copycpcommand",
          "title": "cp (Kopieren)"
        },
        {
          "exercise": "Benennen Sie eine Datei um und verschieben Sie dann diese Datei in ein anderes Verzeichnis.",
          "id": 11,
          "lessonContent": "Wird zum Verschieben von Dateien und auch zum Umbenennen verwendet. In Bezug auf Flags und Funktionalität ähnelt es dem cp-Befehl. \n\nSie können Dateien wie folgt umbenennen:\n\n<pre>$ mv alteDatei neueDatei</pre>\n\nOder Sie können eine Datei tatsächlich in ein anderes Verzeichnis verschieben: \n\n<pre>$ mv datei2 /home/pete/Dokumente</pre>\n\nUnd mehr als eine Datei verschieben:\n\n<pre>$ mv datei_1 datei_2 /irgendeinVerzeichnis</pre>\n\nSie können auch Verzeichnisse umbenennen:\n\n<pre>$ mv verzeichnis1 verzeichnis2</pre>\n\nWie bei cp, wenn Sie eine Datei oder ein Verzeichnis verschieben, wird alles im selben Verzeichnis überschrieben. Sie können also das -i-Flag verwenden, um eine Warnung vor dem Überschreiben zu erhalten.\n\n<pre>mv -i verzeichnis1 verzeichnis2</pre>\n\nAngenommen, Sie möchten tatsächlich eine Datei verschieben, um die vorherige zu überschreiben. Sie können auch ein Backup dieser Datei erstellen und die alte Version einfach mit einem ~ umbenennen. \n\n<pre>$ mv -b verzeichnis1 verzeichnis2</pre>",
          "quizAnswer": "mv cat dog",
          "quizQuestion": "Wie benennen Sie eine Datei namens cat in dog um?",
          "slug": "movemvcommand",
          "title": "mv (Verschieben)"
        },
        {
          "exercise": "Erstellen Sie ein paar Verzeichnisse und verschieben Sie einige Dateien in dieses Verzeichnis.",
          "id": 12,
          "lessonContent": "Wir werden einige Verzeichnisse benötigen, um all diese Dateien zu speichern, an denen wir gearbeitet haben. Der mkdir-Befehl (Make Directory) ist dafür nützlich, er erstellt ein Verzeichnis, wenn es noch nicht existiert. Sie können sogar mehrere Verzeichnisse gleichzeitig erstellen.\n\n<pre>$ mkdir Bücher Gemälde</pre>\n\nSie können auch Unterverzeichnisse gleichzeitig mit dem -p (Eltern-Flag) erstellen.\n\n<pre>$ mkdir -p Bücher/hemmingway/favoriten</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Verzeichnis zu erstellen?",
          "slug": "verzeichniserstellenmkdirbefehl",
          "title": "mkdir (Verzeichnis erstellen)"
        },
        {
          "exercise": "<ol>\n<li>Erstelle eine Datei namens -datei (vergiss das Minuszeichen nicht!).</li>\n<li>Entferne diese Datei.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Jetzt denke ich, dass wir zu viele Dateien haben, lass uns also einige Dateien entfernen. Um Dateien zu entfernen, kannst du den rm-Befehl verwenden. Der rm (remove)-Befehl wird verwendet, um Dateien und Verzeichnisse zu löschen. \n\n<pre>$ rm datei1</pre>\n\nSei vorsichtig beim Verwenden von rm, es gibt keinen magischen Papierkorb, aus dem du entfernte Dateien wiederherstellen kannst. Wenn sie weg sind, sind sie für immer weg, also sei vorsichtig. \n\nGlücklicherweise gibt es einige Sicherheitsmaßnahmen, damit der Durchschnittsbürger nicht einfach eine Menge wichtiger Dateien löschen kann. Schreibgeschützte Dateien fordern dich zur Bestätigung auf, bevor sie gelöscht werden. Wenn ein Verzeichnis schreibgeschützt ist, kann es auch nicht einfach entfernt werden. \n\nWenn dir das egal ist, kannst du absolut eine Menge Dateien löschen. \n\n<pre>$ rm -f datei1</pre>\n\nDie -f- oder Force-Option fordert rm auf, alle Dateien zu entfernen, unabhängig davon, ob sie schreibgeschützt sind oder nicht, ohne den Benutzer zur Bestätigung aufzufordern (solange du die entsprechenden Berechtigungen hast).\n\n<pre>$ rm -i datei</pre>\n\nWenn du die -i-Flagge wie bei vielen anderen Befehlen hinzufügst, erhältst du eine Aufforderung, ob du die Dateien oder Verzeichnisse tatsächlich entfernen möchtest. \n\n<pre>$ rm -r verzeichnis</pre>\n\nDu kannst ein Verzeichnis standardmäßig nicht einfach mit rm löschen, du musst die -r-Flagge (rekursiv) hinzufügen, um alle Dateien und eventuelle Unterverzeichnisse zu entfernen.\n\nDu kannst ein Verzeichnis mit dem rmdir-Befehl entfernen.\n\n<pre>$ rmdir verzeichnis</pre>",
          "quizAnswer": "",
          "quizQuestion": "Wie entfernst du eine Datei namens myfile?",
          "slug": "removermcommand",
          "title": "rm (Entfernen)"
        },
        {
          "exercise": "<ol>\n<li>Suchen Sie eine Datei im Stammverzeichnis, die das Wort net enthält.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Mit all diesen Dateien, die wir im System haben, kann es ein wenig hektisch werden, wenn man versucht, eine bestimmte zu finden. Nun, es gibt einen Befehl, den wir dafür verwenden können, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nMit find müssen Sie das Verzeichnis angeben, in dem Sie suchen werden, wonach Sie suchen, in diesem Fall versuchen wir, eine Datei mit dem Namen puppies.jpg zu finden. \n\nSie können angeben, nach welchem Dateityp Sie suchen. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nSie sehen, dass ich den Dateityp, nach dem ich suche, als (d) für Verzeichnis festgelegt habe und immer noch nach dem Namen MyFolder suche. \n\nEine coole Sache ist, dass find nicht am Verzeichnis, in dem Sie suchen, haltmacht, sondern auch in allen Unterverzeichnissen dieses Verzeichnisses sucht.",
          "quizAnswer": "-name",
          "quizQuestion": "Welche Option sollte ich für find angeben, wenn ich nach Namen suchen möchte?",
          "slug": "findcommand",
          "title": "find"
        },
        {
          "exercise": "Führen Sie Hilfe für den echo-Befehl, den logout-Befehl und den pwd-Befehl aus.",
          "id": 15,
          "lessonContent": "Linux verfügt über einige großartige integrierte Tools, um Ihnen zu helfen, wie Sie ein Befehl verwenden oder welche Optionen für einen Befehl verfügbar sind. Ein Tool, Hilfe, ist ein integrierter Bash-Befehl, der Hilfe für andere Bash-Befehle (echo, logout, pwd usw.) bereitstellt.\n\n<pre>$ help echo</pre>\n\nDies gibt Ihnen eine Beschreibung und die Optionen, die Sie verwenden können, wenn Sie echo ausführen möchten. Für andere ausführbare Programme ist es üblich, eine Option namens --help oder etwas Ähnliches zu haben. \n\n<pre>$ echo --help</pre>\n\nNicht alle Entwickler, die ausführbare Programme bereitstellen, werden sich an diesen Standard halten, aber es ist wahrscheinlich Ihr bester Schuss, um Hilfe zu einem Programm zu finden.",
          "quizAnswer": "help",
          "quizQuestion": "Wie erhalten Sie schnelle Befehlszeilenhilfe für integrierte Bash-Befehle?",
          "slug": "helpcommand",
          "title": "Hilfe"
        },
        {
          "exercise": "Führen Sie den man Befehl auf den ls Befehl aus.",
          "id": 16,
          "lessonContent": "Ich wünschte, einige dieser Programme hätten ein Handbuch, damit wir mehr Informationen über sie sehen können. Zum Glück haben sie das! Passenderweise als man pages bezeichnet, können Sie die Handbücher für einen Befehl mit dem man Befehl anzeigen. \n\n<pre>$ man ls</pre>\n\nMan pages sind Handbücher, die standardmäßig in den meisten Linux-Betriebssystemen integriert sind. Sie bieten Dokumentationen zu Befehlen und anderen Aspekten des Systems. \n\nProbieren Sie es mit einigen Befehlen aus, um mehr Informationen über sie zu erhalten.",
          "quizAnswer": "man",
          "quizQuestion": "Wie sehen Sie die Handbücher für einen Befehl?",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Führen Sie den whatis-Befehl für den less-Befehl aus.",
          "id": 17,
          "lessonContent": "Puh, wir haben bisher ziemlich viele Befehle gelernt. Wenn Sie jemals Zweifel darüber haben, was ein Befehl tut, können Sie den whatis-Befehl verwenden. Der whatis-Befehl liefert eine kurze Beschreibung von Befehlszeilenprogrammen. \n\n<pre>$ whatis cat</pre>\n\nDie Beschreibung stammt aus der Handbuchseite jedes Befehls. Wenn Sie whatis cat ausführen, sehen Sie eine kurze Beschreibung.",
          "quizAnswer": "whatis",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um eine kurze Beschreibung eines Befehls zu sehen?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "Erstellen Sie ein paar Aliase und entfernen Sie sie dann.",
          "id": 18,
          "lessonContent": "Manchmal kann das Tippen von Befehlen wirklich repetitiv werden, oder wenn Sie einen langen Befehl viele Male eingeben müssen, ist es am besten, ein Alias zu haben, das Sie dafür verwenden können. Um ein Alias für einen Befehl zu erstellen, geben Sie einfach einen Aliasnamen an und setzen ihn auf den Befehl. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nJetzt können Sie anstelle von ls -la foobar eingeben und der Befehl wird ausgeführt, ziemlich coole Sache. Beachten Sie, dass dieser Befehl Ihr Alias nach dem Neustart nicht speichert, daher müssen Sie ein dauerhaftes Alias in hinzufügen:\n\n<pre>~/.bashrc</pre>\n\noder ähnlichen Dateien, wenn Sie möchten, dass es nach dem Neustart bestehen bleibt.\n\nSie können Aliase mit dem Befehl unalias entfernen: \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Alias zu erstellen?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Beende die Shell und schau, was passiert. Stelle sicher, dass du in dieser Shell keine weiteren Arbeiten mehr erledigen musst.",
          "id": 19,
          "lessonContent": "Nun, du hast einen guten Job gemacht, um die Grundlagen zu meistern. Wir haben nur an der Oberfläche gekratzt. Jetzt, da du gelernt hast zu krabbeln, werde ich dir im nächsten Kurs beibringen, wie man läuft. \n\nFür den Moment kannst du dir auf die Schulter klopfen und eine Pause machen. Um aus der Shell auszusteigen, kannst du den exit Befehl verwenden\n\n<pre>$ exit</pre>\n\nOder den logout Befehl:\n\n<pre>$ logout</pre>\n\nOder wenn du in einer Terminal-GUI arbeitest, kannst du einfach das Terminal schließen. Bis zum nächsten Kurs!",
          "quizAnswer": "exit",
          "quizQuestion": "Wie kannst du aus der Shell aussteigen?",
          "slug": "exitcommand",
          "title": "Beenden"
        }
      ],
      "slug": "befehlszeile",
      "title": "Befehlszeile"
    },
    {
      "description": "Lernen Sie grundlegende Textmanipulation und Navigation.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Probieren Sie ein paar Befehle aus: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hallo Welt > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "Inzwischen sind wir mit vielen Befehlen und ihrer Ausgabe vertraut geworden, und das bringt uns zu unserem nächsten Thema: Ein- und Ausgabeströme (Input/Output-Streams). Führen wir den folgenden Befehl aus und besprechen, wie das funktioniert. \n\n<pre>$ echo Hallo Welt > peanuts.txt</pre>\n\nWas ist gerade passiert? Überprüfen Sie das Verzeichnis, in dem Sie diesen Befehl ausgeführt haben, und Sie sollten eine Datei namens peanuts.txt sehen. Schauen Sie in diese Datei hinein, und Sie sollten den Text Hallo Welt sehen. In einem Befehl sind viele Dinge passiert, also zerlegen wir ihn. \n\nLassen Sie uns zuerst den ersten Teil zerlegen: \n\n<pre>$ echo Hallo Welt</pre>\n\nWir wissen, dass dies Hallo Welt auf dem Bildschirm ausgibt, aber wie? Prozesse verwenden Ein- und Ausgabeströme, um Eingaben zu erhalten und Ausgaben zurückzugeben. Standardmäßig nimmt der echo-Befehl die Eingabe (Standard-Eingabe oder stdin) von der Tastatur entgegen und gibt die Ausgabe (Standardausgabe oder stdout) auf dem Bildschirm aus. Deshalb sehen Sie, wenn Sie echo Hallo Welt in Ihrer Shell eingeben, Hallo Welt auf dem Bildschirm. Die Umleitung von Ein- und Ausgaben ermöglicht es uns jedoch, dieses Standardverhalten zu ändern und bietet uns eine größere Dateiflexibilität. \n\nLassen Sie uns zum nächsten Teil des Befehls übergehen: \n\n<pre> > </pre>\n\nDas > ist ein Umleitungsoperator, der es uns ermöglicht, festzulegen, wohin die Standardausgabe geht. Er ermöglicht es uns, die Ausgabe von echo Hallo Welt an eine Datei anstelle des Bildschirms zu senden. Wenn die Datei noch nicht existiert, wird sie für uns erstellt. Wenn sie jedoch bereits existiert, wird sie überschrieben (je nach verwendeter Shell können Sie eine Shell-Flagge hinzufügen, um dies zu verhindern). \n\nUnd so funktioniert im Grunde die Umleitung von stdout!\n\nNun, sagen wir, ich möchte meine peanuts.txt nicht überschreiben, zum Glück gibt es auch einen Umleitungsoperator dafür, >>: \n\n<pre>$ echo Hallo Welt >> peanuts.txt</pre>\n\nDies fügt Hallo Welt am Ende der Datei peanuts.txt an. Wenn die Datei noch nicht existiert, wird sie für uns erstellt, wie es der >-Umleitungsoperator getan hat!",
          "quizAnswer": ">>",
          "quizQuestion": "Welchen Umleitungsoperator verwenden Sie, um die Ausgabe an eine Datei anzuhängen?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Probieren Sie ein paar Befehle aus:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "In unserer vorherigen Lektion haben wir gelernt, dass wir verschiedene stdout-Streams verwenden können, wie z.B. eine Datei oder den Bildschirm. Nun gibt es auch verschiedene Standard-Input (stdin)-Streams, die wir ebenfalls verwenden können. Wir wissen, dass wir stdin von Geräten wie der Tastatur haben, aber wir können auch Dateien, Ausgaben von anderen Prozessen und das Terminal verwenden, schauen wir uns ein Beispiel an. \n\nLassen Sie uns die Datei peanuts.txt aus der vorherigen Lektion für dieses Beispiel verwenden, erinnern Sie sich, sie enthielt den Text Hallo Welt. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nGenau wie wir <b>&gt;</b> für die stdout-Umleitung hatten, können wir <b>&lt;</b> für die stdin-Umleitung verwenden. \n\nNormalerweise senden Sie in dem cat-Befehl eine Datei an ihn und diese Datei wird dann zu stdin, in diesem Fall haben wir peanuts.txt umgeleitet, um unser stdin zu sein. Dann wird die Ausgabe von cat peanuts.txt, die Hallo Welt sein würde, in eine andere Datei namens banana.txt umgeleitet.",
          "quizAnswer": "<",
          "quizQuestion": "Welchen Umleiter verwenden Sie, um stdin umzuleiten?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Standard In)"
        },
        {
          "exercise": "Was macht der folgende Befehl? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Lassen Sie uns jetzt etwas Neues ausprobieren, versuchen wir den Inhalt eines Verzeichnisses aufzulisten, das auf Ihrem System nicht existiert, und leiten Sie die Ausgabe erneut in die Datei peanuts.txt um.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nWas Sie sehen sollten, ist: \n\n<pre>ls: kann auf /fake/directory nicht zugreifen: Datei oder Verzeichnis nicht gefunden</pre>\n\nJetzt denken Sie wahrscheinlich, sollte diese Nachricht nicht an die Datei gesendet worden sein? Tatsächlich gibt es hier einen weiteren E/A-Stream namens Standardfehler (stderr). Standardmäßig sendet stderr seine Ausgabe ebenfalls auf den Bildschirm, es handelt sich um einen völlig anderen Stream als stdout. Sie müssen also seine Ausgabe auf eine andere Weise umleiten. \n\nLeider ist der Umleiter nicht so nett wie die Verwendung von <b>&lt;</b> oder <b>&gt;</b>, aber er kommt dem nahe. Wir müssen Dateideskriptoren verwenden. Ein Dateideskriptor ist eine nicht negative Zahl, die verwendet wird, um auf eine Datei oder einen Stream zuzugreifen. Wir werden später ausführlich darauf eingehen, aber vorerst wissen Sie, dass der Dateideskriptor für stdin, stdout und stderr jeweils 0, 1 und 2 ist. \n\nWenn wir jetzt also unseren stderr in die Datei umleiten wollen, können wir dies tun: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nSie sollten nur die stderr-Nachrichten in peanuts.txt sehen. \n\nWas ist, wenn ich sowohl stderr als auch stdout in der peanuts.txt-Datei sehen möchte? Es ist auch möglich, dies mit Dateideskriptoren zu tun: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nDies sendet die Ergebnisse von ls /fake/directory an die Datei peanuts.txt und leitet dann stderr über 2>&1 an stdout weiter. Die Reihenfolge der Operationen ist hier wichtig, 2>&1 sendet stderr an das, worauf stdout zeigt. In diesem Fall zeigt stdout auf eine Datei, daher sendet 2>&1 stderr auch an eine Datei. Wenn Sie also die Datei peanuts.txt öffnen, sollten Sie sowohl stderr als auch stdout sehen. In unserem Fall gibt der obige Befehl nur stderr aus.\n\nEs gibt einen kürzeren Weg, um sowohl stdout als auch stderr in eine Datei umzuleiten:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nWas ist, wenn ich nichts davon haben möchte und die stderr-Nachrichten komplett loswerden möchte? Nun, Sie können die Ausgabe auch in eine spezielle Datei namens /dev/null umleiten, die jegliche Eingabe verwirft.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "Was ist der Umleiter für stderr?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Standard Error)"
        },
        {
          "exercise": "Versuchen Sie die folgenden Befehle: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Lassen Sie uns jetzt etwas über Sanitärinstallationen sprechen, nicht wirklich, aber irgendwie. Lassen Sie uns einen Befehl ausprobieren: \n\n<pre>$ ls -la /etc</pre>\n\nSie sollten eine sehr lange Liste von Elementen sehen, die eigentlich etwas schwer zu lesen ist. Anstatt diese Ausgabe in eine Datei umzuleiten, wäre es nicht schön, wenn wir die Ausgabe einfach in einem anderen Befehl wie less sehen könnten? Nun, das können wir! \n\n<pre>$ ls -la /etc | less </pre>\n\nDer Pipe-Operator |, dargestellt durch einen senkrechten Strich, ermöglicht es uns, den stdout eines Befehls zu erhalten und diesen zum stdin eines anderen Prozesses zu machen. In diesem Fall haben wir den stdout von ls -la /etc genommen und ihn dann an den less-Befehl <i>gepiped</i>. Der Pipe-Befehl ist äußerst nützlich und wir werden ihn bis in alle Ewigkeit weiterverwenden. \n\nNun, was ist, wenn ich die Ausgabe meines Befehls in zwei verschiedene Streams schreiben möchte? Das ist mit dem tee-Befehl möglich: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nSie sollten die Ausgabe von ls auf Ihrem Bildschirm sehen und wenn Sie die Datei peanuts.txt öffnen, sollten Sie dieselben Informationen sehen!",
          "quizAnswer": "|",
          "quizQuestion": "Welche Taste repräsentiert den Pipe-Operator?",
          "slug": "pipeteeredirect",
          "title": "Rohr und T-Stück"
        },
        {
          "exercise": "Was gibt die folgende Ausgabe aus? Warum?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Führen Sie den folgenden Befehl aus: \n\n<pre>$ echo $HOME</pre>\n\nSie sollten den Pfad zu Ihrem Home-Verzeichnis sehen, meiner sieht so aus: /home/pete. \n\nWas bewirkt dieser Befehl? \n\n<pre>$ echo $USER </pre>\n\nSie sollten Ihren Benutzernamen sehen!\n\nWoher stammen diese Informationen? Sie stammen von Ihren Umgebungsvariablen. Sie können diese anzeigen, indem Sie\n\n<pre>$ env </pre>\n\neingeben. Dies gibt eine Menge Informationen über die Umgebungsvariablen aus, die Sie derzeit festgelegt haben. Diese Variablen enthalten nützliche Informationen, die die Shell und andere Prozesse verwenden können.\n\nHier ist ein kurzes Beispiel:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nEine besonders wichtige Variable ist die PATH-Variable. Sie können auf diese Variablen zugreifen, indem Sie einen $ vor den Variablennamen setzen, wie folgt:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nDies gibt eine Liste von Pfaden zurück, die durch einen Doppelpunkt getrennt sind und die Ihr System durchsucht, wenn es einen Befehl ausführt. Angenommen, Sie laden manuell ein Paket aus dem Internet herunter, installieren es und legen es in ein nicht standardmäßiges Verzeichnis und möchten diesen Befehl ausführen. Sie geben $ coolcommand ein und die Eingabeaufforderung gibt den Fehler 'Befehl nicht gefunden' aus. Nun, das ist seltsam, Sie betrachten die Binärdatei in einem Ordner und wissen, dass sie existiert. Was passiert ist, dass die $PATH-Variable dieses Verzeichnis nicht für diese Binärdatei überprüft, daher wird ein Fehler ausgegeben. \n\nAngenommen, Sie hätten eine Vielzahl von Binärdateien, die Sie aus diesem Verzeichnis ausführen möchten, Sie können einfach die PATH-Variable ändern, um dieses Verzeichnis in Ihre PATH-Umgebungsvariable aufzunehmen.",
          "quizAnswer": "env",
          "quizQuestion": "Wie sehen Sie Ihre Umgebungsvariablen?",
          "slug": "envenvironment",
          "title": "env (Umgebung)"
        },
        {
          "exercise": "Was bewirkt der folgende Befehl? Warum?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Wir werden ein paar nützliche Befehle lernen, die Sie zum Verarbeiten von Text verwenden können. Bevor wir beginnen, erstellen wir eine Datei, mit der wir arbeiten werden. Kopieren und fügen Sie den folgenden Befehl ein, fügen Sie dann zwischen lazy und dog ein TAB ein (halten Sie die Strg-Taste gedrückt + TAB).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nDer erste Befehl, den wir lernen werden, ist der cut-Befehl. Er extrahiert Textteile aus einer Datei. \n\nUm Inhalte anhand einer Liste von Zeichen zu extrahieren: \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nDies gibt das 5. Zeichen in jeder Zeile der Datei aus. In diesem Fall ist es \"q\", beachten Sie, dass auch das Leerzeichen als Zeichen zählt. \n\nUm die Inhalte nach einem Feld zu extrahieren, müssen wir eine kleine Änderung vornehmen: \n\n<pre>$ cut -f 2 sample.txt</pre>\n\nDer -f- oder Feld-Befehl schneidet Text basierend auf Feldern ab, standardmäßig verwendet er TABs als Trennzeichen, sodass alles, was durch ein TAB getrennt ist, als Feld betrachtet wird. Sie sollten \"dog\" als Ausgabe sehen.\n\nSie können den Feld-Befehl mit dem Trennzeichen-Befehl kombinieren, um die Inhalte nach einem benutzerdefinierten Trennzeichen zu extrahieren: \n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nDies ändert das TAB-Trennzeichen in ein \";\"-Trennzeichen, und da wir das erste Feld schneiden, sollte das Ergebnis \"The quick brown\" sein.",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "Welchen Befehl würden Sie verwenden, um das erste Zeichen jeder Zeile in einer Datei zu erhalten?",
          "slug": "cutcommand",
          "title": "cut"
        },
        {
          "exercise": "Versuchen Sie, mehrere Dateien zusammenzufügen, was passiert?",
          "id": 7,
          "lessonContent": "Der paste-Befehl ist ähnlich dem cat-Befehl, er fügt Zeilen in einer Datei zusammen. Lassen Sie uns eine neue Datei mit folgendem Inhalt erstellen: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nLassen Sie uns all diese Zeilen in eine Zeile kombinieren: \n\n<pre>$ paste -s sample2.txt</pre>\n\nDer Standard-Trennzeichen für paste ist TAB, daher gibt es jetzt eine Zeile mit TABs, die jedes Wort trennen.\n\nLassen Sie uns dieses Trennzeichen (-d) auf etwas Lesbareres ändern: \n\n<pre>$ paste -d ' ' -s sample2.txt</pre>\n\nJetzt sollte alles in einer Zeile stehen, getrennt durch Leerzeichen.",
          "quizAnswer": "-s",
          "quizQuestion": "Welche Flagge verwenden Sie mit paste, um alles in eine Zeile zu bringen?",
          "slug": "pastecommand",
          "title": "paste"
        },
        {
          "exercise": "Was bewirkt der folgende Befehl und warum? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Angenommen, wir haben eine sehr lange Datei, tatsächlich haben wir viele zur Auswahl, gehen Sie voran und führen Sie cat /var/log/syslog aus. Sie sollten Seiten um Seiten mit Text sehen. Was ist, wenn ich nur die ersten paar Zeilen in dieser Textdatei sehen wollte? Nun, das können wir mit dem head-Befehl tun, standardmäßig zeigt der head-Befehl Ihnen die ersten 10 Zeilen in einer Datei an.\n\n<pre>$ head /var/log/syslog</pre>\n\nSie können auch die Zeilenanzahl nach Belieben ändern, sagen wir, ich möchte stattdessen die ersten 15 Zeilen sehen. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nDie -n-Flagge steht für die Anzahl der Zeilen.",
          "quizAnswer": "-n",
          "quizQuestion": "Welche Flagge würden Sie verwenden, um die Anzahl der Zeilen zu ändern, die Sie für den head-Befehl anzeigen möchten?",
          "slug": "headcommand",
          "title": "head"
        },
        {
          "exercise": "Sieh dir die Manpage von tail an und lies einige der anderen Befehle, die wir nicht besprochen haben.\n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Ähnlich wie der head-Befehl lässt dich der tail-Befehl standardmäßig die letzten 10 Zeilen einer Datei sehen.\n\n<pre>$ tail /var/log/syslog</pre>\n\nZusammen mit head kannst du die Anzahl der Zeilen ändern, die du sehen möchtest.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nEine weitere großartige Option ist die Verwendung der -f (follow) Flagge, dies verfolgt die Datei, während sie wächst. Probiere es aus und schau, was passiert.\n\n<pre>$ tail -f /var/log/syslog</pre>\n\nDeine syslog-Datei ändert sich kontinuierlich, während du mit deinem System interagierst, und mit tail -f kannst du sehen, was alles zu dieser Datei hinzugefügt wird.",
          "quizAnswer": "-f",
          "quizQuestion": "Welche Flagge wird verwendet, um einer Datei mit tail zu folgen?",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "Was passiert, wenn Sie einfach expand ohne Dateieingabe eingeben?",
          "id": 10,
          "lessonContent": "In unserer Lektion zum cut-Befehl hatten wir unsere sample.txt-Datei, die ein Tabulatorzeichen enthielt. Normalerweise zeigen TABs einen deutlichen Unterschied, aber einige Textdateien zeigen das nicht deutlich genug. Tabulatoren in einer Textdatei sind möglicherweise nicht der gewünschte Abstand, den Sie möchten. Verwenden Sie den expand-Befehl, um Ihre Tabulatoren in Leerzeichen zu ändern. \n\n<pre>$ expand sample.txt</pre>\n\nDer obige Befehl gibt die Ausgabe aus, wobei jeder TAB in eine Gruppe von Leerzeichen umgewandelt wird. Um diese Ausgabe in einer Datei zu speichern, verwenden Sie eine Ausgaberichtung wie unten gezeigt. \n\n<pre>$ expand sample.txt > result.txt</pre>\n\nIm Gegensatz zu expand können wir jede Gruppe von Leerzeichen mit dem unexpand-Befehl wieder in einen TAB umwandeln: \n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "Welcher Befehl wird verwendet, um TABs in Leerzeichen umzuwandeln?",
          "slug": "expandunexpandcommand",
          "title": "expand und unexpand"
        },
        {
          "exercise": "Fügen Sie zwei Dateien mit unterschiedlicher Anzahl von Zeilen in jeder Datei zusammen, was passiert?",
          "id": 11,
          "lessonContent": "Der Befehl join ermöglicht es Ihnen, mehrere Dateien anhand eines gemeinsamen Feldes zusammenzuführen: \n\nAngenommen, ich hätte zwei Dateien, die ich zusammenführen möchte:\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\nSehen Sie, wie meine Dateien zusammengeführt wurden? Sie werden standardmäßig anhand des ersten Feldes zusammengeführt und die Felder müssen identisch sein. Wenn sie es nicht sind, können Sie sie sortieren, sodass in diesem Fall die Dateien über 1, 2, 3 verbunden sind. \n\nWie würden wir die folgenden Dateien zusammenführen? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nUm diese Datei zu verbinden, müssen Sie angeben, welche Felder Sie verbinden, in diesem Fall möchten wir Feld 2 in file1.txt und Feld 1 in file2.txt verbinden, daher würde der Befehl so aussehen:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 bezieht sich auf file1.txt und -2 bezieht sich auf file2.txt. Ziemlich praktisch. Sie können auch eine Datei mit dem Befehl split in verschiedene Dateien aufteilen: \n\n<pre>$ split somefile</pre>\n\nDies wird sie in verschiedene Dateien aufteilen, standardmäßig werden sie aufgeteilt, sobald sie eine Grenze von 1000 Zeilen erreichen. Die Dateien werden standardmäßig als x** benannt.",
          "quizAnswer": "join cat dog cow",
          "quizQuestion": "Welchen Befehl würden Sie verwenden, um Dateien mit den Namen cat dog cow zu verbinden?",
          "slug": "joinsplitcommand",
          "title": "join und split"
        },
        {
          "exercise": "Die eigentliche Stärke von sort liegt in seiner Fähigkeit, mit anderen Befehlen kombiniert zu werden. Versuchen Sie den folgenden Befehl und sehen Sie, was passiert?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "Der Befehl sort ist nützlich zum Sortieren von Zeilen.\n\n<pre>\nfile1.txt\ndog\ncow\ncat\nelephant\nbird\n\n$ sort file1.txt\nbird\ncat\ncow\ndog\nelephant\n</pre>\n\nSie können auch eine umgekehrte Sortierung durchführen: \n\n<pre>$ sort -r file1.txt\nelephant\ndog\ncow\ncat\nbird\n</pre>\n\nUnd auch eine Sortierung nach numerischem Wert: \n\n<pre>$ sort -n file1.txt\nbird\ncat\ncow\nelephant\ndog\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Welche Flagge verwenden Sie, um eine umgekehrte Sortierung durchzuführen?",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "Versuchen Sie den folgenden Befehl. Was passiert? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "Der tr (übersetzen) Befehl ermöglicht es Ihnen, eine Reihe von Zeichen in eine andere Zeichenfolge zu übersetzen. Lassen Sie uns ein Beispiel ausprobieren, bei dem alle Kleinbuchstaben in Großbuchstaben übersetzt werden. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nWie Sie sehen können, haben wir die Bereiche von a-z in A-Z umgewandelt und alle von uns eingegebenen Texte, die Kleinbuchstaben sind, in Großbuchstaben umgewandelt.",
          "quizAnswer": "tr",
          "quizQuestion": "Welcher Befehl wird verwendet, um Zeichen zu übersetzen?",
          "slug": "trtranslatecommand",
          "title": "tr (Übersetzen)"
        },
        {
          "exercise": "Welches Ergebnis würden Sie erhalten, wenn Sie uniq -uc versuchen?",
          "id": 14,
          "lessonContent": "Der uniq (einzigartig) Befehl ist ein weiteres nützliches Werkzeug zum Parsen von Text.\n\nAngenommen, Sie hätten eine Datei mit vielen Duplikaten:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nUnd Sie wollten die Duplikate entfernen, dann können Sie den uniq Befehl verwenden:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nLassen Sie uns die Anzahl der Vorkommen einer Zeile erhalten:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nLassen Sie uns nur eindeutige Werte erhalten:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nLassen Sie uns nur doppelte Werte erhalten:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Hinweis</b>: uniq erkennt keine doppelten Zeilen, es sei denn, sie sind benachbart. Zum Beispiel:\n\nAngenommen, Sie hätten eine Datei mit nicht benachbarten Duplikaten:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nDas von uniq zurückgegebene Ergebnis enthält alle Einträge im Gegensatz zum allerersten Beispiel.\n\nUm diese Einschränkung von uniq zu überwinden, können wir sort in Kombination mit uniq verwenden:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "Welchen Befehl würden Sie verwenden, um Duplikate in einer Datei zu entfernen?",
          "slug": "uniquniquecommand",
          "title": "uniq (Einzigartig)"
        },
        {
          "exercise": "Wie würden Sie die Gesamtanzahl der Zeilen erhalten, indem Sie den nl Befehl verwenden, ohne den gesamten Output durchsuchen zu müssen? Tipp: Verwenden Sie einige der anderen Befehle, die Sie in diesem Kurs gelernt haben.",
          "id": 15,
          "lessonContent": "Der wc (Wortanzahl) Befehl zeigt die Gesamtanzahl der Wörter in einer Datei an. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nEr zeigt die Anzahl der Zeilen, Wörter und Bytes, jeweils. \n\nUm nur die Anzahl eines bestimmten Feldes zu sehen, verwenden Sie -l, -w oder -c entsprechend. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nEin weiterer Befehl, den Sie verwenden können, um die Anzahl der Zeilen in einer Datei zu überprüfen, ist der nl (Nummerierung von Zeilen) Befehl. \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "Welchen Befehl würden Sie verwenden, um die Gesamtanzahl der Wörter in einer Datei und nur die Wörter zu erhalten?",
          "slug": "nlwccommand",
          "title": "wc und nl"
        },
        {
          "exercise": "Sie haben vielleicht von egrep oder fgrep gehört, diese sind veraltete grep-Aufrufe und wurden inzwischen durch grep -E und grep -F ersetzt. Lesen Sie die grep-Manpage, um mehr zu erfahren.",
          "id": 16,
          "lessonContent": "Der grep-Befehl ist möglicherweise der häufigste Textverarbeitungsbefehl, den Sie verwenden werden. Er ermöglicht es Ihnen, Dateien nach Zeichenfolgen zu durchsuchen, die einem bestimmten Muster entsprechen. Was ist, wenn Sie wissen wollten, ob eine Datei in einem bestimmten Verzeichnis existiert oder ob Sie sehen wollten, ob eine Zeichenfolge in einer Datei gefunden wurde? Sie würden sicherlich nicht jede Textzeile durchsuchen, Sie würden grep verwenden!\n\nLassen Sie uns unsere sample.txt-Datei als Beispiel verwenden: \n\n<pre>$ grep fox sample.txt</pre>\n\nSie sollten sehen, dass grep fox in der Datei sample.txt gefunden hat. \n\nSie können auch Muster suchen, die nicht auf Groß- und Kleinschreibung achten, mit dem -i Flag: \n\n<pre>$ grep -i somepattern somefile</pre>\n\nUm mit grep noch flexibler zu werden, können Sie es mit anderen Befehlen mit | kombinieren.\n\n<pre>$ env | grep -i User</pre>\n\nWie Sie sehen können, ist grep ziemlich vielseitig. Sie können sogar reguläre Ausdrücke in Ihrem Muster verwenden: \n\n<pre>$ ls /somedir | grep '.txt$'</pre>\n\nSollte alle Dateien zurückgeben, die mit .txt in somedir enden.",
          "quizAnswer": "grep",
          "quizQuestion": "Welchen Befehl verwenden Sie, um ein bestimmtes Muster zu finden?",
          "slug": "grepcommand",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Navigieren Sie wie ein Linux-Spinnenaffe mit vim und emacs durch Text.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Versuchen Sie, reguläre Ausdrücke mit grep zu kombinieren und durch einige Dateien zu suchen.\n\n<pre>\ngrep [regulärer Ausdruck hier] [Datei]",
          "id": 1,
          "lessonContent": "Reguläre Ausdrücke sind ein leistungsstarkes Werkzeug zur musterbasierten Auswahl. Es verwendet spezielle Notationen, ähnlich denen, die wir bereits kennengelernt haben, wie das *-Platzhalterzeichen. \n\nWir werden einige der häufigsten regulären Ausdrücke durchgehen, die fast universell in jeder Programmiersprache sind.\n\nWir verwenden diesen Satz als unseren Teststring:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. Anfang einer Zeile mit ^</b>\n\n<pre>\n<b>^</b>by\nwürde die Zeile \"by the seashore\" passen\n</pre>\n\n<b>2. Ende einer Zeile mit $</b>\n\n<pre>\nseashore<b>$</b>\nwürde die Zeile \"by the seashore\" passen\n</pre>\n\n<b>3. Übereinstimmung mit einem einzelnen Zeichen mit .</b>\n\n<pre>\nb<b>.</b>\nwürde zu by passen\n</pre>\n\n<b>4. Klammernotation mit [] und ()</b>\n\nDas kann etwas knifflig sein, Klammern ermöglichen es uns, Zeichen innerhalb der Klammer anzugeben. \n\n<pre>\nd<b>[iou]</b>g\nwürde passen: dig, dog, dug\n</pre>\n\nDas vorherige Ankerzeichen ^ in einer Klammer bedeutet, dass alles außer den Zeichen innerhalb der Klammer passt. \n\n<pre>\nd<b>[^i]</b>g\nwürde passen: dog und dug, aber nicht dig\n</pre>\n\nKlammern können auch Bereiche verwenden, um die Anzahl der zu verwendenden Zeichen zu erhöhen. \n\n<pre>\nd<b>[a-c]</b>g\npasst zu Mustern wie dag, dbg und dcg\n</pre>\n\nSeien Sie jedoch vorsichtig, da Klammern Groß- und Kleinschreibung beachten:\n\n<pre>\nd<b>[A-C]</b>g\npasst zu dAg, dBg und dCg, aber nicht zu dag, dbg und dcg\n</pre>\n\nUnd das sind einige grundlegende reguläre Ausdrücke.",
          "quizAnswer": ".",
          "quizQuestion": "Welchen regulären Ausdruck würden Sie verwenden, um ein einzelnes Zeichen abzugleichen?",
          "slug": "regularexpressionsregex",
          "title": "regex (Reguläre Ausdrücke)"
        },
        {
          "exercise": "Machen Sie eine kleine Tour mit vim und emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Wenn Sie ein paar Hardcore-Linux-Benutzer in einem Raum versammeln und sie fragen, welcher der beste Texteditor ist, werden Sie eine endlose Debatte über die Göttlichkeit von entweder vim oder emacs hören. Versuchen Sie nicht einmal, die Verwendung eines GUI-Editors anzusprechen, wenn Ihnen Ihr Leben lieb ist. \n\nVim und emacs sind beliebte Texteditoren, die standardmäßig in den meisten Linux-Distributionen installiert sind, und sie haben beide ihre Vor- und Nachteile. Wenn Sie Ihr System wie ein Ninja bedienen möchten, müssen Sie einen dieser Texteditoren verwenden. Sie sind im Wesentlichen Code-, Textverarbeitungs- und praktisch All-in-One-Editoren.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, gehen Sie weiter!",
          "slug": "texteditorsvimoremacs",
          "title": "Texteditoren"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Vim steht für vi (Improved), genau wie der Name schon sagt, steht es für eine verbesserte Version des vi-Texteditor-Befehls.\n\nEs ist super leichtgewichtig, das Öffnen und Bearbeiten einer Datei mit vim ist schnell und einfach. Es ist auch fast immer verfügbar, wenn Sie eine zufällige Linux-Distribution gestartet haben, ist die Wahrscheinlichkeit hoch, dass vim standardmäßig installiert ist. \n\nUm vim zu starten, geben Sie einfach ein: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, weitermachen!",
          "slug": "vimtexteditor",
          "title": "Vim (Vi Improved)"
        },
        {
          "exercise": "Spielen Sie mit dem Suchschlüssel, öffnen Sie eine Textdatei in Vim mit: vim [textfile] und beginnen Sie mit der Suche!",
          "id": 4,
          "lessonContent": "Um nach einem Ausdruck zu suchen, geben Sie einfach den / Schlüssel ein und dann Ihr Suchergebnis, während Sie sich in einer Vim-Sitzung befinden. Sobald Sie die Eingabetaste drücken, können Sie \"n\" drücken, um vorwärts zu gehen oder \"N\", um rückwärts in Ihren Suchergebnissen zu gehen.\n\n<pre>\nMeine hübsche Datei ist sehr hübsch.\n\n/pretty\n\nwird die hübschen Wörter in der Textdatei finden.\n</pre>\n\n\nDer ? Suchbefehl sucht rückwärts in der Textdatei, also würde im vorherigen Beispiel das letzte hübsche zuerst auftauchen. \n<pre>\nMeine hübsche Datei ist sehr hübsch.\n\n?pretty\n\nwird die hübschen Wörter in der Textdatei finden.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Welcher Schlüssel wird in Vim zum Suchen verwendet?",
          "slug": "vimsearchpatterns",
          "title": "Vim Suchmuster"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 5,
          "lessonContent": "Jetzt wirst du vielleicht bemerken, dass die Maus hier nirgendwo verwendet wird. Um ein Textdokument in Vim zu navigieren, verwende die folgenden Tasten: \n\n<ul>\n<li>h oder der linke Pfeil - bewegt dich um ein Zeichen nach links</li>\n<li>k oder der obere Pfeil - bewegt dich um eine Zeile nach oben</li>\n<li>j oder der untere Pfeil - bewegt dich um eine Zeile nach unten</li>\n<li>l oder der rechte Pfeil - bewegt dich um ein Zeichen nach rechts</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "Welcher Buchstabe wird verwendet, um nach unten zu bewegen?",
          "slug": "vimnavigation",
          "title": "Vim Navigation"
        },
        {
          "exercise": "Spielen Sie mit dem Wechsel zwischen Einfüge- und Befehlsmodus.",
          "id": 6,
          "lessonContent": "<p>Vielleicht ist Ihnen aufgefallen, dass Sie nichts eingeben können. Das liegt daran, dass Sie sich im Befehlsmodus befinden. Das kann ziemlich verwirrend sein, besonders wenn Sie einfach eine Datei öffnen und Text eingeben möchten. Der Befehlsmodus wird verwendet, wenn Sie Befehle wie h, j, k, l usw. eingeben. Um Text einzufügen, müssen Sie zuerst den Einfügemodus aktivieren. </p><p></p><ul><br><li>i - Text vor dem Cursor einfügen</li><br><li>O - Text in der vorherigen Zeile einfügen</li><br><li>o - Text in der nächsten Zeile einfügen</li><br><li>a - Text nach dem Cursor anhängen</li><br><li>A - Text am Ende der Zeile anhängen</li><br></ul><p></p><p>Beachten Sie, dass wenn Sie einen dieser Einfügemodi eingeben, vim den Einfügemodus am unteren Rand der Shell aktiviert. Um den Einfügemodus zu verlassen und zum Befehlsmodus zurückzukehren, drücken Sie einfach die Esc-Taste.</p>",
          "quizAnswer": "i",
          "quizQuestion": "Welche Taste wird verwendet, um Text vor dem Cursor einzufügen?",
          "slug": "vimtexteinfügenanhängen",
          "title": "Vim Text anhängen"
        },
        {
          "exercise": "Ich weiß, dass diese Lektion einige Eigenheiten hinzugefügt hat, öffnen Sie einen Texteditor und experimentieren Sie mit diesen.",
          "id": 7,
          "lessonContent": "Jetzt, da wir ein paar Zeilen geschrieben haben, wollen wir sie etwas bearbeiten und einige überflüssige Dinge entfernen.<br><p></p><ul><br><li>x - wird verwendet, um den ausgewählten Text zu schneiden, auch zum Löschen von Zeichen</li><br><li>dd - wird verwendet, um die aktuelle Zeile zu löschen</li><br><li>y - kopiert oder kopiert das ausgewählte Element</li><br><li>yy - kopiert oder kopiert die aktuelle Zeile</li><br><li>p - fügt den kopierten Text vor dem Cursor ein</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "Welches Zeichen wird verwendet, um eine ganze Zeile zu löschen?",
          "slug": "vimediting",
          "title": "Vim-Bearbeitung"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 8,
          "lessonContent": "Jetzt, da du deine Bearbeitung abgeschlossen hast, ist es an der Zeit, tatsächlich in Vim zu speichern und zu beenden: \n\n<ul>\n<li>:w - schreibt oder speichert die Datei</li>\n<li>:q - beendet Vim</li>\n<li>:wq - schreibt und beendet dann</li>\n<li>:q! - beendet Vim, ohne die Datei zu speichern</li>\n<li>ZZ - entspricht :wq, ist jedoch ein Zeichen schneller</li>\n\n<li>u - macht deine letzte Aktion rückgängig</li>\n<li>Strg-r - wiederholt deine letzte Aktion</li>\n</ul>\n\nDu denkst vielleicht, dass ZZ nicht notwendig ist, aber du wirst schließlich feststellen, dass deine Finger dazu neigen, eher zu diesem zu greifen als zu :wq.\n\nPuh, das war eine Menge Informationen über Vim. Jetzt, da du einige grundlegende Befehle und Navigationen kennst, kannst du damit beginnen, einige Textdateien zu bearbeiten. Es gibt viele weitere Optionen, die du in Vim verwenden kannst, um deine Fähigkeiten in diesem Texteditor zu verbessern. Schau dir die Online-Anleitung von Vim an, um einen Überblick zu erhalten.",
          "quizAnswer": ":q!",
          "quizQuestion": "Wie beendest du Vim, ohne die Datei zu speichern?",
          "slug": "vimspeichernundbeenden",
          "title": "Vim Speichern und Beenden"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 9,
          "lessonContent": "Emacs ist für Benutzer, die einen extrem leistungsstarken Texteditor wünschen, was eine Untertreibung sein könnte, da Sie im Grunde genommen in Emacs leben. Sie können all Ihre Code-Bearbeitung, Dateimanipulation usw. alles innerhalb von Emacs erledigen. Es dauert etwas länger, um zu starten, und die Lernkurve ist etwas steiler als bei vim, aber wenn Sie einen leistungsstarken Editor möchten, der äußerst erweiterbar ist, ist dies der richtige für Sie. Wenn ich von erweiterbar spreche, meine ich buchstäblich, dass Sie Skripte für Emacs schreiben können, die seine Funktionalität erweitern.\n\nUm Emacs zu starten, verwenden Sie einfach:\n\n<pre>emacs</pre>\n\nSie sollten mit dem Standard-Begrüßungspuffer begrüßt werden.\n\nPuffer in Emacs ist der Ort, an dem sich Ihr Text befindet. Wenn Sie also eine Datei öffnen, wird ein Puffer verwendet, um den Inhalt dieser Datei zu speichern. Sie können mehrere Puffer gleichzeitig geöffnet haben und problemlos zwischen den Puffern wechseln.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, weitermachen!",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Spielen Sie mit dem Öffnen von Dateien und dem Speichern von Dateien.",
          "id": 10,
          "lessonContent": "In vielen (wenn nicht allen) Emacs-Dokumentationen sehen Sie die Syntax C-[Buchstabe]. Dies bedeutet einfach, die Strg-Taste und den Buchstaben zu drücken, aber der Einfachheit halber nennen wir Strg mit C. Wenn Sie die Syntax M-[Buchstabe] sehen, bedeutet das, die Meta-Taste zu verwenden, meistens die Alt-Taste.\n\n<b>Dateien speichern</b>\n\n<pre>\nC-x C-s - Eine Datei speichern\nC-x C-w - Datei speichern unter\nC-x s - Alle speichern\n</pre>\n\nDie Optionen zum Speichern von Dateien fordern Sie auf, ob Sie jede Datei speichern möchten.\n\n<b>Datei öffnen</b>\n\n<pre>\nC-x C-f\n</pre>\n\nDadurch werden Sie aufgefordert, einen Dateinamen zum Öffnen einzugeben. Wenn Sie keine bereits vorhandene Datei haben, wird eine neue Datei erstellt. Sie können auch ein Verzeichnis laden.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "Welcher Befehl wird verwendet, um eine Datei zu öffnen?",
          "slug": "emacsmanipulatefiles",
          "title": "Emacs Dateien manipulieren"
        },
        {
          "exercise": "Spielen Sie mit Puffern herum.",
          "id": 11,
          "lessonContent": "Um sich in Puffern (oder Dateien, die Sie besuchen) zu bewegen, verwenden Sie die folgenden Befehle:\n\n<b>Puffer wechseln</b>\n\n<pre>\nC-x b - Puffer wechseln\nC-x rechter Pfeil - rechts durch den Puffer zyklisieren\nC-x linker Pfeil - links durch den Puffer zyklisieren\n</pre>\n\n<b>Puffer schließen</b>\n\n<pre>C-x k</pre>\n\n<b>Aktuellen Puffer teilen</b>\n\n<pre>C-x 2</pre>\n\nDies ermöglicht es, mehrere Puffer auf einem Bildschirm zu sehen. Um zwischen diesen Puffern zu wechseln, verwenden Sie: C-x o\n\n<b>Einen einzelnen Puffer als aktuellen Bildschirm festlegen</b>\n\n<pre>C-x 1</pre>\n\nWenn Sie jemals einen Terminal-Multiplexer wie screen und tmux verwendet haben, werden Ihnen die Pufferbefehle sehr vertraut vorkommen.",
          "quizAnswer": "C-x k",
          "quizQuestion": "Wie beenden Sie einen Puffer?",
          "slug": "emacsbuffernavigation",
          "title": "Emacs Puffernavigation"
        },
        {
          "exercise": "Spielen Sie mit der Textnavigation herum.",
          "id": 12,
          "lessonContent": "<b>Textnavigation</b>\n\n<pre>\nC-Pfeil nach oben: einen Absatz nach oben bewegen\nC-Pfeil nach unten: einen Absatz nach unten bewegen\nC-Pfeil nach links: ein Wort nach links bewegen\nC-Pfeil nach rechts: ein Wort nach rechts bewegen\nM->: zum Ende des Puffers bewegen\n</pre>\n\nMit der Textnavigation funktionieren Ihre regulären Texttasten wie gewohnt: Pos1, Ende, Bild auf, Bild ab und die Pfeiltasten usw.\n\n<b>Ausschneiden und Einfügen</b>\n\nUm in Emacs auszuschneiden (killen) oder einzufügen (yanken), müssen Sie zuerst Text auswählen können. Bewegen Sie den Cursor an die Stelle, an der Sie schneiden oder einfügen möchten, und drücken Sie die Taste <pre>C-Leertaste</pre>. Verwenden Sie dann die Navigations-Tasten, um den gewünschten Text auszuwählen. Jetzt können Sie wie folgt ausschneiden und einfügen:\n\n<pre>\nC-w: ausschneiden\nC-y: einfügen\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "Wie bewegen Sie sich zum Ende des Puffers?",
          "slug": "emacsediting",
          "title": "Emacs-Bearbeitung"
        },
        {
          "exercise": "Besuchen Sie die Emacs-Website, um mehr Befehle zu erfahren. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Um Emacs zu beenden</b>\n\n<pre>C-x C-c</pre>\n\nWenn Sie offene Puffer haben, wird es Sie auffordern, sie zu speichern, bevor Sie Emacs beenden.\n\n<b>Verwirrt?</b>\n\n<pre>C-h C-h : Hilfemenü</pre>\n\n<b>Rückgängig machen</b>\n\n<pre>C-x u</pre>\n\nWie Sie sehen können, hat Emacs mehr bewegliche Teile, daher ist die Lernkurve etwas steiler. Dafür erhalten Sie jedoch einen sehr leistungsstarken Texteditor.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "Wie greifen Sie auf das Hilfemenü zu?",
          "slug": "emacsexitingandhelp",
          "title": "Emacs Beenden und Hilfe"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Fortgeschrittene Text-Fu"
    },
    {
      "description": "Erfahren Sie mehr über Benutzerrollen und -verwaltung.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "Für diese Lektion sind keine Übungen vorhanden.",
          "id": 1,
          "lessonContent": "In jedem traditionellen Betriebssystem gibt es Benutzer und Gruppen. Sie existieren ausschließlich für den Zugriff und die Berechtigungen. Wenn ein Prozess ausgeführt wird, wird er als Besitzer dieses Prozesses ausgeführt, ob das nun Jane oder Bob ist. Der Dateizugriff und -besitz hängt ebenfalls von Berechtigungen ab. Sie möchten nicht, dass Jane die Dokumente von Bob sieht und umgekehrt. \n\nJeder Benutzer hat sein eigenes Home-Verzeichnis, in dem seine benutzerspezifischen Dateien gespeichert werden. Dies befindet sich normalerweise unter /home/benutzername, kann jedoch je nach Distribution variieren. \n\nDas System verwendet Benutzer-IDs (UID), um Benutzer zu verwalten. Benutzernamen sind die freundliche Art, Benutzer mit einer Identifikation zu verknüpfen, aber das System identifiziert Benutzer anhand ihrer UID. Das System verwendet auch Gruppen zur Verwaltung von Berechtigungen. Gruppen sind einfach Benutzersets mit Berechtigungen, die von dieser Gruppe festgelegt wurden. Sie werden vom System anhand ihrer Gruppen-ID (GID) identifiziert.\n\nIn Linux haben Sie Benutzer zusätzlich zu den normalen Benutzern, die das System verwenden. Manchmal handelt es sich bei diesen Benutzern um Systemdaemons, die kontinuierlich Prozesse ausführen, um das System am Laufen zu halten. Einer der wichtigsten Benutzer ist root oder Superuser. Root ist der mächtigste Benutzer im System. Root kann auf jede Datei zugreifen und jeden Prozess starten und beenden. Aus diesem Grund kann es gefährlich sein, immer als root zu arbeiten, da Sie potenziell wichtige Systemdateien entfernen könnten. Glücklicherweise kann, wenn Root-Zugriff erforderlich ist und ein Benutzer Root-Zugriff hat, ein Befehl als Root mit dem sudo-Befehl ausgeführt werden. Der sudo-Befehl (Superuser do) wird verwendet, um einen Befehl mit Root-Zugriff auszuführen. Wir werden später genauer darauf eingehen, wie ein Benutzer Root-Zugriff erhält.\n\nVersuchen Sie, eine geschützte Datei wie /etc/shadow anzuzeigen:\n\n<pre>$ cat /etc/shadow</pre>\n\nBeachten Sie, wie Sie einen Berechtigungsfehler erhalten. Sehen Sie sich die Berechtigungen an mit: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dez 1 11:45 /etc/shadow\n</pre>\n\nWir sind noch nicht auf Berechtigungen eingegangen, aber was hier passiert, ist, dass Root der Besitzer der Datei ist und Sie Root-Zugriff benötigen oder Teil der Shadow-Gruppe sein müssen, um den Inhalt lesen zu können. Führen Sie nun den Befehl mit sudo aus:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nJetzt können Sie den Inhalt der Datei sehen!",
          "quizAnswer": "sudo",
          "quizQuestion": "Welchen Befehl verwenden Sie, um als Root auszuführen?",
          "slug": "benutzerundgruppen",
          "title": "Benutzer und Gruppen"
        },
        {
          "exercise": "Öffnen Sie die Datei /etc/sudoers und sehen Sie, welche Superuser-Berechtigungen andere Benutzer auf dem Rechner haben.",
          "id": 2,
          "lessonContent": "Wir haben uns eine Möglichkeit angesehen, wie man mit dem sudo-Befehl Superuser-Zugriff erhält. Sie können auch Befehle als Superuser mit dem su-Befehl ausführen. Dieser Befehl wird \"Benutzer ersetzen\" und eine Root-Shell öffnen, wenn kein Benutzername angegeben ist. Sie können diesen Befehl verwenden, um sich als beliebigen Benutzer zu ersetzen, solange Sie das Passwort kennen. \n\n<pre>$ su</pre>\n\nEs gibt einige Nachteile bei der Verwendung dieser Methode: Es ist viel einfacher, einen kritischen Fehler zu machen, wenn alles als Root ausgeführt wird, Sie haben keine Aufzeichnungen über die Befehle, die Sie verwenden, um Systemkonfigurationen zu ändern, usw. Grundsätzlich, wenn Sie Befehle als Superuser ausführen müssen, bleiben Sie einfach bei sudo.\n\nJetzt, da Sie wissen, welche Befehle als Superuser ausgeführt werden sollen, lautet die Frage, wie wissen Sie, wer Zugriff darauf hat? Das System lässt nicht jeden x-beliebigen Benutzer Befehle als Superuser ausführen, also wie weiß es das? Es gibt eine Datei namens /etc/sudoers, in dieser Datei sind Benutzer aufgeführt, die sudo ausführen können. Sie können diese Datei mit dem <b>visudo</b>-Befehl bearbeiten.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "Welche Datei zeigt die Benutzer, die Zugriff auf sudo haben?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Schauen Sie sich Ihre /etc/passwd-Datei an, betrachten Sie einige der Benutzer und notieren Sie sich die Zugriffsrechte, die sie haben.",
          "id": 3,
          "lessonContent": "Denken Sie daran, dass Benutzernamen keine wirklichen Identifikationen für Benutzer sind. Das System verwendet eine Benutzer-ID (UID), um einen Benutzer zu identifizieren. Um herauszufinden, welche Benutzer welcher ID zugeordnet sind, schauen Sie sich die Datei /etc/passwd an. \n\n<pre>$ cat /etc/passwd</pre>\n\nDiese Datei zeigt Ihnen eine Liste von Benutzern und detaillierte Informationen über sie. Zum Beispiel sieht die erste Zeile in dieser Datei höchstwahrscheinlich so aus:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nJede Zeile zeigt Benutzerinformationen für einen Benutzer an, am häufigsten sehen Sie den Benutzer root als erste Zeile. Es gibt viele durch Doppelpunkte getrennte Felder, die Ihnen zusätzliche Informationen über den Benutzer mitteilen, schauen wir sie uns alle an:\n\n<ol>\n<li>Benutzername</li>\n<li>Benutzerpasswort - das Passwort wird tatsächlich nicht in dieser Datei gespeichert, es wird normalerweise in der Datei /etc/shadow gespeichert. Wir werden im nächsten Lektionsteil mehr über /etc/shadow diskutieren, aber vorerst wissen Sie, dass sie verschlüsselte Benutzerpasswörter enthält. Sie sehen viele verschiedene Symbole in diesem Feld, wenn Sie ein \"x\" sehen, bedeutet das, dass das Passwort in der Datei /etc/shadow gespeichert ist, ein \"*\" bedeutet, dass der Benutzer keinen Anmeldezugriff hat, und wenn ein leeres Feld vorhanden ist, bedeutet das, dass der Benutzer kein Passwort hat.</li>\n<li>Die Benutzer-ID - wie Sie sehen, hat root die UID 0</li>\n<li>Die Gruppen-ID</li>\n<li>GECOS-Feld - Dies wird im Allgemeinen verwendet, um Kommentare über den Benutzer oder das Konto zu hinterlassen, wie z.B. ihren richtigen Namen oder Telefonnummer, es ist komma-getrennt.</li>\n<li>Benutzerverzeichnis</li>\n<li>Benutzer-Shell - Sie werden wahrscheinlich sehen, dass viele Benutzer standardmäßig bash als ihre Shell verwenden</li>\n</ol>\n\nNormalerweise würden Sie auf einer Benutzerseite nur menschliche Benutzer erwarten. Sie werden jedoch feststellen, dass /etc/passwd auch andere Benutzer enthält. Denken Sie daran, dass Benutzer wirklich nur auf dem System sind, um Prozesse mit unterschiedlichen Berechtigungen auszuführen. Manchmal möchten wir Prozesse mit vordefinierten Berechtigungen ausführen. Zum Beispiel wird der Benutzer daemon für Daemon-Prozesse verwendet.\n\nEs sollte auch beachtet werden, dass Sie die Datei /etc/passwd manuell bearbeiten können, wenn Sie Benutzer hinzufügen und Informationen mit dem <b>vipw</b>-Tool ändern möchten, jedoch sollten solche Dinge am besten den Tools überlassen werden, über die wir in einer späteren Lektion sprechen werden, wie z.B. useradd und userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Wie wird in /etc/passwd angezeigt, dass ein Benutzer keinen Anmeldezugriff hat?",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Werfen Sie einen Blick auf die Datei /etc/shadow",
          "id": 4,
          "lessonContent": "Die Datei /etc/shadow wird zur Speicherung von Informationen zur Benutzerauthentifizierung verwendet. Sie erfordert Superuser-Leseberechtigungen. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nSie werden feststellen, dass sie sehr ähnlich zu den Inhalten von /etc/passwd aussieht, jedoch im Passwortfeld ein verschlüsseltes Passwort zu sehen ist. Die Felder sind durch Doppelpunkte getrennt, wie folgt:\n\n<ol>\n<li>Benutzername</li>\n<li>Verschlüsseltes Passwort</li>\n<li>Datum der letzten Passwortänderung - ausgedrückt als Anzahl der Tage seit dem 1. Januar 1970. Wenn hier eine 0 steht, bedeutet das, dass der Benutzer sein Passwort beim nächsten Anmelden ändern sollte</li>\n<li>Mindestalter des Passworts - Tage, die ein Benutzer warten muss, bevor er sein Passwort erneut ändern kann</li>\n<li>Maximales Alter des Passworts - Maximale Anzahl von Tagen, bevor ein Benutzer sein Passwort ändern muss</li>\n<li>Passwortwarnzeitraum - Anzahl der Tage, bevor ein Passwort abläuft</li>\n<li>Passwort-Inaktivitätszeitraum - Anzahl der Tage nach Ablauf eines Passworts, in denen eine Anmeldung mit dem Passwort möglich ist</li>\n<li>Ablaufdatum des Kontos - Datum, an dem der Benutzer sich nicht mehr anmelden kann</li>\n<li>Reserviertes Feld für zukünftige Verwendung</li>\n</ol>\n\nIn den meisten heutigen Distributionen beruht die Benutzerauthentifizierung nicht nur auf der Datei /etc/shadow, es gibt andere Mechanismen wie PAM (Pluggable Authentication Modules), die die Authentifizierung ersetzen.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, gehen Sie weiter!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Führen Sie den Befehl <b>groups</b> aus. Was sehen Sie?",
          "id": 5,
          "lessonContent": "Eine weitere Datei, die bei der Benutzerverwaltung verwendet wird, ist die /etc/group-Datei. Diese Datei ermöglicht verschiedene Gruppen mit unterschiedlichen Berechtigungen. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nSehr ähnlich wie das /etc/password-Feld sind die /etc/group-Felder wie folgt:\n\n<ol>\n<li>Gruppenname</li>\n<li>Gruppenpasswort - Es ist nicht erforderlich, ein Gruppenpasswort festzulegen. Die Verwendung eines erhöhten Privilegs wie sudo ist Standard. Ein \"*\" wird als Standardwert eingesetzt.</li>\n<li>Gruppen-ID (GID)</li>\n<li>Liste der Benutzer - Sie können manuell Benutzer angeben, die Sie in einer bestimmten Gruppe haben möchten</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "Was ist die GID von root?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "Erstellen Sie einen neuen Benutzer, ändern Sie dann sein Passwort und melden Sie sich als der neue Benutzer an.",
          "id": 6,
          "lessonContent": "Die meisten Unternehmensumgebungen verwenden Verwaltungssysteme, um Benutzer, Konten und Passwörter zu verwalten. Auf einem einzelnen Computer gibt es jedoch nützliche Befehle, um Benutzer zu verwalten.\n\n<b>Benutzer hinzufügen</b>\n\nSie können den adduser- oder den useradd-Befehl verwenden. Der adduser-Befehl enthält mehr hilfreiche Funktionen wie das Erstellen eines Home-Verzeichnisses und mehr. Es gibt Konfigurationsdateien zum Hinzufügen neuer Benutzer, die je nach Bedarf des Standardbenutzers angepasst werden können. \n\n<pre>$ sudo useradd bob</pre>\n\nSie werden feststellen, dass der obige Befehl einen Eintrag in /etc/passwd für bob erstellt, Standardgruppen einrichtet und einen Eintrag in der Datei /etc/shadow hinzufügt.\n\n<b>Benutzer entfernen</b>\n\nUm einen Benutzer zu entfernen, können Sie den userdel-Befehl verwenden.\n\n<pre>$ sudo userdel bob</pre>\n\nDies macht im Wesentlichen sein Bestes, um die Dateiänderungen durch useradd rückgängig zu machen.\n\n<b>Passwörter ändern</b>\n\n<pre>$ passwd bob</pre>\n\nDies ermöglicht es Ihnen, das Passwort von sich selbst oder einem anderen Benutzer zu ändern (wenn Sie root sind).",
          "quizAnswer": "passwd",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Passwort zu ändern?",
          "slug": "benutzerverwaltungstools",
          "title": "Benutzerverwaltungstools"
        }
      ],
      "slug": "benutzerverwaltung",
      "title": "Benutzerverwaltung"
    },
    {
      "description": "Erfahren Sie mehr über Berechtigungsstufen und die Änderung von Berechtigungen.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Verwenden Sie den Befehl ls -l auf mehreren Dateien und geben Sie ihre Berechtigungen, Benutzer und Gruppe an.",
          "id": 1,
          "lessonContent": "Wie wir zuvor gelernt haben, haben Dateien unterschiedliche Berechtigungen oder Dateimodi. Schauen wir uns ein Beispiel an:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dez 1 11:45 .\n</pre>\n\nEine Dateiberechtigung besteht aus vier Teilen. Der erste Teil ist der Dateityp, der durch das erste Zeichen in den Berechtigungen angezeigt wird. In unserem Fall, da wir uns ein Verzeichnis ansehen, zeigt es <b>d</b> für den Dateityp an. Am häufigsten sehen Sie ein <b>-</b> für eine reguläre Datei.\n\nDie nächsten drei Teile des Dateimodus sind die tatsächlichen Berechtigungen. Die Berechtigungen sind in 3 Bits gruppiert. Die ersten 3 Bits sind Benutzerberechtigungen, dann Gruppenberechtigungen und dann sonstige Berechtigungen. Ich habe den senkrechten Strich hinzugefügt, um die Unterscheidung zu erleichtern.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nJedes Zeichen stellt eine andere Berechtigung dar: \n<ul>\n<li>r: lesbar</li>\n<li>w: beschreibbar</li>\n<li>x: ausführbar (im Grunde ein ausführbares Programm)</li>\n<li>-: leer</li>\n</ul>\n\nIn dem obigen Beispiel sehen wir, dass der Benutzer pete Lese-, Schreib- und Ausführungsberechtigungen für die Datei hat. Die Gruppe penguins hat Lese- und Ausführungsberechtigungen. Und schließlich haben die anderen Benutzer (alle anderen) Lese- und Ausführungsberechtigungen.",
          "quizAnswer": "x",
          "quizQuestion": "Welches Berechtigungsbit wird für ausführbar verwendet?",
          "slug": "dateiberechtigungen",
          "title": "Dateiberechtigungen"
        },
        {
          "exercise": "Ändern Sie die Berechtigungen einer einfachen Textdatei und sehen Sie, wie sich die Bits ändern, wenn Sie ein ls -l ausführen.",
          "id": 2,
          "lessonContent": "Das Ändern von Berechtigungen kann leicht mit dem <b>chmod</b>-Befehl durchgeführt werden. \n\nZuerst wählen Sie aus, welches Berechtigungsset Sie ändern möchten: Benutzer, Gruppe oder Andere. Sie können Berechtigungen hinzufügen oder entfernen mit einem <b>+</b> oder <b>-</b>, schauen wir uns einige Beispiele an.\n\n<b>Hinzufügen eines Berechtigungsbits auf einer Datei</b>\n<pre>$ chmod u+x meineDatei</pre>\n\nDer obige Befehl liest sich wie folgt: Ändere die Berechtigung auf meineDatei, indem du das ausführbare Berechtigungsbit im Benutzerset hinzufügst. Jetzt hat der Benutzer also Ausführungsberechtigung für diese Datei!\n\n<b>Entfernen eines Berechtigungsbits auf einer Datei</b>\n<pre>$ chmod u-x meineDatei</pre>\n\n<b>Hinzufügen mehrerer Berechtigungsbits auf einer Datei</b>\n<pre>$ chmod ug+w</pre>\n\nEs gibt eine andere Möglichkeit, Berechtigungen im numerischen Format zu ändern. Diese Methode ermöglicht es Ihnen, Berechtigungen auf einmal zu ändern. Anstatt r, w oder x zu verwenden, um Berechtigungen darzustellen, verwenden Sie eine numerische Darstellung für ein einzelnes Berechtigungsset. Sie müssen also nicht die Gruppe mit g oder den Benutzer mit u angeben.\n\nDie numerischen Darstellungen sind wie folgt:\n\n<ul>\n<li>4: Leseberechtigung</li>\n<li>2: Schreibberechtigung</li>\n<li>1: Ausführungsberechtigung</li>\n</ul>\n\nSchauen wir uns ein Beispiel an: \n\n<pre>$ chmod 755 meineDatei</pre>\n\nKönnen Sie erraten, welche Berechtigungen wir dieser Datei geben? Lassen Sie uns das aufschlüsseln, also deckt 755 jetzt die Berechtigungen für alle Sets ab. Die erste Zahl (7) repräsentiert Benutzerberechtigungen, die zweite Zahl (5) repräsentiert Gruppenberechtigungen und die letzte 5 repräsentiert Berechtigungen für Andere. \n\nMoment mal, 7 und 5 wurden oben nicht aufgeführt, woher stammen diese Zahlen? Denken Sie daran, dass wir jetzt alle Berechtigungen zu einer Zahl kombinieren, also müssen Sie etwas Mathematik einbeziehen.\n\n7 = 4 + 2 + 1, also hat 7 die Benutzerberechtigungen und es hat Lese-, Schreib- und Ausführungsberechtigungen\n\n5 = 4 + 1, die Gruppe hat Lese- und Ausführungsberechtigungen\n\n5 = 4 + 1, und alle anderen Benutzer haben Lese- und Ausführungsberechtigungen\n\nEine Sache ist zu beachten: Es ist keine gute Idee, Berechtigungen willkürlich zu ändern, Sie könnten potenziell eine sensible Datei für jeden zur Änderung freigeben. Viele Male möchten Sie jedoch berechtigterweise Berechtigungen ändern, seien Sie einfach vorsichtig bei der Verwendung des chmod-Befehls.",
          "quizAnswer": "4",
          "quizQuestion": "Welche Zahl repräsentiert die Leseberechtigung im numerischen Format?",
          "slug": "berechtigungenändern",
          "title": "Berechtigungen ändern"
        },
        {
          "exercise": "Ändern Sie die Gruppe und den Benutzer einiger Testdateien. Sehen Sie sich anschließend die Berechtigungen mit ls -l an.",
          "id": 3,
          "lessonContent": "Neben der Änderung von Berechtigungen für Dateien können Sie auch die Gruppen- und Benutzerbesitzrechte der Datei ändern. \n\n<b>Benutzerbesitz ändern</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nMit diesem Befehl wird der Besitzer von myfile auf patty gesetzt.\n\n<b>Gruppenbesitz ändern</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nMit diesem Befehl wird die Gruppe von myfile auf whales gesetzt.\n\n<b>Sowohl Benutzer- als auch Gruppenbesitz gleichzeitig ändern</b>\nWenn Sie nach dem Benutzernamen einen Doppelpunkt und den Gruppennamen hinzufügen, können Sie sowohl den Benutzer als auch die Gruppe gleichzeitig festlegen.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "Welchen Befehl verwenden Sie, um den Benutzerbesitz zu ändern?",
          "slug": "ownershippermissions",
          "title": "Besitzberechtigungen"
        },
        {
          "exercise": "<ol>\n<li>Erstellen Sie eine neue Datei und notieren Sie dann ihre Berechtigungen.</li>\n<li>Ändern Sie die umask und erstellen Sie dann eine weitere neue Datei.</li>\n<li>Überprüfen Sie erneut die Berechtigungen der neuen Datei. Was erwarten Sie zu sehen?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Jede Datei, die erstellt wird, kommt mit einem Standardberechtigungssatz. Wenn Sie jemals diesen Standardberechtigungssatz ändern möchten, können Sie dies mit dem Befehl umask tun. Dieser Befehl nimmt den 3-Bit-Berechtigungssatz, den wir in numerischen Berechtigungen sehen. \n\nAnstatt diese Berechtigungen hinzuzufügen, nimmt umask jedoch diese Berechtigungen weg. \n\n<pre>$ umask 021</pre>\n\nIm obigen Beispiel geben wir an, dass wir möchten, dass die Standardberechtigungen neuer Dateien Benutzern den Zugriff auf alles ermöglichen, aber für Gruppen möchten wir ihnen ihre Schreibberechtigung nehmen und für andere möchten wir ihre Ausführungsberechtigung nehmen. Die Standardumask in den meisten Distributionen ist 022, was bedeutet, dass alle Benutzer Zugriff haben, aber keine Schreibberechtigung für Gruppen- und andere Benutzer.\n\nWenn Sie den umask-Befehl ausführen, erhalten Sie diesen Standardberechtigungssatz für jede neue Datei, die Sie erstellen. Wenn Sie jedoch möchten, dass er bestehen bleibt, müssen Sie Ihre Startdatei (.profile) ändern, aber darüber werden wir in einer späteren Lektion sprechen.",
          "quizAnswer": "umask",
          "quizQuestion": "Mit welchem Befehl werden Standarddateiberechtigungen geändert?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Schau dir die Berechtigungen für /etc/passwd im Detail an, fällt dir noch etwas auf? Dateien mit aktiviertem SUID sind auch leicht erkennbar.",
          "id": 5,
          "lessonContent": "Es gibt viele Fälle, in denen normale Benutzer erhöhten Zugriff benötigen, um Aufgaben auszuführen. Der Systemadministrator kann nicht immer da sein, um jedes Mal ein Root-Passwort einzugeben, wenn ein Benutzer Zugriff auf eine geschützte Datei benötigt. Deshalb gibt es spezielle Dateiberechtigungsbits, die dieses Verhalten ermöglichen. Das Set User ID (SUID) ermöglicht einem Benutzer, ein Programm als Besitzer der Programmdatei auszuführen, anstatt als sich selbst.\n\nSchauen wir uns ein Beispiel an: \n\nAngenommen, ich möchte mein Passwort ändern, einfach, oder? Ich benutze einfach den passwd Befehl:\n\n<pre>$ passwd</pre>\n\nWas macht der passwd Befehl? Er modifiziert ein paar Dateien, aber am wichtigsten ist, dass er die /etc/shadow Datei modifiziert. Schauen wir uns diese Datei kurz an: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 1. Dez 11:45 /etc/shadow\n</pre>\n\nMoment mal, diese Datei gehört root? Wie ist es möglich, dass wir eine Datei ändern können, die root gehört? \n\nSchauen wir uns ein anderes Berechtigungsset an, diesmal des von uns ausgeführten Befehls: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 1. Dez 11:45 /usr/bin/passwd\n</pre>\n\nDu wirst hier ein neues Berechtigungsbit <b>s</b> bemerken. Dieses Berechtigungsbit ist das SUID, wenn eine Datei dieses Berechtigungsset hat, ermöglicht es den Benutzern, die das Programm gestartet haben, die Berechtigung des Dateibesitzers sowie die Ausführungsberechtigung zu erhalten, in diesem Fall root. Im Grunde genommen läuft der Benutzer, während er den passwd Befehl ausführt, als root.\n\nDeshalb können wir auf eine geschützte Datei wie /etc/shadow zugreifen, wenn wir den passwd Befehl ausführen. Wenn du dieses Bit entfernen würdest, würdest du feststellen, dass du /etc/shadow nicht ändern und daher dein Passwort nicht ändern kannst. \n\n<b>Ändern von SUID</b>\n\nWie bei regulären Berechtigungen gibt es zwei Möglichkeiten, SUID-Berechtigungen zu ändern. \n\n<i>Symbolischer Weg:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Numerischer Weg:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nWie du sehen kannst, wird das SUID durch eine 4 dargestellt und vor das Berechtigungsset gestellt. Du kannst das SUID als Großbuchstaben <b>S</b> sehen, das bedeutet, dass es immer noch dasselbe tut, aber keine Ausführungsberechtigungen hat.",
          "quizAnswer": "4",
          "quizQuestion": "Welche Zahl repräsentiert das SUID?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 6,
          "lessonContent": "Ähnlich wie das Set-User-ID-Berechtigungsbit gibt es ein Set-Group-ID (SGID)-Berechtigungsbit. Dieses Bit ermöglicht es einem Programm, so zu laufen, als wäre es ein Mitglied dieser Gruppe. \n\nSchauen wir uns ein Beispiel an: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nWir können jetzt sehen, dass das Berechtigungsbit im Gruppenberechtigungsset ist. \n\n<b>Ändern von SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nDie numerische Darstellung für SGID ist 2.",
          "quizAnswer": "2",
          "quizQuestion": "Welche Zahl repräsentiert das SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Wir haben noch nicht über Prozesse gesprochen, aber wir können uns trotzdem ansehen, wie diese Änderung in Echtzeit passiert: \n\n<ol>\n<li>Öffnen Sie ein Terminalfenster und führen Sie den Befehl aus: <b>watch -n 1 \"ps aux | grep passwd\"</b>. Dies wird den passwd-Prozess beobachten.</li>\n<li>Öffnen Sie ein zweites Terminalfenster und führen Sie aus: <b>passwd</b></li>\n<li>Schauen Sie sich das erste Terminalfenster an, Sie werden einen Prozess für passwd sehen. Die erste Spalte in der Prozesstabelle ist die effektive Benutzer-ID, und siehe da, es ist der Root-Benutzer!</li>\n</ol>",
          "id": 7,
          "lessonContent": "Lassen Sie uns kurz auf Prozessberechtigungen eingehen. Erinnern Sie sich daran, wie ich Ihnen gesagt habe, dass wenn Sie das Passwort mit dem SUID-Berechtigungsbit ausführen, das Programm als Root ausgeführt wird? Das stimmt, aber bedeutet das, dass Sie als vorübergehender Root-Benutzer die Passwörter anderer Benutzer ändern können? Nein, zum Glück nicht!\n\nDas liegt an den vielen UIDs, die Linux implementiert. Jeder Prozess hat drei UIDs zugeordnet:\n\nWenn Sie einen Prozess starten, wird er mit denselben Berechtigungen wie der Benutzer oder die Gruppe, die ihn gestartet hat, ausgeführt. Dies wird als <b>effektive Benutzer-ID</b> bezeichnet. Diese UID wird verwendet, um einem Prozess Zugriffsrechte zu gewähren. Wenn also Bob den Befehl touch ausführt, wird der Prozess als er ausgeführt und alle von ihm erstellten Dateien gehören ihm.\n\nEs gibt eine weitere UID, die als <b>reale Benutzer-ID</b> bezeichnet wird. Dies ist die ID des Benutzers, der den Prozess gestartet hat. Diese werden verwendet, um herauszufinden, wer der Benutzer ist, der den Prozess gestartet hat.\n\nEine letzte UID ist die <b>gespeicherte Benutzer-ID</b>, die es einem Prozess ermöglicht, zwischen der effektiven UID und der realen UID hin- und herzuschalten. Dies ist nützlich, da wir nicht möchten, dass unser Prozess die ganze Zeit mit erhöhten Rechten läuft. Es ist einfach eine gute Praxis, spezielle Berechtigungen nur zu bestimmten Zeiten zu verwenden.\n\nLassen Sie uns nun all dies zusammenfügen, indem wir uns den Befehl passwd noch einmal ansehen. \n\nWenn Sie den Befehl passwd ausführen, ist Ihre effektive UID Ihre Benutzer-ID, sagen wir vorerst 500. Oh, aber warten Sie, erinnern Sie sich daran, dass der Befehl passwd die SUID-Berechtigung aktiviert hat. Wenn Sie ihn also ausführen, ist Ihre effektive UID jetzt 0 (0 ist die UID von root). Jetzt kann dieses Programm auf Dateien als root zugreifen.\n\nAngenommen, Sie bekommen einen kleinen Vorgeschmack auf die Macht und möchten Sallys Passwort ändern. Sally hat eine UID von 600. Nun, Sie haben Pech, denn der Prozess hat auch Ihre reale UID in diesem Fall 500. Er weiß, dass Ihre UID 500 ist und Sie daher das Passwort der UID 600 nicht ändern können. (Dies wird natürlich immer umgangen, wenn Sie ein Superuser auf einem Rechner sind und alles kontrollieren und ändern können).\n\nDa Sie passwd ausgeführt haben, wird der Prozess mit Ihrer realen UID gestartet und die UID des Besitzers der Datei (effektive UID) wird gespeichert, damit Sie zwischen den beiden wechseln können. Es ist nicht erforderlich, alle Dateien mit Root-Zugriff zu ändern, wenn es nicht erforderlich ist. \n\nMeistens sind die reale UID und die effektive UID gleich, aber in Fällen wie dem passwd-Befehl ändern sie sich.",
          "quizAnswer": "effektive",
          "quizQuestion": "Welche UID entscheidet, welchen Zugriff gewährt wird?",
          "slug": "prozessberechtigungen",
          "title": "Prozessberechtigungen"
        },
        {
          "exercise": "Welche anderen Dateien und Verzeichnisse haben Ihrer Meinung nach ein Sticky-Bit aktiviert?",
          "id": 8,
          "lessonContent": "Ein letztes spezielles Berechtigungsbit, über das ich sprechen möchte, ist das Sticky-Bit. \n\nDieses Berechtigungsbit \"haftet an einer Datei/Verzeichnis\", was bedeutet, dass nur der Besitzer oder der Root-Benutzer die Datei löschen oder ändern kann. Dies ist sehr nützlich für freigegebene Verzeichnisse. Schauen Sie sich das folgende Beispiel an:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nSie sehen hier ein spezielles Berechtigungsbit am Ende <b>t</b>, das bedeutet, dass jeder Dateien hinzufügen, Dateien schreiben, Dateien im Verzeichnis /tmp ändern kann, aber nur der Root kann das Verzeichnis /tmp löschen. \n\n<b>Sticky-Bit ändern</b>\n\n<pre>$ sudo chmod +t meinverzeichnis\n\n$ sudo chmod 1755 meinverzeichnis</pre>\n\nDie numerische Darstellung für das Sticky-Bit ist <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "Welches Symbol repräsentiert das Sticky-Bit?",
          "slug": "stickybit",
          "title": "Das Sticky-Bit"
        }
      ],
      "slug": "permissions",
      "title": "Berechtigungen"
    },
    {
      "description": "Erfahren Sie mehr über die laufenden Prozesse im System.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Verwenden Sie den ps-Befehl mit verschiedenen Flags und sehen Sie, wie sich die Ausgabe ändert.",
          "id": 1,
          "lessonContent": "Prozesse sind die Programme, die auf Ihrem Rechner ausgeführt werden. Sie werden vom Kernel verwaltet und jedem Prozess ist eine damit verbundene ID zugeordnet, die als <b>Prozess-ID (PID)</b> bezeichnet wird. Diese PID wird in der Reihenfolge vergeben, in der Prozesse erstellt werden. \n\nFühren Sie den Befehl ps aus, um eine Liste der laufenden Prozesse anzuzeigen:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nDies zeigt Ihnen eine schnelle Übersicht über die aktuellen Prozesse:\n\n<ul>\n<li>PID: Prozess-ID</li>\n<li>TTY: Steuerterminal, das mit dem Prozess verbunden ist (dazu kommen wir später im Detail)</li>\n<li>STAT: Prozessstatuscode</li>\n<li>TIME: Gesamte CPU-Nutzungszeit</li>\n<li>CMD: Name des ausführbaren Befehls</li>\n</ul>\n\nWenn Sie die Manpage für ps betrachten, werden Sie feststellen, dass es viele Befehlsoptionen gibt, die Sie übergeben können. Diese variieren je nach den gewünschten Optionen - BSD, GNU oder Unix. Meiner Meinung nach ist der BSD-Stil beliebter, also werden wir diesen verwenden. Falls Sie neugierig sind, der Unterschied zwischen den Stilen liegt in der Anzahl der Bindestriche und den Flags.\n\n<pre>$ ps aux</pre>\n\nDas <b>a</b> zeigt alle laufenden Prozesse an, einschließlich derjenigen, die von anderen Benutzern ausgeführt werden. Das <b>u</b> zeigt mehr Details zu den Prozessen an. Und schließlich listet das <b>x</b> alle Prozesse auf, die kein TTY damit verbunden haben. Diese Programme zeigen in dem TTY-Feld ein ?, sie sind am häufigsten in Daemon-Prozessen zu finden, die als Teil des Systemstarts gestartet werden.\n\nSie werden feststellen, dass Sie jetzt viele weitere Felder sehen, Sie müssen sie nicht alle auswendig lernen. In einem späteren Kurs über fortgeschrittene Prozesse werden wir einige davon erneut durchgehen:\n\n<ul>\n<li>USER: Der effektive Benutzer (dessen Zugriff wir verwenden)</li>\n<li>PID: Prozess-ID</li>\n<li>%CPU: Von der Prozesslaufzeit verwendete CPU-Zeit geteilt durch die Laufzeit des Prozesses</li>\n<li>%MEM: Verhältnis der Größe des residenten Sets des Prozesses zum physischen Speicher auf dem Rechner</li>\n<li>VSZ: Virtuelle Speichernutzung des gesamten Prozesses</li>\n<li>RSS: Resident Set Size, der nicht ausgelagerte physische Speicher, den eine Aufgabe verwendet hat</li>\n<li>TTY: Steuerterminal, das mit dem Prozess verbunden ist</li>\n<li>STAT: Prozessstatuscode</li>\n<li>START: Startzeit des Prozesses</li>\n<li>TIME: Gesamte CPU-Nutzungszeit</li>\n<li>COMMAND: Name des ausführbaren Befehls</li>\n</ul>\n\nDer ps-Befehl kann etwas unübersichtlich sein, aber vorerst werden wir uns hauptsächlich die Felder PID, STAT und COMMAND ansehen. \n\nEin weiterer sehr nützlicher Befehl ist der <b>top</b>-Befehl. top liefert Echtzeitinformationen über die auf Ihrem System laufenden Prozesse anstelle eines Schnappschusses. Standardmäßig erhalten Sie alle 10 Sekunden eine Aktualisierung. Top ist ein äußerst nützliches Tool, um zu sehen, welche Prozesse viele Ihrer Ressourcen verbrauchen. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "Welche ps-Flagge wird verwendet, um detaillierte Informationen über Prozesse anzuzeigen?",
          "slug": "monitorprocessespscommand",
          "title": "ps (Prozesse)"
        },
        {
          "exercise": "Schauen Sie sich Ihre ps-Ausgabe an und listen Sie alle eindeutigen TTY-Werte auf.",
          "id": 2,
          "lessonContent": "Wir haben besprochen, wie es ein TTY-Feld im ps-Ausgabebereich gibt. Das TTY ist das Terminal, das den Befehl ausgeführt hat.\n\nEs gibt zwei Arten von Terminals, normale <b>Terminalgeräte</b> und <b>Pseudoterminalgeräte</b>. Ein normales Terminalgerät ist ein natives Terminalgerät, in das Sie eingeben und Ausgaben an Ihr System senden können. Das klingt wie die Terminalanwendung, die Sie gestartet haben, um zu Ihrer Shell zu gelangen, ist es aber nicht. \n\nWir werden jetzt übergehen, damit Sie diese Aktion sehen können. Tippen Sie auf Strg-Alt-F1, um zu TTY1 (die erste virtuelle Konsole) zu gelangen. Sie werden feststellen, dass Sie außer dem Terminal nichts haben, keine Grafiken usw. Dies wird als normales Terminalgerät betrachtet. Sie können dies mit Strg-Alt-F7 verlassen. \n\nEin Pseudoterminal ist das, woran Sie gewöhnt sind zu arbeiten. Sie emulieren Terminals mit dem Shell-Terminalfenster und werden durch PTS gekennzeichnet. Wenn Sie erneut ps betrachten, sehen Sie Ihren Shell-Prozess unter pts/*. \n\nOk, jetzt zurück zum Steuerungsterminal. Prozesse sind normalerweise an ein Steuerungsterminal gebunden. Wenn Sie beispielsweise ein Programm auf Ihrem Shell-Fenster wie find ausführen und das Fenster schließen, würde auch Ihr Prozess damit beendet. \n\nEs gibt Prozesse wie Dämonenprozesse, die spezielle Prozesse sind, die im Wesentlichen das System am Laufen halten. Sie starten oft beim Systemstart und werden normalerweise beim Herunterfahren des Systems beendet. Sie laufen im Hintergrund und da wir nicht möchten, dass diese speziellen Prozesse beendet werden, sind sie nicht an ein Steuerungsterminal gebunden. Im ps-Ausgabebereich wird das TTY als <b>?</b> aufgeführt, was bedeutet, dass es kein Steuerungsterminal hat.",
          "quizAnswer": "?",
          "quizQuestion": "Welcher Wert wird für einen Prozess angegeben, der kein Steuerungsterminal hat?",
          "slug": "steuerungsterminal",
          "title": "Steuerungsterminal"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Bevor wir uns mit praktischeren Anwendungen von Prozessen befassen, müssen wir zunächst verstehen, was sie sind und wie sie funktionieren. Dieser Teil kann verwirrend sein, da wir in die Details eintauchen, also kommen Sie gerne zu dieser Lektion zurück, wenn Sie jetzt nicht darüber lernen möchten. \n\nEin Prozess ist, wie wir bereits gesagt haben, ein laufendes Programm im System, genauer gesagt ist es das System, das Speicher, CPU, E/A zuweist, um das Programm auszuführen. Ein Prozess ist eine Instanz eines laufenden Programms, öffnen Sie drei Terminalfenster, führen Sie in zwei Fenstern den <b>cat</b>-Befehl ohne Übergeben von Optionen aus (der cat-Prozess bleibt als Prozess geöffnet, weil er stdin erwartet). Führen Sie nun im dritten Fenster aus: <b>ps aux | grep cat</b>. Sie werden feststellen, dass es zwei Prozesse für cat gibt, obwohl sie dasselbe Programm aufrufen.\n\nDer Kernel ist für Prozesse zuständig, wenn wir ein Programm ausführen, lädt der Kernel den Programmcode in den Speicher, bestimmt und allokiert Ressourcen und behält dann jeden Prozess im Auge, er weiß: \n\n<ul>\n<li>Der Status des Prozesses</li>\n<li>Die Ressourcen, die der Prozess verwendet und erhält</li>\n<li>Der Prozessbesitzer</li>\n<li>Signalverarbeitung (dazu später mehr)</li>\n<li>Und im Grunde alles andere</li>\n</ul>\n\nAlle Prozesse versuchen, einen Teil dieses süßen Ressourcenkuchens zu bekommen, es ist die Aufgabe des Kernels sicherzustellen, dass Prozesse je nach Prozessanforderungen die richtige Menge an Ressourcen erhalten. Wenn ein Prozess endet, werden die von ihm verwendeten Ressourcen nun für andere Prozesse freigegeben.",
          "quizAnswer": "Kernel",
          "quizQuestion": "Was verwaltet und steuert Prozesse?",
          "slug": "prozessdetails",
          "title": "Prozessdetails"
        },
        {
          "exercise": "Schauen Sie sich Ihre laufenden Prozesse an. Können Sie erkennen, welche anderen Prozesse Eltern haben?",
          "id": 4,
          "lessonContent": "Auch diese Lektion und die nächste sind rein informativ, um Ihnen zu zeigen, was unter der Oberfläche passiert. Gehen Sie gerne noch einmal darauf zurück, nachdem Sie etwas mehr mit Prozessen gearbeitet haben.\n\nWenn ein neuer Prozess erstellt wird, klonen sich im Grunde genommen ein bestehender Prozess selbst mithilfe eines sogenannten Fork-Systemaufrufs (Systemaufrufe werden erst sehr weit in der Zukunft diskutiert). Der Fork-Systemaufruf erstellt einen weitgehend identischen Kindprozess. Dieser Kindprozess erhält eine neue Prozess-ID (PID), und der ursprüngliche Prozess wird sein Elternprozess und hat etwas, das als Elternprozess-ID <b>PPID</b> bezeichnet wird. Anschließend kann der Kindprozess entweder weiterhin dasselbe Programm verwenden, das sein Elternteil zuvor verwendet hat, oder häufiger den execve-Systemaufruf verwenden, um ein neues Programm zu starten. Dieser Systemaufruf zerstört das von Kernel für diesen Prozess implementierte Speichermanagement und richtet neue für das neue Programm ein. \n\nWir können dies in Aktion sehen:\n\n<pre>$ ps l</pre>\n\nDie Option l gibt uns eine „lange Format“- oder noch detailliertere Ansicht unserer laufenden Prozesse. Sie sehen eine Spalte mit der Bezeichnung <b>PPID</b>, dies ist die Eltern-ID. Schauen Sie nun auf Ihren Terminal, Sie sehen einen laufenden Prozess, das ist Ihre Shell, also auf meinem System habe ich einen Prozess, der bash ausführt. Erinnern Sie sich daran, als Sie den Befehl ps l ausgeführt haben, haben Sie ihn von dem Prozess ausgeführt, der bash ausführte. Nun sehen Sie, dass die <b>PID</b> der bash-Shell die <b>PPID</b> des <b>ps l</b>-Befehls ist.\n\nWenn also jeder Prozess einen Elternteil haben muss und sie nur Forks voneinander sind, muss es einen Mutterprozess aller Prozesse geben, oder? Sie haben recht, wenn das System hochfährt, erstellt der Kernel einen Prozess namens <b>init</b>, der eine PID von 1 hat. Der init-Prozess kann nicht beendet werden, es sei denn, das System wird heruntergefahren. Er läuft mit Root-Berechtigungen und führt viele Prozesse aus, die das System am Laufen halten. Wir werden uns im Kurs zum Systemstart genauer mit init befassen, aber vorerst wissen Sie, dass es der Prozess ist, der alle anderen Prozesse erzeugt.",
          "quizAnswer": "fork",
          "quizQuestion": "Welcher Systemaufruf erstellt einen neuen Prozess?",
          "slug": "prozesserstellung",
          "title": "Prozesserstellung"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 5,
          "lessonContent": "Jetzt, da wir wissen, was passiert, wenn ein Prozess erstellt wird, was passiert, wenn wir ihn nicht mehr benötigen? Sei gewarnt, manchmal kann es in Linux ein wenig düster werden...\n\nEin Prozess kann mit dem _exit-Systemaufruf beendet werden, dadurch werden die Ressourcen freigegeben, die der Prozess verwendet hat, um sie erneut zuzuweisen. Wenn ein Prozess bereit ist zu terminieren, teilt er dem Kernel mit, warum er terminiert, mit etwas, das als Beendigungsstatus bezeichnet wird. Am häufigsten bedeutet ein Status von 0, dass der Prozess erfolgreich war. Das reicht jedoch nicht aus, um einen Prozess vollständig zu beenden. Der Elternprozess muss das Beenden des Kindprozesses anerkennen, indem er den wait-Systemaufruf verwendet, der den Beendigungsstatus des Kindprozesses überprüft. Ich weiß, es ist grausam, darüber nachzudenken, aber der wait-Aufruf ist eine Notwendigkeit, schließlich möchte jeder Elternteil wissen, wie sein Kind gestorben ist.\n\nEs gibt einen anderen Weg, um einen Prozess zu beenden, und das beinhaltet die Verwendung von Signalen, worüber wir bald sprechen werden.\n\n<b>Waisenprozesse</b>\n\nWenn ein Elternprozess stirbt, bevor ein Kindprozess stirbt, weiß der Kernel, dass er keinen wait-Aufruf erhalten wird. Stattdessen macht er diese Prozesse zu \"Waisen\" und stellt sie unter die Obhut von init (erinnere dich an die Mutter aller Prozesse). Init wird schließlich den wait-Systemaufruf für diese Waisen ausführen, damit sie sterben können.\n\n<b>Zombie-Prozesse</b>\n\nWas passiert, wenn ein Kind terminiert und der Elternprozess noch nicht wait aufgerufen hat? Wir möchten immer noch sehen können, wie ein Kindprozess terminiert wurde, also auch wenn der Kindprozess beendet ist, macht der Kernel den Kindprozess zu einem Zombie-Prozess. Die Ressourcen, die der Kindprozess verwendet hat, sind immer noch für andere Prozesse freigegeben, jedoch gibt es immer noch einen Eintrag im Prozesstabelle für diesen Zombie. Zombie-Prozesse können auch nicht getötet werden, da sie technisch gesehen \"tot\" sind, also können Sie keine Signale verwenden, um sie zu töten. Wenn der Elternprozess schließlich den wait-Systemaufruf aufruft, wird der Zombie verschwinden, dies wird als \"Ernten\" bezeichnet. Wenn der Elternprozess keinen wait-Aufruf durchführt, wird init den Zombie adoptieren und automatisch wait ausführen und den Zombie entfernen. Es kann schlecht sein, zu viele Zombie-Prozesse zu haben, da sie Platz in der Prozesstabelle beanspruchen. Wenn sie voll ist, wird dies verhindern, dass andere Prozesse ausgeführt werden.",
          "quizAnswer": "0",
          "quizQuestion": "Was ist der häufigste Beendigungsstatus für einen erfolgreichen Prozess?",
          "slug": "prozessbeendigung",
          "title": "Prozessbeendigung"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 6,
          "lessonContent": "Ein Signal ist eine Benachrichtigung an einen Prozess, dass etwas passiert ist.\n\n<b>Warum wir Signale haben</b>\n\nSie sind Software-Unterbrechungen und haben viele Verwendungszwecke:\n\n<ul>\n<li>Ein Benutzer kann eine der speziellen Terminalzeichen (Strg-C) oder (Strg-Z) eingeben, um Prozesse zu beenden, zu unterbrechen oder zu suspendieren</li>\n<li>Hardwareprobleme können auftreten und der Kernel möchte den Prozess benachrichtigen</li>\n<li>Softwareprobleme können auftreten und der Kernel möchte den Prozess benachrichtigen</li>\n<li>Es sind im Grunde Wege, wie Prozesse kommunizieren können</li>\n</ul>\n\n<b>Signalprozess</b>\n\nWenn ein Signal durch ein Ereignis erzeugt wird, wird es dann an einen Prozess übermittelt und befindet sich in einem ausstehenden Zustand, bis es übermittelt wird. Wenn der Prozess ausgeführt wird, wird das Signal übermittelt. Prozesse haben jedoch Signalmasken und können die Signalübermittlung blockieren, wenn dies angegeben ist. Wenn ein Signal übermittelt wird, kann ein Prozess eine Vielzahl von Dingen tun: \n\n<ul>\n<li>Das Signal ignorieren</li>\n<li>Das Signal \"abfangen\" und eine spezifische Handler-Routine ausführen</li>\n<li>Der Prozess kann beendet werden, im Gegensatz zum normalen Beenden des Systemaufrufs</li>\n<li>Das Signal blockieren, abhängig von der Signalmaske</li>\n</ul>\n\n<b>Gängige Signale</b>\n\nJedes Signal ist durch Ganzzahlen mit symbolischen Namen definiert, die in Form von SIGxxx vorliegen. Einige der häufigsten Signale sind: \n\n<ul>\n<li>SIGHUP oder HUP oder 1: Aufhängen</li>\n<li>SIGINT oder INT oder 2: Unterbrechung</li>\n<li>SIGKILL oder KILL oder 9: Beenden</li>\n<li>SIGSEGV oder SEGV oder 11: Speicherzugriffsfehler</li>\n<li>SIGTERM oder TERM oder 15: Softwarebeendigung</li>\n<li>SIGSTOP oder STOP: Stoppen</li>\n</ul>\n\nDie Zahlen können bei Signalen variieren, daher werden sie normalerweise anhand ihrer Namen bezeichnet.\n\nEinige Signale sind nicht blockierbar, ein Beispiel ist das SIGKILL-Signal. Das KILL-Signal zerstört den Prozess.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "Welches Signal ist nicht blockierbar?",
          "slug": "prozesssignale",
          "title": "Signale"
        },
        {
          "exercise": "Beenden Sie einige Prozesse unter Verwendung verschiedener Signale.",
          "id": 7,
          "lessonContent": "Sie können Signale senden, die Prozesse beenden, ein solches Kommando wird passenderweise als das kill-Kommando bezeichnet. \n\n<pre>$ kill 12445</pre>\n\nDie 12445 ist die PID des Prozesses, den Sie beenden möchten. Standardmäßig sendet es ein TERM-Signal. Das SIGTERM-Signal wird an einen Prozess gesendet, um seine Beendigung zu fordern, indem er ihm erlaubt, seine Ressourcen sauber freizugeben und seinen Zustand zu speichern. \n\nSie können auch ein Signal mit dem kill-Kommando angeben: \n\n<pre>$ kill -9 12445</pre>\n\nDies wird das SIGKILL-Signal ausführen und den Prozess beenden. \n\n<b>Unterschiede zwischen SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nDiese Signale klingen alle vernünftig ähnlich, haben aber ihre Unterschiede. \n\n<ul>\n<li>SIGHUP - Auflegen, wird an einen Prozess gesendet, wenn das steuernde Terminal geschlossen wird. Wenn Sie beispielsweise ein Terminalfenster geschlossen haben, in dem ein Prozess lief, würden Sie ein SIGHUP-Signal erhalten. Im Grunde genommen wurden Sie aufgelegt</li>\n<li>SIGINT - Ist ein Unterbrechungssignal, sodass Sie Strg-C verwenden können und das System versucht, den Prozess ordnungsgemäß zu beenden</li>\n<li>SIGTERM - Beendet den Prozess, erlaubt ihm jedoch, einige Aufräumarbeiten zu erledigen</li>\n<li>SIGKILL - Beendet den Prozess, beendet ihn mit Feuer, führt keine Aufräumarbeiten durch</li>\n<li>SIGSTOP - Stoppt/unterbricht einen Prozess</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "Wie lautet der Signalname für das Standard-Kill-Kommando?",
          "slug": "prozesse-beenden",
          "title": "kill (Beenden)"
        },
        {
          "exercise": "Welche Prozesse sind nicht sehr nett und warum?",
          "id": 8,
          "lessonContent": "Wenn Sie mehrere Dinge auf Ihrem Computer ausführen, wie vielleicht Chrome, Microsoft Word oder Photoshop gleichzeitig, mag es so aussehen, als ob diese Prozesse gleichzeitig laufen, aber das ist nicht ganz richtig. \n\nProzesse verwenden die CPU für einen kurzen Zeitraum, der als Zeitscheibe bezeichnet wird. Dann pausieren sie für Millisekunden und ein anderer Prozess erhält eine kleine Zeitscheibe. Standardmäßig erfolgt die Prozessplanung in dieser Round-Robin-Manier. Jeder Prozess erhält genügend Zeitscheiben, bis er mit der Verarbeitung fertig ist. Der Kernel übernimmt all diese Prozesswechsel und macht die meiste Zeit einen ziemlich guten Job daraus.\n\nProzesse können nicht entscheiden, wann und wie lange sie CPU-Zeit erhalten. Wenn alle Prozesse normal funktionieren würden, würden sie (ungefähr) jeweils die gleiche Menge an CPU-Zeit erhalten. Es gibt jedoch eine Möglichkeit, den Prozessplanungsalgorithmus des Kernels mit einem Nettigkeitswert zu beeinflussen. Nettigkeit ist ein ziemlich seltsamer Name, aber was es bedeutet, ist, dass Prozesse eine Zahl haben, um ihre Priorität für die CPU zu bestimmen. Eine hohe Zahl bedeutet, dass der Prozess nett ist und eine niedrigere Priorität für die CPU hat, und eine niedrige oder negative Zahl bedeutet, dass der Prozess nicht sehr nett ist und so viel CPU wie möglich erhalten möchte. \n\n<pre>$ top</pre>\n\nSie können derzeit eine Spalte für NI sehen, das ist der Nettigkeitsgrad eines Prozesses.\n\nUm den Nettigkeitsgrad zu ändern, können Sie die Befehle nice und renice verwenden:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nDer nice-Befehl wird verwendet, um die Priorität für einen neuen Prozess festzulegen. Der renice-Befehl wird verwendet, um die Priorität für einen vorhandenen Prozess festzulegen. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "niedrig",
          "quizQuestion": "Wenn ich möchte, dass ein Prozess eine höhere CPU-Priorität erhält, verwende ich eine niedrigere oder höhere Nettigkeitszahl?",
          "slug": "prozessnettigkeit",
          "title": "Nettigkeit"
        },
        {
          "exercise": "Werfen Sie einen Blick auf die laufenden Prozesse auf Ihrem System und überprüfen Sie deren Prozesszustände.",
          "id": 9,
          "lessonContent": "Lassen Sie uns den Befehl ps aux erneut betrachten:\n\n<pre>$ ps aux</pre>\n\nIm STAT-Feld sehen Sie viele Werte. Ein Linux-Prozess kann sich in verschiedenen Zuständen befinden. Die häufigsten Zustandscodes, die Sie sehen werden, sind unten beschrieben:\n\n<ul>\n<li>R: läuft oder ist ausführbar, er wartet nur darauf, dass die CPU ihn verarbeitet</li>\n<li>S: Unterbrechbarer Schlaf, wartet auf Abschluss eines Ereignisses, wie z.B. Eingabe vom Terminal</li>\n<li>D: Nicht unterbrechbarer Schlaf, Prozesse, die nicht beendet oder mit einem Signal unterbrochen werden können, normalerweise müssen Sie sie neu starten oder das Problem beheben, um sie zu beenden</li>\n<li>Z: Zombie, wir haben in einer früheren Lektion besprochen, dass Zombies beendete Prozesse sind, die darauf warten, dass ihre Status abgerufen werden</li>\n<li>T: Angehalten, ein Prozess, der angehalten wurde</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "Welcher STAT-Code wird verwendet, um einen nicht unterbrechbaren Schlaf darzustellen?",
          "slug": "prozesszustaende",
          "title": "Prozesszustände"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 10,
          "lessonContent": "Denken Sie daran, dass in Linux alles eine Datei ist, auch Prozesse. Prozessinformationen werden in einem speziellen Dateisystem namens /proc-Dateisystem gespeichert.\n\n<pre>$ ls /proc</pre>\n\nSie sollten hier mehrere Werte sehen, es gibt Unterverzeichnisse für jede PID. Wenn Sie sich eine PID im ps-Output angesehen haben, sollten Sie sie im /proc-Verzeichnis finden können.\n\nGehen Sie jetzt weiter und geben Sie einen der Prozesse ein und sehen Sie sich diese Datei an:\n\n<pre>$ cat /proc/12345/status</pre>\n\nSie sollten Informationen zum Prozesszustand sowie detailliertere Informationen sehen. Das /proc-Verzeichnis ist die Art und Weise, wie der Kernel das System betrachtet, daher gibt es hier viel mehr Informationen als das, was Sie in ps sehen würden.",
          "quizAnswer": "/proc",
          "quizQuestion": "Welches Dateisystem speichert Prozessinformationen?",
          "slug": "procfilesystem",
          "title": "/proc-Dateisystem"
        },
        {
          "exercise": "Verschieben Sie einige Jobs zwischen Hintergrund und Vordergrund",
          "id": 11,
          "lessonContent": "Angenommen, Sie arbeiten in einem einzelnen Terminalfenster und führen einen Befehl aus, der eine Ewigkeit dauert. Sie können nicht mit der Shell interagieren, bis der Befehl abgeschlossen ist. Wir möchten jedoch weiterhin an unseren Maschinen arbeiten, daher müssen wir diese Shell offen halten. Glücklicherweise können wir steuern, wie unsere Prozesse mit Jobs ausgeführt werden: \n\n<b>Senden eines Jobs in den Hintergrund</b>\n\nDurch Anhängen eines kaufmännischen Und-Zeichens (&) an den Befehl wird er im Hintergrund ausgeführt, sodass Sie Ihre Shell weiterhin verwenden können. Schauen wir uns ein Beispiel an:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Alle Hintergrundjobs anzeigen</b>\n\nNun können Sie die Jobs anzeigen, die Sie gerade in den Hintergrund geschickt haben.\n\n<pre>$ jobs\n\n[1]    Running     sleep 1000 &\n[2]-   Running     sleep 1001 &\n[3]+   Running     sleep 1002 &\n\n</pre>\n\nHier wird Ihnen die Job-ID in der ersten Spalte angezeigt, dann der Status und der ausgeführte Befehl. Das <b>+</b> neben der Job-ID bedeutet, dass es sich um den zuletzt gestarteten Hintergrundjob handelt. Der Job mit dem <b>-</b> ist der zweitjüngste Befehl.\n\n<b>Senden eines Jobs in den Hintergrund bei einem vorhandenen Job</b>\n\nWenn Sie bereits einen Job ausgeführt haben und ihn in den Hintergrund verschieben möchten, müssen Sie ihn nicht beenden und von vorne beginnen. Unterbrechen Sie zuerst den Job mit Strg-Z und führen Sie dann den Befehl <b>bg</b> aus, um ihn in den Hintergrund zu senden.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Stopped     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Running     sleep 1000 &\n[2]    Running     sleep 1001 &\n[3]-   Running     sleep 1002 &\n[4]+   Running     sleep 1003 &\n</pre>\n\n<b>Verschieben eines Jobs vom Hintergrund in den Vordergrund</b>\n\nUm einen Job aus dem Hintergrund zu holen, geben Sie einfach die gewünschte Job-ID an. Wenn Sie fg ohne Optionen ausführen, wird der zuletzt ausgeführte Hintergrundjob zurückgeholt (der Job mit dem + Zeichen daneben)\n\n<pre>$ fg %1</pre>\n\n<b>Beenden von Hintergrundjobs</b>\n\nÄhnlich wie beim Verschieben von Jobs aus dem Hintergrund können Sie die Prozesse mit ihrer Job-ID beenden.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "Welcher Befehl wird verwendet, um Hintergrundjobs aufzulisten?",
          "slug": "jobcontrol",
          "title": "Job Control"
        }
      ],
      "slug": "prozesse",
      "title": "Prozesse"
    },
    {
      "description": "Erfahren Sie alles über die Paketverwaltungstools dpkg, apt-get, rpm und yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "Für diese Lektion sind keine Übungen vorgesehen.",
          "id": 1,
          "lessonContent": "Ihr System besteht aus vielen Paketen wie Internetbrowsern, Texteditoren, Media-Playern usw. Diese Pakete werden über Paketmanager verwaltet, die die Software auf Ihrem System installieren und warten. Nicht alle Pakete werden jedoch über Paketmanager installiert. Sie können Pakete häufig direkt aus ihrem Quellcode installieren (darauf werden wir bald eingehen). Die meiste Zeit werden Sie jedoch einen Paketmanager verwenden, um Software zu installieren. Die häufigsten Arten von Paketen sind Debian (.deb) und Red Hat (.rpm). Debian-Pakete werden in Distributionen wie Debian, Ubuntu, LinuxMint usw. verwendet. Red Hat-Pakete sind in Red Hat Enterprise Linux, Fedora, CentOS usw. zu finden.\n\nWas sind Pakete? Sie kennen sie vielleicht als Chrome, Photoshop usw., aber sie sind eigentlich nur viele Dateien, die zu einer kompiliert wurden. Die Personen (oder manchmal eine einzelne Person), die diese Software schreiben, werden als <b>Upstream-Anbieter</b> bezeichnet. Sie kompilieren ihren Code und schreiben, wie er installiert werden kann. Diese Upstream-Anbieter arbeiten daran, neue Software herauszubringen und vorhandene Software zu aktualisieren. Wenn sie bereit sind, sie der Welt zur Verfügung zu stellen, senden sie ihr Paket an <b>Paketbetreuer</b>, die dafür sorgen, dass dieses Stück Software in die Hände der Benutzer gelangt. Diese Paketbetreuer überprüfen, verwalten und verteilen diese Software in Form von Paketen.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, gehen Sie weiter!",
          "slug": "softwaredistribution",
          "title": "Softwareverteilung"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen verfügbar.",
          "id": 2,
          "lessonContent": "Wie gelangen Pakete, die ins Internet hochgeladen werden, irgendwie auf unsere Computer? Gehst du auf die Download-Seite jedes Pakets, das du möchtest, und klickst auf Download und Installieren? Nun, eigentlich kannst du das tun, aber es gibt etwas Besseres namens Paket-Repositories. Repositories sind einfach zentrale Speicherorte für Pakete. Es gibt Unmengen von Repositories, die viele Pakete enthalten, und das Beste daran ist, dass sie alle im Internet zu finden sind, keine lästigen Installationsdisks. Deine Maschine weiß nicht, wo sie nach diesen Repositories suchen soll, es sei denn, du sagst ihr explizit, wo sie suchen soll.\n\nAngenommen, ich möchte beispielsweise die WackyWidgets-Software auf meiner Maschine haben. Nun, WackyWidgets verwaltet ihre eigenen Repositories für ihre Widget-Pakete. In diesem Repository befinden sich 10 Pakete, das CoolWidget-Paket, das SuperWidget-Paket usw. WackyWidgets hostet dieses Repository unter einem Quellenlink namens: http://download.widgets/linux/deb/\n\nAnstatt also auf ihrer Website direkt das Paket herunterzuladen, kannst du deiner Maschine sagen, dass sie die WackyWidgets-Software über den Quellenlink finden soll. \n\nDeine Distribution wird bereits mit vorab genehmigten Quellen geliefert, um Pakete zu beziehen, und so werden alle Basispakete installiert, die du auf deinem System siehst. Auf einem Debian-System ist diese Quellen-Datei die <b>/etc/apt/sources.list</b>-Datei. Deine Maschine wird wissen, dass sie dort nachschauen und nach allen von dir hinzugefügten Quellen-Repositories suchen soll.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Wo befindet sich die Quellen-Datei in einem Debian-System?",
          "slug": "packagerepositories",
          "title": "Paket-Repositories"
        },
        {
          "exercise": "Machen Sie sich mit der tar-Dokumentation vertraut und sehen Sie sich die anderen verfügbaren Optionen in der Manpage an.",
          "id": 3,
          "lessonContent": "Bevor wir uns mit der Paketinstallation und den verschiedenen Managern befassen, müssen wir über das Archivieren und Komprimieren von Dateien sprechen, da Sie höchstwahrscheinlich damit konfrontiert werden, wenn Sie im Internet nach Software suchen. \n\nSie wissen wahrscheinlich bereits, was ein Dateiarchiv ist, Sie sind höchstwahrscheinlich auf Dateitypen wie .rar und .zip gestoßen. Dies sind Archive von Dateien, sie enthalten viele Dateien in sich, aber sie kommen in dieser sehr ordentlichen einzelnen Datei, die als Archiv bekannt ist.\n\n<b>Dateien mit gzip komprimieren</b>\n\ngzip ist ein Programm, das in Linux zum Komprimieren von Dateien verwendet wird, sie enden mit der Erweiterung .gz. \n\nUm eine Datei zu komprimieren:\n<pre>$ gzip meinecooledatei</pre>\n\nUm die Datei zu dekomprimieren:\n<pre>$ gunzip meinecooledatei.gz</pre>\n\n<b>Archive mit tar erstellen</b>\nLeider kann gzip nicht mehrere Dateien zu einem Archiv hinzufügen. Glücklicherweise haben wir das Programm tar, das dies kann. Wenn Sie ein Archiv mit tar erstellen, wird es die Erweiterung .tar haben. \n\n<pre>$ tar cvf meinarchiv.tar meinecooledatei1 meinecooledatei2</pre>\n\n<ul>\n<li>c - erstellen</li>\n<li>v - teilen Sie dem Programm mit, dass es ausführlich sein soll und lassen Sie uns sehen, was es tut</li>\n<li>f - der Dateiname der tar-Datei muss nach dieser Option kommen, wenn Sie eine tar-Datei erstellen, müssen Sie einen Namen ausdenken</li>\n</ul>\n\n<b>Archive mit tar entpacken</b>\n\nUm den Inhalt einer tar-Datei zu extrahieren, verwenden Sie: \n\n<pre>$ tar xvf meinarchiv.tar</pre>\n\n<ul>\n<li>x - extrahieren</li>\n<li>v - teilen Sie dem Programm mit, dass es ausführlich sein soll und lassen Sie uns sehen, was es tut</li>\n<li>f - die Datei, die Sie extrahieren möchten</li>\n</ul>\n\n<b>Archive mit tar und gzip komprimieren/dekomprimieren</b>\n\nOft sehen Sie eine tar-Datei, die komprimiert wurde, z. B.: meinekomprimiertearchiv.tar.gz, alles, was Sie tun müssen, ist von außen nach innen zu arbeiten, also zuerst die Komprimierung mit gunzip zu entfernen und dann die tar-Datei zu entpacken. Oder Sie können alternativ die Option <b>z</b> mit tar verwenden, die ihm einfach sagt, das gzip- oder gunzip-Dienstprogramm zu verwenden.\n\nErstellen Sie eine komprimierte tar-Datei:\n<pre>$ tar czf meineDatei.tar.gz</pre>\n\nEntkomprimieren und entpacken: \n<pre>$ tar xzf datei.tar</pre>\n\nWenn Sie Hilfe benötigen, denken Sie daran: e<b>X</b>trahiere alle <b>Z</b>ee <b>F</b>iles!\n\ntar ist einer dieser Befehle, die so wichtig sind und doch erinnern Sie sich nie wirklich daran, relevantes xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Weitere Dienstprogramme</b>\n\nAuf Ihrer Linux-Reise werden Sie auf andere Archiv- und Komprimierungstypen wie bzip2, compress, zip, unzip usw. stoßen. Sie sind etwas weniger verbreitet, aber denken Sie daran, dass verschiedene Dienstprogramme verschiedene Befehle erfordern.",
          "quizAnswer": "c",
          "quizQuestion": "Welche tar-Flagge wird zum Erstellen von Archiven verwendet?",
          "slug": "compressedarchivestar",
          "title": "tar und gzip"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen vorgesehen.",
          "id": 4,
          "lessonContent": "Pakete funktionieren sehr selten alleine, sie werden meistens von Abhängigkeiten begleitet, um ihnen beim Ausführen zu helfen. Zum Beispiel, nehmen wir an, wir haben eine Gruppe von Restaurants, diese Restaurants bieten alle verschiedene Küchen an, jedoch beziehen sie alle ihre Zutaten vom selben Bauernhof. Ihr Essen ist abhängig von den Vorräten des Bauernhofs, wenn der Bauernhof plötzlich aufhören würde, Essen zu liefern, dann wären die Restaurants in einem ziemlich schlechten Zustand. \n\nIn Linux sind diese Abhängigkeiten oft andere Pakete oder gemeinsam genutzte Bibliotheken. Gemeinsam genutzte Bibliotheken sind Codebibliotheken, die von anderen Programmen verwendet werden möchten und die nicht selbst neu schreiben möchten. Denken Sie wieder an das Restaurant, wie viel Arbeit wäre es, wenn jedes Restaurant auch seine eigenen Lebensmittel anbauen würde? Zu viel.\n\nWir werden uns im Kurs zum Dateisystem genauer mit gemeinsam genutzten Bibliotheken befassen, also denken Sie jetzt einfach daran, dass Pakete Abhängigkeiten haben, um ihnen beim Ausführen zu helfen, ob diese Abhängigkeiten andere Pakete oder Bibliotheken sind, wenn die Abhängigkeiten nicht vorhanden sind, wird das Paket in einem fehlerhaften Zustand enden und die meiste Zeit nicht einmal installiert werden.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, gehen Sie weiter!",
          "slug": "packagedependencies",
          "title": "Paketabhängigkeiten"
        },
        {
          "exercise": "Finden Sie ein Programm, das Sie auf Ihrem System installieren möchten, wie Google Chrome, und installieren Sie es mit einem dieser Befehle.",
          "id": 5,
          "lessonContent": "Obwohl der Großteil dieses Kurses sich mit Paketverwaltungssystemen beschäftigt (die Batmans der Paketverwaltung), dürfen wir die Robins nicht vergessen. Obwohl sie sehr nützlich und zuverlässig sind, kommen sie nicht mit dem coolen Batmobil und dem Utility-Gürtel.\n\nGenau wie .exe eine einzelne ausführbare Datei ist, sind auch .deb und .rpm solche. Normalerweise würden Sie diese nicht sehen, wenn Sie Paketquellen verwenden, aber wenn Sie Pakete direkt herunterladen, werden Sie sie höchstwahrscheinlich in einem dieser beliebten Formate erhalten. Offensichtlich sind sie exklusiv für ihre Distributionen, .deb für Debian-basierte und .rpm für Red Hat-basierte.\n\nUm diese direkten Pakete zu installieren, können Sie die Paketverwaltungsbefehle verwenden: rpm und dpkg. Diese Tools werden verwendet, um Paketdateien zu installieren, installieren jedoch nicht die Paketabhängigkeiten. Wenn Ihr Paket beispielsweise 10 Abhängigkeiten hatte, müssten Sie diese Pakete separat installieren und dann deren Abhängigkeiten und so weiter. Wie Sie sehen können, war das einer der Gründe, die die umfassenden Verwaltungssysteme hervorgebracht haben, über die wir später sprechen werden.\n\nDenken Sie daran, dass es unzählige Male geben wird, in denen Sie ein Paket mit einem dieser Tools installieren, abfragen oder überprüfen müssen, also merken Sie sich diese Befehle. \n\n<b>Ein Paket installieren</b>\n\n<pre>\nDebian: $ dpkg -i some_deb_package.deb\nRPM: $ rpm -i some_rpm_package.rpm\n</pre>\n\nDas <b>i</b> steht für installieren. Sie können auch das längere Format von --install verwenden. \n\n<b>Ein Paket entfernen</b>\n\n<pre>\nDebian: $ dpkg -r some_deb_package.deb\nRPM: $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian: <b>r</b> für entfernen\nRPM: <b>e</b> für löschen\n\n<b>Installierte Pakete auflisten</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> für auflisten\nRPM: <b>q</b> für abfragen und <b>a</b> für alle",
          "quizAnswer": "dpkg",
          "quizQuestion": "Welches ist das Paketverwaltungstool für .deb-Dateien?",
          "slug": "packageinstalltools",
          "title": "rpm und dpkg"
        },
        {
          "exercise": "Führen Sie jeden dieser Paketbefehle aus und sehen Sie sich die Ausgabe an, die Sie erhalten.",
          "id": 6,
          "lessonContent": "Ah, die Batmans des Paketmanagements, diese Systeme kommen mit allem Drum und Dran, um die Paketinstallation, -entfernung und -änderungen zu erleichtern, einschließlich der Installation von Paketabhängigkeiten. Zwei der beliebtesten Managementsysteme sind <b>yum</b> und <b>apt</b>. Yum ist exklusiv für die Red Hat-Familie und apt ist exklusiv für die Debian-Familie.\n\n<b>Installieren eines Pakets aus einem Repository</b>\n\n<pre>\nDebian: $ apt install paketname\nRPM: $ yum install paketname\n</pre>\n\n<b>Ein Paket entfernen</b>\n\n<pre>\nDebian: $ apt remove paketname\nRPM: $ yum erase paketname\n</pre>\n\n<b>Aktualisieren von Paketen für ein Repository</b>\n\nEs ist immer bewährte Praxis, Ihre Paket-Repositories zu aktualisieren, damit sie vor der Installation und Aktualisierung eines Pakets auf dem neuesten Stand sind. \n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Informationen zu einem installierten Paket abrufen</b>\n\n<pre>\nDebian: apt show paketname\nRPM: yum info paketname\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Welcher Befehl wird verwendet, um Paketinformationen auf einem Debian-System anzuzeigen?",
          "slug": "packagemanagementsystems",
          "title": "yum und apt"
        },
        {
          "exercise": "Finde ein Quellcode-Programm (von einer vertrauenswürdigen Website) und installiere es aus dem Quellcode.",
          "id": 7,
          "lessonContent": "Oftmals wirst du auf ein obskures Paket stoßen, das nur in Form von reinem Quellcode verfügbar ist. Du musst einige Befehle verwenden, um dieses Quellcode-Paket zu kompilieren und auf deinem System zu installieren. \n\nZuerst benötigst du Software, um die Tools zu installieren, die es dir ermöglichen, Quellcode zu kompilieren. \n\n<pre>$ sudo apt install build-essential</pre>\n\nSobald du das erledigt hast, entpacke den Inhalt der Paketdatei, höchstwahrscheinlich eine .tar.gz-Datei. \n\n<pre>$ tar -xzvf paket.tar.gz</pre>\n\nBevor du irgendetwas machst, wirf einen Blick in die README- oder INSTALL-Datei im Paket. Manchmal gibt es spezifische Installationsanweisungen. \n\nJe nach Kompiliermethode, die der Entwickler verwendet hat, musst du unterschiedliche Befehle verwenden, wie z. B. cmake oder etwas anderes.\n\nJedoch wirst du am häufigsten die grundlegende make-Kompilierung sehen, daher werden wir das besprechen:\n\nIm Paketinhalt befindet sich ein Konfigurationsskript, dieses Skript überprüft die Abhängigkeiten auf deinem System und wenn etwas fehlt, erhältst du einen Fehler und musst diese Abhängigkeiten beheben. \n\n<pre>$ ./configure</pre>\n\nDas <b>./</b> ermöglicht es dir, ein Skript im aktuellen Verzeichnis auszuführen. \n\n<pre>$ make</pre>\n\nIm Paketinhalt gibt es eine Datei namens Makefile, die Regeln zum Erstellen der Software enthält. Wenn du den make-Befehl ausführst, schaut er sich diese Datei an, um die Software zu erstellen.\n\n<pre>$ sudo make install</pre>\n\nDieser Befehl installiert tatsächlich das Paket, er kopiert die richtigen Dateien an die richtigen Stellen auf deinem Computer.\n\nWenn du das Paket deinstallieren möchtest, verwende:\n\n<pre>$ sudo make uninstall</pre>\n\nSei vorsichtig bei der Verwendung von make install, du könntest nicht realisieren, was tatsächlich im Hintergrund passiert. Wenn du dich entscheidest, dieses Paket zu entfernen, könntest du möglicherweise nicht alles entfernen, weil du nicht realisiert hast, was deinem System hinzugefügt wurde. Vergiss stattdessen alles, was ich dir gerade über make install erklärt habe, und verwende den <b>checkinstall</b>-Befehl. Dieser Befehl erstellt eine .deb-Datei für dich, die du einfach installieren und deinstallieren kannst. \n\n<pre>$ sudo checkinstall</pre> \n\nDieser Befehl wird im Wesentlichen \"make install\" ausführen, ein .deb-Paket erstellen und installieren. Dadurch wird es einfacher, das Paket später zu entfernen.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "Was solltest du IMMER anstelle von make install verwenden?",
          "slug": "quellcodekompilieren",
          "title": "Quellcode kompilieren"
        }
      ],
      "slug": "packages",
      "title": "Pakete"
    },
    {
      "description": "Erfahren Sie mehr über Linux-Geräte und wie sie mit dem Kernel und dem Benutzerbereich interagieren.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Schauen Sie sich den Inhalt des /dev Verzeichnisses an, erkennen Sie bekannte Geräte?",
          "id": 1,
          "lessonContent": "Wenn Sie ein Gerät an Ihren Computer anschließen, benötigt es in der Regel einen Gerätetreiber, um ordnungsgemäß zu funktionieren. Sie können mit Gerätetreibern über Gerätedateien oder Geräteknoten interagieren, dies sind spezielle Dateien, die wie normale Dateien aussehen. Da diese Gerätedateien genauso wie normale Dateien sind, können Sie Programme wie ls, cat usw. verwenden, um mit ihnen zu interagieren. Diese Gerätedateien werden in der Regel im /dev Verzeichnis gespeichert. Gehen Sie voran und ls das /dev Verzeichnis auf Ihrem System, Sie werden eine große Anzahl von Gerätedateien sehen, die auf Ihrem System vorhanden sind. \n\n<pre>$ ls /dev </pre>\n\nEinige dieser Geräte haben Sie bereits verwendet und mit ihnen interagiert, wie z.B. /dev/null. Erinnern Sie sich, wenn wir Ausgaben nach /dev/null senden, weiß der Kernel, dass dieses Gerät alle unsere Eingaben annimmt und einfach verwirft, sodass nichts zurückgegeben wird.\n\nFrüher mussten Sie, wenn Sie ein Gerät zu Ihrem System hinzufügen wollten, die Gerätedatei in /dev hinzufügen und dann wahrscheinlich vergessen. Wiederholen Sie das ein paar Mal und Sie können sehen, wo das Problem lag. Das /dev Verzeichnis würde mit statischen Gerätedateien von Geräten überfüllt werden, die Sie längst aufgerüstet, nicht mehr verwendet usw. haben. Geräten werden auch Gerätedateien in der Reihenfolge zugewiesen, in der der Kernel sie findet. Wenn Sie also jedes Mal Ihr System neu starten, könnten die Geräte je nach Entdeckungszeitpunkt unterschiedliche Gerätedateien haben.\n\nZum Glück verwenden wir diese Methode nicht mehr, jetzt haben wir etwas, das wir verwenden, um Geräte dynamisch hinzuzufügen und zu entfernen, die derzeit auf dem System verwendet werden, und wir werden dies in den kommenden Lektionen besprechen.",
          "quizAnswer": "/dev",
          "quizQuestion": "Wo werden Gerätedateien auf dem System gespeichert?",
          "slug": "devdirectory",
          "title": "/dev Verzeichnis"
        },
        {
          "exercise": "Schauen Sie sich Ihr /dev-Verzeichnis an und finden Sie heraus, welche Arten von Geräten Sie sehen können.",
          "id": 2,
          "lessonContent": "Bevor wir darüber sprechen, wie Geräte verwaltet werden, werfen wir tatsächlich einen Blick auf einige Geräte.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nDie Spalten sind von links nach rechts wie folgt:\n\n<ul>\n<li>Berechtigungen</li>\n<li>Besitzer</li>\n<li>Gruppe</li>\n<li>Major Device Nummer</li>\n<li>Minor Device Nummer</li>\n<li>Zeitstempel</li>\n<li>Gerätename</li>\n</ul>\n\nDenken Sie daran, dass Sie im ls-Befehl den Dateityp mit dem ersten Bit in jeder Zeile sehen können. Gerätedateien werden wie folgt gekennzeichnet: \n\n<ul>\n<li>c - Zeichen</li>\n<li>b - Block</li>\n<li>p - Pipe</li>\n<li>s - Socket</li>\n</ul>\n\n<b>Zeichengerät</b>\n\nDiese Geräte übertragen Daten, aber nur ein Zeichen auf einmal. Sie werden viele Pseudogeräte (/dev/null) als Zeichengeräte sehen, diese Geräte sind nicht wirklich physisch mit dem Gerät verbunden, ermöglichen dem Betriebssystem jedoch eine größere Funktionalität. \n\n<b>Blockgerät</b>\n\nDiese Geräte übertragen Daten in großen festen Blockgrößen. Sie sehen häufig Geräte, die Datenblöcke verwenden, als Blockgeräte, wie z. B. Festplatten, Dateisysteme usw. \n\n<b>Rohrgerät</b>\n\nBenannte Rohre ermöglichen es zwei oder mehr Prozessen, miteinander zu kommunizieren. Sie ähneln Zeichengeräten, aber anstatt die Ausgabe an ein Gerät zu senden, wird sie an einen anderen Prozess gesendet. \n\n<b>Socket-Gerät</b>\n\nSocket-Geräte erleichtern die Kommunikation zwischen Prozessen, ähnlich wie Rohrgeräte, können aber mit vielen Prozessen gleichzeitig kommunizieren. \n\n<b>Gerätecharakterisierung</b>\n\nGeräte werden mit zwei Zahlen charakterisiert, <b>Major Device Nummer</b> und <b>Minor Device Nummer</b>. Sie können diese Zahlen im obigen ls-Beispiel sehen, sie sind durch ein Komma getrennt. Angenommen, ein Gerät hätte die Gerätenummern: <b>8, 0</b>:\n\nDie Major Device Nummer repräsentiert den Gerätetreiber, der verwendet wird, in diesem Fall 8, was oft die Hauptnummer für sd-Blockgeräte ist. Die Minor-Nummer gibt dem Kernel an, um welches eindeutige Gerät es sich in dieser Treiberklasse handelt, in diesem Fall wird 0 verwendet, um das erste Gerät (a) zu repräsentieren.",
          "quizAnswer": "c",
          "quizQuestion": "Was ist das Symbol für Zeichengeräte im ls -l Befehl?",
          "slug": "devicetypes",
          "title": "Gerätetypen"
        },
        {
          "exercise": "Schreiben Sie auf die Pseudo-Geräte und sehen Sie, was passiert, seien Sie vorsichtig, dass Sie nicht auf Ihre Festplatten auf diese Geräte schreiben!",
          "id": 3,
          "lessonContent": "Hier sind die häufigsten Gerätenamen, auf die Sie stoßen werden: \n\n<b>SCSI-Geräte</b>\n\nWenn Sie eine Art Massenspeicher auf Ihrem Gerät haben, ist die Wahrscheinlichkeit groß, dass es das SCSI-Protokoll verwendet. SCSI steht für Small Computer System Interface, es handelt sich um ein Protokoll, das die Kommunikation zwischen Festplatten, Druckern, Scannern und anderen Peripheriegeräten mit Ihrem System ermöglicht. Möglicherweise haben Sie von SCSI-Geräten gehört, die in modernen Systemen nicht mehr verwendet werden, jedoch ordnen unsere Linux-Systeme SCSI-Festplatten Festplattenlaufwerken in /dev zu. Sie werden durch einen Präfix von sd (SCSI-Disk) repräsentiert:\n\nGängige SCSI-Gerätedateien:\n\n<ul>\n<li>/dev/sda - Erste Festplatte</li>\n<li>/dev/sdb - Zweite Festplatte</li>\n<li>/dev/sda3 - Dritte Partition auf der ersten Festplatte</li>\n</ul>\n\n<b>Pseudo-Geräte</b>\n\nWie wir zuvor besprochen haben, sind Pseudo-Geräte nicht physisch mit Ihrem System verbunden, die häufigsten Pseudo-Geräte sind Zeichengeräte: \n\n<ul>\n<li>/dev/zero - akzeptiert und verwirft alle Eingaben, erzeugt einen kontinuierlichen Strom von NULL (Wert Null) Bytes</li>\n<li>/dev/null - akzeptiert und verwirft alle Eingaben, erzeugt keine Ausgabe</li>\n<li>/dev/random - erzeugt Zufallszahlen</li>\n</ul>\n\n<b>PATA-Geräte</b>\n\nManchmal werden in älteren Systemen Festplatten mit einem hd-Präfix bezeichnet: \n\n<ul>\n<li>/dev/hda - Erste Festplatte</li>\n<li>/dev/hdd2 - Zweite Partition auf der vierten Festplatte</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "Wie würde üblicherweise der Gerätename für die erste Partition auf der zweiten SCSI-Festplatte lauten?",
          "slug": "gerätenamen",
          "title": "Gerätenamen"
        },
        {
          "exercise": "Schauen Sie sich den Inhalt des /sys-Verzeichnisses an und sehen Sie, welche Dateien sich dort befinden.",
          "id": 4,
          "lessonContent": "Sysfs wurde vor langer Zeit erstellt, um Geräte auf unserem System besser zu verwalten, was das Verzeichnis /dev nicht geschafft hat. Sysfs ist ein virtuelles Dateisystem, das meist im Verzeichnis /sys eingehängt wird. Es liefert uns detailliertere Informationen als das, was wir im Verzeichnis /dev sehen könnten. Beide Verzeichnisse /sys und /dev scheinen sehr ähnlich zu sein und sind es in gewisser Hinsicht auch, aber es gibt wesentliche Unterschiede. Grundsätzlich ist das /dev-Verzeichnis einfach, es ermöglicht anderen Programmen, auf Geräte selbst zuzugreifen, während das /sys-Dateisystem verwendet wird, um Informationen anzuzeigen und das Gerät zu verwalten. \n\nDas /sys-Dateisystem enthält im Wesentlichen alle Informationen zu allen Geräten auf Ihrem System, wie Hersteller und Modell, wo das Gerät angeschlossen ist, der Zustand des Geräts, die Hierarchie der Geräte und mehr. Die Dateien, die Sie hier sehen, sind keine Geräteknoten, daher interagieren Sie nicht wirklich mit Geräten aus dem /sys-Verzeichnis, sondern verwalten Geräte. \n\nWerfen Sie einen Blick auf den Inhalt des /sys-Verzeichnisses:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "Welches Verzeichnis wird verwendet, um detaillierte Informationen zu Geräten anzuzeigen?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Führen Sie den angegebenen udevadm-Befehl aus und überprüfen Sie die Ausgabe.",
          "id": 5,
          "lessonContent": "Früher und auch heute, wenn Sie wirklich wollten, würden Sie Geräteknoten mit einem Befehl wie diesem erstellen: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nDieser Befehl erstellt einen Geräteknoten /dev/sdb1 und macht ihn zu einem Blockgerät (b) mit einer Hauptnummer von 8 und einer Nebennummer von 3.\n\nUm ein Gerät zu entfernen, würden Sie einfach die Gerätedatei im /dev-Verzeichnis löschen. \n\nGlücklicherweise müssen wir das heute nicht mehr tun, dank udev. Das udev-System erstellt und entfernt dynamisch Gerätedateien für uns, je nachdem, ob sie verbunden sind oder nicht. Es gibt einen udevd-Dämon, der auf dem System läuft und auf Nachrichten vom Kernel über angeschlossene Geräte hört. Udevd wird diese Informationen analysieren und mit den Regeln abgleichen, die in /etc/udev/rules.d festgelegt sind. Abhängig von diesen Regeln wird es höchstwahrscheinlich Geräteknoten und symbolische Links für die Geräte erstellen. Sie können Ihre eigenen udev-Regeln schreiben, aber das ist etwas außerhalb des Rahmens dieses Unterrichts. Glücklicherweise enthält Ihr System bereits viele udev-Regeln, sodass Sie wahrscheinlich nie Ihre eigenen schreiben müssen.\n\nSie können auch die udev-Datenbank und sysfs mit dem <b>udevadm</b>-Befehl anzeigen. Dieses Tool ist sehr nützlich, kann aber manchmal sehr verworren sein. Ein einfacher Befehl, um Informationen für ein Gerät anzuzeigen, wäre:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "Was fügt Geräte dynamisch hinzu und entfernt sie wieder?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Probieren Sie jeden dieser Befehle aus und sehen Sie sich die Ausgabe an, die Sie erhalten.",
          "id": 6,
          "lessonContent": "Genau wie wir den ls-Befehl verwenden würden, um Dateien und Verzeichnisse aufzulisten, können wir ähnliche Tools verwenden, die Informationen über Geräte auflisten.\n\n<b>USB-Geräte auflisten</b>\n\n<pre>$ lsusb </pre>\n\n<b>PCI-Geräte auflisten</b>\n\n<pre>$ lspci </pre>\n\n<b>SCSI-Geräte auflisten</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "Welcher Befehl kann verwendet werden, um USB-Geräte anzuzeigen?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Verwenden Sie den dd-Befehl, um ein Backup Ihres Laufwerks zu erstellen und die Ausgabe in eine .img-Datei zu setzen.",
          "id": 7,
          "lessonContent": "Das dd-Tool ist super nützlich zum Konvertieren und Kopieren von Daten. Es liest Eingaben aus einer Datei oder einem Datenstrom und schreibt sie in eine Datei oder einen Datenstrom. \n\nBetrachten Sie den folgenden Befehl: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nDieser Befehl kopiert die Inhalte von backup.img nach /dev/sdb. Es kopiert die Daten in Blöcken von 1024 Bytes, bis keine Daten mehr kopiert werden müssen. \n\n<ul>\n<li>if=Datei - Eingabedatei, liest aus einer Datei anstelle von der Standardeingabe</li>\n<li>of=Datei - Ausgabedatei, schreibt in eine Datei anstelle von der Standardausgabe</li>\n<li>bs=Bytes - Blockgröße, liest und schreibt diese Anzahl von Bytes Daten auf einmal. Sie können verschiedene Größenmetriken verwenden, indem Sie die Größe mit k für Kilobyte, m für Megabyte usw. kennzeichnen, also sind 1024 Bytes 1k</li>\n<li>count=Anzahl - Anzahl der zu kopierenden Blöcke.</li>\n</ul>\n\nSie werden einige dd-Befehle sehen, die die Option count verwenden, normalerweise mit dd if, wenn Sie eine Datei kopieren möchten, die 1 Megabyte groß ist, möchten Sie normalerweise sehen, dass die Datei als 1 Megabyte fertig kopiert ist. Angenommen, Sie führen den folgenden Befehl aus: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nUnsere backup.img-Datei ist 10M groß, jedoch kopieren wir in diesem Befehl nur 1M 2-mal, sodass nur 2M kopiert werden und unsere kopierten Daten unvollständig sind. Count kann in vielen Situationen nützlich sein, aber wenn Sie nur Daten kopieren, können Sie count und sogar bs weitgehend weglassen. Wenn Sie Ihre Datenübertragungen wirklich optimieren möchten, sollten Sie diese Optionen verwenden.\n\ndd ist äußerst leistungsfähig, Sie können es verwenden, um Backups von allem zu erstellen, einschließlich ganzer Festplatten, Wiederherstellen von Festplattenabbildern und mehr. Seien Sie vorsichtig, dieses leistungsstarke Tool kann teuer werden, wenn Sie nicht sicher sind, was Sie tun.",
          "quizAnswer": "bs",
          "quizQuestion": "Was ist die dd-Option für die Blockgröße?",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Geräte"
    },
    {
      "description": "Erfahren Sie mehr über das Linux-Dateisystem, die verschiedenen Arten von Dateisystemen, Partitionierung und mehr.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Schauen Sie in Ihr /usr-Verzeichnis, welche Art von Informationen befinden sich dort?",
          "id": 1,
          "lessonContent": "An diesem Punkt sind Sie wahrscheinlich mit der Verzeichnisstruktur Ihres Systems gut vertraut, falls nicht, werden Sie es bald sein. Dateisysteme können in ihrer Struktur variieren, aber größtenteils sollten sie dem Dateisystem-Hierarchie-Standard entsprechen. \n\nFühren Sie <b>ls -l /</b> aus, um die unter dem Stammverzeichnis aufgeführten Verzeichnisse zu sehen. Ihre Verzeichnisse können anders aussehen als meine, aber sie sollten größtenteils wie folgt aussehen:\n\n<ul>\n<li>/ - Das Stammverzeichnis der gesamten Dateisystem-Hierarchie, alles ist unter diesem Verzeichnis eingebettet.</li>\n<li>/bin - Wesentliche sofort ausführbare Programme (Binärdateien), enthält die grundlegendsten Befehle wie ls und cp.</li>\n<li>/boot - Enthält Kernel-Bootloader-Dateien.</li>\n<li>/dev - Gerätedateien.</li>\n<li>/etc - Kernsystemkonfigurationsverzeichnis, sollte nur Konfigurationsdateien enthalten und keine Binärdateien.</li>\n<li>/home - Persönliche Verzeichnisse für Benutzer, enthält Ihre Dokumente, Dateien, Einstellungen usw.</li>\n<li>/lib - Enthält Bibliotheksdateien, die von Binärdateien verwendet werden können.</li>\n<li>/media - Wird als Anknüpfungspunkt für Wechselmedien wie USB-Laufwerke verwendet.</li>\n<li>/mnt - Temporär eingehängte Dateisysteme.</li>\n<li>/opt - Optionale Anwendungssoftwarepakete.</li>\n<li>/proc - Informationen über aktuell laufende Prozesse.</li>\n<li>/root - Das Stammverzeichnis des Root-Benutzers.</li>\n<li>/run - Informationen über das laufende System seit dem letzten Start.</li>\n<li>/sbin - Enthält wesentliche Systembinärdateien, die normalerweise nur vom Root-Benutzer ausgeführt werden können.</li>\n<li>/srv - Standortspezifische Daten, die vom System bereitgestellt werden.</li>\n<li>/tmp - Speicherort für temporäre Dateien.</li>\n<li>/usr - Dies ist leider benannt, enthält in den meisten Fällen keine Benutzerdateien im Sinne eines Benutzerverzeichnisses. Dies ist für benutzerinstallierte Software und Dienstprogramme gedacht, jedoch bedeutet das nicht, dass Sie keine persönlichen Verzeichnisse hinzufügen können. In diesem Verzeichnis befinden sich Unterverzeichnisse für /usr/bin, /usr/local usw.</li>\n<li>/var - Verzeichnis für Variablen, wird für Systemprotokollierung, Benutzerverfolgung, Zwischenspeicher usw. verwendet. Grundsätzlich alles, was sich ständig ändert.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "In welchem Verzeichnis werden Protokolle gespeichert?",
          "slug": "dateisystemhierarchie",
          "title": "Dateisystem-Hierarchie"
        },
        {
          "exercise": "Recherchieren Sie online zu den anderen Dateisystemtypen: ReiserFS, ZFS, JFS und andere, die Sie finden können.",
          "id": 2,
          "lessonContent": "Es gibt viele verschiedene Dateisystemimplementierungen. Einige sind schneller als andere, einige unterstützen größere Speicherkapazitäten und andere funktionieren nur auf kleineren Speicherkapazitäten. Unterschiedliche Dateisysteme organisieren ihre Daten auf unterschiedliche Weise, und wir werden im Detail darauf eingehen, welche Arten von Dateisystemen es gibt. Da es so viele verschiedene Implementierungen gibt, benötigen Anwendungen eine Möglichkeit, mit den verschiedenen Operationen umzugehen. Daher gibt es etwas, das als Virtual File System (VFS) Abstraktionsschicht bezeichnet wird. Es handelt sich um eine Schicht zwischen Anwendungen und den verschiedenen Dateisystemtypen, sodass Ihre Anwendungen unabhängig vom Dateisystem damit arbeiten können. \n\nSie können viele Dateisysteme auf Ihren Festplatten haben, abhängig davon, wie sie partitioniert sind, und wir werden das in einer kommenden Lektion durchgehen.\n\n<b>Journaling</b>\n\nJournaling ist standardmäßig bei den meisten Dateisystemtypen aktiviert, aber für den Fall, dass es nicht der Fall ist, sollten Sie wissen, was es bewirkt. Angenommen, Sie kopieren eine große Datei und plötzlich geht der Strom aus. Nun, wenn Sie sich auf einem nicht-journalisierten Dateisystem befinden, würde die Datei beschädigt werden und Ihr Dateisystem wäre inkonsistent, und dann würde Ihr System beim nächsten Start eine Dateisystemüberprüfung durchführen, um sicherzustellen, dass alles in Ordnung ist. Die Reparaturen könnten jedoch je nach Größe Ihres Dateisystems eine Weile dauern. \n\nWenn Sie jedoch auf einem journalisierten System wären, würde Ihr Rechner noch bevor er mit dem Kopieren der Datei beginnt, in einer Protokolldatei (Journal) festhalten, was Sie tun werden. Wenn Sie die Datei dann tatsächlich kopieren, markiert das Journal diese Aufgabe als abgeschlossen, sobald sie abgeschlossen ist. Das Dateisystem ist aufgrund dessen immer in einem konsistenten Zustand, sodass es genau weiß, wo Sie aufgehört haben, wenn Ihr Rechner plötzlich heruntergefahren wird. Dies verkürzt auch die Bootzeit, da es anstatt das gesamte Dateisystem zu überprüfen, nur Ihr Journal betrachtet.\n\n<b>Gängige Desktop-Dateisystemtypen</b>\n\n<ul>\n<li>ext4 - Dies ist die aktuellste Version der nativen Linux-Dateisysteme. Es ist kompatibel mit den älteren Versionen ext2 und ext3. Es unterstützt Festplattenvolumina von bis zu 1 Exabyte und Dateigrößen von bis zu 16 Terabyte und vieles mehr. Es ist die Standardwahl für Linux-Dateisysteme.</li>\n<li>Btrfs - \"Better or Butter FS\", es ist ein neues Dateisystem für Linux, das mit Snapshots, inkrementellen Backups, Leistungssteigerungen und vielem mehr kommt. Es ist weit verbreitet, aber noch nicht ganz stabil und kompatibel.</li>\n<li>XFS - Hochleistungs-Journaling-Dateisystem, ideal für ein System mit großen Dateien wie einem Medienserver.</li>\n<li>NTFS und FAT - Windows-Dateisysteme</li>\n<li>HFS+ - Macintosh-Dateisystem</li>\n</ul>\n\nÜberprüfen Sie, welche Dateisysteme auf Ihrem Rechner vorhanden sind: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-Blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nDer <b>df</b> Befehl gibt Informationen zur Dateisystem-Disknutzung und anderen Details über Ihre Festplatte aus. Wir werden später noch mehr über dieses Tool sprechen.",
          "quizAnswer": "ext4",
          "quizQuestion": "Was ist der gängige Linux-Dateisystemtyp?",
          "slug": "dateisystemtypen",
          "title": "Dateisystemtypen"
        },
        {
          "exercise": "Führen Sie <b>parted -l</b> auf Ihrem Gerät aus und bewerten Sie Ihre Ergebnisse.",
          "id": 3,
          "lessonContent": "Festplatten können in Partitionen unterteilt werden, wodurch im Wesentlichen mehrere Blockgeräte entstehen. Denken Sie an Beispiele wie /dev/sda1 und /dev/sda2, /dev/sda ist die gesamte Festplatte, aber /dev/sda1 ist die erste Partition auf dieser Festplatte. Partitionen sind äußerst nützlich, um Daten zu trennen. Wenn Sie ein bestimmtes Dateisystem benötigen, können Sie einfach eine Partition erstellen, anstatt die gesamte Festplatte zu einem Dateisystemtyp zu machen.\n\n<b>Partitionstabelle</b>\n\nJede Festplatte hat eine Partitionstabelle, die dem System mitteilt, wie die Festplatte partitioniert ist. Diese Tabelle zeigt an, wo Partitionen beginnen und enden, welche Partitionen bootfähig sind, welche Sektoren der Festplatte welcher Partition zugeordnet sind usw. Es gibt zwei Hauptpartitionstabellenschemata, die verwendet werden: Master Boot Record (MBR) und GUID Partition Table (GPT).\n\n<b>Partition</b>\n\nFestplatten bestehen aus Partitionen, die uns helfen, unsere Daten zu organisieren. Sie können mehrere Partitionen auf einer Festplatte haben, die sich nicht überschneiden können. Wenn Platz nicht einer Partition zugeordnet ist, wird er als Freiraum bezeichnet. Die Arten von Partitionen hängen von Ihrer Partitionstabelle ab. Innerhalb einer Partition können Sie ein Dateisystem haben oder eine Partition anderen Dingen wie Swap widmen.\n\n<i>MBR</i>\n\n<ul>\n<li>Traditionelle Partitionstabelle, wurde als Standard verwendet</li>\n<li>Kann primäre, erweiterte und logische Partitionen haben</li>\n<li>MBR hat eine Grenze von vier primären Partitionen</li>\n<li>Zusätzliche Partitionen können erstellt werden, indem eine primäre Partition in eine erweiterte Partition umgewandelt wird (es kann nur eine erweiterte Partition auf einer Festplatte geben). Dann fügen Sie innerhalb der erweiterten Partition logische Partitionen hinzu. Die logischen Partitionen werden genauso wie jede andere Partition verwendet. Verrückt, ich weiß.</li>\n<li>Unterstützt Festplatten bis zu 2 Terabyte</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>GUID Partition Table (GPT) wird zum neuen Standard für die Festplattenpartitionierung</li>\n<li>Hat nur eine Art von Partition und Sie können viele davon erstellen</li>\n<li>Jede Partition hat eine global eindeutige ID (GUID)</li>\n<li>Wird hauptsächlich in Verbindung mit dem UEFI-basierten Booten verwendet (darauf werden wir in einem anderen Kurs eingehen)</li>\n</ul>\n\n<b>Dateisystemstruktur</b>\n\nWir wissen aus unserer vorherigen Lektion, dass ein Dateisystem eine organisierte Sammlung von Dateien und Verzeichnissen ist. In seiner einfachsten Form besteht es aus einer Datenbank zur Verwaltung von Dateien und den eigentlichen Dateien selbst, aber wir werden etwas genauer darauf eingehen. \n\n<ul>\n<li>Bootblock - Dies befindet sich in den ersten Sektoren des Dateisystems und wird vom Dateisystem nicht wirklich verwendet. Es enthält Informationen, die zum Booten des Betriebssystems verwendet werden. Das Betriebssystem benötigt nur einen Bootblock. Wenn Sie mehrere Partitionen haben, haben sie Bootblöcke, aber viele davon werden nicht verwendet.</li>\n<li>Superblock - Dies ist ein einzelner Block, der nach dem Bootblock kommt, und enthält Informationen über das Dateisystem, wie die Größe der Inodetabelle, die Größe der logischen Blöcke und die Größe des Dateisystems.</li>\n<li>Inodetabelle - Denken Sie an dies als die Datenbank, die unsere Dateien verwaltet (wir haben eine ganze Lektion über Inodes, also keine Sorge). Jede Datei oder jedes Verzeichnis hat einen eindeutigen Eintrag in der Inodetabelle und enthält verschiedene Informationen über die Datei.</li>\n<li>Datenblöcke - Dies sind die tatsächlichen Daten für die Dateien und Verzeichnisse.</li>\n</ul>\n\nSchauen wir uns die verschiedenen Partitionstabellen an. Im Folgenden finden Sie ein Beispiel für eine Partition unter Verwendung der MBR-Partitionierungstabelle (msdos). Sie können die primären, erweiterten und logischen Partitionen auf dem Gerät sehen.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSektorgröße (logisch/physikalisch): 512B/512B\nPartitionstabelle: msdos\n\nNummer  Start   Ende     Größe    Typ      Dateisystem     Flags\n 1      1049kB  6860MB  6859MB  primär   ext4            boot\n 2      6861MB  21.5GB  14.6GB  erweitert\n 5      6861MB  7380MB  519MB   logisch   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logisch   xfs\n</pre>\n\n\nDieses Beispiel ist GPT und verwendet nur eine eindeutige ID für die Partitionen.\n\n<pre>\nModell: Thumb Drive (scsi)\nDisk /dev/sdb: 4041MB\nSektorgröße (logisch/physikalisch): 512B/512B\nPartitionstabelle: gpt\n\nNummer  Start   Ende     Größe     Dateisystem  Name        Flags\n 1      17.4kB  1000MB  1000MB                first\n 2      1000MB  4040MB  3040MB                second\n</pre>",
          "quizAnswer": "erweitert",
          "quizQuestion": "Welcher Partitionstyp wird verwendet, um mehr als 4 Partitionen im MBR-Partitionierungsschema zu erstellen?",
          "slug": "anatomieeinerfestplatte",
          "title": "Anatomie einer Festplatte"
        },
        {
          "exercise": "Partitionieren Sie ein USB-Laufwerk, wobei die Hälfte des Laufwerks als ext4 und die andere Hälfte als freier Speicherplatz verwendet wird.",
          "id": 4,
          "lessonContent": "Lassen Sie uns praktische Dinge mit Dateisystemen machen, indem wir den Prozess an einem USB-Laufwerk durchgehen. Wenn Sie keines haben, keine Sorge, Sie können trotzdem an den nächsten Lektionen teilnehmen. \n\nZuerst müssen wir unsere Festplatte partitionieren. Es gibt viele Tools, um dies zu tun: \n\n<ul>\n<li>fdisk - grundlegendes partitionierungstool für die Befehlszeile, unterstützt kein GPT</li>\n<li>parted - dies ist ein Befehlszeilentool, das sowohl MBR- als auch GPT-Partitionierung unterstützt</li>\n<li>gparted - dies ist die GUI-Version von parted</li>\n<li>gdisk - fdisk, unterstützt jedoch nur GPT, nicht MBR</li>\n</ul>\n\nLassen Sie uns parted verwenden, um unsere Partitionierung durchzuführen. Angenommen, ich schließe das USB-Gerät an und wir sehen, dass der Gerätename /dev/sdb2 ist. \n\n<b>Starten Sie parted</b>\n\n<pre>$ sudo parted</pre>\n\nSie werden in das parted-Tool eingeben, hier können Sie Befehle ausführen, um Ihr Gerät zu partitionieren. \n\n<b>Wählen Sie das Gerät aus</b>\n\n<pre>select /dev/sdb2</pre>\n\nUm das Gerät auszuwählen, mit dem Sie arbeiten werden, wählen Sie es anhand seines Gerätenamens aus.\n\n<b>Aktuelle Partitionstabelle anzeigen</b>\n\n<pre>\n(parted) print                                                            \nModell: Seagate (scsi)\nDisk /dev/sda: 21,5GB\nSektorgröße (logisch/physikalisch): 512B/512B\nPartitionstabelle: msdos\n\nNummer  Start   Ende     Größe    Typ      Dateisystem     Flags\n 1      1049kB  6860MB  6859MB  primär   ext4            boot\n 2      6861MB  21,5GB  14,6GB  erweitert\n 5      6861MB  7380MB  519MB   logisch   linux-swap(v1)\n 6      7381MB  21,5GB  14,1GB  logisch   xfs\n</pre>\n\nHier sehen Sie die verfügbaren Partitionen auf dem Gerät. Die <b>Start</b>- und <b>End</b>-Punkte sind die Stellen, an denen die Partitionen auf der Festplatte Platz einnehmen. Sie sollten einen guten Start- und Endpunkt für Ihre Partitionen finden. \n\n<b>Partitionieren Sie das Gerät</b>\n\n<pre>mkpart primär 123 4567</pre>\n\nWählen Sie einfach einen Start- und Endpunkt aus und erstellen Sie die Partition. Sie müssen den Partitionstyp angeben, abhängig von der verwendeten Tabelle. \n\n<b>Ändern Sie die Größe einer Partition</b>\n\nSie können auch die Größe einer Partition ändern, wenn kein Platz mehr vorhanden ist. \n\n<pre>resize 2 1245 3456</pre>\n\nWählen Sie die Partitionsnummer und dann die Start- und Endpunkte aus, an denen Sie sie ändern möchten. \n\nParted ist ein sehr leistungsfähiges Tool, und Sie sollten vorsichtig sein, wenn Sie Ihre Festplatten partitionieren.",
          "quizAnswer": "mkpart",
          "quizQuestion": "Was ist der parted-Befehl, um eine Partition zu erstellen?",
          "slug": "festplattenpartitionierung",
          "title": "Festplattenpartitionierung"
        },
        {
          "exercise": "Erstellen Sie ein ext4-Dateisystem auf dem USB-Laufwerk.",
          "id": 5,
          "lessonContent": "Jetzt, da Sie tatsächlich eine Festplatte partitioniert haben, erstellen wir ein Dateisystem!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nSo einfach ist das! Das <b>mkfs</b> (Dateisystem erstellen) Tool ermöglicht es uns, den Dateisystemtyp und den Speicherort anzugeben. Sie sollten nur ein Dateisystem auf einer neu partitionierten Festplatte erstellen oder wenn Sie eine alte neu partitionieren. Wenn Sie versuchen, ein Dateisystem über einem bestehenden zu erstellen, wird Ihr Dateisystem höchstwahrscheinlich in einem beschädigten Zustand bleiben.",
          "quizAnswer": "mkfs",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Dateisystem zu erstellen?",
          "slug": "creatingfilesystems",
          "title": "Dateisysteme erstellen"
        },
        {
          "exercise": "Schauen Sie sich die Manpage für mount und umount an und sehen Sie, welche anderen Optionen Sie verwenden können.",
          "id": 6,
          "lessonContent": "Bevor Sie den Inhalt Ihres Dateisystems anzeigen können, müssen Sie es einbinden. Dazu benötigen Sie den Gerätestandort, den Dateisystemtyp und einen Einhängepunkt. Der Einhängepunkt ist ein Verzeichnis im System, an dem das Dateisystem angehängt wird. Wir möchten also unser Gerät an einen Einhängepunkt anhängen. \n\nErstellen Sie zunächst den Einhängepunkt, in unserem Fall <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nSo einfach ist das! Wenn wir jetzt zu /mydrive gehen, können wir den Inhalt unseres Dateisystems sehen, das <b>-t</b> gibt den Dateisystemtyp an, dann haben wir den Gerätestandort und schließlich den Einhängepunkt. \n\nUm ein Gerät von einem Einhängepunkt aushängen: \n\n<pre>$ sudo umount /mydrive \noder \n$ sudo umount /dev/sdb2</pre>\n\nDenken Sie daran, dass der Kernel Geräte in der Reihenfolge benennt, in der er sie findet. Was ist, wenn sich aus irgendeinem Grund der Gerätename nach dem Einhängen ändert? Glücklicherweise können Sie anstelle eines Namens eine universell eindeutige ID (UUID) eines Geräts verwenden.\n\nUm die UUIDs auf Ihrem System für Blockgeräte anzuzeigen:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nWir sehen die Gerätenamen, ihre entsprechenden Dateisystemtypen und ihre UUIDs. Wenn wir jetzt etwas einhängen möchten, können wir verwenden:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nMeistens müssen Sie Geräte nicht über ihre UUIDs einhängen, es ist viel einfacher, den Gerätenamen zu verwenden, und oft weiß das Betriebssystem, wie man gängige Geräte wie USB-Laufwerke einhängt. Wenn Sie jedoch ein Dateisystem beim Start automatisch einhängen müssen, z. B. wenn Sie eine sekundäre Festplatte hinzugefügt haben, sollten Sie die UUID verwenden, und das werden wir im nächsten Lektion behandeln.",
          "quizAnswer": "mount",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Dateisystem anzuhängen?",
          "slug": "dateisystemeinhängenundaushängen",
          "title": "Einbinden und Aushängen"
        },
        {
          "exercise": "Fügen Sie das USB-Laufwerk, an dem wir gearbeitet haben, als Eintrag in /etc/fstab hinzu. Wenn Sie neu starten, sollte es immer noch eingebunden sein.",
          "id": 7,
          "lessonContent": "Wenn wir möchten, dass Dateisysteme beim Start automatisch eingebunden werden, können wir sie zu einer Datei namens /etc/fstab hinzufügen (ausgesprochen \"eff es tab\" und nicht \"eff stab\"), kurz für Dateisystemtabelle. Diese Datei enthält eine dauerhafte Liste von eingebundenen Dateisystemen.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nJede Zeile stellt ein Dateisystem dar, die Felder sind: \n\n<ul>\n<li>UUID - Gerätekennung</li>\n<li>Einhängepunkt - Verzeichnis, in das das Dateisystem eingehängt ist</li>\n<li>Dateisystemtyp</li>\n<li>Optionen - andere Einhängeoptionen, siehe Handbuch für weitere Details</li>\n<li>Dump - wird vom Dump-Dienstprogramm verwendet, um zu entscheiden, wann ein Backup erstellt werden soll, Sie sollten standardmäßig auf 0 setzen</li>\n<li>Pass - Wird von fsck verwendet, um zu entscheiden, in welcher Reihenfolge Dateisysteme überprüft werden sollen, wenn der Wert 0 ist, wird es nicht überprüft</li>\n</ul>\n\nUm einen Eintrag hinzuzufügen, ändern Sie einfach direkt die Datei /etc/fstab mit der oben genannten Eintragssyntax. Seien Sie vorsichtig beim Ändern dieser Datei, Sie könnten Ihr Leben etwas schwieriger machen, wenn Sie einen Fehler machen.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "Welche Datei wird verwendet, um festzulegen, wie Dateisysteme eingebunden werden sollen?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Partitionieren Sie den freien Speicher im USB-Laufwerk für den Swap-Speicher.",
          "id": 8,
          "lessonContent": "In unserem vorherigen Beispiel habe ich Ihnen gezeigt, wie Sie Ihre Partitionstabelle sehen können. Lassen Sie uns dieses Beispiel erneut betrachten, genauer gesagt diese Zeile:\n\n<pre>\nNumber  Start   End     Size    Type      File system     Flags\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n</pre>\n\nWas ist diese Swap-Partition? Nun, Swap ist das, was wir verwenden, um virtuellen Speicher für unser System zuzuweisen. Wenn Ihr Speicher knapp ist, verwendet das System diese Partition, um Teile des Speichers von inaktiven Prozessen auf die Festplatte zu \"swappen\", sodass Sie nicht durch Speichermangel beeinträchtigt werden.\n\n<b>Verwendung einer Partition für den Swap-Speicher</b>\n\nAngenommen, wir möchten unsere Partition /dev/sdb2 für den Swap-Speicher verwenden.\n\n<ol>\n<li>Stellen Sie zunächst sicher, dass sich nichts auf der Partition befindet</li>\n<li>Führen Sie aus: mkswap /dev/sdb2, um Swap-Bereiche zu initialisieren</li>\n<li>Führen Sie aus: swapon /dev/sdb2, um das Swap-Gerät zu aktivieren</li>\n<li>Wenn Sie möchten, dass die Swap-Partition beim Booten bestehen bleibt, müssen Sie einen Eintrag in der Datei /etc/fstab hinzufügen. sw ist der Dateisystemtyp, den Sie verwenden werden.</li>\n<li>Um den Swap zu entfernen: swapoff /dev/sdb2</li>\n</ol>\n\nIm Allgemeinen sollten Sie etwa doppelt so viel Swap-Speicher zuweisen, wie Sie an Arbeitsspeicher haben. Moderne Systeme heute sind jedoch normalerweise leistungsfähig genug und verfügen bereits über ausreichend RAM.",
          "quizAnswer": "swapon",
          "quizQuestion": "Was ist der Befehl, um den Swap-Speicher auf einem Gerät zu aktivieren?",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "Schauen Sie sich Ihre Festplattenauslastung und den freien Speicherplatz mit du und df an.",
          "id": 9,
          "lessonContent": "Es gibt einige Tools, die Sie verwenden können, um die Auslastung Ihrer Festplatten zu sehen: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-Blöcke    Verwendet Verfügbar Verw% Eingehängt auf\n/dev/sda1       6,2G  2,3G  3,6G  40% /\n</pre>\n\nDer df-Befehl zeigt Ihnen die Auslastung Ihrer aktuell eingehängten Dateisysteme. Die -h-Flagge gibt Ihnen ein menschenlesbares Format. Sie können sehen, um welches Gerät es sich handelt und wie viel Kapazität verwendet und verfügbar ist. \n\nAngenommen, Ihre Festplatte wird voll und Sie möchten wissen, welche Dateien oder Verzeichnisse diesen Speicherplatz belegen, dafür können Sie den <b>du</b>-Befehl verwenden. \n\n<pre>$ du -h</pre>\n\nDies zeigt Ihnen die Festplattenauslastung des aktuellen Verzeichnisses, in dem Sie sich befinden. Sie können einen Blick auf das Stammverzeichnis mit <b>du -h /</b> werfen, aber das kann etwas unübersichtlich werden.\n\nBeide Befehle sind in der Syntax so ähnlich, dass es schwer sein kann, sich zu merken, welchen man verwenden soll. Um zu überprüfen, wie viel Ihrer <b>Festplatte</b> <b>frei</b> ist, verwenden Sie df. Um die <b>Festplattenauslastung</b> zu überprüfen, verwenden Sie du.",
          "quizAnswer": "df",
          "quizQuestion": "Welcher Befehl wird verwendet, um anzuzeigen, wie viel Speicherplatz auf Ihrer Festplatte frei ist?",
          "slug": "diskusage",
          "title": "Festplattenauslastung"
        },
        {
          "exercise": "Schauen Sie sich die Manpage für fsck an, um zu sehen, was es noch kann.",
          "id": 10,
          "lessonContent": "Manchmal ist unser Dateisystem nicht immer in bestem Zustand. Bei einem plötzlichen Herunterfahren kann unsere Daten beschädigt werden. Es liegt am System, uns wieder in einen funktionsfähigen Zustand zu bringen (obwohl wir es sicher auch selbst versuchen können).\n\nDer <b>fsck</b> (Dateisystemprüfung) Befehl wird verwendet, um die Konsistenz eines Dateisystems zu überprüfen und kann sogar versuchen, es für uns zu reparieren. Normalerweise wird fsck beim Booten einer Festplatte ausgeführt, bevor Ihre Festplatte eingehängt wird, um sicherzustellen, dass alles in Ordnung ist. Manchmal ist Ihre Festplatte jedoch so schlecht, dass Sie dies manuell tun müssen. Stellen Sie jedoch sicher, dass Sie dies durchführen, während Sie in einer Rettungs-CD oder an einem Ort sind, an dem Sie auf Ihr Dateisystem zugreifen können, ohne dass es eingehängt ist.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "Welcher Befehl wird verwendet, um die Integrität eines Dateisystems zu überprüfen?",
          "slug": "dateisystemreparatur",
          "title": "Dateisystemreparatur"
        },
        {
          "exercise": "Beobachten Sie einige Inodennummern für verschiedene Dateien, welche werden normalerweise zuerst erstellt?",
          "id": 11,
          "lessonContent": "Erinnern Sie sich daran, wie unser Dateisystem aus all unseren tatsächlichen Dateien und einer Datenbank besteht, die diese Dateien verwaltet? Die Datenbank wird als Inode-Tabelle bezeichnet. \n\n<b>Was ist ein Inode?</b>\n\nEin Inode (Indexknoten) ist ein Eintrag in dieser Tabelle, und es gibt einen für jede Datei. Er beschreibt alles über die Datei, wie z.B.:\n\n<ul>\n<li>Dateityp - reguläre Datei, Verzeichnis, Zeichengerät, usw.</li>\n<li>Besitzer</li>\n<li>Gruppe</li>\n<li>Zugriffsberechtigungen</li>\n<li>Zeitstempel - mtime (Zeit der letzten Dateiänderung), ctime (Zeit der letzten Attributänderung), atime (Zeit des letzten Zugriffs)</li>\n<li>Anzahl der harten Verknüpfungen zur Datei</li>\n<li>Dateigröße</li>\n<li>Anzahl der Blöcke, die der Datei zugewiesen sind</li>\n<li>Zeiger auf die Datenblöcke der Datei - am wichtigsten!</li>\n</ul>\n\nIm Grunde speichern Inodes alles über die Datei, außer dem Dateinamen und der Datei selbst!\n\n<b>Wann werden Inodes erstellt?</b>\n\nWenn ein Dateisystem erstellt wird, wird auch Platz für Inodes zugewiesen. Es gibt Algorithmen, die bestimmen, wie viel Inode-Speicherplatz Sie je nach Volumen der Festplatte und mehr benötigen. Sie haben wahrscheinlich schon einmal Fehlermeldungen für Speicherplatzprobleme gesehen. Nun, dasselbe kann auch für Inodes passieren (obwohl seltener), Sie können also keine weiteren Dateien erstellen, wenn Ihnen die Inodes ausgehen. Denken Sie daran, dass die Datenspeicherung sowohl von den Daten als auch von der Datenbank (Inodes) abhängt. \n\nUm zu sehen, wie viele Inodes auf Ihrem System noch übrig sind, verwenden Sie den Befehl <b>df -i</b>\n\n<b>Inode-Informationen</b>\n\nInodes werden durch Nummern identifiziert. Wenn eine Datei erstellt wird, wird ihr eine Inodennummer zugewiesen, die Nummer wird in aufeinanderfolgender Reihenfolge zugewiesen. Manchmal fällt Ihnen jedoch auf, dass eine neu erstellte Datei eine Inodennummer erhält, die niedriger ist als andere. Das liegt daran, dass gelöschte Inodes von anderen Dateien wiederverwendet werden können. Um Inodennummern anzuzeigen, führen Sie <b>ls -li</b> aus:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nDas erste Feld in diesem Befehl listet die Inodennummer auf.\n\nSie können auch detaillierte Informationen über eine Datei mit stat anzeigen, es gibt Ihnen auch Informationen über die Inode.\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  Datei: ‘/home/pete/Desktop/’\n  Größe: 6               Blöcke: 0          IO-Block: 4096   Verzeichnis\nGerät: 806h/2054d      Inode: 140         Verknüpfungen: 2\nZugriff: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nZugriff: 2016-01-20 20:13:50.647435982 -0800\nÄnderung: 2016-01-20 20:13:06.191675843 -0800\nLetzte Änderung: 2016-01-20 20:13:06.191675843 -0800\n Erstellt: -\n</pre>\n\n\n<b>Wie lokalisieren Inodes Dateien?</b>\n\nWir wissen, dass unsere Daten irgendwo auf der Festplatte sind, leider wurden sie wahrscheinlich nicht sequenziell gespeichert, daher müssen wir Inodes verwenden. Inodes zeigen auf die tatsächlichen Datenblöcke Ihrer Dateien. In einem typischen Dateisystem (nicht alle funktionieren gleich) enthält jeder Inode 15 Zeiger, die ersten 12 Zeiger zeigen direkt auf die Datenblöcke. Der 13. Zeiger zeigt auf einen Block mit Zeigern auf weitere Blöcke, der 14. Zeiger zeigt auf einen weiteren verschachtelten Block von Zeigern, und der 15. Zeiger zeigt wiederum auf einen weiteren Block von Zeigern! Verwirrend, ich weiß! Der Grund, warum dies so gemacht wird, ist, die Inodenstruktur für jede Inode gleich zu halten, aber Dateien unterschiedlicher Größe referenzieren zu können. Wenn Sie eine kleine Datei haben, können Sie sie schneller mit den ersten 12 direkten Zeigern finden, größere Dateien können mit den verschachtelten Zeigern gefunden werden. Auf jeden Fall ist die Struktur des Inodes dieselbe.",
          "quizAnswer": "df -i",
          "quizQuestion": "Wie sehen Sie, wie viele Inodes auf Ihrem System noch übrig sind?",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "Spielen Sie mit der Erstellung von Symlinks und Hardlinks, löschen Sie ein paar und sehen Sie, was passiert.",
          "id": 12,
          "lessonContent": "Lassen Sie uns ein früheres Beispiel für Inode-Informationen verwenden: \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nDu hast vielleicht bemerkt, dass wir das dritte Feld im ls-Befehl bisher vernachlässigt haben, dieses Feld ist die Linkanzahl. Die Linkanzahl ist die Gesamtanzahl der harten Links, die eine Datei hat, das bedeutet dir im Moment nichts. Lassen Sie uns also zuerst über Links sprechen. \n\n<b>Symlinks</b>\n\nIm Windows-Betriebssystem gibt es sogenannte Verknüpfungen, Verknüpfungen sind nur Aliasnamen für andere Dateien. Wenn Sie etwas mit der Originaldatei machen, könnten Sie die Verknüpfung potenziell brechen. In Linux entsprechen Verknüpfungen symbolische Links (oder Softlinks oder Symlinks). Symlinks ermöglichen es uns, auf eine andere Datei über ihren Dateinamen zu verweisen. Ein weiterer Typ von Links, die in Linux gefunden werden, sind Hardlinks, dies sind tatsächlich eine andere Datei mit einem Link zu einem Inode. Lassen Sie uns sehen, was ich damit in der Praxis meine, beginnend mit Symlinks.\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n</pre>\n\nSie sehen, dass ich einen symbolischen Link namens myfilelink erstellt habe, der auf myfile verweist. Symbolische Links werden durch -> gekennzeichnet. Beachten Sie, wie ich jedoch eine neue Inode-Nummer erhalten habe, Symlinks sind nur Dateien, die auf Dateinamen verweisen. Wenn Sie einen Symlink ändern, wird auch die Datei geändert. Inode-Nummern sind eindeutig für Dateisysteme, Sie können nicht zwei gleiche Inode-Nummern in einem einzigen Dateisystem haben, das bedeutet, dass Sie nicht auf eine Datei in einem anderen Dateisystem über ihre Inode-Nummer verweisen können. Wenn Sie jedoch Symlinks verwenden, verwenden sie keine Inode-Nummern, sie verwenden Dateinamen, sodass sie über verschiedene Dateisysteme hinweg referenziert werden können. \n\n<b>Hardlinks</b>\n\nLassen Sie uns ein Beispiel für einen Hardlink sehen:\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myhardlink\n</pre>\n\nEin Hardlink erstellt einfach eine weitere Datei mit einem Link zum selben Inode. Wenn ich den Inhalt von myfile2 oder myhardlink ändern würde, würde die Änderung auf beiden sichtbar sein, aber wenn ich myfile2 löschen würde, wäre die Datei immer noch über myhardlink zugänglich. Hier kommt unsere Linkanzahl im ls-Befehl ins Spiel. Die Linkanzahl ist die Anzahl der Hardlinks, die ein Inode hat, wenn Sie eine Datei entfernen, wird diese Linkanzahl verringert. Der Inode wird nur gelöscht, wenn alle Hardlinks zum Inode gelöscht wurden. Wenn Sie eine Datei erstellen, ist ihre Linkanzahl 1, weil es die einzige Datei ist, die auf diesen Inode verweist. Im Gegensatz zu Symlinks erstrecken sich Hardlinks nicht über Dateisysteme, da Inodes eindeutig für das Dateisystem sind. \n\n<b>Erstellen eines Symlinks</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nUm einen symbolischen Link zu erstellen, verwenden Sie den ln-Befehl mit -s für symbolisch und geben ein Ziel und dann einen Linknamen an. \n\n<b>Erstellen eines Hardlinks</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nÄhnlich wie bei der Erstellung eines Symlinks, lassen Sie dieses Mal das -s weg.",
          "quizAnswer": "ln -s",
          "quizQuestion": "Welcher Befehl wird verwendet, um einen Symlink zu erstellen?",
          "slug": "symlinks",
          "title": "Symlinks"
        }
      ],
      "slug": "dasdateisystem",
      "title": "Das Dateisystem"
    },
    {
      "description": "Erfahren Sie mehr über die Phasen des Linux-Startvorgangs.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Starten Sie Ihr System neu und sehen Sie, ob Sie jeden Schritt erkennen können, während Ihr Computer hochfährt.",
          "id": 1,
          "lessonContent": "Nun, da wir ein ziemlich gutes Verständnis einiger wichtiger Komponenten von Linux haben, lassen Sie uns sie alle zusammenfügen, indem wir lernen, wie das System startet. Wenn Sie Ihren Computer einschalten, führt er einige interessante Schritte aus, wie das Anzeigen des Logobildschirms, das Durchlaufen verschiedener Meldungen und schließlich werden Sie mit einem Anmeldefenster aufgefordert. Es passiert tatsächlich eine Menge Dinge zwischen dem Drücken der Ein-/Aus-Taste und dem Anmelden, über die wir in diesem Kurs sprechen werden. \n\nDer Linux-Startvorgang kann in 4 einfache Phasen unterteilt werden: \n\n<b>1. BIOS</b>\n\nDas BIOS (steht für \"Basic Input/Output System\") initialisiert die Hardware und stellt mit einem Power-on-Self-Test (POST) sicher, dass alle Hardware einsatzbereit ist. Die Hauptaufgabe des BIOS besteht darin, den Bootloader zu laden.\n\n<b>2. Bootloader</b>\n\nDer Bootloader lädt den Kernel in den Speicher und startet dann den Kernel mit einer Reihe von Kernelparametern. Einer der häufigsten Bootloader ist GRUB, der ein universeller Linux-Standard ist. \n\n<b>3. Kernel</b>\n\nWenn der Kernel geladen ist, initialisiert er sofort Geräte und Speicher. Die Hauptaufgabe des Kernels besteht darin, den Init-Prozess zu laden. \n\n<b>4. Init</b>\n\nDenken Sie daran, dass der Init-Prozess der erste Prozess ist, der gestartet wird. Init startet und stoppt wichtige Dienstprozesse im System. Es gibt drei Hauptimplementierungen von Init in Linux-Distributionen. Wir werden sie kurz durchgehen und uns dann in einem anderen Kurs näher damit befassen.\n\nDa ist sie, die (sehr) einfache Erklärung des Linux-Startvorgangs. Wir werden in den nächsten Lektionen detaillierter auf diese Phasen eingehen.",
          "quizAnswer": "init",
          "quizQuestion": "Was ist die letzte Phase im Linux-Startvorgang?",
          "slug": "bootprocessoverview",
          "title": "Überblick über den Bootvorgang"
        },
        {
          "exercise": "Gehen Sie in Ihr BIOS-Menü und prüfen Sie, ob Sie das UEFI-Booten aktiviert haben.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nDer erste Schritt im Linux-Bootvorgang ist das BIOS, das Integritätsprüfungen des Systems durchführt. Das BIOS ist eine Firmware, die in den meisten IBM-PC-kompatiblen Computern vorkommt, der dominierende Computertyp, der heute auf dem Markt ist. Sie haben wahrscheinlich die BIOS-Firmware verwendet, um die Bootreihenfolge Ihrer Festplatten zu ändern, die Systemzeit zu überprüfen, die MAC-Adresse Ihres Geräts usw. Das Hauptziel des BIOS besteht darin, den System-Bootloader zu finden.\n\nSobald das BIOS die Festplatte hochfährt, sucht es nach dem Bootblock, um herauszufinden, wie das System hochgefahren werden soll. Abhängig davon, wie Sie Ihre Festplatte partitioniert haben, wird nach dem Master Boot Record (MBR) oder GPT gesucht. Der MBR befindet sich im ersten Sektor der Festplatte, den ersten 512 Bytes. Der MBR enthält den Code zum Laden eines anderen Programms irgendwo auf der Festplatte, dieses Programm lädt dann tatsächlich unseren Bootloader hoch.\n\nWenn Sie Ihre Festplatte jedoch mit GPT partitioniert haben, ändert sich die Position des Bootloaders etwas.\n\n<b>UEFI</b>\n\nEs gibt eine andere Möglichkeit, Ihr System hochzufahren, anstatt das BIOS zu verwenden, und das ist mit UEFI (steht für \"Unified Extensible Firmware Interface\"). UEFI wurde als Nachfolger des BIOS konzipiert, die meisten Hardwaregeräte von heute sind mit einer UEFI-Firmware ausgestattet. Macintosh-Maschinen verwenden seit Jahren das EFI-Booten und Windows hat den Großteil seiner Systeme auf das UEFI-Booten umgestellt. Das GPT-Format war für die Verwendung mit EFI vorgesehen. Wenn Sie eine GPT-Festplatte booten, benötigen Sie nicht unbedingt EFI. Der erste Sektor einer GPT-Festplatte ist für einen \"Schutz-MBR\" reserviert, um das Booten auf einem BIOS-basierten Gerät zu ermöglichen.\n\nUEFI speichert alle Informationen zum Startvorgang in einer .efi-Datei. Diese Datei wird auf einer speziellen Partition namens EFI-Systempartition auf der Hardware gespeichert. In dieser Partition befindet sich der Bootloader. UEFI bietet viele Verbesserungen gegenüber der traditionellen BIOS-Firmware. Da wir jedoch Linux verwenden, verwenden die meisten von uns BIOS. Daher werden alle diese Lektionen unter dieser Voraussetzung durchgeführt.",
          "quizAnswer": "Bootloader",
          "quizQuestion": "Was lädt das BIOS?",
          "slug": "bootvorgangbios",
          "title": "Boot-Vorgang: BIOS"
        },
        {
          "exercise": "Wenn Sie GRUB als Ihren Bootloader haben, gehen Sie mit 'e' ins GRUB-Menü und sehen Sie sich die Einstellungen an.",
          "id": 3,
          "lessonContent": "Die Hauptaufgaben des Bootloaders sind:\n\n<ul>\n<li>Starten eines Betriebssystems, es kann auch zum Starten von Nicht-Linux-Betriebssystemen verwendet werden</li>\n<li>Auswahl eines Kernels</li>\n<li>Festlegen von Kernelparametern</li>\n</ul>\n\nDer häufigste Bootloader für Linux ist GRUB, den Sie höchstwahrscheinlich auf Ihrem System verwenden. Es gibt viele andere Bootloader, die Sie verwenden können, wie z.B. LILO, efilinux, coreboot, SYSLINUX und mehr. Wir werden jedoch nur mit GRUB als unserem Bootloader arbeiten. \n\nWir wissen also, dass das Hauptziel des Bootloaders darin besteht, den Kernel zu laden, aber wo findet er den Kernel? Um ihn zu finden, müssen wir uns unsere Kernelparameter ansehen. Die Parameter können gefunden werden, indem Sie im GRUB-Menü beim Start die Taste 'e' drücken. Wenn Sie kein GRUB haben, keine Sorge, wir werden die Bootparameter durchgehen, die Sie sehen werden:\n\n<ul>\n<li>initrd - Gibt den Speicherort des Initial-RAM-Disk an (darüber werden wir im nächsten Lektion mehr sprechen).</li>\n<li>BOOT_IMAGE - Hier befindet sich das Kernel-Image</li>\n<li>root - Der Speicherort des Wurzeldateisystems, der Kernel sucht innerhalb dieses Speicherorts nach init. Es wird oft durch seine UUID oder den Gerätenamen wie z.B. /dev/sda1 dargestellt.</li>\n<li>ro - Dieser Parameter ist ziemlich standardmäßig, er mountet das Dateisystem im Nur-Lese-Modus.</li>\n<li>quiet - Dies wird hinzugefügt, damit Sie keine Anzeigemeldungen sehen, die im Hintergrund während des Bootvorgangs ablaufen.</li>\n<li>splash - Dies ermöglicht das Anzeigen des Splash-Screens.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "Welcher Kernelparameter sorgt dafür, dass Sie keine Startmeldungen sehen?",
          "slug": "bootprocessbootloader",
          "title": "Bootvorgang: Bootloader"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen verfügbar.",
          "id": 4,
          "lessonContent": "Nun, da unser Bootloader die erforderlichen Parameter übergeben hat, schauen wir uns an, wie der Startvorgang erfolgt:\n\n<b>Initrd vs Initramfs</b>\n\nEs gibt ein gewisses Huhn-und-Ei-Problem, wenn wir über den Kernel-Startvorgang sprechen. Der Kernel verwaltet die Hardware unseres Systems, jedoch sind nicht alle Treiber während des Startvorgangs für den Kernel verfügbar. Daher sind wir auf ein temporäres Wurzeldateisystem angewiesen, das nur die wesentlichen Module enthält, die der Kernel benötigt, um auf den Rest der Hardware zuzugreifen. In älteren Versionen von Linux wurde diese Aufgabe dem initrd (Initial RAM-Disk) übertragen. Der Kernel würde das initrd einbinden, die erforderlichen Starttreiber erhalten und dann, wenn er alles geladen hatte, was er brauchte, das initrd durch das eigentliche Wurzeldateisystem ersetzen. Heutzutage haben wir etwas namens initramfs, dies ist ein temporäres Wurzeldateisystem, das in den Kernel selbst integriert ist, um alle erforderlichen Treiber für das eigentliche Wurzeldateisystem zu laden, sodass keine Suche nach der initrd-Datei mehr erforderlich ist. \n\n<b>Einhängen des Wurzeldateisystems</b>\n\nNun hat der Kernel alle Module, die er benötigt, um ein Wurzeldatengerät zu erstellen und die Wurzelpartition einzuhängen. Bevor Sie jedoch weitermachen, wird die Wurzelpartition tatsächlich zuerst im Nur-Lese-Modus eingehängt, damit fsck sicher ausgeführt und die Systemintegrität überprüft werden kann. Anschließend wird das Wurzeldateisystem im Lese-Schreib-Modus neu eingehängt. Dann lokalisiert der Kernel das init-Programm und führt es aus.",
          "quizAnswer": "initramfs",
          "quizQuestion": "Was wird in modernen Systemen verwendet, um ein temporäres Wurzeldateisystem zu laden?",
          "slug": "bootprocesskernel",
          "title": "Boot-Vorgang: Kernel"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 5,
          "lessonContent": "Wir haben init in früheren Lektionen besprochen und wissen, dass es der erste Prozess ist, der gestartet wird und alle anderen wichtigen Dienste auf unserem System startet. Aber wie?\n\nTatsächlich gibt es drei Hauptimplementierungen von init in Linux: \n\n<b>System V init (sysv)</b>\n\nDies ist das traditionelle Init-System. Es startet und stoppt Prozesse sequenziell, basierend auf Startskripten. Der Zustand der Maschine wird durch Runlevel dargestellt, jeder Runlevel startet oder stoppt eine Maschine auf unterschiedliche Weise. \n\n<b>Upstart</b>\n\nDies ist das Init-System, das Sie in älteren Ubuntu-Installationen finden. Upstart verwendet die Idee von Jobs und Ereignissen und funktioniert, indem es Jobs startet, die bestimmte Aktionen als Reaktion auf Ereignisse ausführen. \n\n<b>Systemd</b>\n\nDies ist der neue Standard für Init, er ist zielorientiert. Im Grunde haben Sie ein Ziel, das Sie erreichen möchten, und systemd versucht, die Abhängigkeiten des Ziels zu erfüllen, um das Ziel zu erreichen. \n\nWir haben einen ganzen Kurs über Init-Systeme, in dem wir uns ausführlicher mit jedem dieser Systeme beschäftigen werden.",
          "quizAnswer": "systemd",
          "quizQuestion": "Was ist der neueste Standard für init?",
          "slug": "bootprocessinit",
          "title": "Boot-Vorgang: Init"
        }
      ],
      "slug": "system-starten",
      "title": "System starten"
    },
    {
      "description": "Der wichtigste Teil des Linux-Systems, erfahren Sie, wie er funktioniert und wie Sie ihn konfigurieren können.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "Für diese Lektion sind keine Übungen vorgesehen.",
          "id": 1,
          "lessonContent": "Wie Sie bis zu diesem Punkt gelernt haben, ist der Kernel der Kern des Betriebssystems. Wir haben über die anderen Teile des Betriebssystems gesprochen, aber noch nicht gezeigt, wie sie alle zusammenarbeiten. Das Linux-Betriebssystem kann in drei verschiedene Abstraktionsebenen unterteilt werden.\n\nDie grundlegendste Ebene ist die Hardware, dazu gehören unsere CPU, Speicher, Festplatten, Netzwerkanschlüsse usw. Die physische Ebene, die tatsächlich berechnet, was unsere Maschine tut.\n\nDie nächste Ebene ist der Kernel, der die Prozess- und Speicherverwaltung, die Gerätekommunikation, Systemaufrufe, die Einrichtung unseres Dateisystems usw. übernimmt. Die Aufgabe des Kernels besteht darin, mit der Hardware zu kommunizieren, um sicherzustellen, dass sie das tut, was wir wollen, dass unsere Prozesse tun. \n\nUnd die Ebene, mit der Sie vertraut sind, ist der Benutzerbereich, der Benutzerbereich umfasst die Shell, die Programme, die Sie ausführen, die Grafiken usw.\n\nIn diesem Kurs werden wir uns auf den Kernel konzentrieren und seine Feinheiten kennenlernen.",
          "quizAnswer": "kernel",
          "quizQuestion": "Welche Ebene des Betriebssystems verwaltet Geräte?",
          "slug": "kerneloverview",
          "title": "Überblick über den Kernel"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 2,
          "lessonContent": "Die nächsten Lektionen werden ziemlich theoretisch, also wenn du nach praktischen Inhalten suchst, kannst du weiterblättern und später zurückkommen.\n\nWarum haben wir unterschiedliche Abstraktionsebenen für den Benutzerbereich und den Kernel? Warum können wir nicht beide Kräfte in einer Ebene kombinieren? Nun, es gibt einen sehr guten Grund, warum diese beiden Ebenen getrennt existieren. Sie arbeiten in verschiedenen Modi, der Kernel arbeitet im Kernelmodus und der Benutzerbereich arbeitet im Benutzermodus. \n\nIm Kernelmodus hat der Kernel vollständigen Zugriff auf die Hardware, er kontrolliert alles. Im Benutzermodus gibt es nur einen sehr kleinen sicheren Speicher und eine CPU, auf die du zugreifen darfst. Im Grunde genommen wird alles, was mit der Hardware zu tun hat, wie das Lesen von Daten von unseren Festplatten, das Schreiben von Daten auf unsere Festplatten, die Steuerung unseres Netzwerks usw., im Kernelmodus ausgeführt. Warum ist das notwendig? Stell dir vor, deine Maschine wäre mit Spyware infiziert, du möchtest nicht, dass sie direkten Zugriff auf die Hardware deines Systems hat. Sie könnte auf alle deine Daten, deine Webcam usw. zugreifen, und das wäre nicht gut. \n\nDiese verschiedenen Modi werden als Privilegieniveaus bezeichnet (passend benannt nach den Privilegien, die du erhältst) und werden oft als Schutzringe beschrieben. Um das Bild zu vereinfachen, sagen wir, du erfährst, dass Britney Spears in deiner Stadt in deinem örtlichen Klerb ist, sie wird von ihren Groupies geschützt, dann von ihren persönlichen Leibwächtern und dann vom Türsteher vor dem Klerb. Du möchtest ihr Autogramm bekommen (warum auch nicht?), aber du kommst nicht zu ihr, weil sie stark geschützt ist. Die Ringe funktionieren genauso, der innerste Ring entspricht dem höchsten Privilegieniveau. Es gibt zwei Hauptniveaus oder Modi in einer x86-Computerarchitektur. Ring #3 ist das Privileg, in dem Benutzermodusanwendungen ausgeführt werden, Ring #0 ist das Privileg, in dem der Kernel ausgeführt wird. Ring #0 kann jede Systemanweisung ausführen und genießt vollstes Vertrauen. Jetzt, da wir wissen, wie diese Privilegieniveaus funktionieren, wie können wir überhaupt etwas auf unsere Hardware schreiben? Werden wir nicht immer in einem anderen Modus als dem Kernel sein? \n\nDie Antwort lautet: mit Systemaufrufen. Systemaufrufe ermöglichen es uns, eine privilegierte Anweisung im Kernelmodus auszuführen und dann in den Benutzermodus zurückzukehren.",
          "quizAnswer": "0",
          "quizQuestion": "Welche Ringnummer hat die höchsten Privilegien?",
          "slug": "kernelprivilegieniveaus",
          "title": "Privilegieniveaus"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 3,
          "lessonContent": "Erinnern Sie sich an Britney aus der vorherigen Lektion? Angenommen, wir möchten sie sehen und zusammen etwas trinken, wie gelangen wir vom Stehen draußen in den Menschenmengen in ihren innersten Kreis? Wir würden Systemaufrufe verwenden. Systemaufrufe sind wie VIP-Pässe, die Sie zu einer geheimen Seitentür bringen, die direkt zu Britney führt.\n\nSystemaufrufe (Syscalls) bieten Benutzerprozessen eine Möglichkeit, den Kernel um etwas zu bitten. Der Kernel stellt bestimmte Dienste über die Systemaufruf-API zur Verfügung. Diese Dienste ermöglichen es uns, in eine Datei zu lesen oder zu schreiben, den Speicherverbrauch zu ändern, unser Netzwerk zu ändern usw. Die Anzahl der Dienste ist festgelegt, daher können Sie nicht beliebig viele Systemaufrufe hinzufügen. Ihr System hat bereits eine Tabelle, welche Systemaufrufe existieren, und jeder Systemaufruf hat eine eindeutige ID. \n\nIch werde nicht auf Details von Systemaufrufen eingehen, da dies erfordern würde, dass Sie ein wenig C kennen, aber das Grundlegende ist, dass wenn Sie ein Programm wie ls aufrufen, der Code in diesem Programm einen Systemaufruf-Wrapper enthält (also noch nicht den tatsächlichen Systemaufruf). Innerhalb dieses Wrappers ruft er den Systemaufruf auf, der eine Falle ausführt. Diese Falle wird dann vom Systemaufruf-Handler abgefangen und verweist dann auf den Systemaufruf in der Systemaufruftabelle. Angenommen, wir versuchen den stat() Systemaufruf aufzurufen, er wird durch eine Syscall-ID identifiziert und der Zweck des stat() Systemaufrufs besteht darin, den Status einer Datei abzufragen. Denken Sie daran, Sie haben das ls-Programm im Nicht-Privilegierten Modus ausgeführt. Jetzt sieht es, dass Sie versuchen, einen Systemaufruf zu tätigen, es schaltet Sie dann in den Kernelmodus um, dort tut es viele Dinge, aber am wichtigsten ist, dass es Ihre Syscall-Nummer nachschlägt, sie in einer Tabelle anhand der Syscall-ID findet und dann die Funktion ausführt, die Sie ausführen wollten. Sobald dies erledigt ist, kehrt es in den Benutzermodus zurück und Ihr Prozess erhält einen Rückgabestatus, ob es erfolgreich war oder ob ein Fehler aufgetreten ist. Die Funktionsweise von Syscalls wird sehr detailliert, ich würde empfehlen, online nach weiteren Informationen zu suchen. \n\nSie können tatsächlich die Systemaufrufe, die ein Prozess tätigt, mit dem Befehl strace anzeigen. Der Befehl strace ist nützlich, um zu debuggen, wie ein Programm ausgeführt wurde. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "Systemaufruf",
          "quizQuestion": "Was wird verwendet, um vom Benutzermodus in den Kernelmodus zu wechseln?",
          "slug": "systemcalls",
          "title": "System Calls"
        },
        {
          "exercise": "<ol>\n<li>Ermitteln Sie, welche Kernelversion Sie haben.</li>\n<li>Recherchieren Sie die verschiedenen verfügbaren Kernelversionen.</li>\n</ol>",
          "id": 4,
          "lessonContent": "Ok, jetzt, da wir all das langweilige Zeug aus dem Weg haben, reden wir über das tatsächliche Installieren und Modifizieren von Kernels. Sie können mehrere Kernels auf Ihrem System installieren, erinnern Sie sich an unsere Lektion zum Bootvorgang? Im GRUB-Menü können wir auswählen, welchen Kernel wir booten möchten. \n\nUm zu sehen, welche Kernelversion Sie auf Ihrem System haben, verwenden Sie den folgenden Befehl:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nDer uname-Befehl gibt Systeminformationen aus, der -r-Befehl gibt die gesamte Kernelversionsnummer aus.\n\nSie können den Linux-Kernel auf verschiedene Weisen installieren, Sie können das Quellpaket herunterladen und aus den Quellen kompilieren oder Sie können es mit Paketverwaltungstools installieren.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\nund dann einfach in den installierten Kernel neu starten. Einfach, oder? Ein bisschen, Sie müssen auch andere Linux-Pakete installieren, wie z.B. die linux-headers, linux-image-generic, usw.). Sie können auch die Versionsnummer angeben, sodass der obige Befehl wie folgt aussehen kann: <b>sudo apt install 3.19.0-43-generic</b>\n\nAlternativ, wenn Sie nur die aktualisierte Kernelversion möchten, verwenden Sie einfach dist-upgrade, es führt Upgrades für alle Pakete auf Ihrem System durch:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nEs gibt viele verschiedene Kernelversionen, einige werden als LTS (Langzeitunterstützung) verwendet, einige sind die neuesten und besten, die Kompatibilität kann zwischen Kernelversionen sehr unterschiedlich sein, daher möchten Sie möglicherweise verschiedene Kernel ausprobieren.",
          "quizAnswer": "uname -r",
          "quizQuestion": "Wie sehen Sie die Kernelversion Ihres Systems?",
          "slug": "kernelinstallation",
          "title": "Kernel-Installation"
        },
        {
          "exercise": "Gehen Sie in Ihr Boot-Verzeichnis und sehen Sie, welche Dateien sich darin befinden.",
          "id": 5,
          "lessonContent": "Was passiert, wenn Sie einen neuen Kernel installieren? Nun, es fügt tatsächlich ein paar Dateien zu Ihrem System hinzu, diese Dateien werden normalerweise dem /boot-Verzeichnis hinzugefügt. \n\nSie werden mehrere Dateien für verschiedene Kernel-Versionen sehen:\n\n<ul>\n<li>vmlinuz - dies ist der tatsächliche Linux-Kernel</li>\n<li>initrd - wie wir zuvor besprochen haben, wird das initrd als temporäres Dateisystem verwendet, bevor der Kernel geladen wird</li>\n<li>System.map - symbolische Suchtabelle</li>\n<li>config - Kernel-Konfigurationseinstellungen, wenn Sie Ihren eigenen Kernel kompilieren, können Sie festlegen, welche Module geladen werden können</li>\n</ul>\n\nWenn Ihr /boot-Verzeichnis keinen Platz mehr hat, können Sie immer alte Versionen dieser Dateien löschen oder einfach einen Paketmanager verwenden, aber seien Sie vorsichtig bei der Wartung in diesem Verzeichnis und löschen Sie nicht versehentlich den Kernel, den Sie verwenden.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "Wie heißt das Kernel-Abbild in /boot?",
          "slug": "kernellocation",
          "title": "Kernel-Standort"
        },
        {
          "exercise": "Entladen Sie Ihr Bluetooth-Modul mit modprobe und sehen Sie, was passiert. Wie werden Sie das beheben?",
          "id": 6,
          "lessonContent": "Angenommen, ich habe ein tolles Auto, in das ich viel Zeit und Geld investiere. Ich füge einen Spoiler, eine Anhängerkupplung, einen Fahrradträger und andere zufällige Dinge hinzu. Diese Komponenten ändern die Kernfunktionalität des Autos nicht tatsächlich und ich kann sie sehr einfach entfernen und hinzufügen. Der Kernel verwendet dasselbe Konzept mit Kernel-Modulen.\n\nDer Kernel an sich ist ein monolithisches Softwarestück. Wenn wir Unterstützung für einen neuen Tastaturtyp hinzufügen möchten, schreiben wir diesen Code nicht direkt in den Kernelcode. Genau wie wir keinen Fahrradträger an unser Auto schweißen würden (nun ja, vielleicht würden das einige Leute tun). Kernel-Module sind Code-Stücke, die bei Bedarf in den Kernel geladen und entladen werden können. Sie ermöglichen es uns, die Funktionalität des Kernels zu erweitern, ohne tatsächlich zum Kernkernelcode hinzuzufügen. Wir können auch Module hinzufügen, ohne das System neu starten zu müssen (in den meisten Fällen).\n\n<b>Liste der aktuell geladenen Module anzeigen</b>\n\n<pre>$ lsmod</pre>\n\n<b>Ein Modul laden</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe versucht, das Modul von <b>/lib/modules/(Kernel-Version)/kernel/drivers</b> zu laden. Kernel-Module können auch Abhängigkeiten haben, modprobe lädt unsere Modulabhängigkeiten, wenn sie nicht bereits geladen sind.\n\n<b>Ein Modul entfernen</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Beim Booten laden</b>\n\nSie können auch Module während des Systemstarts laden, anstatt sie vorübergehend mit modprobe zu laden (die beim Neustart entladen werden). Ändern Sie einfach das <b>/etc/modprobe.d</b>-Verzeichnis und fügen Sie eine Konfigurationsdatei wie folgt hinzu:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nOptionen peanut_butter Typ=Mandel\n</pre>\n\nEin etwas ausgefallenes Beispiel, aber wenn Sie ein Modul namens peanut_butter haben und einen Kernelparameter für Typ=Mandel hinzufügen möchten, können Sie es mit dieser Konfigurationsdatei beim Start laden lassen. Beachten Sie auch, dass Kernel-Module ihre eigenen Kernelparameter haben, sodass Sie das Modul spezifisch lesen sollten, um mehr zu erfahren.\n\n<b>Nicht beim Booten laden</b>\n\nSie können auch sicherstellen, dass ein Modul beim Booten nicht geladen wird, indem Sie eine Konfigurationsdatei wie folgt hinzufügen:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nSchwarze Liste peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "Welcher Befehl wird verwendet, um ein Modul zu entladen?",
          "slug": "kernelmodule",
          "title": "Kernel-Module"
        }
      ],
      "slug": "kernel",
      "title": "Kernel"
    },
    {
      "description": "Erfahren Sie mehr über die verschiedenen Init-Systeme, SysV, Upstart und systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Wenn Sie System V ausführen, ändern Sie den Standard-Runlevel Ihrer Maschine auf etwas anderes und sehen Sie, was passiert.",
          "id": 1,
          "lessonContent": "Der Hauptzweck von init besteht darin, wichtige Prozesse auf dem System zu starten und zu stoppen. Es gibt drei Hauptimplementierungen von init in Linux: System V, Upstart und systemd. In dieser Lektion werden wir die traditionellste Version von init durchgehen, System V init oder Sys V (ausgesprochen als 'System Five'). \n\nUm herauszufinden, ob Sie die Sys V init-Implementierung verwenden, prüfen Sie, ob Sie eine /etc/inittab-Datei haben. Dann verwenden Sie höchstwahrscheinlich Sys V. \n\nSys V startet und stoppt Prozesse sequenziell. Wenn Sie beispielsweise einen Dienst namens foo-a starten möchten, muss foo-a bereits ausgeführt werden, bevor foo-b funktionieren kann. Sys V verwendet Skripte, um dies zu erreichen. Diese Skripte starten und stoppen Dienste für uns. Wir können eigene Skripte schreiben oder meistens die bereits im Betriebssystem integrierten Skripte verwenden, die zum Laden wichtiger Dienste verwendet werden. \n\nDie Vorteile der Verwendung dieser Implementierung von init liegen darin, dass Abhängigkeiten relativ einfach gelöst werden können, da Sie wissen, dass foo-a vor foo-b ausgeführt wird. Die Leistung ist jedoch nicht optimal, da normalerweise jeweils eine Sache gestartet oder gestoppt wird. \n\nWenn Sie Sys V verwenden, wird der Zustand der Maschine durch Runlevel definiert, die von 0 bis 6 festgelegt sind. Diese verschiedenen Modi variieren je nach Distribution, sehen aber meistens wie folgt aus: \n\n<ul>\n<li>0: Herunterfahren</li>\n<li>1: Einzelbenutzermodus</li>\n<li>2: Mehrbenutzermodus ohne Netzwerk</li>\n<li>3: Mehrbenutzermodus mit Netzwerk</li>\n<li>4: Nicht verwendet</li>\n<li>5: Mehrbenutzermodus mit Netzwerk und GUI</li>\n<li>6: Neustart</li>\n</ul>\n\nBeim Start des Systems wird überprüft, in welchem Runlevel Sie sich befinden, und Skripte innerhalb dieser Runlevel-Konfiguration werden ausgeführt. Die Skripte befinden sich in <b>/etc/rc.d/rc[Runlevel-Nummer].d/</b> oder <b>/etc/init.d</b>. Skripte, die mit S (Start) oder K (Beenden) beginnen, werden beim Start und beim Herunterfahren ausgeführt. Die Zahlen neben diesen Zeichen geben die Reihenfolge an, in der sie ausgeführt werden. \n\nZum Beispiel:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nWir sehen, dass beim Wechsel in den Runlevel 0 oder den Herunterfahren-Modus unser System versucht, ein Skript auszuführen, um die Update-Dienste zu beenden und dann openvpn zu starten. Um herauszufinden, in welchen Runlevel Ihr System bootet, können Sie den Standard-Runlevel in der Datei /etc/inittab sehen. Sie können auch Ihren Standard-Runlevel in dieser Datei ändern. \n\nEine Sache ist zu beachten: System V wird langsam ersetzt, vielleicht nicht heute oder auch in Jahren. Möglicherweise sehen Sie jedoch Runlevel in anderen Init-Implementierungen auftauchen, dies dient hauptsächlich zur Unterstützung von Diensten, die nur mit System V init-Skripten gestartet oder gestoppt werden.",
          "quizAnswer": "0",
          "quizQuestion": "Welcher Runlevel wird normalerweise für das Herunterfahren verwendet?",
          "slug": "sysvoverview",
          "title": "System V Übersicht"
        },
        {
          "exercise": "Verwalten Sie ein paar Dienste und ändern Sie deren Zustände, was beobachten Sie?",
          "id": 2,
          "lessonContent": "Es gibt viele Befehlszeilentools, die Sie verwenden können, um Sys V-Dienste zu verwalten. \n\n<b>Dienste auflisten</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Einen Dienst starten</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Einen Dienst stoppen</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Einen Dienst neu starten</b>\n\n<pre>$ sudo service networking restart</pre>\n\nDiese Befehle sind nicht spezifisch für Sys V Init-Systeme, Sie können sie auch verwenden, um Upstart-Dienste zu verwalten. Da Linux versucht, sich von den traditionelleren Sys V Init-Skripten zu entfernen, gibt es immer noch Maßnahmen, um diesen Übergang zu erleichtern.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Wie lautet der Befehl, um einen Dienst namens peanut mit Sys V zu stoppen?",
          "slug": "sysvservices",
          "title": "System V Service"
        },
        {
          "exercise": "Wenn Sie Upstart verwenden, versuchen Sie, die Aufgabenkonfigurationen in /etc/init zu verstehen.",
          "id": 3,
          "lessonContent": "Upstart wurde von Canonical entwickelt, daher war es eine Zeit lang die Init-Implementierung auf Ubuntu, jedoch wird auf modernen Ubuntu-Installationen jetzt systemd verwendet. Upstart wurde erstellt, um die Probleme mit Sys V zu verbessern, wie z. B. die strengen Startvorgänge, Blockieren von Aufgaben usw. Das ereignis- und aufgabenorientierte Modell von Upstart ermöglicht es ihm, auf Ereignisse zu reagieren, wenn sie auftreten. \n\nUm herauszufinden, ob Sie Upstart verwenden, ist ein /usr/share/upstart-Verzeichnis ein ziemlich guter Indikator. \n\nAufgaben sind die Aktionen, die Upstart ausführt, und Ereignisse sind Nachrichten, die von anderen Prozessen empfangen werden, um Aufgaben auszulösen. Um eine Liste von Aufgaben und ihrer Konfiguration zu sehen:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nIn diesen Aufgabenkonfigurationen finden Sie Informationen dazu, wie Aufgaben gestartet werden und wann sie gestartet werden sollen.\n\nZum Beispiel könnte in der networking.conf-Datei etwas so Einfaches stehen wie:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nDas bedeutet, dass das Einrichten des Netzwerks auf Runlevel 2, 3 oder 5 gestartet wird und das Netzwerk auf Runlevel 0 gestoppt wird. Es gibt viele Möglichkeiten, die Konfigurationsdatei zu schreiben, und Sie werden feststellen, dass, wenn Sie sich die verschiedenen verfügbaren Aufgabenkonfigurationen ansehen. \n\nDie Art und Weise, wie Upstart funktioniert, ist folgende: \n\n<ol>\n<li>Zuerst lädt es die Aufgabenkonfigurationen von /etc/init</li>\n<li>Sobald ein Startereignis eintritt, werden Aufgaben ausgeführt, die durch dieses Ereignis ausgelöst wurden.</li>\n<li>Diese Aufgaben erzeugen neue Ereignisse, und diese Ereignisse lösen weitere Aufgaben aus</li>\n<li>Upstart macht so weiter, bis alle notwendigen Aufgaben abgeschlossen sind</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Welche Init-Implementierung wird von Ubuntu verwendet?",
          "slug": "upstartoverview",
          "title": "Upstart-Übersicht"
        },
        {
          "exercise": "Beobachten Sie Ihre Liste der Upstart-Jobs, ändern Sie jetzt den Jobzustand mit einem der heute gelernten Befehle. Was fällt Ihnen danach auf?",
          "id": 4,
          "lessonContent": "Upstart kann viele Ereignisse und Jobs auslösen, leider gibt es keinen einfachen Weg zu sehen, wo ein Ereignis oder Job seinen Ursprung hat, also müssen Sie sich in den Jobkonfigurationen in /etc/init umsehen. Die meiste Zeit werden Sie nie die Upstart-Jobkonfigurationsdateien ansehen müssen, aber Sie möchten einige bestimmte Jobs leichter steuern. Es gibt viele nützliche Befehle, die Sie in einem Upstart-System verwenden können. \n\n<b>Jobs anzeigen</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nSie sehen eine Liste von Upstart-Jobs mit verschiedenen Statuswerten. In jeder Zeile ist der Jobname der erste Wert und das zweite Feld (vor dem /) ist tatsächlich das Ziel des Jobs, der dritte Wert (nach dem /) ist der aktuelle Status. Wir sehen also, dass unser Shutdown-Job letztendlich gestoppt werden soll, aber er befindet sich derzeit im Zustand des Wartens. Der Jobstatus und die Ziele ändern sich, wenn Sie Jobs starten oder stoppen. \n\n<b>Bestimmten Job anzeigen</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nWir werden nicht auf die Details eingehen, wie man eine Upstart-Jobkonfiguration schreibt, aber wir wissen bereits, dass Jobs in diesen Konfigurationen gestoppt, gestartet und neu gestartet werden. Diese Jobs senden auch Ereignisse aus, um andere Jobs zu starten. Wir werden die manuellen Befehle des Upstart-Betriebs durchgehen, aber wenn Sie neugierig sind, sollten Sie sich tiefer in die .conf-Dateien eingraben.\n\n<b>Manuell einen Job starten</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Manuell einen Job stoppen</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Manuell einen Job neu starten</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Manuell ein Ereignis auslösen</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Wie würde ich manuell einen Upstart-Job namens peanuts neu starten?",
          "slug": "upstartjobs",
          "title": "Upstart-Jobs"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen verfügbar.",
          "id": 5,
          "lessonContent": "Systemd wird langsam zum aufstrebenden Standard für Init. Wenn Sie ein /usr/lib/systemd-Verzeichnis haben, verwenden Sie höchstwahrscheinlich systemd.\n\nSystemd verwendet Ziele, um Ihr System hochzufahren. Grundsätzlich haben Sie ein Ziel, das Sie erreichen möchten, und dieses Ziel hat auch Abhängigkeiten, die wir erreichen müssen. Systemd ist äußerst flexibel und robust, es folgt keiner strengen Sequenz, um Prozesse zu starten. Hier ist, was während des typischen systemd-Startvorgangs passiert:\n\n<ol>\n<li>Zunächst lädt systemd seine Konfigurationsdateien, die sich normalerweise in /etc/systemd/system oder /usr/lib/systemd/system befinden</li>\n<li>Dann bestimmt es sein Startziel, das normalerweise default.target ist</li>\n<li>Systemd ermittelt die Abhängigkeiten des Startziels und aktiviert sie</l>\n</ol>\n\nÄhnlich wie bei den Sys V-Runleveln startet systemd in verschiedene Ziele:\n\n<ul>\n<li>poweroff.target - System herunterfahren</li>\n<li>rescue.target - Einzelbenutzermodus</li>\n<li>multi-user.target - Mehrbenutzermodus mit Netzwerk</li>\n<li>graphical.target - Mehrbenutzermodus mit Netzwerk und GUI</li>\n<li>reboot.target - Neustart</li>\n</ul>\n\nDas Standardstartziel default.target zeigt normalerweise auf graphical.target. \n\nDas Hauptobjekt, mit dem systemd arbeitet, sind sogenannte Units. Systemd startet und stoppt nicht nur Dienste, es kann Dateisysteme einhängen, Ihre Netzwerk-Sockets überwachen usw. und aufgrund dieser Robustheit arbeitet es mit verschiedenen Arten von Units. Die häufigsten Units sind:\n\n<ul>\n<li>Service-Units - dies sind die Dienste, die wir starten und stoppen, diese Unit-Dateien enden auf .service</li>\n<li>Mount-Units - Diese hängen Dateisysteme ein, diese Unit-Dateien enden auf .mount</li>\n<li>Target-Units - Diese gruppieren andere Units, die Dateien enden auf .target</li>\n</ul>\n\nAngenommen, wir starten in unser default.target, nun gruppiert dieses Ziel die networking.service-Unit, crond.service-Unit usw., sodass, sobald wir eine einzelne Unit aktivieren, alles unterhalb dieser Unit ebenfalls aktiviert wird.",
          "quizAnswer": "target",
          "quizQuestion": "Welche Unit wird verwendet, um andere Units zu gruppieren?",
          "slug": "systemdoverview",
          "title": "Systemd-Übersicht"
        },
        {
          "exercise": "Überprüfen Sie die Status der Units und starten und stoppen Sie einige Services. Was beobachten Sie?",
          "id": 6,
          "lessonContent": "Wir werden nicht auf die Details des Schreibens von systemd-Unit-Dateien eingehen. Wir werden jedoch eine kurze Übersicht über eine Unit-Datei geben und wie man Units manuell steuert. \n\nHier ist eine einfache Service-Unit-Datei: foobar.service\n\n<pre>\n[Unit]\nDescription=Mein Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nDies ist ein einfaches Service-Ziel. Am Anfang der Datei sehen wir einen Abschnitt für [Unit], der es uns ermöglicht, unserer Unit-Datei eine Beschreibung zu geben und die Reihenfolge der Aktivierung der Unit zu steuern. Der nächste Teil ist der Abschnitt [Service], hier können wir einen Service starten, stoppen oder neu laden. Und der Abschnitt [Install] wird für Abhängigkeiten verwendet. Dies ist nur die Spitze des Eisbergs beim Schreiben von systemd-Dateien, also empfehle ich Ihnen, sich mit dem Thema zu beschäftigen, wenn Sie mehr wissen möchten. \n\nNun, lassen Sie uns einige Befehle betrachten, die Sie mit systemd-Units verwenden können: \n\n<b>Units auflisten</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Status einer Unit anzeigen</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Einen Service starten</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Einen Service stoppen</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Einen Service neu starten</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Eine Unit aktivieren</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Eine Unit deaktivieren</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nSie haben noch nicht gesehen, wie tief systemd geht, also lesen Sie mehr darüber, wenn Sie mehr erfahren möchten.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "Was ist der Befehl, um einen Service mit dem Namen peanut.service zu starten?",
          "slug": "systemdgoals",
          "title": "Systemd Ziele"
        },
        {
          "exercise": "Was denken Sie, passiert mit init, wenn Sie Ihren Computer herunterfahren?",
          "id": 7,
          "lessonContent": "Kaum zu glauben, dass wir tatsächlich noch nicht über Möglichkeiten gesprochen haben, Ihren Systemzustand über die Befehlszeile zu steuern, aber wenn wir über init sprechen, sprechen wir nicht nur über die Modi, die uns dazu bringen, unser System zu starten, sondern auch über diejenigen, die unser System stoppen.\n\nUm Ihr System herunterzufahren:\n\n<pre>$ sudo shutdown -h now</pre>\n\nDies wird das System anhalten (ausschalten), Sie müssen auch eine Zeit angeben, wann dies geschehen soll. Sie können eine Zeit in Minuten hinzufügen, die das System in dieser Zeit herunterfährt.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nDies wird Ihr System in zwei Minuten herunterfahren. Sie können auch mit dem shutdown-Befehl neu starten: \n\n<pre>$ sudo shutdown -r now</pre>\n\nOder einfach den reboot-Befehl verwenden:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "Was ist der Befehl, um Ihr System in 4 Minuten auszuschalten?",
          "slug": "powerstates",
          "title": "Stromzustände"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Erlernen Sie die Ressourcenüberwachung mit top, Lastdurchschnitten, iostat und mehr!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Spielen Sie mit dem top-Befehl herum und sehen Sie, welche Prozesse die meisten Ressourcen verwenden.",
          "id": 1,
          "lessonContent": "In diesem Kurs werden wir besprechen, wie Sie die Ressourcennutzung auf Ihrem System lesen und analysieren können. Diese Lektion zeigt einige großartige Tools, die Sie verwenden können, wenn Sie verfolgen müssen, was ein Prozess tut. \n\n<b>top</b>\n\nWir haben top bereits besprochen, aber wir werden uns genauer damit befassen, was es tatsächlich anzeigt. Denken Sie daran, dass top das Tool ist, das wir verwenden, um eine Echtzeitansicht der Systemnutzung durch unsere Prozesse zu erhalten:\n\n<pre>\ntop - 18:06:26 up 6 Tage,  4:07,  2 Benutzer,  durchschnittliche Auslastung: 0,92, 0,62, 0,59\nAufgaben: 389 insgesamt,   1 laufend, 387 schlafend,   0 gestoppt,   1 Zombie\n%Cpu(s):  1,8 Ben,  0,4 sys,  0,0 ni, 97,6 id,  0,1 wa,  0,0 hi,  0,0 si,  0,0 st\nKiB Speicher:  32870888 insgesamt, 27467976 verwendet,  5402912 frei,   518808 Puffer\nKiB Swap: 33480700 insgesamt,    39892 verwendet, 33440808 frei. 19454152 zwischengespeicherter Speicher\n\n  PID BENUTZER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     ZEIT+ BEFEHL                             \n 6675 patty    20   0 1731472 520960  30876 S   8,3  1,6 160:24,79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4,3  0,5   5:28,13 chrome \n</pre>\n\nLassen Sie uns über die Bedeutung dieser Ausgabe sprechen. Sie müssen sich das nicht merken, aber kommen Sie darauf zurück, wenn Sie eine Referenz benötigen.\n\n<b>1. Zeile: Dies sind die gleichen Informationen, die Sie sehen würden, wenn Sie den uptime-Befehl ausführen würden (weitere Informationen folgen)</b>\n\nDie Felder sind von links nach rechts:\n<ol>\n<li>Aktuelle Zeit</li>\n<li>Wie lange das System bereits läuft</li>\n<li>Wie viele Benutzer derzeit angemeldet sind</li>\n<li>Systemdurchschnittslast (weitere Informationen folgen)</li>\n</ol>\n\n<b>2. Zeile: Aufgaben, die ausgeführt, schlafend, gestoppt und als Zombie markiert sind</b>\n\n<b>3. Zeile: CPU-Informationen</b>\n\n<ol>\n<li>us: Benutzer-CPU-Zeit - Prozentsatz der CPU-Zeit, die mit der Ausführung von Benutzerprozessen verbracht wird, die nicht nett sind.</li>\n<li>sy: System-CPU-Zeit - Prozentsatz der CPU-Zeit, die mit der Ausführung des Kernels und der Kernelprozesse verbracht wird</li>\n<li>ni: Nette CPU-Zeit - Prozentsatz der CPU-Zeit, die mit der Ausführung von netten Prozessen verbracht wird</li>\n<li>id: CPU-Idle-Zeit - Prozentsatz der CPU-Zeit, die im Leerlauf verbracht wird</li>\n<li>wa: I/O-Wartezeit - Prozentsatz der CPU-Zeit, die auf E/A-Wartezeiten entfällt. Wenn dieser Wert niedrig ist, liegt das Problem wahrscheinlich nicht bei der Festplatte oder dem Netzwerk-I/O</li> \n<li>hi: Hardware-Interrupts - Prozentsatz der CPU-Zeit, der für die Bedienung von Hardware-Interrupts aufgewendet wird</li>\n<li>si: Software-Interrupts - Prozentsatz der CPU-Zeit, der für die Bedienung von Software-Interrupts aufgewendet wird</li>\n<li>st: Stahlzeit - Wenn Sie virtuelle Maschinen ausführen, ist dies der Prozentsatz der CPU-Zeit, der Ihnen für andere Aufgaben entzogen wurde</li>\n</ol>\n\n<b>4. und 5. Zeile: Speichernutzung und Swap-Nutzung</b>\n\n<b>Liste der aktuell verwendeten Prozesse</b>\n\n<ol>\n<li>PID: ID des Prozesses</li>\n<li>BENUTZER: Benutzer, der Eigentümer des Prozesses ist</li>\n<li>PR: Priorität des Prozesses</li>\n<li>NI: Der Nettowert</li>\n<li>VIRT: Virtueller Speicher, der vom Prozess verwendet wird</li>\n<li>RES: Physischer Speicher, der vom Prozess verwendet wird</li>\n<li>SHR: Gemeinsamer Speicher des Prozesses</li>\n<li>S: Gibt den Status des Prozesses an: S=Schlafend, R=Laufend, Z=Zombie, D=Ununterbrechbar, T=Gestoppt</li>\n<li>%CPU - dies ist der Prozentsatz der CPU, der von diesem Prozess verwendet wird</li>\n<li>%MEM - Prozentsatz des RAMs, der von diesem Prozess verwendet wird</li>\n<li>ZEIT+ - Gesamtaktivitätszeit dieses Prozesses</li>\n<li>BEFEHL - Name des Prozesses</li>\n</ol>\n\nSie können auch eine Prozess-ID angeben, wenn Sie nur bestimmte Prozesse verfolgen möchten:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "Welcher Befehl zeigt die gleiche Ausgabe wie die erste Zeile in top an?",
          "slug": "trackingprocessestop",
          "title": "Prozesse verfolgen: top"
        },
        {
          "exercise": "Lesen Sie die Handbücher für lsof und fuser, es gibt viele Informationen, die wir nicht behandelt haben, die es Ihnen ermöglichen, diese Tools flexibler einzusetzen.",
          "id": 2,
          "lessonContent": "Angenommen, Sie haben ein USB-Laufwerk angeschlossen und an einigen Dateien gearbeitet. Sobald Sie fertig waren, trennen Sie das USB-Gerät und erhalten den Fehler \"Gerät oder Ressource belegt\". Wie finden Sie heraus, welche Dateien auf dem USB-Laufwerk noch verwendet werden? Es gibt tatsächlich zwei Tools, die Sie dafür verwenden können: \n\n<b>lsof</b>\n\nDenken Sie daran, dass Dateien nicht nur Textdateien, Bilder usw. sind, sondern alles im System, Festplatten, Pipes, Netzwerk-Sockets, Geräte usw. Um zu sehen, was von einem Prozess verwendet wird, können Sie das lsof-Kommando (kurz für \"Liste offener Dateien\") verwenden. Dies zeigt Ihnen eine Liste aller offenen Dateien und ihrer zugehörigen Prozesse an. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nJetzt kann ich sehen, welche Prozesse das Gerät/die Datei noch geöffnet haben. In unserem USB-Beispiel können Sie diese Prozesse auch beenden, damit wir dieses lästige Laufwerk aushängen können.\n\n<b>fuser</b>\n\nEine weitere Möglichkeit, einen Prozess zu verfolgen, ist das fuser-Kommando (kurz für \"Dateinutzer\"), dies zeigt Ihnen Informationen über den Prozess, der die Datei verwendet, oder den Dateinutzer an. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nWir können sehen, welche Prozesse gerade unser /home/pete-Verzeichnis verwenden. Die lsof- und fuser-Tools sind sehr ähnlich, machen Sie sich mit diesen Tools vertraut und versuchen Sie sie das nächste Mal zu verwenden, wenn Sie eine Datei oder einen Prozess verfolgen müssen.",
          "quizAnswer": "lsof",
          "quizQuestion": "Welches Kommando wird verwendet, um offene Dateien und ihre Prozessinformationen aufzulisten?",
          "slug": "trackingprocesseslsoffuser",
          "title": "lsof und fuser"
        },
        {
          "exercise": "Führe den Befehl <b>ps m</b> aus und sieh nach, welche Prozesse bei dir multi-threaded laufen.",
          "id": 3,
          "lessonContent": "Du hast vielleicht von den Begriffen single-threaded und multi-threaded Prozessen gehört. Threads sind sehr ähnlich zu Prozessen, da sie verwendet werden, um dasselbe Programm auszuführen, oft als leichte Prozesse bezeichnet. Wenn ein Prozess einen Thread hat, ist er single-threaded, und wenn ein Prozess mehr als einen Thread hat, ist er multi-threaded. Allerdings haben alle Prozesse mindestens einen Thread. \n\nProzesse arbeiten mit ihren eigenen isolierten Systemressourcen, Threads können diese Ressourcen jedoch leicht untereinander teilen, was es ihnen erleichtert, untereinander zu kommunizieren. Manchmal ist es effizienter, eine multi-threaded Anwendung zu haben als eine multi-Prozess-Anwendung.\n\nGrundsätzlich, nehmen wir an, du öffnest LibreOffice Writer und Chrome, jeder ist sein eigener separater Prozess. Jetzt gehst du in Writer und fängst an, Text zu bearbeiten, wenn du den Text bearbeitest, wird er automatisch gespeichert. Diese beiden parallelen \"leichten Prozesse\" des Speicherns und Bearbeitens sind Threads. \n\nUm Prozess Threads anzuzeigen, kannst du verwenden: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nDie Prozesse sind jeweils mit ihrer PID gekennzeichnet, und unter den Prozessen befinden sich ihre Threads (gekennzeichnet durch --). So kannst du sehen, dass die oben genannten Prozesse beide single-threaded sind.",
          "quizAnswer": "Wahr",
          "quizQuestion": "Wahr oder falsch, alle Prozesse starten als single-threaded.",
          "slug": "processthreads",
          "title": "Prozess Threads"
        },
        {
          "exercise": "Überprüfen Sie die durchschnittliche Auslastung Ihres Systems und sehen Sie, was sie macht.",
          "id": 4,
          "lessonContent": "Lassen Sie uns einen nützlichen Befehl überprüfen, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 up 1 Tag,  5:59,  2 Benutzer,  durchschnittliche Auslastung: 0.00, 0.02, 0.05\n</pre>\n\nWir haben in der ersten Lektion dieses Kurses über die Betriebszeit gesprochen, aber wir haben das Feld der durchschnittlichen Auslastung noch nicht behandelt. Durchschnittliche Auslastungen sind eine gute Möglichkeit, die CPU-Auslastung auf Ihrem System zu sehen. Diese Zahlen repräsentieren die durchschnittliche CPU-Auslastung in 1, 5 und 15 Minuten Intervallen. Was meine ich mit CPU-Auslastung? Die CPU-Auslastung ist die durchschnittliche Anzahl von Prozessen, die darauf warten, von der CPU ausgeführt zu werden.\n\nAngenommen, Sie haben eine Single-Core-CPU, denken Sie an diesen Kern als eine einzelne Spur im Verkehr. Wenn es Stoßzeiten auf der Autobahn gibt, wird diese Spur sehr beschäftigt sein und der Verkehr wird bei 100% oder einer Auslastung von 1 sein. Nun ist der Verkehr so schlecht geworden, dass er die Autobahn blockiert und die normalen Straßen um das Zweifache der üblichen Anzahl von Autos beschäftigt, wir können sagen, dass Ihre Auslastung 200% oder eine Auslastung von 2 beträgt. Angenommen, es klärt sich etwas auf und es gibt nur noch halb so viele Autos auf der Autobahnspur, dann können wir sagen, dass die Auslastung der Spur 0,5 beträgt. Wenn der Verkehr nicht existent ist und wir schneller nach Hause kommen können, sollte die Auslastung idealerweise sehr niedrig sein, wie der Verkehr um 2 Uhr morgens. Die Autos sind in diesem Fall Prozesse und diese Prozesse warten nur darauf, von der Autobahn abzufahren und nach Hause zu kommen.\n\nNur weil Sie eine durchschnittliche Auslastung von 1 haben, bedeutet das nicht, dass Ihr Computer herumschleppt. Die meisten modernen Maschinen haben heutzutage mehrere Kerne. Wenn Sie beispielsweise einen Quad-Core-Prozessor (4 Kerne) haben und Ihre durchschnittliche Auslastung 1 beträgt, betrifft es tatsächlich nur 25% Ihrer CPU. Denken Sie bei jedem Kern an eine Spur im Verkehr. Sie können die Anzahl der Kerne auf Ihrem System mit <b>cat /proc/cpuinfo</b> anzeigen.\n\nBeim Beobachten der durchschnittlichen Auslastung müssen Sie die Anzahl der Kerne berücksichtigen. Wenn Sie feststellen, dass Ihr Computer immer eine überdurchschnittliche Auslastung aufweist, könnte etwas nicht stimmen.",
          "quizAnswer": "uptime",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um die durchschnittliche Auslastung zu sehen?",
          "slug": "cpumonitoring",
          "title": "CPU Überwachung"
        },
        {
          "exercise": "Verwenden Sie iostat, um Ihre Festplattenauslastung anzuzeigen.",
          "id": 5,
          "lessonContent": "Wir können auch die CPU-Auslastung überwachen sowie die Festplattenauslastung mit einem praktischen Tool namens <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     28.01.2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0,13    0,03    0,50    0,01    0,00   99,33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0,17         3,49         1,92     385106     212417\n</pre>\n\nDer erste Teil enthält die CPU-Informationen:\n\n<ul>\n<li>%user - Zeigt den Prozentsatz der CPU-Auslastung an, der beim Ausführen auf Benutzerebene (Anwendung) auftrat</li>\n<li>%nice - Zeigt den Prozentsatz der CPU-Auslastung an, der beim Ausführen auf Benutzerebene mit einer angenehmen Priorität auftrat. Benutzer-CPU-Auslastung mit angenehmen Prioritäten</li>\n<li>%system - Zeigt den Prozentsatz der CPU-Auslastung an, der beim Ausführen auf Systemebene (Kernel) auftrat.</li>\n<li>%iowait - Zeigt den Prozentsatz der Zeit an, in der die CPU oder CPUs untätig waren, während das System eine ausstehende Festplatten-E/A-Anforderung hatte.</li>\n<li>%steal - Zeigt den Prozentsatz der Zeit an, die die virtuelle CPU oder CPUs in unfreiwilliger Wartezeit verbracht haben, während der Hypervisor einen anderen virtuellen Prozessor bediente.</li>\n<li>%idle - Zeigt den Prozentsatz der Zeit an, in der die CPU oder CPUs untätig waren und das System keine ausstehende Festplatten-E/A-Anforderung hatte.</li>\n</ul>\n\nDer zweite Teil betrifft die Festplattenauslastung:\n\n<ul>\n<li>tps - Gibt die Anzahl der Transfers pro Sekunde an, die an das Gerät gesendet wurden. Ein Transfer ist eine E/A-Anforderung an das Gerät. Mehrere logische Anforderungen können zu einer einzelnen E/A-Anforderung an das Gerät kombiniert werden. Die Größe eines Transfers ist unbestimmt.</li>\n<li>kB_read/s - Gibt die Menge der vom Gerät gelesenen Daten in Kilobyte pro Sekunde an.</li>\n<li>kB_wrtn/s - Gibt die Menge der auf das Gerät geschriebenen Daten in Kilobyte pro Sekunde an.</li>\n<li>kB_read - Die Gesamtzahl der gelesenen Kilobyte.</li>\n<li>kB_wrtn - Die Gesamtzahl der geschriebenen Kilobyte.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "Welcher Befehl kann verwendet werden, um die I/O- und CPU-Auslastung anzuzeigen?",
          "slug": "iomonitoring",
          "title": "I/O Überwachung"
        },
        {
          "exercise": "Betrachten Sie Ihren Speicherverbrauch mit vmstat.",
          "id": 6,
          "lessonContent": "Zusätzlich zur CPU-Überwachung und I/O-Überwachung können Sie Ihren Speicherverbrauch mit <b>vmstat</b> überwachen\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nDie Felder sind wie folgt:\n\n<b>procs</b>\n<ul>\n<li>r - Anzahl der Prozesse für Laufzeit</li>\n<li>b - Anzahl der Prozesse im nicht unterbrechbaren Schlaf</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - Menge des verwendeten virtuellen Speichers</li>\n<li>free - Menge des freien Speichers</li>\n<li>buff - Menge des als Puffer verwendeten Speichers</li>\n<li>cache - Menge des als Cache verwendeten Speichers</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Menge des von der Festplatte eingetauschten Speichers</li>\n<li>so - Menge des auf die Festplatte ausgelagerten Speichers</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Menge der von einem Blockgerät empfangenen Blöcke</li>\n<li>bo - Menge der an ein Blockgerät gesendeten Blöcke</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - Anzahl der Unterbrechungen pro Sekunde</li>\n<li>cs - Anzahl der Kontextwechsel pro Sekunde</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Zeit im Benutzermodus verbracht</li>\n<li>sy - Zeit im Kernelmodus verbracht</li>\n<li>id - Zeit im Leerlauf verbracht</li>\n<li>wa - Zeit im Warten auf I/O verbracht</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "Welches Tool wird verwendet, um die Speicherauslastung anzuzeigen?",
          "slug": "speicherueberwachung",
          "title": "Speicherüberwachung"
        },
        {
          "exercise": "Installieren Sie sar auf Ihrem System und beginnen Sie mit der Sammlung und Analyse der Ressourcennutzung Ihres Systems.",
          "id": 7,
          "lessonContent": "Diese Überwachungstools sind gut, um zu prüfen, wenn Ihre Maschine Probleme hat, aber was ist mit Maschinen, die Probleme haben, wenn Sie nicht hinschauen. Für diese benötigen Sie ein kontinuierliches Überwachungstool, etwas, das Ihre Systemaktivitätsinformationen sammelt, meldet und speichert. In dieser Lektion werden wir ein großartiges Tool namens <b>sar</b> verwenden.\n\n<b>Installation von sar</b>\nSar ist ein Tool, das zur historischen Analyse Ihres Systems verwendet wird. Stellen Sie zunächst sicher, dass es installiert ist, indem Sie das Paket sysstat installieren <b>sudo apt install sysstat</b>.\n\n<b>Einrichten der Datensammlung</b>\nNormalerweise beginnt Ihr System automatisch mit der Datensammlung, sobald Sie sysstat installiert haben. Falls nicht, können Sie es aktivieren, indem Sie das ENABLED-Feld in /etc/default/sysstat ändern.\n\n<b>Verwendung von sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nDieser Befehl listet die Details ab dem Start des Tages auf.\n\n<pre>$ sudo sar -r</pre>\n\nDies listet die Details zur Speicherauslastung seit dem Start des Tages auf.\n\n<pre>$ sudo sar -P</pre>\n\nDies listet die Details zur CPU-Auslastung auf.\n\nUm die Ansicht eines anderen Tages zu sehen, können Sie in /var/log/sysstat/saXX gehen, wobei XX der Tag ist, den Sie anzeigen möchten.\n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "Was ist ein gutes Tool zur Überwachung von Systemressourcen?",
          "slug": "kontinuierlicheüberwachung",
          "title": "Kontinuierliche Überwachung"
        },
        {
          "exercise": "Erstellen Sie einen Cronjob, den Sie zu einer geplanten Zeit ausführen möchten.",
          "id": 8,
          "lessonContent": "Obwohl wir über die Ressourcennutzung gesprochen haben, denke ich, dass dies ein guter Zeitpunkt ist, um ein nützliches Tool in Linux zu erwähnen, das verwendet wird, um Aufgaben mit cron zu planen. Es gibt einen Dienst, der Programme für Sie zu der von Ihnen geplanten Zeit ausführt. Dies ist wirklich nützlich, wenn Sie ein Skript haben, das einmal täglich ausgeführt werden soll und etwas für Sie ausführen muss. \n\nZum Beispiel, sagen wir, ich habe ein Skript in /home/pete/scripts/change_wallpaper. Ich verwende dieses Skript jeden Morgen, um das Bild zu ändern, das ich als Hintergrundbild verwende, aber jeden Morgen muss ich dieses Skript manuell ausführen. Stattdessen kann ich einen Cron-Job erstellen, der mein Skript über cron ausführt. Ich kann die Zeit angeben, zu der dieser Cron-Job ausgeführt werden soll, und mein Skript ausführen. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nDie Felder sind von links nach rechts wie folgt:\n<ul>\n<li>Minute - (0-59)</li>\n<li>Stunde - (0-23)</li>\n<li>Tag des Monats - (1-31)</li>\n<li>Monat - (1-12)</li>\n<li>Tag der Woche - (0-7). 0 und 7 sind als Sonntag gekennzeichnet</li>\n</ul>\n\nDas Sternchen im Feld bedeutet, dass jeder Wert übereinstimmen soll. Also in meinem obigen Beispiel möchte ich, dass dies jeden Tag in jedem Monat um 8:30 Uhr läuft.\n\nUm einen Cronjob zu erstellen, bearbeiten Sie einfach die Crontab-Datei:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "Was ist der Befehl, um Ihre Cronjobs zu bearbeiten?",
          "slug": "cronjobs",
          "title": "Cron Jobs"
        }
      ],
      "slug": "processutilization",
      "title": "Prozessauslastung"
    },
    {
      "description": "Erfahren Sie mehr über Systemprotokolle und das Verzeichnis /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Schauen Sie sich Ihre /var/log/syslog-Datei an und sehen Sie, was sonst noch auf Ihrem Computer passiert.",
          "id": 1,
          "lessonContent": "Die Dienste, der Kernel, die Daemons usw. auf Ihrem System tun ständig etwas, diese Daten werden tatsächlich zur Speicherung auf Ihrem System in Form von Protokollen gesendet. Dies ermöglicht es uns, ein für Menschen lesbares Journal der Ereignisse zu haben, die auf unserem System stattfinden. Diese Daten werden normalerweise im /var-Verzeichnis aufbewahrt, das /var-Verzeichnis ist der Ort, an dem wir unsere variablen Daten wie Protokolle aufbewahren!\n\nWie werden diese Nachrichten überhaupt auf Ihrem System empfangen? Es gibt einen Dienst namens syslog, der diese Informationen an den Systemprotokollierer sendet.\n\nSyslog enthält tatsächlich viele Komponenten, eine der wichtigen ist ein laufender Daemon namens syslogd (neuere Linux-Distributionen verwenden rsyslogd), der auf Ereignisnachrichten wartet und diejenigen filtert, über die er informiert werden möchte, und je nachdem, was er mit dieser Nachricht tun soll, sendet er sie an eine Datei, Ihre Konsole oder tut nichts damit.\n\nMan würde denken, dass dieser Systemprotokollierer der zentrale Ort zur Verwaltung von Protokollen ist, aber leider ist er das nicht. Sie werden viele Anwendungen sehen, die ihre eigenen Protokollregeln schreiben und verschiedene Protokolldateien generieren, aber im Allgemeinen sollte das Format von Protokollen einen Zeitstempel und die Ereignisdetails enthalten.\n\nHier ist ein Beispiel für eine Zeile aus syslog:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nHier sehen wir, dass am 27. Januar um 07:41:32 Uhr unser Cron-Dienst den cron.weekly-Job ausgeführt hat. Sie können alle Ereignisnachrichten anzeigen, die syslog in der Datei /var/log/syslog sammelt.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "Welcher Daemon verwaltet Protokolle auf neueren Linux-Systemen?",
          "slug": "systemlogging",
          "title": "Systemprotokollierung"
        },
        {
          "exercise": "Schauen Sie sich Ihre /etc/rsyslog.d-Konfigurationsdatei an und sehen Sie, was sonst noch über den Systemlogger protokolliert wird.",
          "id": 2,
          "lessonContent": "Der Syslog-Dienst verwaltet und sendet Protokolle an den Systemlogger. Rsyslog ist eine weiterentwickelte Version von Syslog, die von den meisten Linux-Distributionen verwendet werden sollte. Die Ausgabe aller Protokolle, die der Syslog-Dienst sammelt, befindet sich unter /var/log/syslog (jede Nachricht außer Auth-Nachrichten).\n\nUm herauszufinden, welche Dateien von unserem Systemlogger verwaltet werden, schauen Sie sich die Konfigurationsdateien in /etc/rsyslog.d an:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nDiese Regeln zur Protokollierung von Dateien werden durch den Selektor in der linken Spalte und die Aktion in der rechten Spalte gekennzeichnet. Die Aktion gibt an, wohin die Protokollinformationen gesendet werden sollen, in eine Datei, Konsole usw. Denken Sie daran, dass nicht jede Anwendung und Dienst rsyslog verwendet, um ihre Protokolle zu verwalten. Wenn Sie also speziell wissen möchten, was protokolliert wird, müssen Sie in dieses Verzeichnis schauen.\n\nLassen Sie uns die Protokollierung tatsächlich in Aktion sehen. Sie können manuell ein Protokoll mit dem Befehl logger senden:\n\n<pre>\nlogger -s Hallo\n</pre>\n\nSchauen Sie nun in Ihre /var/log/syslog und Sie sollten diesen Eintrag in Ihren Protokollen sehen!",
          "quizAnswer": "logger",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um manuell eine Nachricht zu protokollieren?",
          "slug": "syslog",
          "title": "Zuerst einige Standard-Logdateien. Protokollierung nach Einrichtung."
        },
        {
          "exercise": "Schauen Sie sich Ihre /var/log/messages- und /var/log/syslog-Dateien an und sehen Sie, worin die Unterschiede bestehen.",
          "id": 3,
          "lessonContent": "Es gibt viele Protokolldateien, die Sie auf Ihrem System anzeigen können, viele wichtige finden Sie unter /var/log. Wir werden sie nicht alle durchgehen, aber wir werden ein paar der wichtigsten besprechen. \n\nEs gibt zwei allgemeine Protokolldateien, die Sie anzeigen können, um einen Einblick in das zu bekommen, was Ihr System tut:\n\n<b>/var/log/messages</b>\n\nDieses Protokoll enthält alle nicht-kritischen und nicht-Debug-Nachrichten, einschließlich Nachrichten, die während des Bootvorgangs (dmesg), Authentifizierung, Cron, Daemon usw. protokolliert wurden. Sehr nützlich, um einen Einblick in das Verhalten Ihrer Maschine zu bekommen. \n\n<b>/var/log/syslog</b>\n\nDies protokolliert alles außer Authentifizierungsnachrichten, es ist äußerst nützlich zum Debuggen von Fehlern auf Ihrer Maschine. \n\nDiese beiden Protokolle sollten ausreichen, um Probleme mit Ihrem System zu beheben. Wenn Sie jedoch nur einen bestimmten Protokollkomponenten anzeigen möchten, gibt es auch separate Protokolle dafür.",
          "quizAnswer": "syslog",
          "quizQuestion": "Welche Protokolldatei protokolliert alles außer Authentifizierungsnachrichten?",
          "slug": "generallogging",
          "title": "Allgemeines Protokollieren"
        },
        {
          "exercise": "Schauen Sie sich Ihre dmesg- und kern-Protokolle an, welche Unterschiede bemerken Sie?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nBeim Booten protokolliert Ihr System Informationen über den Kernel-Ringpuffer. Dies zeigt uns Informationen über Hardwaretreiber, Kernelinformationen und -status während des Bootvorgangs und mehr. Diese Protokolldatei befindet sich unter /var/log/dmesg und wird bei jedem Neustart zurückgesetzt. Möglicherweise sehen Sie jetzt keinen Nutzen darin, aber wenn Sie jemals Probleme beim Booten oder Hardwareprobleme haben, ist dmesg der beste Ort, um nachzusehen. Sie können dieses Protokoll auch mit dem Befehl dmesg anzeigen. \n\n<b>/var/log/kern.log</b>\nEin weiteres Protokoll, das Sie zur Anzeige von Kernelinformationen verwenden können, ist die Datei /var/log/kern.log. Hier werden die Kernelinformationen und -ereignisse auf Ihrem System protokolliert, es protokolliert auch die Ausgabe von dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "Welcher Befehl kann verwendet werden, um Kernel-Bootnachrichten anzuzeigen?",
          "slug": "kernellogging",
          "title": "Kernel Logging"
        },
        {
          "exercise": "Führen Sie einige fehlgeschlagene Anmeldeversuche durch und dann einen erfolgreichen, sehen Sie sich Ihr /var/log/auth.log an und sehen Sie, was passiert ist.",
          "id": 5,
          "lessonContent": "Die Authentifizierungsprotokollierung kann sehr nützlich sein, wenn Sie Probleme beim Anmelden haben. \n\n<b>/var/log/auth.log</b>\n\nDies enthält Systemberechtigungsprotokolle, wie z.B. Benutzeranmeldung und die verwendete Authentifizierungsmethode. \n\nBeispiel-Snippet:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "Welches Protokoll wird für die Benutzerauthentifizierung verwendet?",
          "slug": "authenticationlogging",
          "title": "Authentifizierungsprotokollierung"
        },
        {
          "exercise": "Schauen Sie sich Ihre logrotate-Konfigurationsdatei an und sehen Sie, wie sie einige Ihrer Protokolle verwaltet.",
          "id": 6,
          "lessonContent": "Protokolldateien generieren viele Daten und speichern diese auf Ihren Festplatten. Es gibt jedoch viele Probleme damit. Im Wesentlichen möchten wir nur neuere Protokolle sehen und unseren Festplattenspeicher effizient verwalten. Wie machen wir das? Die Antwort lautet: mit logrotate. \n\nDas Dienstprogramm logrotate übernimmt das Protokollmanagement für uns. Es verfügt über eine Konfigurationsdatei, die es uns ermöglicht, anzugeben, wie viele und welche Protokolle aufbewahrt werden sollen, wie unsere Protokolle komprimiert werden sollen, um Speicherplatz zu sparen, und mehr. Das logrotate-Tool wird normalerweise einmal täglich aus cron ausgeführt, und die Konfigurationsdateien befinden sich in /etc/logrotate.d. \n\nEs gibt andere Tools zum Rotieren von Protokollen, die Sie verwenden können, aber logrotate ist das gängigste.",
          "quizAnswer": "logrotate",
          "quizQuestion": "Welches Dienstprogramm wird zum Verwalten von Protokollen verwendet?",
          "slug": "managinglogfiles",
          "title": "Verwalten von Protokolldateien"
        }
      ],
      "slug": "protokollierung",
      "title": "Protokollierung"
    },
    {
      "description": "Erfahren Sie mehr über Netzwerkfreigabe mit rsync, scp, nfs und mehr.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Versuchen Sie, eine Datei mit scp von einem Rechner auf einen anderen zu kopieren.",
          "id": 1,
          "lessonContent": "Sie sind in der Regel nicht der einzige Computer in Ihrem Netzwerk, dies ist besonders der Fall, wenn Sie in einer kommerziellen Umgebung arbeiten. Wenn wir Daten von einem Rechner auf einen anderen übertragen möchten, ist es manchmal einfacher, ein USB-Laufwerk anzuschließen und sie manuell zu kopieren. Aber in den meisten Fällen, wenn Sie mit Maschinen im selben Netzwerk arbeiten, erfolgt die Datenübertragung über die Netzwerkdateifreigabe. \n\nIn diesem Kurs werden wir ein paar verschiedene Methoden durchgehen, um Daten zwischen verschiedenen Maschinen in Ihrem Netzwerk zu kopieren. Wir werden einige einfache Dateikopien besprechen, dann werden wir darüber sprechen, wie man ganze Verzeichnisse auf Ihrem Rechner einbindet, die als separater Laufwerk fungieren. \n\nEin einfaches Dateifreigabe-Tool ist der <b>scp</b>-Befehl. Der scp-Befehl steht für sicheres Kopieren, er funktioniert genau wie der cp-Befehl, ermöglicht es Ihnen jedoch, von einem Host zu einem anderen Host im selben Netzwerk zu kopieren. Er funktioniert über ssh, sodass alle Ihre Aktionen die gleiche Authentifizierung und Sicherheit wie ssh verwenden. \n\n<b>Um eine Datei von einem lokalen Host auf einen Remote-Host zu kopieren</b>\n\n<pre>$ scp myfile.txt benutzername@remotehost.com:/remote/verzeichnis</pre>\n\n<b>Um eine Datei von einem Remote-Host auf Ihren lokalen Host zu kopieren</b>\n\n<pre>$ scp benutzername@remotehost.com:/remote/verzeichnis/myfile.txt /lokales/verzeichnis</pre>\n\n<b>Um ein Verzeichnis von Ihrem lokalen Host auf einen Remote-Host zu kopieren</b>\n\n<pre>$ scp -r meinverzeichnis benutzername@remotehost.com:/remote/verzeichnis</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um Dateien sicher von einem Host auf einen anderen zu kopieren?",
          "slug": "netzwerkdateifreigabe",
          "title": "Dateifreigabe-Übersicht"
        },
        {
          "exercise": "Verwenden Sie rsync, um ein Verzeichnis mit einem anderen Verzeichnis zu synchronisieren, stellen Sie sicher, dass Sie kein wichtiges Verzeichnis überschreiben!",
          "id": 2,
          "lessonContent": "Ein weiteres Werkzeug, das zum Kopieren von Daten von verschiedenen Hosts verwendet wird, ist rsync (kurz für Remote-Synchronisation). Rsync ist dem scp sehr ähnlich, hat jedoch einen wesentlichen Unterschied. Rsync verwendet einen speziellen Algorithmus, der im Voraus überprüft, ob bereits Daten vorhanden sind, die Sie kopieren, und kopiert nur die Unterschiede. Angenommen, Sie kopieren eine Datei und Ihr Netzwerk wird unterbrochen, sodass der Kopiervorgang in der Mitte gestoppt wird. Anstatt alles von vorne zu kopieren, kopiert rsync nur die Teile, die nicht kopiert wurden. \n\nEs überprüft auch die Integrität einer Datei, die Sie mit Prüfsummen kopieren. Diese kleinen Optimierungen ermöglichen eine größere Flexibilität beim Dateitransfer und machen rsync ideal für die Synchronisierung von Verzeichnissen remote und lokal, Datenbackups, große Datentransfers und mehr.\n\nEinige häufig verwendete rsync-Optionen:\n\n<ul>\n<li>v - ausführliche Ausgabe</li>\n<li>r - rekursiv in Verzeichnisse</li>\n<li>h - menschenlesbare Ausgabe</li>\n<li>z - komprimiert für einfacheren Transfer, ideal für langsame Verbindungen</li>\n</ul>\n\n<b>Dateien auf demselben Host kopieren/synchronisieren</b>\n\n<pre>$ rsync -zvr /mein/lokales/verzeichnis/eins /mein/lokales/verzeichnis/zwei</pre>\n\n<b>Dateien auf den lokalen Host von einem Remote-Host kopieren/synchronisieren</b>\n\n<pre>$ rsync /lokales/verzeichnis benutzername@remotehost.com:/remote/verzeichnis</pre>\n\n<b>Dateien auf einen Remote-Host von einem lokalen Host kopieren/synchronisieren</b>\n\n<pre>$ rsync benutzername@remotehost.com:/remote/verzeichnis /lokales/verzeichnis</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "Welcher Befehl wäre nützlich für Datenbackups?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "Versuchen Sie, einen SimpleHTTPServer einzurichten!",
          "id": 3,
          "lessonContent": "Python hat ein sehr nützliches Tool zum Bereitstellen von Dateien über HTTP. Dies ist großartig, wenn Sie einfach einen schnellen Netzwerkfreigabe erstellen möchten, auf die andere Maschinen in Ihrem Netzwerk zugreifen können. Um das zu tun, gehen Sie einfach in das Verzeichnis, das Sie freigeben möchten, und führen Sie aus:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nDies richtet einen einfachen Webserver ein, auf den Sie über die lokale Adresse zugreifen können. Holen Sie sich also die IP-Adresse der Maschine, auf der Sie dies ausgeführt haben, und greifen Sie dann auf einem anderen Gerät im Browser darauf zu: http://IP_ADRESSE:8000. Auf Ihrem eigenen Gerät können Sie die verfügbaren Dateien anzeigen, indem Sie http://localhost:8000 in Ihrem Webbrowser eingeben.\n\nSie können dies auch mit Node tun oder wenn Sie Python 3 ausführen, wird die Syntax etwas anders sein.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Welches Tool können Sie verwenden, um mit Python einen einfachen HTTP-Server zu erstellen?",
          "slug": "simplehttpserver",
          "title": "Einfacher HTTP-Server"
        },
        {
          "exercise": "Lesen Sie die Manpage für NFS, um mehr zu erfahren.",
          "id": 4,
          "lessonContent": "Die am häufigsten verwendete Netzwerkdateifreigabe für Linux ist NFS (Network File System). NFS ermöglicht einem Server, Verzeichnisse und Dateien mit einem oder mehreren Clients über das Netzwerk zu teilen. \n\nWir werden hier nicht auf die Details zur Erstellung eines NFS-Servers eingehen, da dies komplex werden kann. Wir werden jedoch die Einrichtung von NFS-Clients besprechen.\n\n<b>Einrichten eines NFS-Clients</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/verzeichnis /mount_verzeichnis</pre>\n\n<b>Automatisches Einhängen</b>\n\nAngenommen, Sie verwenden den NFS-Server häufig und möchten ihn dauerhaft eingehängt halten. Normalerweise würden Sie denken, dass Sie die Datei /etc/fstab bearbeiten müssten, aber Sie erhalten möglicherweise nicht immer eine Verbindung zum Server, was beim Booten Probleme verursachen kann. Stattdessen sollten Sie das automatische Einhängen einrichten, damit Sie sich bei Bedarf mit dem NFS-Server verbinden können. Dies wird mit dem <b>automount</b>-Tool oder in neueren Versionen von Linux mit <b>amd</b> durchgeführt. Wenn auf eine Datei in einem bestimmten Verzeichnis zugegriffen wird, sucht automount den entfernten Server und hängt ihn automatisch ein.",
          "quizAnswer": "automount",
          "quizQuestion": "Welches Tool wird verwendet, um Einhängepunkte automatisch zu verwalten?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Richten Sie eine Samba-Freigabe ein, wenn Sie noch keine haben, öffnen Sie smb.conf und machen Sie sich mit den Optionen in der Konfigurationsdatei vertraut.",
          "id": 5,
          "lessonContent": "In den Anfangstagen der Computertechnik wurde es notwendig, dass Windows-Maschinen Dateien mit Linux-Maschinen teilen konnten, daher wurde das Server Message Block (SMB)-Protokoll geboren. SMB wurde zum Teilen von Dateien zwischen Windows-Betriebssystemen (Mac hat auch Dateifreigabe mit SMB) verwendet und später in Form des Common Internet File System (CIFS)-Protokolls bereinigt und optimiert. \n\nSamba ist der Begriff für die Linux-Dienstprogramme, um mit CIFS unter Linux zu arbeiten. Neben der Dateifreigabe können auch Ressourcen wie Drucker freigegeben werden. \n\n<b>Erstellen Sie eine Netzwerkfreigabe mit Samba</b>\n\nLassen Sie uns die grundlegenden Schritte durchgehen, um eine Netzwerkfreigabe zu erstellen, auf die eine Windows-Maschine zugreifen kann:\n\n<b>Installieren Sie Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Setup smb.conf</b>\n\nDie Konfigurationsdatei für Samba befindet sich unter /etc/samba/smb.conf. Diese Datei sollte dem System mitteilen, welche Verzeichnisse freigegeben werden sollen, ihre Zugriffsberechtigungen und weitere Optionen. Die Standard smb.conf enthält bereits viele auskommentierte Codes, die Sie als Beispiel für Ihre eigenen Konfigurationen verwenden können.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Ein Passwort für Samba einrichten</b>\n\n<pre>$ sudo smbpasswd -a [Benutzername]</pre>\n\n<b>Erstellen Sie ein freigegebenes Verzeichnis</b>\n\n<pre>$ mkdir /mein/verzeichnis/zum/teilen</pre>\n\n<b>Starten Sie den Samba-Dienst neu</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Zugriff auf eine Samba-Freigabe über Windows</b>\n\nIn Windows geben Sie einfach die Netzwerkverbindung im Ausführen-Prompt ein: \\\\HOST\\freigabename.\n\n<b>Zugriff auf eine Samba/Windows-Freigabe über Linux</b>\n\n<pre>$ smbclient //HOST/verzeichnis -U benutzer</pre>\n\nDas Samba-Paket enthält ein Befehlszeilentool namens <b>smbclient</b>, das Sie verwenden können, um auf jeden Windows- oder Samba-Server zuzugreifen. Sobald Sie mit der Freigabe verbunden sind, können Sie Dateien durchsuchen und übertragen.\n\n<b>Binden Sie eine Samba-Freigabe an Ihr System an</b>\n\nAnstatt Dateien einzeln zu übertragen, können Sie die Netzwerkfreigabe einfach auf Ihrem System einbinden.\n\n<pre>$ sudo mount -t cifs servername:verzeichnis mountpunkt -o benutzer=benutzername,passwort=passwort</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Was ist das neueste Protokoll, das für den Dateitransfer zwischen Windows und Linux verwendet wird?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Netzwerkfreigabe"
    },
    {
      "description": "Erfahren Sie mehr über Netzwerkgrundlagen und das TCP/IP-Modell.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 1,
          "lessonContent": "Schauen wir uns ein typisches Heimnetzwerk an, das aus verschiedenen Komponenten besteht. \n\n<ul>\n<li>ISP - Ihr Internetdienstanbieter, das Unternehmen, bei dem Sie bezahlen, um Internet in Ihrem Haus zu erhalten.</li>\n<li>Router - Der Router ermöglicht es jedem Gerät in Ihrem Netzwerk, eine Verbindung zum Internet herzustellen. In den meisten modernen Routern können Sie sich drahtlos oder über ein Ethernet-Kabel verbinden.</li>\n<li>WAN - Weitverkehrsnetzwerk, so nennen wir das Netzwerk, das alles zwischen Ihrem Router und einem weiteren Netzwerk wie dem Internet umfasst.</li>\n<li>WLAN - Drahtloses lokales Netzwerk, das ist das Netzwerk zwischen Ihrem Router und allen drahtlosen Geräten, die Sie haben könnten, wie Laptops.</li>\n<li>LAN - Lokales Netzwerk, das ist das Netzwerk zwischen Ihrem Router und allen verkabelten Geräten wie Desktop-PCs.</li>\n<li>Hosts - Jedes Gerät in einem Netzwerk wird als Host bezeichnet.</li>\n</ul>\n\nDie Daten und Informationen, die durch Netzwerke übertragen werden, werden als Pakete bezeichnet, und am Ende des Abschnitts Networking Nomad werden Sie im Detail verstehen, wie ein Paket zu und von Hosts reist.",
          "quizAnswer": "LAN",
          "quizQuestion": "Wie nennt man das lokale Netzwerk?",
          "slug": "netzwerkgrundlagen",
          "title": "Netzwerkgrundlagen"
        },
        {
          "exercise": "Lesen Sie mehr über das OSI-Modell: <a href=\"https://de.wikipedia.org/wiki/OSI-Modell\">https://de.wikipedia.org/wiki/OSI-Modell</a>",
          "id": 2,
          "lessonContent": "Bevor wir uns mit einigen praktischen Netzwerkthemen befassen können, müssen wir uns mit einigen langweiligen Fachbegriffen beschäftigen, die Sie wahrscheinlich schon einmal gehört haben. Das OSI (Open Systems Interconnection) Modell ist ein theoretisches Netzwerkmodell. Dieses Modell zeigt uns, wie ein Paket durch ein Netzwerk in sieben verschiedenen Schichten wandert. Ich werde nicht auf die Details dieses Modells eingehen, da die meisten dieser Netzwerkkurse sich auf das TCP/IP-Modell konzentrieren werden, aber es sollte erwähnt werden, dass ein solches theoretisches Netzwerkmodell existiert und tatsächlich einen großen Einfluss auf das TCP/IP-Netzwerkmodell hatte, das wir heute verwenden.",
          "quizAnswer": "OSI",
          "quizQuestion": "Was wird als theoretisches Netzwerkmodell verwendet?",
          "slug": "osimodel",
          "title": "OSI-Modell"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Das OSI-Modell hat letztendlich zum TCP/IP-Modell geführt, das die Grundlage des Internets bildet. Es handelt sich um die tatsächliche Implementierung von Netzwerken. Das TCP/IP-Modell verwendet die TCP/IP-Protokollsuite, die wir einfach als TCP/IP bezeichnen. Diese Protokolle arbeiten zusammen, um festzulegen, wie Daten gesammelt, adressiert, übertragen und durch ein Netzwerk geroutet werden sollen. Mit dem TCP/IP-Modell können wir sehen, wie diese Protokolle verwendet werden, um aufzuschlüsseln, wie ein Paket durch das Netzwerk reist.\n\n<b>Anwendungsschicht</b>\n\nDie oberste Schicht des TCP/IP-Modells. Sie bestimmt, wie die Programme Ihres Computers (wie z.B. Ihr Webbrowser) mit den Transportdiensten der Transportschicht interagieren, um die gesendeten oder empfangenen Daten anzuzeigen.\n\nDiese Schicht verwendet:\n<ul>\n<li>HTTP (Hypertext Transfer Protocol) - für Webseiten im Internet verwendet.</li>\n<li>SMTP (Simple Mail Transfer Protocol) - Übertragung von E-Mails</li>\n</ul>\n\n<b>Transportschicht</b>\n\nWie Daten übertragen werden, umfasst die Überprüfung der richtigen Ports, die Integrität der Daten und im Wesentlichen die Zustellung unserer Pakete.\n\nDiese Schicht verwendet:\n<ul>\n<li>TCP (Transmission Control Protocol) - zuverlässige Datenübertragung</li>\n<li>UDP (User Datagram Protocol) - unzuverlässige Datenübertragung</li>\n</ul>\n\n<b>Netzwerkschicht</b>\n\nDiese Schicht legt fest, wie Pakete zwischen Hosts und über Netzwerke hinweg bewegt werden.\n\nDiese Schicht verwendet:\n<ul>\n<li>IP (Internet Protocol) - Hilft dabei, Pakete von einer Maschine zur anderen zu routen.</li>\n<li>ICMP (Internet Control Message Protocol) - Hilft uns zu verstehen, was passiert, z.B. Fehlermeldungen und Debugging-Informationen.</li>\n</ul>\n\n<b>Verbindungsschicht</b>\n\nDiese Schicht legt fest, wie Daten über ein physisches Hardwarestück gesendet werden. Beispielsweise Daten, die über Ethernet, Glasfaser usw. übertragen werden.\n\nDie oben aufgeführten Listen von Protokollen, die jede Schicht verwendet, sind nicht umfassend, und Sie werden auf viele andere Protokolle stoßen, die eine Rolle spielen.\n\nIn den folgenden Lektionen werden wir uns mit jeder dieser Schichten befassen und besprechen, wie unser Paket durch das Netzwerk im Rahmen des TCP/IP-Modells verläuft (es gibt viele Perspektiven, wie ein Paket über Netzwerke reist, wir werden sie nicht alle betrachten, aber seien Sie sich bewusst, dass sie existieren).",
          "quizAnswer": "Anwendung",
          "quizQuestion": "Was ist die oberste Schicht des TCP/IP-Modells?",
          "slug": "tcpipmodel",
          "title": "TCP/IP-Modell"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen verfügbar.",
          "id": 4,
          "lessonContent": "Bevor wir uns damit beschäftigen, wie ein Paket über ein Netzwerk bewegt wird, müssen wir uns mit einigen Begriffen vertraut machen. Wenn Sie einen Brief versenden, müssen Sie wissen, an wen er gesendet wird und woher er kommt. Pakete benötigen dieselben Informationen, unsere Hosts und andere Hosts werden mithilfe von MAC (Media Access Control)-Adressen und IP-Adressen identifiziert. Um es uns Menschen leichter zu machen, verwenden wir Hostnamen, um einen Host zu identifizieren.\n\n<b>MAC-Adressen</b>\n\nEine MAC-Adresse ist ein eindeutiger Bezeichner, der als Hardwareadresse verwendet wird. Diese Adresse ändert sich nie. Wenn Sie Zugriff auf das Internet erhalten möchten, benötigt Ihr Gerät eine sogenannte Netzwerkschnittstellenkarte. Dieser Netzwerkadapter verfügt über seine eigene Hardwareadresse, die zur Identifizierung Ihres Geräts verwendet wird. Eine MAC-Adresse für ein Ethernet-Gerät sieht etwa so aus: 00:C4:B5:45:B2:43. MAC-Adressen werden den Netzwerkadaptern bei der Herstellung zugewiesen. Jeder Hersteller hat eine organisationsspezifische Kennung (OUI), um sie als Hersteller zu identifizieren. Diese OUI wird durch die ersten 3 Bytes der MAC-Adresse angegeben. Zum Beispiel hat Dell 00-14-22, sodass ein Netzwerkadapter von Dell eine MAC-Adresse wie: 00-14-22-34-B2-C2 haben könnte. \n\n<b>IP-Adressen</b>\n\nEine IP-Adresse wird verwendet, um ein Gerät in einem Netzwerk zu identifizieren. Sie sind hardwareunabhängig und können je nach Verwendung von IPv4 oder IPv6 in der Syntax variieren (dazu später mehr). Für den Moment gehen wir davon aus, dass Sie IPv4 verwenden, sodass eine typische IP-Adresse so aussehen würde: 10.24.12.4. IP-Adressen werden auf der Softwareseite des Netzwerks verwendet. Jedes Mal, wenn ein System mit dem Internet verbunden ist, sollte es eine IP-Adresse haben. Sie können sich auch ändern, wenn sich Ihr Netzwerk ändert, und sind eindeutig für das gesamte Internet (dies ist nicht immer der Fall, wenn wir über NAT lernen). \n\nDenken Sie daran, dass es sowohl Software als auch Hardware benötigt, um Pakete über Netzwerke zu bewegen. Daher haben wir zwei Bezeichner für jede, MAC (Hardware) und IP (Software).\n\n<b>Hostnamen</b>\n\nEine letzte Möglichkeit, Ihre Geräte zu identifizieren, ist durch Hostnamen. Hostnamen nehmen Ihre IP-Adresse und ermöglichen es Ihnen, diese Adresse mit einem menschenlesbaren Namen zu verknüpfen. Anstatt sich 192.12.41.4 zu merken, können Sie sich einfach myhost.com merken.",
          "quizAnswer": "4",
          "quizQuestion": "Wie viele Bytes hat eine IPv4-Adresse?",
          "slug": "netzwerkadressierung",
          "title": "Netzwerkadressierung"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 5,
          "lessonContent": "Angenommen, ich möchte eine E-Mail an Patty senden. Wir werden jede der TCP/IP-Schichten durchgehen, um dies in Aktion zu sehen. \n\nDenken Sie daran, dass Pakete verwendet werden, um Daten über Netzwerke zu übertragen. Ein Paket besteht aus einem Header und Nutzlast. Der Header enthält Informationen darüber, wohin das Paket geht und woher es kommt. Die Nutzlast sind die tatsächlichen Daten, die übertragen werden. Wenn unser Paket das Netzwerk durchläuft, fügt jede Schicht dem Header des Pakets Informationen hinzu. Beachten Sie auch, dass verschiedene Schichten einen anderen Begriff für unser \"Paket\" verwenden. In der Transportschicht kapseln wir im Wesentlichen unsere Daten in ein Segment ein und in der Verbindungsschicht bezeichnen wir dies als Frame, aber wissen Sie einfach, dass der Begriff Paket im Zusammenhang mit demselben verwendet werden kann.\n\nZuerst beginnen wir in der Anwendungsschicht. Wenn wir unsere E-Mail über unseren E-Mail-Client senden, wird die Anwendungsschicht diese Daten kapseln. Die Anwendungsschicht kommuniziert über einen bestimmten Port mit der Transportschicht und sendet über diesen Port ihre Daten. Wir möchten eine E-Mail über das Anwendungsschichtprotokoll SMTP (Simple Mail Transfer Protocol) senden. Die Daten werden über unser Transportprotokoll gesendet, das eine Verbindung zu diesem Port öffnet (Port 25 wird für SMTP verwendet). So werden diese Daten über diesen Port gesendet und diese Daten werden an die Transportschicht gesendet, um in Segmente eingekapselt zu werden.",
          "quizAnswer": "Anwendung",
          "quizQuestion": "Welche Schicht wird verwendet, um die Paketdaten in einem benutzerfreundlichen Format darzustellen?",
          "slug": "anwendungsschicht",
          "title": "Anwendungsschicht"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen verfügbar.",
          "id": 6,
          "lessonContent": "Die Transportschicht hilft uns, unsere Daten auf eine Weise zu übertragen, die von Netzwerken gelesen werden kann. Sie zerlegt unsere Daten in Stücke, die transportiert und in der richtigen Reihenfolge wieder zusammengesetzt werden. Diese Stücke werden als Segmente bezeichnet. Segmente erleichtern den Datentransport über Netzwerke. \n\n<b>Ports</b>\n\nObwohl wir über IP-Adressen wissen, wohin wir unsere Daten senden, sind sie nicht spezifisch genug, um unsere Daten an bestimmte Prozesse oder Dienste zu senden. Dienste wie HTTP verwenden einen Kommunikationskanal über Ports. Wenn wir Webseitendaten senden möchten, müssen wir sie über den HTTP-Port (Port 80) senden. Neben der Bildung von Segmenten fügt die Transportschicht auch die Quell- und Zielports dem Segment hinzu, damit der Empfänger beim Erhalt des endgültigen Pakets weiß, welchen Port er verwenden soll. \n\n<b>UDP</b>\n\nEs gibt zwei beliebte Transportprotokolle UDP und TCP. Wir werden UDP kurz besprechen und uns hauptsächlich auf TCP konzentrieren, da es am häufigsten verwendet wird.\n\nUDP ist keine zuverlässige Methode zum Transportieren von Daten, tatsächlich ist es ihm egal, ob Sie alle Ihre Originaldaten erhalten. Das mag schrecklich klingen, aber es hat seine Verwendungen, wie z.B. für das Streamen von Medien, es ist in Ordnung, wenn Sie einige Frames verlieren, im Gegenzug erhalten Sie Ihre Daten etwas schneller. \n\n<b>TCP</b>\n\nTCP bietet eine zuverlässige, verbindungsorientierte Datenstromübertragung. TCP verwendet Ports, um Daten zu und von Hosts zu senden. Eine Anwendung öffnet eine Verbindung von einem Port auf ihrem Host zu einem anderen Port auf einem entfernten Host. Um die Verbindung herzustellen, verwenden wir den TCP-Handshake. \n\n<ul>\n<li>Der Client (verbindender Prozess) sendet dem Server ein SYN-Segment, um eine Verbindung anzufordern</li>\n<li>Der Server sendet dem Client ein SYN-ACK-Segment, um die Verbindungsanforderung des Clients zu bestätigen</li>\n<li>Der Client sendet dem Server ein ACK, um die Verbindungsanforderung des Servers zu bestätigen</li>\n</ul>\n\nSobald diese Verbindung hergestellt ist, können Daten über eine TCP-Verbindung ausgetauscht werden. Die Daten werden in verschiedenen Segmenten gesendet und mit TCP-Sequenznummern verfolgt, damit sie in der richtigen Reihenfolge angeordnet werden können, wenn sie übermittelt werden. In unserem E-Mail-Beispiel fügt die Transportschicht dem Quellport des Quellhosts den Zielport (25) hinzu.",
          "quizAnswer": "TCP",
          "quizQuestion": "Was ist ein zuverlässiges Transportprotokoll?",
          "slug": "transportschicht",
          "title": "Transportschicht"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 7,
          "lessonContent": "Die Netzwerkschicht bestimmt die Routen unserer Pakete vom Quellrechner zum Zielrechner. Glücklicherweise reist unser Paket in unserem Beispiel nur innerhalb desselben Netzwerks, aber das Internet besteht aus vielen Netzwerken. Diese kleineren Netzwerke, aus denen das Internet besteht, werden als Subnetze bezeichnet. Alle Subnetze sind auf irgendeine Weise miteinander verbunden, weshalb wir beispielsweise auf www.google.com zugreifen können, obwohl es sich in einem eigenen Netzwerk befindet. Ich werde nicht ins Detail gehen, da wir einen ganzen Kurs den Subnetzen gewidmet haben, aber im Hinblick auf unsere Netzwerkschicht wissen Sie jetzt, dass die IP-Adressen die Regeln für die Kommunikation mit verschiedenen Subnetzen festlegen. \n\nIn der Netzwerkschicht empfängt sie das Segment aus der Transportschicht, kapselt dieses Segment in ein IP-Paket ein und fügt die IP-Adresse des Quellrechners und die IP-Adresse des Zielrechners dem Paketheader hinzu. Zu diesem Zeitpunkt verfügt unser Paket also über Informationen darüber, wohin es geht und woher es kommt. Jetzt sendet es unser Paket an die physische Hardwareebene.",
          "quizAnswer": "Subnetze",
          "quizQuestion": "Wie werden die kleineren Netzwerke genannt, aus denen das Internet besteht?",
          "slug": "netzwerkschicht",
          "title": "Netzwerkschicht"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 8,
          "lessonContent": "Am unteren Ende des TCP/IP-Modells befindet sich die Link-Schicht. Diese Schicht ist die hardware-spezifische Schicht.\n\nIn der Link-Schicht wird unser Paket erneut in etwas namens Frame verkapselt. Der Frame-Header fügt die Quell- und Ziel-MAC-Adressen unserer Hosts, Prüfsummen und Pakettrennzeichen hinzu, damit der Empfänger erkennen kann, wann ein Paket endet. \n\nGlücklicherweise sind wir im selben Netzwerk, sodass unser Paket nicht allzu weit reisen muss. Zuerst fügt die Link-Schicht meine Quell-MAC-Adresse dem Frame-Header hinzu, aber sie muss auch Pattys MAC-Adresse kennen. Wie weiß sie das und wie finde ich sie, da sie nicht im Internet ist? Wir verwenden ARP!\n\n<b>ARP (Adressauflösungsprotokoll)</b>\n\nARP findet die MAC-Adresse, die mit einer IP-Adresse verbunden ist. ARP wird innerhalb desselben Netzwerks verwendet. Wenn Patty nicht im selben Netzwerk wäre, würden wir ein Routing-System verwenden, um den nächsten Router zu bestimmen, der das Paket empfangen würde, und sobald wir im selben Netzwerk wären, könnten wir ARP verwenden. \n\nSobald wir im selben Netzwerk sind, verwenden Systeme zuerst die ARP-Look-up-Tabelle, die Informationen darüber speichert, welche IP-Adressen mit welchen MAC-Adressen verbunden sind. Wenn der Wert dort nicht vorhanden ist, wird ARP verwendet. Dann sendet das System eine Broadcast-Nachricht an das Netzwerk mit dem ARP-Protokoll, um herauszufinden, welcher Host die IP 10.10.1.4 hat. Eine Broadcast-Nachricht ist eine spezielle Nachricht, die an alle Hosts in einem Netzwerk gesendet wird (passenderweise für das Senden eines Broadcasts benannt). Jede Maschine mit der angeforderten IP-Adresse antwortet mit einem ARP-Paket, das die IP-Adresse und die MAC-Adresse enthält.\n\nNun, da wir alle notwendigen Daten haben, die wir brauchen, IP-Adresse und MAC-Adressen, leitet unsere Link-Schicht diesen Frame über unsere Netzwerkschnittstellenkarte weiter zum nächsten Gerät und findet Pattys Netzwerk. Dieser Schritt ist etwas komplexer als ich es gerade erklärt habe, aber wir werden in dem Routing-Kurs mehr Details besprechen.\n\nUnd da ist es, ein einfacher (oder nicht so einfacher) Paketdurchlauf durch die TCP/IP-Schicht. Bedenken Sie, dass Pakete nicht in einer Einbahnstraße wie dieser reisen. Wir sind noch nicht einmal in Pattys Netzwerk angekommen! Beim Durchqueren von Netzwerken ist es erforderlich, das TCP/IP-Modell mindestens zweimal zu durchlaufen, bevor Daten gesendet oder empfangen werden. In der Realität würde das Aussehen dieses Pakets etwa so aussehen: \n\n<b>Paketdurchlauf</b>\n\n<ol>\n<li>Pete sendet Patty eine E-Mail: Diese Daten werden an die Transportschicht gesendet.</li>\n<li>Die Transportschicht verkapselt die Daten in einen TCP- oder UDP-Header, um ein Segment zu bilden. Das Segment fügt die Ziel- und Quell-TCP- oder UDP-Port hinzu und wird dann an die Netzwerkschicht gesendet.</li>\n<li>Die Netzwerkschicht verkapselt das TCP-Segment in ein IP-Paket, fügt die Quell- und Ziel-IP-Adresse hinzu. Routet dann das Paket zur Link-Schicht.</li>\n<li>Das Paket erreicht dann Petes physische Hardware und wird in einem Frame verkapselt. Die Quell- und Ziel-MAC-Adresse werden dem Frame hinzugefügt.</li>\n<li>Patty empfängt diesen Datenframe über ihre physische Schicht und überprüft jeden Frame auf Datenintegrität, dekapselt dann den Frameinhalt und sendet das IP-Paket an die Netzwerkschicht.</li>\n<li>Die Netzwerkschicht liest das Paket, um die zuvor angehängte Quell- und Ziel-IP zu finden. Sie überprüft, ob ihre IP mit der Ziel-IP übereinstimmt, was der Fall ist! Sie dekapselt das Paket und sendet das Segment an die Transportschicht.</li>\n<li>Die Transportschicht dekapselt die Segmente, überprüft die TCP- oder UDP-Portnummern und stellt eine Verbindung zur Anwendungsschicht basierend auf diesen Portnummern her.</li>\n<li>Die Anwendungsschicht empfängt die Daten von der Transportschicht auf dem angegebenen Port und präsentiert sie Patty in Form der endgültigen E-Mail-Nachricht</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Was wird verwendet, um die MAC-Adresse im selben Netzwerk zu finden?",
          "slug": "linklayer",
          "title": "Link Layer"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 9,
          "lessonContent": "Ein wichtiges Netzwerkkonzept, das wir noch nicht behandelt haben, ist DHCP (Dynamic Host Configuration Protocol)\n\nDHCP weist IP-Adressen, Subnetzmasken und Gateways unseren Geräten zu. Zum Beispiel, nehmen wir an, Sie haben ein Handy und möchten eine Telefonnummer erhalten, um mit anderen Personen zu sprechen. Sie müssen Ihren Mobilfunkanbieter anrufen und dieser wird Ihnen eine Nummer geben. Solange Sie Ihre Rechnungen bezahlen, können Sie Ihr Handy weiterhin nutzen. DHCP ist in diesem Fall der Mobilfunkanbieter, der Ihnen eine IP-Adresse gibt, damit Sie mit anderen IP-Adressen kommunizieren können. Ihnen wird auch eine IP-Adresse zugewiesen, die für eine bestimmte Zeit gültig ist und je nach Ihren Leasingeinstellungen erneuert wird.\n\nDHCP ist aus vielen Gründen großartig, es ermöglicht einem Netzwerkadministrator, sich keine Gedanken über die Zuweisung von IP-Adressen machen zu müssen und verhindert auch die Einrichtung von doppelten IP-Adressen. Jedes physische Netzwerk sollte seinen eigenen DHCP-Server haben, damit ein Host eine IP-Adresse anfordern kann. In einer normalen häuslichen Umgebung fungiert der Router normalerweise als DHCP-Server.\n\nDer Weg, wie DHCP alle Ihre dynamischen Host-Informationen erhält, ist:\n\n<ol>\n<li>DHCP DISCOVER - Diese Nachricht wird gesendet, um nach einem DHCP-Server zu suchen.</li>\n<li>DHCP OFFER - Der DHCP-Server im Netzwerk antwortet mit einer Angebotsnachricht. Das Angebot enthält ein Paket mit DHCP-Leasezeit, Subnetzmaske, IP-Adresse usw.</li>\n<li>DHCP REQUEST - Der Client sendet erneut eine Broadcast-Nachricht, um allen DHCP-Servern mitzuteilen, welches Angebot er akzeptiert hat.</li>\n<li>DHCP ACK - Die Bestätigung wird vom Server gesendet.</li>\n</ol>\n\nDHCP wird noch komplexer, aber das ist das Wesentliche.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "Was sind die Schritte in einer DHCP-Anfrage?",
          "slug": "dhcpoverview",
          "title": "DHCP-Übersicht"
        }
      ],
      "slug": "netzwerkgrundlagen",
      "title": "Netzwerkgrundlagen"
    },
    {
      "description": "Erfahren Sie mehr über Subnetze und wie Sie Subnetzarithmetik durchführen können!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Finden Sie Ihre IP-Adresse mit ifconfig.",
          "id": 1,
          "lessonContent": "Jeder Netzwerkhost hat eine eindeutige Adresse, und jede eindeutige Adresse kann verwendet werden, um den Host im Netzwerk zu lokalisieren. Diese eindeutigen Adressen werden als 'IP-Adressen' bezeichnet. Eine IPv4-Adresse sieht ungefähr so aus:\n\n<pre>204.23.124.23</pre>\n\nDiese Adresse enthält tatsächlich zwei Teile: den Netzwerkanteil (der angibt, in welchem Netzwerk es sich befindet) und den Hostanteil (der den Host identifiziert). In diesem Kurs werden wir hauptsächlich über IPv4-Adressen sprechen, die Sie normalerweise sehen, wenn von 'IP-Adressen' die Rede ist.\n\nEine IP-Adresse wird durch die Punkte in Oktette unterteilt. Es gibt 4 Oktette in einer IPv4-Adresse. Wenn Sie ein wenig Informatik kennen, wissen Sie, dass ein Oktett 8 Bits sind, und Sie wissen, dass 8 Bits tatsächlich 1 Byte entsprechen. Das bedeutet, dass eine IPv4-Adresse 4 Bytes hat. Wir verwenden Bits häufig, wenn es um Subnetze und IP-Adressen geht.\n\nSie können Ihre IP-Adresse mit dem Befehl 'ifconfig -a' anzeigen:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nWie Sie sehen können, ist meine IPv4-Adresse: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "Wie viele Bytes sind in einer IPv4-Adresse?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Verwenden Sie ifconfig, um Ihre Subnetzmaske anzuzeigen.",
          "id": 2,
          "lessonContent": "Wie kann ich feststellen, ob ich im selben Netzwerk wie Patty bin? Nun, wir können einfach das Subnetz, kurz für Subnetzwerk, betrachten. Ein Subnetz ist eine Gruppe von Hosts mit IP-Adressen, die auf bestimmte Weise ähnlich sind. Diese Hosts befinden sich normalerweise in unmittelbarer Nähe zueinander, und Sie können problemlos Daten an Hosts im selben Subnetz senden und von ihnen empfangen. Denken Sie daran, wie das Senden von Postleitzahlen, es ist viel einfacher als das Senden von Post in einen anderen Staat. \n\nZum Beispiel würden alle Hosts mit einer IP-Adresse, die mit 123.45.67 beginnt, im selben Subnetz sein. Mein Host hat die IP 123.45.67.8 und Pattys hat die IP 123.45.67.9. Die gemeinsamen Zahlen sind mein Netzwerkpräfix und die 8 und 9 sind unsere Hosts, daher ist mein Netzwerk dasselbe wie das von Patty. Ein Subnetz ist in ein Netzwerkpräfix, wie z.B. 123.45.67.0, und eine Subnetzmaske unterteilt.\n\n<b>Subnetzmasken</b>\n\nSubnetzmasken bestimmen, welcher Teil Ihrer IP-Adresse der Netzwerkanteil und welcher Teil der Hostanteil ist. \n\nEine typische Subnetzmaske kann so aussehen:\n\n<pre>255.255.255.0</pre>\n\nDer 255-Teil ist tatsächlich unsere Maske. Um dies etwas einfacher zu verstehen, erinnern Sie sich daran, wie wir jedes Oktett als 8 Bits bezeichnen? In der Informatik wird ein Bit durch eine 0 oder eine 1 in binärer Form dargestellt. Wenn binäre Zahlen verwendet werden, bedeutet 1 ein und 0 aus. Was ergibt also 8 Mal 0 oder 1?\n\nGeben Sie bei Google \"Binär-zu-Dezimal-Rechner\" ein und konvertieren Sie 11111111 in dezimaler Form. Was erhalten Sie? 255! Ein Oktett reicht also von 0 bis 255. Wenn wir also eine Subnetzmaske von 255.255.255.0 und eine IP-Adresse von 192.168.1.0 hätten, wie viele Hosts gibt es in diesem Subnetz? Wir werden die Antwort in unserer Subnetzberechnung herausfinden.\n\nWenn wir über unser Subnetz sprechen, bezeichnen wir es normalerweise durch das Netzwerkpräfix gefolgt von der Subnetzmaske:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>Warum?</b>\n\nWarum zum Teufel erstellen wir Subnetze? Subnetting wird verwendet, um Netzwerke zu segmentieren und den Datenverkehr innerhalb dieses Netzwerks zu steuern. Ein Host in einem Subnetz kann also nicht mit einem anderen Host in einem anderen Subnetz interagieren. \n\nAber Moment mal, was ist, wenn ich mich mit anderen Hosts wie yahoo.com verbinden möchte? Dann müssen Sie Subnetze miteinander verbinden. Um Subnetze zu verbinden, müssen Sie einfach die Hosts finden, die mit mehr als einem Subnetz verbunden sind. Wenn z.B. mein Host unter 192.168.1.129 mit einem lokalen Netzwerk von 192.168.1.129/24 verbunden ist, kann er auf alle Hosts in diesem Netzwerk zugreifen. Um auf Hosts im restlichen Internet zuzugreifen, muss er über den Router kommunizieren. Traditionell befindet sich auf den meisten Netzwerken mit einer Subnetzmaske von 255.255.255.0 der Router normalerweise unter der Adresse 1 des Subnetzes, also 192.168.1.1. Dieser Router wird einen Port haben, der ihn mit einem anderen Subnetz verbindet (mehr dazu im Routing-Kurs). Bestimmte IP-Adressen (private Netzwerke) sind für das Internet nicht sichtbar, und wir haben Dinge wie NAT im Einsatz (dazu später mehr).",
          "quizAnswer": "Wahr",
          "quizQuestion": "Wahr oder falsch, ein Subnetz besteht aus einer Subnetzmaske und einem Netzwerkpräfix.",
          "slug": "subnets",
          "title": "Subnetze"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Ok, wir wissen, dass Subnetzmasken wichtig sind, um herauszufinden, wie viele Hosts wir in unserem Subnetz haben können. Also wie viele Hosts wären das?\n\nAngenommen, ich habe eine IP-Adresse von <b>192.168.1.0</b> und eine Subnetzmaske von <b>255.255.255.0</b>, jetzt lassen Sie uns diese Zahlen in binärer Form gegenüberstellen. Verwenden Sie vorerst einen Online-Rechner, um diese Werte von Dezimal in binär umzuwandeln.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nDie IP-Adresse wird von unserer Subnetzmaske maskiert, wenn Sie eine 1 sehen, ist sie maskiert und wir tun so, als ob wir sie nicht sehen würden. Die einzigen möglichen Hosts, die wir haben können, stammen also aus dem Bereich 00000000. Denken Sie daran, dass 11111111 in binärer Form 255 entspricht, wir berücksichtigen auch die 0 als Hostnummer, daher gibt es 256 mögliche Optionen. Es mag jedoch so aussehen, als ob wir 256 mögliche Optionen hätten, aber tatsächlich ziehen wir 2 Hosts ab, weil wir die Broadcast-Adresse und die Subnetzadresse berücksichtigen müssen, was uns 254 mögliche Hosts in unserem Subnetz hinterlässt. Wir wissen also, dass wir Hosts mit IP-Adressen im Bereich von 192.168.1.1 - 192.168.1.254 haben können.",
          "quizAnswer": "11111111",
          "quizQuestion": "Was ist das binäre Äquivalent von 255?",
          "slug": "subnetmath",
          "title": "Subnet Math"
        },
        {
          "exercise": "Schauen Sie sich Ihre IP-Adresse und Subnetzmaske an und sehen Sie, wie viele Hosts Sie in Ihrem Subnetz haben können.",
          "id": 4,
          "lessonContent": "Ich hasse es, diesen Abschnitt hinzufügen zu müssen. In der realen Welt müssten Sie höchstwahrscheinlich niemals Subnetz-Mathematik von Hand durchführen. Wenn Sie jedoch in einem Interview damit konfrontiert werden, müssen Sie wissen, wie man in und aus binärer Form für Subnetting konvertiert. Glücklicherweise gibt es einige arithmetische Tricks, die Sie auswendig lernen können. \n\nMerken Sie sich zuerst Ihre Basis-2-Berechnungen, einfach machen:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Dezimal zu Binär Tabelle</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nEs gibt viele Gründe, warum die folgende Tabelle so aussieht, wie sie aussieht. Wenn Sie neugierig sind, wie sie funktioniert, gibt es viele Ressourcen online.\n\nOkay, haben Sie diese auswendig gelernt? Lassen Sie uns eine schnelle Dezimal zu Binär Umwandlung durchführen:\n\n<b>Wandeln Sie 192.168.23.43 in Binär um</b>\n\nDenken Sie daran: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nLassen Sie uns die Umwandlung des ersten Oktetts in Binär durchgehen und Sie werden verstehen, wie der Rest funktioniert.\n\n<ol>\n<li>Können Sie 192 - 128 subtrahieren? Ja, also ist das erste Bit 1</li>\n<li>192 - 128 = 64, die nächste Zahl in der Tabelle ist 64, können Sie 64 - 64 subtrahieren? Ja, also ist das zweite Bit 1</li>\n<li>Wir haben keine Zahlen mehr zum Subtrahieren, also ist unsere binäre Form von 192 11000000</li>\n</ol>\n\n<b>Wandeln Sie Binär 11000000 in Dezimal um</b>\n\nFür die Umwandlung von Binär in Dezimal addieren Sie die Zahlen, die eine 1 haben, also:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "Was ist die binäre Umwandlung von 123?",
          "slug": "subnettingcheats",
          "title": "Subnetting Cheats"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen vorgesehen.",
          "id": 5,
          "lessonContent": "CIDR (classless inter-domain routing) wird verwendet, um eine Subnetzmaske auf eine kompaktere Weise darzustellen. Sie können Subnetze in CIDR-Notation sehen, bei der ein Subnetz wie das 10.42.3.0/255.255.255.0 als 10.42.3.0/24 geschrieben wird, was einfach bedeutet, dass sowohl das Subnetzpräfix als auch die Subnetzmaske enthalten sind.\n\nDenken Sie daran, dass eine IP-Adresse aus 4 Bytes oder 32 Bits besteht. CIDR gibt an, wie viele Bits als Netzwerkpräfix verwendet werden. Also bedeutet 123.12.24.0/23, dass die ersten 23 Bits verwendet werden. Nun, was bedeutet das? Wie viele Hosts sind das? \n\nEin einfacher Trick besteht darin, die Gesamtanzahl der Bits, die eine IP-Adresse haben kann (32), von der CIDR-Adresse (23) abzuziehen. Das ergibt 9 Bits, 2^9 = 512, aber wir müssen 2 Adressen entfernen (Subnetzadresse und Broadcast-Adresse), also haben wir 510 verwendbare Hosts.",
          "quizAnswer": "",
          "quizQuestion": "Keine Fragen, weitermachen!",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 6,
          "lessonContent": "Wir haben NAT (Network Address Translation) schon einmal erwähnt, aber nicht näher darauf eingegangen. Wenn wir an unserem Netzwerk arbeiten, bedeutet das, dass das Internet unsere IP-Adresse sehen kann? Nicht ganz.\n\nNAT macht ein Gerät wie unseren Router zu einem Vermittler zwischen dem Internet und dem privaten Netzwerk. Es wird also nur eine einzige, eindeutige IP-Adresse benötigt, um eine gesamte Gruppe von Computern zu repräsentieren.\n\nDenken Sie an NAT wie an eine Empfangsdame in einem großen Büro, wenn jemand Sie kontaktieren möchte, kennt er nur die Nummer des gesamten Büros, die Empfangsdame müsste dann nach Ihrer Durchwahl suchen und den Anruf an Sie weiterleiten.\n\n<b>Wie funktioniert es?</b>\n\nEin einfacher Fall würde so aussehen:\n\n<ol>\n<li>Patty möchte sich mit www.google.com verbinden, also sendet ihr Rechner diese Anfrage über den Router</li>\n<li>Der Router nimmt diese Anfrage entgegen und öffnet eine eigene Verbindung zu google.com, dann sendet er Pattys Anfrage, sobald eine Verbindung hergestellt ist</li>\n<li>Der Router ist der Vermittler zwischen Patty und www.google.com. Google weiß nichts über Patty, stattdessen sieht es nur den Router.</li>\n</ol>\n\nNAT und Paket-Routing im Allgemeinen können ziemlich kompliziert werden, aber wir werden nicht auf die Details eingehen.",
          "quizAnswer": "NAT",
          "quizQuestion": "Was wird verwendet, um eine einzelne private Adresse im Internet zu repräsentieren?",
          "slug": "natnetworkaddresstranslation",
          "title": "NAT"
        },
        {
          "exercise": "Überprüfen Sie ifconfig, um zu sehen, ob eine IPv6-Adresse aufgelistet ist.",
          "id": 7,
          "lessonContent": "Wir haben den Begriff IPv6 hier und da gehört, aber was ist das? Jedes Gerät, das mit dem Internet verbunden ist, erhält seine eigene IP-Adresse, die Anzahl ist jedoch begrenzt und wir nähern uns dieser Zahl im digitalen Zeitalter. IPv6 wurde erstellt, um uns zu ermöglichen, mehr Hosts mit dem Internet zu verbinden. Es bringt mehr IP-Verbesserungen mit sich, jedoch ist die Akzeptanz recht langsam. Es ist nicht dazu gedacht, IPv4 zu ersetzen, sondern sie sollen sich ergänzen. Die beiden IP-Protokolle sind sehr ähnlich und wenn Sie IPv4 kennen, werden Sie auch IPv6 verstehen. Der Hauptunterschied liegt in der Art und Weise, wie die Adresse geschrieben wird. So sieht eine typische IPv6-Adresse aus:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "Welche IP-Adresse wird verwendet, um die Anzahl der Hosts zu erhöhen, die sich mit dem Internet verbinden können?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Subnetting"
    },
    {
      "description": "Erfahren Sie, wie Pakete über Netzwerke geroutet werden!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 1,
          "lessonContent": "Wir haben den Begriff Router bereits verwendet, hoffentlich wissen Sie, was das ist, da Sie wahrscheinlich einen zu Hause haben. Ein Router ermöglicht es Maschinen in einem Netzwerk, miteinander sowie mit anderen Netzwerken zu kommunizieren. Auf einem typischen Router finden Sie LAN-Ports, die es Ihren Maschinen ermöglichen, sich mit demselben lokalen Netzwerk zu verbinden, und Sie werden auch einen Internet-Uplink-Port haben, der Sie mit dem Internet verbindet. Manchmal sehen Sie diesen Port als WAN bezeichnet, weil er Sie im Grunde mit einem breiteren Netzwerk verbindet. Wenn wir irgendwelche Arten von Netzwerkaktivitäten durchführen, müssen sie durch den Router gehen. Der Router entscheidet, wohin unsere Netzwerkpakete gehen und welche hereinkommen. Er routet unsere Pakete zwischen mehreren Netzwerken, um vom Quellhost zum Zielhost zu gelangen. \n\n<b>Wie funktioniert ein Router?</b>\n\nDenken Sie beim Routing an die Postzustellung: Wir haben eine Adresse, an die wir einen Brief senden möchten. Wenn wir ihn zur Post bringen, sehen sie, oh, dieser geht nach Kalifornien, ich werde ihn auf den LKW nach Kalifornien legen (ich habe ehrlich gesagt keine Ahnung, wie das Postsystem funktioniert). Der Brief wird dann nach San Francisco geschickt, in San Francisco gibt es verschiedene Postleitzahlen, und in diesen Postleitzahlen gibt es kleinere Adresscodes, bis schließlich jemand in der Lage ist, Ihren Brief an die gewünschte Adresse zuzustellen. Andererseits, wenn Sie bereits in San Francisco und in derselben Postleitzahl wohnen, wird der Briefträger wahrscheinlich genau wissen, wohin der Brief gehen muss, ohne ihn an jemand anderen weitergeben zu müssen. \n\nWenn wir Pakete routen, verwenden sie ähnliche Adress-\"Routen\", z. B. um zu Netzwerk A zu gelangen, senden Sie diese Pakete an Netzwerk B. Wenn wir keine Route dafür festgelegt haben, haben wir eine Standardroute, die unsere Pakete nutzen. Diese Routen sind in einer Routingtabelle festgelegt, die unser System verwendet, um uns über Netzwerke zu navigieren.\n\n<b>Hops</b>\n\nWenn Pakete über Netzwerke bewegt werden, bewegen sie sich in Hops, ein Hop ist, wie wir grob die Entfernung messen, die das Paket zurücklegen muss, um vom Ursprung zum Ziel zu gelangen. Angenommen, ich habe zwei Router, die Host A mit Host B verbinden, dann sagen wir, dass es zwei Hops zwischen Host A und Host B gibt. Jeder Hop ist ein Zwischengerät wie die Router, die wir passieren müssen.\n\n<b>Grundlegender Unterschied zwischen Switching, Routing & Flooding verstehen</b>\nPacket SWITCHING bedeutet im Grunde, Daten zu empfangen, zu verarbeiten und an das Zielgerät weiterzuleiten.\nROUTING ist ein Prozess zur Erstellung der Routingtabelle, damit wir das SWITCHING besser durchführen können.\nVor dem Routing wurde FLOODING verwendet. Wenn ein Router nicht weiß, wohin er ein Paket senden soll, wird jedes eingehende Paket durch jede ausgehende Verbindung gesendet, außer der, über die es angekommen ist.",
          "quizAnswer": "Hops",
          "quizQuestion": "Wie messen Pakete die Entfernung?",
          "slug": "wasisteinrouter",
          "title": "Was ist ein Router?"
        },
        {
          "exercise": "Schauen Sie sich Ihre Routing-Tabelle an und sehen Sie, wohin Ihre Pakete gehen können.",
          "id": 2,
          "lessonContent": "Schauen Sie sich die Routing-Tabelle Ihres Rechners an:\n\n<pre>\npete@icebox:~$ sudo route -n\nKernel IP Routing-Tabelle\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Ziel</b>\n\nIm ersten Feld haben wir eine Ziel-IP-Adresse von 192.168.224.0, das besagt, dass jedes Paket, das versucht, zu diesem Netzwerk zu gelangen, über mein Ethernet-Kabel (eth0) ausgeht. Wenn ich 192.168.224.5 wäre und zu 192.168.224.7 gelangen wollte, würde ich einfach die Netzwerkschnittstelle eth0 direkt verwenden.\n\nBeachten Sie, dass wir Adressen von <b>0.0.0.0</b> haben, das bedeutet, dass keine Adresse angegeben ist oder unbekannt ist. Wenn ich zum Beispiel ein Paket an die IP-Adresse 151.123.43.6 senden wollte, weiß unsere Routing-Tabelle nicht, wohin das geht, daher kennzeichnet sie es als 0.0.0.0 und leitet unser Paket daher zum Gateway.\n\n<b>Gateway</b>\n\nWenn wir ein Paket senden, das nicht im selben Netzwerk ist, wird es an diese Gateway-Adresse gesendet. Dies wird passenderweise als Gateway zu einem anderen Netzwerk bezeichnet.\n\n<b>Genmask</b>\n\nDies ist die Subnetzmaske, die verwendet wird, um festzustellen, welche IP-Adressen zu welchem Ziel passen.\n\n<b>Flags</b>\n\n<ul>\n<li>UG - Netzwerk ist aktiv und ist ein Gateway</li>\n<li>U - Netzwerk ist aktiv</li>\n</ul>\n\n<b>Iface</b>\n\nDies ist die Schnittstelle, über die unser Paket ausgeht. Eth0 steht normalerweise für das erste Ethernet-Gerät auf Ihrem System.",
          "quizAnswer": "Gateway",
          "quizQuestion": "Wohin werden Pakete geroutet, wenn unsere Routing-Tabelle es nicht weiß?",
          "slug": "routingtable",
          "title": "Routing-Tabelle"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "<b>Lassen Sie uns betrachten, wie ein Paket innerhalb seines lokalen Netzwerks reist</b>\n\n<ol>\n<li>Zuerst vergleicht die lokale Maschine die Ziel-IP-Adresse, um zu sehen, ob sie sich im selben Subnetz befindet, indem sie ihre Subnetzmaske betrachtet.</li>\n<li>Wenn Pakete gesendet werden, müssen sie eine Quell-MAC-Adresse, eine Ziel-MAC-Adresse, eine Quell-IP-Adresse und eine Ziel-IP-Adresse haben, zu diesem Zeitpunkt kennen wir jedoch nicht die Ziel-MAC-Adresse.</li>\n<li>Um zum Zielrechner zu gelangen, verwenden wir ARP, um eine Anfrage im lokalen Netzwerk zu senden und die MAC-Adresse des Zielrechners zu finden.</li>\n<li>Jetzt kann das Paket erfolgreich gesendet werden!</li>\n</ol>\n\n<b>Lassen Sie uns betrachten, wie ein Paket außerhalb seines Netzwerks reist</b>\n\n<ol>\n<li>Zuerst vergleicht die lokale Maschine die Ziel-IP-Adresse, da sie außerhalb unseres Netzwerks liegt, sieht sie nicht die MAC-Adresse des Zielrechners. Und wir können ARP nicht verwenden, da die ARP-Anfrage an lokal verbundene Hosts gesendet wird.</li>\n<li>Also schaut unser Paket nun in die Routingtabelle, es kennt die Adresse der Ziel-IP nicht, also sendet es sie an das Standardgateway (einen anderen Router). Jetzt enthält unser Paket unsere Quell-IP, Ziel-IP und Quell-MAC, jedoch haben wir keine Ziel-MAC. Denken Sie daran, MAC-Adressen sind nur im selben Netzwerk erreichbar. Was tut es also? Es sendet eine ARP-Anfrage, um die MAC-Adresse des Standardgateways zu erhalten.</li>\n<li>Der Router betrachtet das Paket und bestätigt die Ziel-MAC-Adresse, aber es ist nicht die endgültige Ziel-IP-Adresse, also schaut er weiter in die Routingtabelle, um das Paket an eine andere IP-Adresse weiterzuleiten, die dem Paket hilft, zu seinem Ziel zu gelangen. Jedes Mal, wenn das Paket weitergeleitet wird, entfernt es die alten Quell- und Ziel-MAC-Adressen und aktualisiert das Paket mit den neuen Quell- und Ziel-MAC-Adressen.</li>\n<li>Sobald das Paket im selben Netzwerk weitergeleitet wird, verwenden wir ARP, um die endgültige Ziel-MAC-Adresse zu finden</li>\n<li>Während dieses Prozesses ändert unser Paket weder die Quell- noch die Ziel-IP-Adresse.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Wie finden wir die MAC-Adresse einer IP-Adresse?",
          "slug": "pfadeinespakets",
          "title": "Pfad eines Pakets"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 4,
          "lessonContent": "Es wäre mühsam, für jedes Gerät in Ihrem Netzwerk manuell Routen in einer Routing-Tabelle konfigurieren zu müssen. Deshalb verwenden wir sogenannte Routing-Protokolle. Routing-Protokolle werden verwendet, um unserem System bei Netzwerkänderungen zu helfen. Sie lernen verschiedene Routen kennen, bauen sie in der Routing-Tabelle auf und leiten dann unsere Pakete auf diese Weise weiter. Es gibt zwei Hauptarten von Routing-Protokollen: Distanzvektorprotokolle und Linkzustandsprotokolle.\n\n<b>Konvergenz</b>\n\nBevor wir über die Protokolle sprechen, sollten wir einen Begriff im Routing besprechen, der als Konvergenz bezeichnet wird. Bei der Verwendung von Routing-Protokollen kommunizieren Router mit anderen Routern, um Informationen über das Netzwerk zu sammeln und auszutauschen. Wenn sie sich darauf einigen, wie ein Netzwerk aussehen sollte, bildet jede Routing-Tabelle die vollständige Topologie des Netzwerks ab und 'konvergiert' somit. Wenn in der Netzwerktopologie etwas passiert, wird die Konvergenz vorübergehend unterbrochen, bis alle Router über diese Änderung informiert sind.",
          "quizAnswer": "Konvergenz",
          "quizQuestion": "Wie lautet der Begriff, wenn alle Routing-Tabellen die Netzwerktopologie kennen?",
          "slug": "routingprotocols",
          "title": "Routing-Protokolle"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 5,
          "lessonContent": "Distanzvektorprotokolle bestimmen den Pfad anderer Netzwerke anhand der Hop-Anzahl, die ein Paket über das Netzwerk nimmt. Wenn Netzwerk A 3 Hops entfernt war und Netzwerk B neben Netzwerk A lag, nehmen wir an, dass es 4 Hops entfernt sein muss. Bei Distanzvektorprotokollen wäre die nächste Route diejenige mit der geringsten Anzahl von Hops.\n\nDistanzvektorprotokolle eignen sich gut für kleine Netzwerke. Wenn Netzwerke jedoch skalieren, dauert es länger, bis die Router konvergieren, da sie regelmäßig die gesamte Routing-Tabelle an jeden Router senden. Ein weiterer Nachteil von Distanzvektorprotokollen ist die Effizienz, da sie Routen wählen, die in Hops näher sind, aber nicht immer die effizienteste Route wählen.\n\nEines der gängigen Distanzvektorprotokolle ist RIP (Routing Information Protocol). Es sendet alle 30 Sekunden die Routing-Tabelle an jeden Router im Netzwerk. Für ein großes Netzwerk kann dies einige ernsthafte Ressourcen erfordern, weshalb RIP die Hop-Anzahl auf 15 begrenzt.",
          "quizAnswer": "falsch",
          "quizQuestion": "Wahr oder falsch, Distanzprotokolle verwenden die Route mit der geringsten Bandbreite?",
          "slug": "distanzvektorprotokolle",
          "title": "Distanzvektorprotokolle"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 6,
          "lessonContent": "Link State Protokolle sind ideal für große Netzwerke. Sie sind komplexer als Distanzvektorprotokolle, aber ein großer Vorteil ist ihre Fähigkeit, schnell zu konvergieren. Dies liegt daran, dass sie anstatt regelmäßig die gesamte Routing-Tabelle zu senden, nur Aktualisierungen an benachbarte Routen senden. Sie verwenden einen anderen Algorithmus, um zuerst den kürzesten Pfad zu berechnen und ihr Netzwerktopologie in Form eines Graphen zu konstruieren, um zu zeigen, welche Router mit anderen Routern verbunden sind.\n\nEines der gängigen Link State Protokolle ist OSPF (Open Shortest Path First). Es aktualisiert die Routing-Tabellen nur bei einer Netzwerkänderung. Es hat keine Hop-Limitierung.",
          "quizAnswer": "OSPF",
          "quizQuestion": "Was ist eines der häufigsten Link State Protokolle?",
          "slug": "linkstateprotocols",
          "title": "Link State Protokolle"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 7,
          "lessonContent": "Das letzte wichtige Protokoll, über das wir sprechen werden, ist BGP. BGP ist im Grunde genommen, wie das Internet funktioniert. Es wird verwendet, um Routing-Informationen zwischen autonomen Systemen zu sammeln und auszutauschen. Denken Sie an ein autonomes System als einen Internetdienstanbieter, ein Unternehmen, eine Universität, eine Organisation usw. Ohne BGP würden diese Systeme nicht wissen, wie sie miteinander kommunizieren sollen, sie wären einfach isoliert. Anstatt Routing innerhalb dieser autonomen Systeme durchzuführen, routet BGP zwischen ihnen.\n\nAngenommen, Sie sind in Ihrem Heimnetzwerk und ich arbeite von Starbucks aus. Ich möchte in der Lage sein, mit Ihnen zu kommunizieren, also sende ich eine E-Mail und das Netzwerkpaket durchläuft das Netzwerk von Starbucks, springt dort herum und durchläuft die Routing-Tabellen im Netzwerk von Starbucks, bis es schließlich einen Punkt am Rand des Starbucks-Netzwerks erreicht und an einen Border Gateway-Router weitergibt. Dieser Router enthält die Informationen für mein Paket, um das Starbucks-Netzwerk zu verlassen und andere Netzwerke zu durchqueren.",
          "quizAnswer": "BGP",
          "quizQuestion": "Welches Protokoll macht im Wesentlichen das Internet aus?",
          "slug": "bgpbordergatewayprotocol",
          "title": "Border Gateway Protocol"
        }
      ],
      "slug": "routing",
      "title": "Routing"
    },
    {
      "description": "Erfahren Sie mehr über die Netzwerkkonfiguration mit Linux-Tools!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Versuchen Sie, den Zustand Ihrer Netzwerkschnittstellen auf aktiv oder inaktiv zu ändern und beobachten Sie, was passiert.\n\nKönnen Sie Ihre Netzwerkschnittstellen sowohl mit den Befehlen ifconfig als auch ip ändern?",
          "id": 1,
          "lessonContent": "Eine Netzwerkschnittstelle ist die Verbindung des Kernel zwischen der Softwareseite des Netzwerks und der Hardwareseite. Wir haben bereits ein Beispiel dafür gesehen: \n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> Der ifconfig Befehl</b>\n\nDas <b>ifconfig</b> Tool ermöglicht es uns, unsere Netzwerkschnittstellen zu konfigurieren. Wenn keine Netzwerkschnittstellen eingerichtet sind, wissen die Gerätetreiber des Kernels und das Netzwerk nicht, wie sie miteinander kommunizieren sollen. Ifconfig wird beim Booten ausgeführt und konfiguriert unsere Schnittstellen über Konfigurationsdateien, aber wir können sie auch manuell ändern. Die Ausgabe von ifconfig zeigt den Schnittstellennamen auf der linken Seite und auf der rechten Seite detaillierte Informationen. Sie werden Schnittstellen mit den Namen eth0 (erste Ethernet-Karte im Gerät), wlan0 (drahtlose Schnittstelle), lo (Loopback-Schnittstelle) am häufigsten sehen. Die Loopback-Schnittstelle wird verwendet, um Ihren Computer darzustellen, sie leitet Sie einfach zurück zu sich selbst. Dies ist gut für Debugging oder die Verbindung zu lokal ausgeführten Servern. \n\nDer Status der Schnittstellen kann aktiv (up) oder inaktiv (down) sein. Wie Sie sich vorstellen können, wenn Sie eine Schnittstelle \"ausschalten\" möchten, können Sie sie auf inaktiv setzen. Die Felder, die Sie in der Ausgabe von ifconfig wahrscheinlich am häufigsten betrachten werden, sind HWaddr (MAC-Adresse der Schnittstelle), inet-Adresse (IPv4-Adresse) und inet6 (IPv6-Adresse). Natürlich können Sie auch die Subnetzmaske und die Broadcast-Adresse sehen. Sie können auch Schnittstelleninformationen unter /etc/network/interfaces einsehen.\n\n<b>Um eine Schnittstelle zu erstellen und zu aktivieren</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nDies weist der Schnittstelle eth0 eine IP-Adresse und Netzmaske zu und aktiviert sie.\n\n<b>Um eine Schnittstelle zu aktivieren oder zu deaktivieren</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> Der ip Befehl </b>\n\nDer <b>ip</b> Befehl ermöglicht es uns auch, den Netzwerkstack eines Systems zu manipulieren. Je nach der verwendeten Distribution kann dies die bevorzugte Methode zur Manipulation Ihrer Netzwerkeinstellungen sein. \n\nHier sind einige Beispiele für seine Verwendung:\n\n<b>Um Informationen zu allen Schnittstellen anzuzeigen</b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Um die Statistiken einer Schnittstelle anzuzeigen</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>Um den den Schnittstellen zugewiesenen IP-Adressen anzuzeigen</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>Um Schnittstellen zu aktivieren oder zu deaktivieren</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Um einer Schnittstelle eine IP-Adresse hinzuzufügen</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "Was ist der Befehl zum Konfigurieren unserer Netzwerkschnittstellen?",
          "slug": "netzwerkschnittstellen",
          "title": "Netzwerkschnittstellen"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen, aber Sie können weitere Informationen zu den hier besprochenen Befehlen in den Handbuchseiten nachlesen\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Wir haben bereits besprochen, wie Sie unsere Routing-Tabellen mit dem route-Befehl anzeigen können. Wenn Sie Routen hinzufügen oder entfernen möchten, können Sie dies manuell tun.\n\n<b>Fügen Sie eine neue Route hinzu</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Löschen Sie eine Route</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nSie können diese Änderungen auch mit dem <b>ip</b>-Befehl durchführen:\n\n<b>Um eine Route hinzuzufügen</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Um eine Route zu löschen</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\noder\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "Was ist das Befehlsflag zum Löschen einer Route?",
          "slug": "route",
          "title": "route"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Wir haben bereits über DHCP gesprochen und in den meisten Fällen müssen Sie Ihre IP-Adressen, Subnetzmasken usw. niemals statisch festlegen. Stattdessen verwenden Sie DHCP! Der dhclient wird beim Booten gestartet und erhält eine Liste von Netzwerkschnittstellen aus der Datei dhclient.conf. Für jede aufgeführte Schnittstelle versucht er, die Schnittstelle mithilfe des DHCP-Protokolls zu konfigurieren.\n\nIn der Datei dhclient.leases behält dhclient eine Liste von Leases über Systemneustarts hinweg bei. Nach dem Lesen von dhclient.conf wird die Datei dhclient.leases gelesen, um ihm mitzuteilen, welche Leases bereits zugewiesen wurden. \n\n<b>Um eine neue IP-Adresse zu erhalten</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "Was versucht, IP-Adressen mit dem DHCP-Protokoll zuzuweisen?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 4,
          "lessonContent": "Natürlich, wenn Sie möchten, dass das Netzwerk Ihres Systems automatisch eingerichtet wird, gibt es bereits etwas dafür. Die meisten Distributionen verwenden den NetworkManager-Daemon, um ihre Netzwerke automatisch zu konfigurieren. \n\nSie werden den NetworkManager in Form eines Applets irgendwo in der Taskleiste Ihres Desktops bemerken, wenn Sie eine grafische Benutzeroberfläche verwenden. Wie Sie sehen können, verwaltet er die Hardware und Verbindungsinformationen Ihres Netzwerks. Beispielsweise sammelt der NetworkManager beim Start Informationen zur Netzwerkhardware, sucht nach Verbindungen zu drahtlosen, kabelgebundenen usw. und aktiviert sie dann.\n\nEs gibt auch Befehlszeilentools, um mit dem NetworkManager zu interagieren:\n\n<b>nm-tool</b>\n\nnm-tool zeigt den Zustand des NetworkManagers und seiner Geräte an\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nZustand: verbunden (global)\n\n- Gerät: eth0  [Kabelverbindung 1] -------------------------------------------\n  Typ:              Kabelgebunden\n  Treiber:            pcnet32\n  Zustand:             verbunden\n  Standard:           ja\n  HW-Adresse:        12:3D:45:56:7D:CC\n\n  Fähigkeiten:\n    Trägererkennung:  ja\n\n  Eigenschaften des Kabels\n    Träger:         an\n\n  IPv4-Einstellungen:\n    Adresse:         192.168.22.1\n    Präfix:          24 (255.255.255.0)\n    Gateway:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nDer Befehl nmcli ermöglicht es Ihnen, NetworkManager zu steuern und zu ändern. Weitere Details finden Sie in der Manpage.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "Was ist der Befehl, um Informationen zum NetworkManager anzuzeigen?",
          "slug": "networkmanager",
          "title": "Network Manager"
        },
        {
          "exercise": "Beobachten Sie, was mit Ihrem ARP-Cache passiert, wenn Sie Ihren Computer neu starten und dann etwas im Netzwerk tun.",
          "id": 5,
          "lessonContent": "Wenn wir eine MAC-Adresse mit ARP nachschlagen, überprüft es zuerst den lokal gespeicherten ARP-Cache auf unserem System. Sie können diesen Cache tatsächlich anzeigen:\n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nDer ARP-Cache ist tatsächlich leer, wenn eine Maschine hochfährt. Er wird gefüllt, während Pakete an andere Hosts gesendet werden. Wenn wir ein Paket an ein Ziel senden, das nicht im ARP-Cache enthalten ist, passiert Folgendes:\n\n<ol>\n<li>Der Quellhost erstellt den Ethernet-Rahmen mit einem ARP-Anforderungspaket</li>\n<li>Der Quellhost sendet diesen Rahmen an das gesamte Netzwerk</li>\n<li>Wenn einer der Hosts im Netzwerk die richtige MAC-Adresse kennt, sendet er ein Antwortpaket und einen Rahmen mit der MAC-Adresse</li>\n<li>Der Quellhost fügt die IP-zur-MAC-Adresszuordnung dem ARP-Cache hinzu und sendet dann das Paket</li>\n</ol>\n\nSie können Ihren ARP-Cache auch über den ip-Befehl anzeigen:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "Welchen Befehl können Sie verwenden, um Ihren ARP-Cache anzuzeigen?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Netzwerkkonfiguration"
    },
    {
      "description": "Erfahren Sie mehr über gängige Netzwerktools, die Ihnen bei der Diagnose und Behebung von Problemen helfen!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 1,
          "lessonContent": "Das Internet Control Message Protocol (ICMP) ist Teil der TCP/IP-Protokollfamilie. Es wird verwendet, um Aktualisierungen und Fehlermeldungen zu senden und ist ein äußerst nützliches Protokoll zur Fehlerbehebung von Netzwerkproblemen wie einem fehlgeschlagenen Paketzustellung.\n\nJede ICMP-Nachricht enthält ein Typ-, Code- und Prüfsummenfeld. Das Typ-Feld ist der Typ der ICMP-Nachricht, der Code ist ein Untertyp und beschreibt weitere Informationen über die Nachricht und die Prüfsumme wird verwendet, um Probleme mit der Integrität der Nachricht zu erkennen.\n\nLassen Sie uns einige gängige ICMP-Typen betrachten:\n\n<ul>\n<li>Typ 0 - Echo-Antwort</li>\n<li>Typ 3 - Ziel nicht erreichbar</li>\n<li>Typ 8 - Echo-Anforderung</li>\n<li>Typ 11 - Zeitüberschreitung</li>\n</ul>\n\nWenn ein Paket sein Ziel nicht erreichen kann, wird eine ICMP-Nachricht vom Typ 3 generiert. Innerhalb von Typ 3 gibt es 16 Code-Werte, die weiter beschreiben, warum das Ziel nicht erreicht werden kann:\n\n<ul>\n<li>Code 0 - Netzwerk nicht erreichbar</li>\n<li>Code 1 - Host nicht erreichbar</li>\netc..etc..\n</ul>\n\nDiese Nachrichten werden sinnvoller, wenn wir einige Netzwerkdiagnosetools verwenden.",
          "quizAnswer": "8",
          "quizQuestion": "Was ist der ICMP-Typ für Echo-Anforderung?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Führen Sie ein Ping auf einer Website durch und betrachten Sie die Ausgabe, die Sie erhalten.",
          "id": 2,
          "lessonContent": "Eines der einfachsten Netzwerktools <b>ping</b>, das verwendet wird, um zu testen, ob ein Paket einen Host erreichen kann. Es funktioniert, indem ICMP-Echo-Anforderungen (Typ 8) an den Zielhost gesendet und auf eine ICMP-Echo-Antwort (Typ 0) gewartet wird. Ping ist erfolgreich, wenn ein Host das Anforderungspaket sendet und eine Antwort vom Ziel erhält. Schauen wir uns ein Beispiel an: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) Bytes Daten.\n64 Bytes von nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 Bytes von nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 Bytes von nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nIn diesem Beispiel verwenden wir ping, um zu überprüfen, ob wir zu www.google.com gelangen können. Die -c-Flagge (count) wird verwendet, um das Senden von Echo-Anforderungspaketen zu stoppen, nachdem die Anzahl erreicht wurde. \n\nDer erste Teil besagt, dass wir 64-Byte-Pakete an 74.125.239.112 (google.com) senden, und der Rest zeigt uns die Details der Reise. Standardmäßig wird ein Paket pro Sekunde gesendet.\n\n<b>icmp_seq</b>\n\nDas Feld icmp_seq wird verwendet, um die Sequenznummer der gesendeten Pakete anzuzeigen. In diesem Fall habe ich 3 Pakete gesendet und wir können sehen, dass 3 Pakete zurückgekommen sind. Wenn Sie ein Ping durchführen und einige Sequenznummern fehlen, bedeutet dies, dass ein Konnektivitätsproblem vorliegt und nicht alle Ihre Pakete durchkommen. Wenn die Sequenznummer durcheinander ist, ist Ihre Verbindung wahrscheinlich sehr langsam, da Ihre Pakete die Standardzeit von einer Sekunde überschreiten. \n\n<b>ttl</b>\n\nDas Feld Time To Live (ttl) wird als Hop-Zähler verwendet. Bei jedem Hop wird der Zähler um eins verringert, und sobald der Hop-Zähler 0 erreicht, stirbt unser Paket. Dies soll dem Paket eine Lebensdauer geben, wir wollen nicht, dass unsere Pakete ewig herumreisen.\n\n<b>time</b>\n\nDie Roundtrip-Zeit, die von Ihnen benötigt wird, um das Echo-Anforderungspaket zu senden und eine Echo-Antwort zu erhalten.",
          "quizAnswer": "ms",
          "quizQuestion": "Was ist die Maßeinheit für die Roundtrip-Zeit?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Führen Sie den traceroute-Befehl auf Ihrem Rechner aus und beobachten Sie die Ausgabe.",
          "id": 3,
          "lessonContent": "Der traceroute-Befehl wird verwendet, um zu sehen, wie Pakete geroutet werden. Er funktioniert, indem er Pakete mit zunehmenden TTL-Werten sendet, beginnend mit 1. Der erste Router erhält das Paket und verringert den TTL-Wert um eins, wodurch das Paket verworfen wird. Der Router sendet uns eine ICMP Time Exceeded-Nachricht zurück. Dann erhält das nächste Paket einen TTL von 2, sodass es den ersten Router passiert, aber wenn es zum zweiten Router gelangt, ist der TTL 0 und es wird eine weitere ICMP Time Exceeded-Nachricht zurückgegeben. Traceroute funktioniert auf diese Weise, weil es beim Senden und Verwerfen von Paketen eine Liste der Router erstellt, die die Pakete durchlaufen, bis es schließlich sein Ziel erreicht und eine ICMP Echo Reply-Nachricht erhält. \n\nHier ist ein kleiner Ausschnitt eines traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute zu google.com (216.58.216.174), maximal 30 Sprünge, 60 Byte Pakete                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nJede Zeile ist ein Router oder eine Maschine, die zwischen mir und meinem Ziel liegt. Es zeigt den Namen des Ziels und seine IP-Adresse, und die letzten drei Spalten entsprechen der Round-Trip-Zeit eines Pakets zu diesem Router. Standardmäßig senden wir drei Pakete entlang der Route.",
          "quizAnswer": "ttl",
          "quizQuestion": "Was wird um eins verringert, wenn Pakete über das Netzwerk gehoppt werden?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Schauen Sie sich die Manpage für netstat an und lernen Sie alle Funktionen kennen, die es zu bieten hat.",
          "id": 4,
          "lessonContent": "<b>Bekannte Ports</b>\n\nWir haben die Datenübertragung durch Ports auf unserem Rechner besprochen, schauen wir uns einige bekannte Ports an.\n\nSie können eine Liste der bekannten Ports erhalten, indem Sie die Datei <b>/etc/services</b> betrachten: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..etc..\n</pre>\n\nDie erste Spalte ist der Name des Dienstes, dann die Portnummer und das Transportprotokoll, das verwendet wird.\n\n<b>netstat</b>\n\nEin äußerst nützliches Tool, um detaillierte Informationen über Ihr Netzwerk zu erhalten, ist <b>netstat</b>. Netstat zeigt verschiedene netzwerkbezogene Informationen wie Netzwerkverbindungen, Routing-Tabellen, Informationen über Netzwerkschnittstellen und mehr an. Es ist das Schweizer Taschenmesser der Netzwerktools. Wir werden uns hauptsächlich auf eine Funktion konzentrieren, die netstat hat, und das ist der Status der Netzwerkverbindungen. Bevor wir uns ein Beispiel ansehen, sprechen wir zuerst über Sockets und Ports. Ein Socket ist eine Schnittstelle, die es Programmen ermöglicht, Daten zu senden und zu empfangen, während ein Port verwendet wird, um zu identifizieren, welche Anwendung Daten senden oder empfangen soll. Die Socket-Adresse ist die Kombination aus IP-Adresse und Port. Jede Verbindung zwischen einem Host und einem Ziel erfordert einen eindeutigen Socket. Zum Beispiel ist HTTP ein Dienst, der auf Port 80 läuft. Wir können jedoch viele HTTP-Verbindungen haben, und um jede Verbindung aufrechtzuerhalten, wird pro Verbindung ein Socket erstellt.\n\n<pre>\npete@icebox:~$ netstat -at\nAktive Internetverbindungen (Server und etabliert)\nProto Recv-Q Send-Q Lokale Adresse           Fremde Adresse         Status      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nDer Befehl netstat -a zeigt die hörenden und nicht hörenden Sockets für Netzwerkverbindungen an, das -t-Flag zeigt nur TCP-Verbindungen an. \n\nDie Spalten sind von links nach rechts wie folgt:\n\n<ul>\n<li>Proto: Verwendetes Protokoll, TCP oder UDP.</li>\n<li>Recv-Q: Daten, die darauf warten, empfangen zu werden</li>\n<li>Send-Q: Daten, die darauf warten, gesendet zu werden</li>\n<li>Lokale Adresse: Lokal verbundener Host</li>\n<li>Fremde Adresse: Remote-verbundener Host</li>\n<li>Status: Der Status des Sockets</li>\n</ul>\n\nSehen Sie sich die Manpage für eine Liste der Socket-Status an, aber hier sind einige:\n\n<ul>\n<li>LISTENING: Der Socket wartet auf eingehende Verbindungen. Denken Sie daran, wenn wir eine TCP-Verbindung herstellen, muss unser Ziel auf uns warten, bevor wir uns verbinden können.</li>\n<li>SYN_SENT: Der Socket versucht aktiv, eine Verbindung herzustellen.</li>\n<li>ETABLIERT: Der Socket hat eine hergestellte Verbindung</li>\n<li>CLOSE_WAIT: Der Remote-Host wurde heruntergefahren, und wir warten darauf, dass der Socket geschlossen wird</li>\n<li>TIME_WAIT: Der Socket wartet nach dem Schließen darauf, noch im Netzwerk befindliche Pakete zu verarbeiten</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "Welcher Port wird für HTTPS verwendet?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Laden Sie das Wireshark-Tool herunter und installieren Sie es, und probieren Sie die Benutzeroberfläche aus.",
          "id": 5,
          "lessonContent": "Das Thema der Paketanalyse könnte einen eigenen Kurs füllen, und es gibt viele Bücher, die sich ausschließlich mit der Paketanalyse befassen. Heute werden wir jedoch nur die Grundlagen lernen. Es gibt zwei äußerst beliebte Paketanalysatoren, Wireshark und tcpdump. Diese Tools scannen Ihre Netzwerkschnittstellen, erfassen die Paketaktivität, analysieren die Pakete und geben die Informationen für uns aus. Sie ermöglichen es uns, tief in die Netzwerkanalyse einzutauchen und uns mit den Details auf niedriger Ebene zu beschäftigen. Wir werden tcpdump verwenden, da es eine einfachere Benutzeroberfläche hat. Wenn Sie jedoch die Paketanalyse in Ihr Repertoire aufnehmen möchten, empfehle ich Ihnen, sich Wireshark anzusehen.\n\n<b>Installieren von tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Erfassen von Paketdaten auf einer Schnittstelle</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 3, length 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 3, length 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 4, length 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 4, length 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 5, length 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 5, length 64\n11:28:30.674953 ARP, Request who-has 172.254.1.0 tell ThePickleParty.lan, length 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, length 306\n</pre>\n\nBeim Ausführen einer Paketaufzeichnung werden Sie feststellen, dass viele Dinge passieren. Das ist zu erwarten, da im Hintergrund viel Netzwerkaktivität stattfindet. In meinem obigen Beispiel habe ich nur einen Ausschnitt meiner Aufzeichnung genommen, speziell die Zeit, als ich beschloss, www.google.com anzupingen.\n\n<b>Verständnis der Ausgabe</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n</pre>\n\n<ul>\n<li>Das erste Feld ist ein Zeitstempel der Netzwerkaktivität</li>\n<li>IP, enthält die Protokollinformationen</li>\n<li>Anschließend sehen Sie die Quell- und Zieladresse: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, dies ist die Start- und Endsequenznummer des TCP-Pakets</li>\n<li>Länge, Länge in Bytes</li>\n</ul>\n\nWie Sie aus unserer tcpdump-Ausgabe sehen können, senden wir ein ICMP Echo Request-Paket an www.google.com und erhalten als Antwort ein ICMP Echo Reply-Paket! Beachten Sie auch, dass verschiedene Pakete unterschiedliche Informationen ausgeben werden. Sehen Sie im Handbuch nach, um zu erfahren, was diese sind.\n\n<b>Speichern der tcpdump-Ausgabe in einer Datei</b>\n\n<pre>\n$ sudo tcpdump -w /some/file\n</pre>\n\n\nEinige abschließende Gedanken: Wir haben nur die Oberfläche des Themas der Paketanalyse angekratzt. Es gibt so viel, was Sie betrachten können, und wir haben noch nicht einmal die Möglichkeit erwähnt, noch tiefer in die Hex- und ASCII-Ausgabe einzutauchen. Es gibt viele Ressourcen online, die Ihnen helfen können, mehr über Paketanalysatoren zu erfahren, und ich fordere Sie auf, diese zu finden!",
          "quizAnswer": "-i",
          "quizQuestion": "Was ist die Flagge, um mit tcpdump eine bestimmte Schnittstelle zu erfassen?",
          "slug": "paketanalyse",
          "title": "Paketanalyse"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Fehlerbehebung"
    },
    {
      "description": "Alles und mehr, was Sie über DNS wissen wollten.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 1,
          "lessonContent": "Stellen Sie sich vor, jedes Mal, wenn Sie eine Suche auf Google durchführen möchten, müssten Sie http://192.78.12.4 anstelle von www.google.com eingeben. Nun, ohne DNS (\"Domain Name System\") genau das würde passieren. Das Low-Level-Netzwerk versteht nur die Roh-IP-Adresse zur Identifizierung eines Hosts. DNS ermöglicht es uns Menschen, Websites und Hosts nach Namen anstelle einer IP-Adresse zu verfolgen. Es ist wie eine Kontaktliste für das Internet. Wenn Sie den Namen einer Person kennen, aber deren Telefonnummer nicht wissen, können Sie einfach in Ihrer Kontaktliste nachschlagen.\n\nDNS ist im Wesentlichen eine verteilte Datenbank von Hostnamen zu IP-Adressen. Wir verwalten unsere Datenbank, damit die Leute wissen, wie sie zu unserer Website/unserem Domain gelangen, und anderswo verwaltet eine andere Person ihre Datenbank, damit andere zu ihrer Domain gelangen können. Diese Domains können dann miteinander kommunizieren und eine riesige Kontaktliste des Internets erstellen.\n\nIn diesem Kurs werden wir einige Grundlagen von DNS durchgehen, aber seien Sie gewarnt, DNS ist ein umfassendes Thema und wenn Sie wirklich tiefer in die Materie eintauchen möchten, müssen Sie zusätzliche Recherchen durchführen.",
          "quizAnswer": "falsch",
          "quizQuestion": "Wahr oder falsch, DNS hilft uns, MAC-Adressen für Hostnamen zu finden?",
          "slug": "wasistdns",
          "title": "Was ist DNS?"
        },
        {
          "exercise": "Für diese Lektion sind keine Übungen vorgesehen.",
          "id": 2,
          "lessonContent": "Die DNS-Datenbank des Internets basiert darauf, dass Websites und Organisationen einen Teil dieser Datenbank bereitstellen. Dafür benötigen sie:\n\n<b>Name Server</b>\n\nWir richten DNS über \"Nameserver\" ein. Die Nameserver laden unsere DNS-Einstellungen und Konfigurationen und beantworten Fragen von Clients oder anderen Servern, die beispielsweise wissen möchten: \"Wer ist google.com?\". Wenn der Nameserver die Antwort auf diese Abfrage nicht kennt, leitet er die Anfrage an andere Nameserver weiter. Nameserver können \"authoritativ\" sein, was bedeutet, dass sie die tatsächlichen DNS-Einträge, nach denen gesucht wird, enthalten, oder \"rekursiv\", was bedeutet, dass sie andere Server fragen und diese Server wiederum andere Server fragen, bis sie einen autoritativen Server gefunden haben, der die DNS-Einträge enthält. Rekursive Server können auch die gewünschten Informationen zwischenspeichern, anstatt einen autoritativen Server zu erreichen.\n\n<b>Zonen-Datei</b>\n\nIn einem Nameserver befindet sich etwas, das Zonendateien genannt wird. Zonendateien enthalten Informationen über die Domain oder wie man zur Domain gelangt, wenn der Nameserver sie nicht kennt.\n\n<b>Resource Records</b>\n\nEine Zonendatei besteht aus Einträgen von Ressourceneinträgen. Jede Zeile ist ein Eintrag und enthält Informationen über Hosts, Nameserver, andere Ressourcen usw. Die Felder bestehen aus folgendem: \n\n<ul>\n<li>Eintragsname</li>\n<li>TTL - Die Zeit, nach der wir den Eintrag verwerfen und einen neuen erhalten, wird in DNS durch Zeit angegeben, sodass Einträge eine TTL von einer Stunde haben können. Der Grund dafür ist, dass sich das Internet ständig ändert. Innerhalb einer Minute kann ein Host einer IP-Adresse X zugeordnet sein und im nächsten Moment einer IP-Adresse Y.</li>\n<li>Klasse - Namensraum der Eintragsinformationen, am häufigsten wird IN für Internet verwendet</li>\n<li>Typ - Art der Informationen, die in den Eintragsdaten gespeichert sind. Wir werden nicht auf Einzelheiten der Eintragstypen eingehen, aber Sie haben wahrscheinlich gängige wie A für Adresse, MX für Mail-Exchanger usw. gesehen.</li>\n<li>Daten - Dieses Feld kann je nach Eintragstyp eine IP-Adresse oder etwas anderes enthalten.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "Welcher Ressourceneintragstyp wird für Mail-Exchanger verwendet?",
          "slug": "dnskomponenten",
          "title": "DNS-Komponenten"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 3,
          "lessonContent": "Schauen wir uns ein Beispiel an, wie Ihr Host eine Domain (catzontheinterwebz.com) mit DNS findet. Im Wesentlichen arbeiten wir uns nach unten, bis wir den DNS-Server erreichen, der von dieser Domain weiß.\n\n<b>Lokaler DNS-Server</b>\n\nZuerst fragt unser Host: \"Wo ist catzontheinterwebz.com?\" Unser lokaler DNS-Server weiß es nicht, also geht er zum Anfang des Trichters, um die Root-Server zu fragen. Beachten Sie, dass unser Host diese Anfragen nicht direkt stellt, um catzontheinterwebz.com zu finden. Die meisten Benutzer sprechen mit einem rekursiven DNS-Server, der von ihren ISPs bereitgestellt wird, und dieser Server ist dann damit beauftragt, den Standort von catzontheinterwebz.com zu finden.\n\n<b>Root-Server</b>\n\nEs gibt 13 Root-Server für das Internet, sie sind gespiegelt und weltweit verteilt, um DNS-Anfragen für das Internet zu bearbeiten. Es gibt also wirklich Hunderte von Servern, die arbeiten, sie werden von verschiedenen Organisationen kontrolliert und enthalten Informationen über Top-Level-Domains. Top-Level-Domains sind Ihnen als .org, .com, .net usw. bekannt. Der Root-Server weiß also nicht, wo catzontheinterwebz.com ist, also sagt er uns, den .com-Top-Level-Domain-DNS-Server an der IP-Adresse zu fragen, die er uns gibt.\n\n<b>Top-Level-Domain</b>\n\nJetzt senden wir eine weitere Anfrage an den Namensserver, der über \".com\"-Adressen Bescheid weiß, und fragen, ob er weiß, wo catzontheinterwebz.com ist? Die TLD hat catzontheinterwebz.com nicht in ihren Zonendateien, sieht aber einen Eintrag für den Namensserver von catzontheinterwebz.com. Also gibt sie uns die IP-Adresse dieses Namensservers und sagt uns, dort nachzusehen.\n\n<b>Autoritativer DNS-Server</b>\n\nJetzt senden wir eine letzte Anfrage an den DNS-Server, der tatsächlich den Datensatz hat, den wir wollen. Der Namensserver sieht, dass er eine Zonendatei für catzontheinterwebz.com hat und es einen Ressourceneintrag für 'www' für diesen Host gibt. Dann gibt er uns die IP-Adresse dieses Hosts und wir können endlich einige Katzen im Internet sehen.",
          "quizAnswer": "TLD",
          "quizQuestion": "Was ist die Abkürzung für die Namensserver, wo .com, .net, .org usw. Adressen gefunden werden?",
          "slug": "dnsprocess",
          "title": "DNS-Prozess"
        },
        {
          "exercise": "Keine Übungen für diese Lektion.",
          "id": 4,
          "lessonContent": "<p>Bevor unsere Maschine tatsächlich auf DNS zugreift, um eine Abfrage durchzuführen, sucht sie zuerst lokal auf unseren Maschinen. </p><br><p><b>/etc/hosts</b></p><p>Die Datei /etc/hosts enthält Zuordnungen einiger Hostnamen zu IP-Adressen. Die Felder sind ziemlich selbsterklärend, es gibt eines für die IP-Adresse, den Hostnamen und dann etwaige Aliasnamen für den Host. </p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>Sie sehen normalerweise Ihre localhost-Adresse standardmäßig in dieser Datei aufgeführt. Sie können auch den Zugriff auf Hosts verwalten, indem Sie die Dateien /etc/hosts.deny oder /etc/hosts.allow ändern. Wenn Sie jedoch sicherheitsbewusst sind, ist dies nicht wirklich der richtige Weg, und Sie sollten stattdessen Ihre Firewall-Regeln ändern. </p><p>Lassen Sie uns ein lustiges Beispiel für /etc/hosts sehen. Ändern Sie die Datei und fügen Sie eine Zeile für hinzu:</p><pre>123.45.6.7  www.google.com</pre><p>Speichern Sie die Datei und gehen Sie jetzt zu www.google.com. Haben Sie Probleme? Nun, das liegt daran, dass wir www.google.com gerade auf eine völlig falsche IP-Adresse abgebildet haben. Da unsere Hosts zuerst lokal nach IP-Adresszuordnungen suchen, erreichen sie DNS nie, um google.com zu finden. </p><p><b>/etc/resolv.conf</b></p><p>Traditionell haben wir eine Datei namens /etc/resolv.conf verwendet, um DNS-Namensserver für effizientere Abfragen zuzuordnen. Mit den Verbesserungen, die an DNS vorgenommen wurden, ist diese Datei jedoch oft irrelevant. Tatsächlich können Sie in meinem Beispiel unten sehen, dass /etc/resolv.conf nicht manuell verwaltet wird. Konsultieren Sie die distributions-spezifischen Einstellungen, um DNS-Namensserverzuordnungen zu verwalten.</p><pre>conf(5)-Datei für von resolvconf(8) generierten glibc-resolver(3)<br>#     DIESE DATEI NICHT MANUELL BEARBEITEN -- IHRE ÄNDERUNGEN WERDEN ÜBERSCHRIEBEN<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "Welche Datei wird verwendet, um Hostnamen auf unseren Maschinen IP-Adressen zuzuordnen?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "Für diese Lektion gibt es keine Übungen.",
          "id": 5,
          "lessonContent": "Wir werden hier keine Anleitung zur Einrichtung eines DNS-Servers durchgehen, da dies ein ziemlich umfangreiches Tutorial wäre. Stattdessen finden Sie hier eine schnelle Vergleichsliste der beliebten DNS-Server, die mit Linux verwendet werden können.\n\n<b>BIND</b>\n\nDer beliebteste DNS-Server im Internet, er ist der Standard, der mit Linux-Distributionen verwendet wird. Er wurde ursprünglich an der University of California in Berkeley entwickelt, daher der Name BIND (Berkeley Internet Name Domain). Wenn Sie volle Leistung und Flexibilität benötigen, machen Sie mit BIND nichts falsch.\n\n<b>DNSmasq</b>\n\nLeichtgewichtig und viel einfacher zu konfigurieren als BIND. Wenn Sie Einfachheit wünschen und nicht alle Funktionen von BIND benötigen, verwenden Sie DNSmasq. Es enthält alle Tools, die Sie für die Einrichtung von DHCP und DNS benötigen, und wird für ein kleineres Netzwerk empfohlen.\n\n<b>PowerDNS</b>\n\nVoll ausgestattet und ähnlich wie BIND, bietet es Ihnen etwas mehr Flexibilität mit Optionen. Es liest Informationen aus mehreren Datenbanken wie MySQL, PostgreSQL usw. für eine einfachere Verwaltung. Nur weil BIND bisher der Standard war, heißt das nicht, dass es so bleiben muss.\n\nDies ist keine vollständige Liste, aber sie sollte Ihnen eine Vorstellung davon geben, wo Sie suchen müssen, wenn Sie Ihren eigenen DNS-Server einrichten.",
          "quizAnswer": "BIND",
          "quizQuestion": "Was ist der de facto DNS-Server für Linux?",
          "slug": "dnssetup",
          "title": "DNS-Einrichtung"
        },
        {
          "exercise": "Lesen Sie die Manpage für dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nDas Tool \"Namensserver-Lookup\" wird verwendet, um Namensserver abzufragen, um Informationen über Ressourceneinträge zu finden. Lassen Sie uns herausfinden, wo sich der Namensserver für google.com befindet:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nNon-authoritative answer:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (Domain Information Groper) ist ein leistungsstarkes Tool, um Informationen über DNS-Namensserver zu erhalten. Es ist flexibler als nslookup und ideal zur Fehlerbehebung von DNS-Problemen.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; QUESTION SECTION:\n;www.google.com.                        IN      A\n\n;; ANSWER SECTION:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Query time: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; WHEN: Sun Feb 07 10:14:00 PST 2016\n;; MSG SIZE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "Welches Tool wird verwendet, um detaillierte Informationen über DNS-Namensserver zu erhalten?",
          "slug": "dnstools",
          "title": "DNS-Tools"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Inhalt",
      "exerciseAndQuiz": "Übung & Quiz"
    },
    "exerciseBox": {
      "exercise": "Übung"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Ein neues Leben für LinuxJourney, das so vielen Menschen geholfen hat, ihre ersten Schritte in die Welt von Linux zu machen.",
      "title": "Entdecken Sie die Kraft von Linux"
    },
    "navbar": {
      "home": "Startseite",
      "language": "Sprache",
      "lessons": "Lektionen",
      "resources": "Ressourcen",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Zurück zu den Kapiteln",
      "checkAnswer": "Antwort überprüfen",
      "correctAnswer": "Richtige Antwort: ",
      "nextLesson": "Nächste Lektion",
      "placeholderAnswer": "Geben Sie hier Ihre Antwort ein",
      "quiz": "Quiz",
      "showCorrectAnswer": "Richtige Antwort anzeigen"
    },
    "resources": {
      "data": [
        {
          "description": "Ein Schritt-für-Schritt-Leitfaden für Anfänger, der die Geschichte des Terminals und grundlegende Befehle erklärt",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Offizielles Ubuntu-Tutorial"
        },
        {
          "description": "Eine klare Übersicht darüber, wie das Terminal funktioniert, wie Befehle ausgeführt und im Dateisystem navigiert werden.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "Eines der am meisten empfohlenen Bücher!",
          "href": "https://www.amazon.de/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "Wie Linux funktioniert"
        },
        {
          "description": "Extrem umfassendes Buch für jeden SysAdmin.",
          "href": "https://www.amazon.de/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "UNIX and Linux System Administration Handbook"
        },
        {
          "description": "Großer umfassender Leitfaden zum Shell-Skripting.",
          "href": "https://www.amazon.de/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Linux Command Bible"
        },
        {
          "description": "Für ernsthafte Linux-Benutzer, ein großartiger Einstieg in die Kernelprogrammierung.",
          "href": "https://www.amazon.de/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "The Linux Programming Interface: A Linux and UNIX System"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Entdecken Sie kuratierte Bücher, Tutorials und Tools, um Ihr Linux-Wissen zu vertiefen.",
        "title": "Ressourcen"
      },
      "title": "Ressourcen"
    }
  }
}