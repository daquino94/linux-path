{
  "chapters": [
    {
      "description": "Cos'è Linux? Inizia scegliendo una distribuzione e procedi con l'installazione.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Lettura aggiuntiva:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "Ehi novellino! Quindi hai deciso di immergerti in questo meraviglioso mondo noto come Linux? Beh, meglio che ti prepari, perché sarà una strada lunga e difficile. Il mio nome è Penguin Pete e sono qui per guidarti in questo viaggio. Cominciamo con un po' di retroscena su Linux. \n\nPer capire come è nato Linux, torniamo indietro al 1969, quando Ken Thompson e Dennis Ritchie dei Bell Laboratories svilupparono il sistema operativo UNIX. Successivamente è stato riscritto in C per renderlo più portabile ed è diventato un sistema operativo ampiamente utilizzato. \n\nUna decina d'anni dopo, Richard Stallman iniziò a lavorare sul progetto GNU (GNU is Not UNIX), il kernel GNU chiamato Hurd, che purtroppo non fu mai completato. Anche la GNU General Public License (GPL), una licenza software libera, fu creata come risultato di ciò.\n\nIl kernel è la parte più importante del sistema operativo. Permette all'hardware di comunicare con il software. Fa anche molte altre cose, ma approfondiremo questo argomento in un corso diverso. Per ora, sappi solo che il kernel controlla praticamente tutto ciò che avviene sul tuo sistema. \n\nDurante questo periodo furono sviluppati altri sforzi come BSD, MINIX, ecc. per essere sistemi simili a UNIX. Tuttavia, una cosa che tutti questi sistemi simili a UNIX avevano in comune era la mancanza di un kernel unificato. \n\nPoi, nel 1991, un giovane di nome Linus Torvalds iniziò a sviluppare quello che oggi conosciamo come il kernel Linux.",
          "quizAnswer": "Linus Torvalds",
          "quizQuestion": "Chi ha sviluppato il kernel Linux?",
          "slug": "storia-linux",
          "title": "Storia"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 2,
          "lessonContent": "Nella lezione precedente, abbiamo appreso del kernel Linux che alimenta milioni di dispositivi al giorno. Prima di procedere, è importante notare che il termine Linux è in realtà un po' fuorviante, poiché si riferisce effettivamente al kernel Linux. Tuttavia, molte distribuzioni utilizzano il kernel Linux e sono comunemente conosciute come sistemi operativi Linux. \n\nUn sistema Linux è diviso in tre parti principali:\n\n<ul>\n<li>Hardware - Questo include tutta l'hardware su cui il sistema è in esecuzione, nonché memoria, CPU, dischi, ecc.</li>\n<li>Kernel Linux - Come discusso in precedenza, il kernel è il nucleo del sistema operativo. Gestisce l'hardware e gli indica come interagire con il sistema.</li>\n<li>User Space - Questo è dove gli utenti come te interagiranno direttamente con il sistema.</li>\n</ul>\n\nIl primo passo che dovremo compiere è installare Linux sul tuo computer. Hai molte opzioni tra cui scegliere e questo corso ti aiuterà a informarti e a iniziare a scegliere una distribuzione Linux. \n\nCi sono molte distribuzioni Linux tra cui scegliere, esamineremo solo le opzioni più popolari.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, passa avanti!",
          "slug": "sceltadistribuzionelinux",
          "title": "Scelta di una distribuzione Linux"
        },
        {
          "exercise": "Se sei interessato ad avere Debian come sistema operativo, vai alla sezione di installazione e prova: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Panoramica</b>\nDebian è un sistema operativo composto interamente da software libero e open-source. È ampiamente conosciuto ed è in fase di sviluppo da oltre 20 anni. Ci sono tre rami che puoi utilizzare, Stabile, Testing e Instabile. \n\nStabile è un buon ramo su cui stare. Testing e Instabile sono rilasci continui. Ciò significa che eventuali modifiche incrementali in quei rami diventeranno alla fine Stabile. Ad esempio, se volessi passare all'aggiornamento successivo da Windows 8 a Windows 10, dovresti fare un'installazione completa di Windows 10. Tuttavia, essendo sul rilascio Testing, riceverai automaticamente gli aggiornamenti fino a quando non diventerà il prossimo sistema operativo senza dover fare un'installazione completa. \n\n<b>Gestione dei pacchetti</b>\nDebian utilizza anche strumenti di gestione dei pacchetti Debian. Ogni distribuzione Linux installa e gestisce i pacchetti in modo diverso e utilizza strumenti di gestione dei pacchetti diversi. Approfondiremo questo argomento in un corso successivo. \n\n<b>Configurabilità</b>\nDebian potrebbe non ricevere gli ultimi aggiornamenti, ma è estremamente stabile. Se desideri un buon sistema operativo \"core\", questo è quello che fa per te.\n\n<b>Utilizzi</b>\nDebian è un ottimo sistema operativo per qualsiasi piattaforma.",
          "quizAnswer": "Rolling",
          "quizQuestion": "Che tipo di rilascio hanno Testing e Instabile?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Se sei interessato ad avere RHEL come sistema operativo, vai alla sezione di installazione e prova: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Panoramica</b>\nRed Hat Enterprise Linux comunemente indicato come RHEL è sviluppato da Red Hat. RHEL ha regole rigorose per limitare la ridistribuzione gratuita, anche se fornisce comunque il codice sorgente gratuitamente.\n\n<b>Gestione dei pacchetti</b>\nRHEL utilizza un gestore di pacchetti diverso da Debian, il gestore di pacchetti RPM, di cui parleremo in seguito.\n\n<b>Configurabilità</b>\nI sistemi operativi basati su RHEL si differenzieranno leggermente dai sistemi operativi basati su Debian, soprattutto nella gestione dei pacchetti. Se decidi di optare per RHEL, è probabilmente meglio se sai che dovrai lavorarci.\n\n<b>Utilizzi</b>\nCome suggerisce il nome, è principalmente utilizzato in ambito enterprise, quindi se hai bisogno di un sistema operativo server solido, questo potrebbe essere una buona scelta.",
          "quizAnswer": "RPM",
          "quizQuestion": "Quale gestore di pacchetti utilizza RHEL?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Se sei interessato ad avere Ubuntu come sistema operativo, vai alla sezione di installazione e prova: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Panoramica</b>\nUna delle distribuzioni Linux più popolari per macchine personali è Ubuntu. Ubuntu rilascia anche il proprio gestore dell'ambiente desktop Unity di default. \n\n<b>Gestione dei pacchetti</b>\nUbuntu è un sistema operativo basato su Debian sviluppato da Canonical. Quindi utilizza un sistema di gestione dei pacchetti Debian di base.\n\n<b>Configurabilità</b>\nUbuntu è una scelta eccellente per un principiante che vuole avvicinarsi a Linux. Ubuntu offre facilità d'uso e un'ottima esperienza dell'interfaccia utente che ha portato alla sua ampia adozione. È ampiamente utilizzato e supportato ed è più simile ad altri sistemi operativi come OSX e Windows in termini di usabilità.\n\n<b>Usi</b>\nOttimo per qualsiasi piattaforma, desktop, laptop e server.",
          "quizAnswer": "Debian",
          "quizQuestion": "Da quale sistema operativo è basato Ubuntu?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Se sei interessato ad avere Fedora come sistema operativo, vai alla sezione di installazione e prova: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Panoramica</b>\nSupportato da Red Hat, il Progetto Fedora è guidato dalla comunità e contiene software open source e gratuito. Red Hat Enterprise Linux si dirama da Fedora, quindi pensa a Fedora come a un sistema operativo RHEL upstream. Alla fine RHEL riceverà aggiornamenti da Fedora dopo un'attenta fase di test e garanzia di qualità. Pensate a Fedora come a un equivalente di Ubuntu che utilizza un backend Red Hat invece di Debian.\n\n<b>Gestione dei pacchetti</b>\nUtilizza il gestore dei pacchetti Red Hat.\n\n<b>Configurabilità</b>\nSe desideri utilizzare un sistema operativo basato su Red Hat, questa è una versione user friendly.\n\n<b>Utilizzi</b>\nFedora è ottimo se desideri un sistema operativo basato su Red Hat senza il prezzo. Consigliato per desktop e laptop.",
          "quizAnswer": "Fedora",
          "quizQuestion": "Da cosa si dirama RHEL?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Se sei interessato ad utilizzare Linux Mint come sistema operativo, vai alla sezione di installazione e prova: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Panoramica</b>\nLinux Mint si basa su Ubuntu. Utilizza i repository software di Ubuntu, quindi gli stessi pacchetti sono disponibili su entrambe le distribuzioni. Linux Mint è preferito da altri rispetto a Ubuntu perché non include alcuni software proprietari presenti in Ubuntu come Unity.\n\n<b>Gestione dei pacchetti</b>\nPoiché Linux Mint si basa su Ubuntu, utilizza il gestore di pacchetti Debian.\n\n<b>Configurabilità</b>\nOttima interfaccia utente, ottima per principianti e meno ingombrante di Ubuntu. In questo corso, utilizzerò Linux Mint, ma è possibile utilizzare qualsiasi altra distribuzione.\n\n<b>Utilizzi</b>\nOttimo per desktop e laptop.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "Da cosa è basato Linux Mint?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Se sei interessato ad avere Gentoo come sistema operativo, vai alla sezione di installazione e prova: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Panoramica</b>\nGentoo offre una flessibilità incredibile con il sistema operativo a un prezzo. È fatto per utenti avanzati che non si dispiacciono di sporcare le mani con il sistema.\n\n<b>Gestione dei pacchetti</b>\nGentoo utilizza il proprio sistema di gestione dei pacchetti, Portage. Il sistema di gestione dei pacchetti Portage è molto modulare e facile da mantenere, il che gioca un ruolo importante nell'intero sistema operativo che è molto flessibile.\n\n<b>Configurabilità</b>\nSe stai iniziando con Linux e vuoi intraprendere un percorso più difficile, ti consiglierei di scegliere Gentoo o Arch Linux come distribuzione.\n\n<b>Utilizzi</b>\nOttimo per desktop e laptop.",
          "quizAnswer": "Portage",
          "quizQuestion": "Quale sistema di gestione dei pacchetti utilizza Gentoo?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Se sei interessato ad avere Arch come sistema operativo, vai alla sezione di installazione e prova: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Panoramica</b>\nArch è una distribuzione Linux leggera e flessibile guidata al 100% dalla comunità. Simile a Debian, Arch utilizza un modello di rilascio continuo in modo che gli aggiornamenti incrementali diventino alla fine il rilascio stabile. È necessario mettere le mani nella pasta per comprendere il sistema e le sue funzioni, ma in cambio si ottiene un controllo completo e totale del proprio sistema.\n\n<b>Gestione dei pacchetti</b>\nUtilizza il proprio gestore di pacchetti, Pacman, per installare, aggiornare e gestire i pacchetti.\n\n<b>Configurabilità</b>\nSe desideri un sistema operativo leggero e vuoi davvero capire Linux, usa Arch! C'è una certa curva di apprendimento, ma per gli utenti Linux più esperti, questa è una scelta eccellente.\n\n<b>Utilizzi</b>\nOttimo per desktop e laptop. Se hai anche un dispositivo piccolo come un Raspberry Pi e hai bisogno di installare un sistema operativo leggero, non puoi sbagliare con Arch.",
          "quizAnswer": "Pacman",
          "quizQuestion": "Quale gestore di pacchetti utilizza Arch Linux?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Se sei interessato ad avere openSUSE come sistema operativo, vai alla pagina di download e prova: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Panoramica</b>\nopenSUSE Linux è creato dal Progetto openSUSE. Una comunità che promuove l'uso di Linux ovunque, lavorando insieme in modo aperto, trasparente e amichevole come parte della comunità mondiale del Software Libero e Open Source. openSUSE è la seconda distribuzione Linux ancora in esecuzione più vecchia e condivide il sistema di base con i premiati prodotti SUSE Linux Enterprise di SUSE.\n\n<b>Gestione dei pacchetti</b>\nUtilizza il gestore di pacchetti RPM.\n\n<b>Configurabilità</b>\nopenSUSE è una grande scelta per un nuovo utente Linux. Offre un'applicazione di installazione/amministrazione grafica facile da usare (<a href=\"http://yast.github.io/\">YaST</a>) e un sistema di base ordinato, facile da modificare. openSUSE include tutto ciò di cui hai bisogno per goderti Internet senza preoccupazioni di virus/spyware e per esprimere la tua creatività, che sia con le tue foto, video, musica o codice.\n\n<b>Utilizzi</b>\nopenSUSE Leap è completamente in grado di essere utilizzato su un PC desktop e un laptop.",
          "quizAnswer": "yast",
          "quizQuestion": "Qual è il nome dello Strumento di Amministrazione/Installazione di openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Iniziare"
    },
    {
      "description": "Impara i fondamenti della linea di comando, navigando tra file, directory e altro ancora.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Prova alcuni altri comandi Linux e vedi cosa producono:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "Il mondo è tuo, o meglio la shell è il tuo mondo. Cos'è la shell? La shell è essenzialmente un programma che prende i tuoi comandi dalla tastiera e li invia al sistema operativo per eseguirli. Se hai mai usato un'interfaccia grafica, probabilmente hai visto programmi come \"Terminal\" o \"Console\", che sono solo programmi che avviano una shell per te. In tutto questo corso impareremo le meraviglie della shell. \n\nIn questo corso utilizzeremo il programma shell bash (Bourne Again shell), quasi tutte le distribuzioni Linux utilizzeranno di default la shell bash. Ci sono altre shell disponibili come ksh, zsh, tsch, ma non entreremo in dettagli su queste. \n\nIniziamo subito! A seconda della distribuzione, il prompt della tua shell potrebbe cambiare, ma per lo più dovrebbe seguire il seguente formato:\n<pre>username@hostname:current_directory\npete@icebox:/home/pete $</pre>\n\nHai notato il $ alla fine del prompt? Le diverse shell avranno prompt diversi, nel nostro caso il $ è per un utente normale che utilizza Bash, Bourne o Korn shell, non devi aggiungere il simbolo del prompt quando digiti il comando, basta sapere che è lì.\n\nCominciamo con un comando semplice, echo. Il comando echo stampa semplicemente gli argomenti di testo sul display.\n\n<pre>$ echo Ciao Mondo</pre>",
          "quizAnswer": "Ciao Mondo",
          "quizQuestion": "Cosa dovrebbe essere stampato sul display quando si digita echo Ciao Mondo?",
          "slug": "theshell",
          "title": "La Shell"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 2,
          "lessonContent": "Tutto in Linux è un file. Man mano che ti addentri più a fondo in Linux, capirai questo concetto, ma per ora tienilo presente. Ogni file è organizzato all'interno di un albero di directory gerarchico. La prima directory nel filesystem è chiamata in modo appropriato 'directory radice'. La directory radice contiene molte cartelle e file, all'interno delle quali puoi memorizzare ulteriori cartelle e file, e così via. Ecco un esempio di come appare l'albero delle directory: \n\n<pre>/\n|-- bin\n|   |-- file1\n|   |-- file2\n|-- etc\n|   |-- file3\n|   `-- directory1\n|       |-- file4\n|       `-- file5\n|-- home\n|-- var\n</pre>\n\nLe posizioni di questi file e directory sono indicate come 'percorsi'. Se avessi una cartella chiamata 'home' con una cartella al suo interno chiamata 'pete' e un'altra cartella in quella cartella chiamata 'Movies', quel percorso sarebbe simile a questo: '/home/pete/Movies'. Piuttosto semplice, vero?\n\nNavigare nel filesystem, molto simile a navigare nella vita reale, è più facile se sai dove ti trovi e dove stai andando. Per vedere dove ti trovi, puoi utilizzare il comando 'pwd'. Questo comando significa 'print working directory' e ti mostra in quale directory ti trovi. Nota che il percorso deriva dalla directory radice.\n\n<pre>$ pwd</pre>\n\nDove sei? Dove sono? Prova a farlo.",
          "quizAnswer": "pwd",
          "quizQuestion": "Come posso trovare in quale directory ti trovi attualmente?",
          "slug": "printworkingdirectorypwdcommand",
          "title": "pwd (Print Working Directory)"
        },
        {
          "exercise": "<ol>\n<li>Esegui il comando cd senza alcuna opzione, dove ti porta?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Ora che sai dove ti trovi, vediamo se possiamo muoverci un po' nel filesystem. Ricorda che dovremo navigare utilizzando i percorsi. Ci sono due modi diversi per specificare un percorso, con percorsi assoluti e relativi. \n\n<ul>\n<li>Percorso assoluto: Questo è il percorso dalla directory radice. La radice è il capo supremo. La directory radice è comunemente indicata con una barra. Ogni volta che il tuo percorso inizia con / significa che stai partendo dalla directory radice. Ad esempio, /home/pete/Desktop.</li>\n\n<li>Percorso relativo: Questo è il percorso da dove ti trovi attualmente nel filesystem. Se fossi nella posizione /home/pete/Documents e volessi raggiungere una directory all'interno di Documents chiamata taxes, non devo specificare l'intero percorso dalla radice come /home/pete/Documents/taxes, posso semplicemente andare a taxes/ invece.</li>\n</ul>\n\nOra che sai come funzionano i percorsi, abbiamo solo bisogno di qualcosa che ci aiuti a cambiare nella directory desiderata. Fortunatamente, abbiamo cd o “change directory” per farlo. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nOra ho cambiato la mia posizione di directory in /home/pete/Pictures.\n\nOra da questa directory ho una cartella interna chiamata Hawaii, posso navigare in quella cartella con:\n\n<pre>$ cd Hawaii</pre>\n\nHai notato come ho usato solo il nome della cartella? È perché ero già in /home/pete/Pictures.\n\nPuò diventare piuttosto stancante navigare continuamente con percorsi assoluti e relativi, fortunatamente ci sono alcuni scorciatoie per aiutarti. \n\n<ul>\n<li>. (directory corrente). Questa è la directory in cui ti trovi attualmente. </li>\n<li>.. (directory precedente). Ti porta alla directory sopra quella corrente.</li>\n<li>~ (directory home). Questa directory predefinita è la tua “directory home”. Come ad esempio /home/pete.</li>\n<li>- (directory precedente). Ti porterà alla directory precedente in cui ti trovavi appena prima.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\nProvali!",
          "quizAnswer": "cd ..",
          "quizQuestion": "Se sei in /home/pete/Pictures e vuoi andare a /home/pete, quale è una buona scorciatoia da utilizzare?",
          "slug": "changedirectorycdcommand",
          "title": "cd (Cambia Directory)"
        },
        {
          "exercise": "Esegui ls con diversi flag e osserva l'output che ricevi.",
          "id": 4,
          "lessonContent": "Ora che sappiamo come muoverci nel sistema, come possiamo capire cosa è disponibile per noi? Al momento è come se ci stessimo muovendo al buio. Beh, possiamo utilizzare il meraviglioso comando ls per elencare i contenuti delle directory. Il comando ls elencherà directory e file nella directory corrente per impostazione predefinita, tuttavia è possibile specificare il percorso di cui si desidera elencare le directory.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls è uno strumento piuttosto utile, mostra anche informazioni dettagliate sui file e le directory che stai guardando.\n\nNota anche che non tutti i file in una directory saranno visibili. I nomi dei file che iniziano con . sono nascosti, tuttavia è possibile visualizzarli con il comando ls e passare il flag -a ad esso (a per tutti). \n\n<pre>$ ls -a</pre>\n\nC'è anche un altro utile flag di ls, -l per long, che mostra un elenco dettagliato dei file in un formato lungo. Questo ti mostrerà informazioni dettagliate, partendo da sinistra: permessi del file, numero di collegamenti, nome del proprietario, gruppo del proprietario, dimensione del file, timestamp dell'ultima modifica e nome del file/directory. \n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotale 80\ndrwxr-x--- 7 pete penguingroup   4096 20 nov 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 19 ott 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 20 nov 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096  7 ott 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 21 set 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 27 lug 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 27 lug 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 27 lug 12:41   Videos</pre>\n\nI comandi hanno delle cose chiamate flag (o argomenti o opzioni, come preferisci chiamarle) per aggiungere più funzionalità. Vedi come abbiamo aggiunto -a e -l, beh puoi aggiungerli entrambi insieme con -la. L'ordine dei flag determina l'ordine in cui vengono applicati, nella maggior parte dei casi questo non ha molta importanza quindi puoi anche fare ls -al e funzionerà comunque.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "Quale comando useresti per vedere i file nascosti?",
          "slug": "elencodidirectorycomandols",
          "title": "ls (Elenco delle Directory)"
        },
        {
          "exercise": "<ol>\n<li>Crea un nuovo file</li>\n<li>Nota il timestamp</li>\n<li>Usa touch sul file e controlla nuovamente il timestamp</li>\n</ol>",
          "id": 5,
          "lessonContent": "Impariamo come creare alcuni file. Un modo molto semplice è utilizzare il comando touch. Touch ti permette di creare nuovi file vuoti.\n\n<pre>$ touch mysuperduperfile</pre>\n\nEd ecco, nuovo file! \n\nTouch è anche utilizzato per modificare i timestamp su file e directory esistenti. Prova a fare un ls -l su un file e nota il timestamp, poi tocca quel file e aggiornerà il timestamp. \n\nCi sono molti altri modi per creare file che coinvolgono altre cose come la ridirezione e gli editor di testo, ma arriveremo a questo nel corso sulla Manipolazione del Testo.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "Come si crea un file chiamato myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Esegui il comando file su diverse directory e file e annota l'output.",
          "id": 6,
          "lessonContent": "Nella lezione precedente abbiamo appreso riguardo al comando touch, torniamo su questo argomento per un attimo. Hai notato che il nome del file non rispettava gli standard di denominazione come probabilmente hai visto con altri sistemi operativi come Windows? Normalmente ti aspetteresti un file chiamato banana.jpeg e ti aspetteresti un file immagine JPEG. \n\nIn Linux, i nomi dei file non sono necessariamente rappresentativi del contenuto del file. Puoi creare un file chiamato funny.gif che in realtà non è un file GIF. \n\nPer scoprire di che tipo è un file, puoi utilizzare il comando file. Esso ti mostrerà una descrizione del contenuto del file.\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "Quale comando puoi utilizzare per trovare il tipo di file di un file?",
          "slug": "filecommand",
          "title": "file"
        },
        {
          "exercise": "Esegui cat su file e directory diversi. Poi prova a concatenare più file.",
          "id": 7,
          "lessonContent": "Siamo quasi alla fine della navigazione dei file, ma prima impariamo come leggere un file. Un comando semplice da usare è il comando gatto, abbreviato in cat, che non solo visualizza i contenuti del file ma può anche combinare più file e mostrarti l'output di essi. \n\n<pre>$ cat filecane fileuccello</pre>\n\nNon è ottimo per visualizzare file di grandi dimensioni ed è pensato solo per contenuti brevi. Ci sono molti altri strumenti che usiamo per visualizzare file di testo più grandi di cui parleremo nella prossima lezione.",
          "quizAnswer": "cat",
          "quizQuestion": "Qual è un buon modo per vedere i contenuti di un file?",
          "slug": "comandogatto",
          "title": "gatto"
        },
        {
          "exercise": "Esegui meno su un file, quindi passa su e intorno al file. Prova a cercare una parola specifica. Naviga rapidamente all'inizio o alla fine del file.",
          "id": 8,
          "lessonContent": "Se stai visualizzando file di testo più grandi di una semplice output, meno è meglio. (Esiste effettivamente un comando chiamato più che fa qualcosa di simile, quindi è ironico.) Il testo viene visualizzato in modo paginato, quindi puoi navigare attraverso un file di testo pagina per pagina. \n\nVai avanti e guarda i contenuti di un file con meno. Una volta nel comando meno, puoi effettivamente utilizzare altri comandi da tastiera per navigare nel file. \n\n<pre>$ meno /home/pete/Documents/text1</pre>\n\nUtilizza il seguente comando per navigare attraverso meno: \n\n<ul>\n<li>q - Utilizzato per uscire da meno e tornare alla tua shell.</li>\n<li>Pagina su, Pagina giù, Su e Giù - Naviga utilizzando i tasti freccia e i tasti di pagina.</li>\n<li>g - Si sposta all'inizio del file di testo.</li>\n<li>G - Si sposta alla fine del file di testo.</li>\n<li>/ricerca - Puoi cercare un testo specifico all'interno del documento di testo. Anteporre le parole che desideri cercare con /</li>\n<li>h - Se hai bisogno di un po' di aiuto su come utilizzare meno mentre sei in meno, utilizza help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "Come si esce da un comando meno?",
          "slug": "comandomeno",
          "title": "meno"
        },
        {
          "exercise": "Naviga attraverso la cronologia dei tuoi comandi precedenti con i tasti Su e Giù. Gioca con la ricerca inversa ctrl-R.",
          "id": 9,
          "lessonContent": "Nella tua shell, c'è una cronologia dei comandi che hai inserito in precedenza, puoi effettivamente sfogliare questi comandi. Questo è abbastanza utile quando vuoi trovare ed eseguire un comando che hai usato in precedenza senza doverlo digitare di nuovo.\n\n<pre>$ history</pre>\n\nVuoi eseguire lo stesso comando che hai fatto prima, basta premere la freccia su. \n\nVuoi eseguire il comando precedente senza riscriverlo? Usa !!. Se hai digitato cat file1 e vuoi eseguirlo di nuovo, puoi semplicemente scrivere !! e eseguirà l'ultimo comando che hai eseguito. \n\nUn'altra scorciatoia della cronologia è ctrl-R, questo è il comando di ricerca inversa, se premi ctrl-R e inizi a digitare parti del comando che desideri, ti mostrerà le corrispondenze e potrai semplicemente navigare tra esse premendo di nuovo il tasto ctrl-R. Una volta trovato il comando che vuoi usare di nuovo, premi il tasto Invio.\n\nIl nostro terminale si sta un po' ingombrando, vero? Facciamo un po' di pulizia, usa il comando clear per pulire il display.\n\n<pre>$ clear</pre>\n\nEcco, sembra migliore, vero? \n\nMentre parliamo di cose utili, una delle funzionalità più utili in qualsiasi ambiente a riga di comando è il completamento automatico. Se inizi a digitare l'inizio di un comando, file, directory, ecc. e premi il tasto Tab, completerà in base a ciò che trova nella directory che stai cercando a condizione che non ci siano altri file che iniziano con quelle lettere. Ad esempio, se stessi cercando di eseguire il comando chrome, puoi digitare chr e premere Tab e completerà chrome.",
          "quizAnswer": "clear",
          "quizQuestion": "Qual è il comando per pulire il terminale?",
          "slug": "comandocronologia",
          "title": "cronologia"
        },
        {
          "exercise": "Copia un paio di file, fai attenzione a non sovrascrivere nulla di importante.",
          "id": 10,
          "lessonContent": "Iniziamo a fare delle copie di questi file. Molto simile a copiare e incollare file in altri sistemi operativi, la shell ci offre un modo ancora più semplice per farlo. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile è il file che vuoi copiare e /home/pete/Documents/cooldocs è dove stai copiando il file.\n\nPuoi copiare anche file e directory multipli e utilizzare dei caratteri jolly. Un carattere jolly è un carattere che può essere sostituito per una selezione basata su un modello, offrendoti maggiore flessibilità con le ricerche. Puoi utilizzare i caratteri jolly in ogni comando per maggiore flessibilità.\n\n<ul>\n<li>* il carattere jolly dei caratteri jolly, viene utilizzato per rappresentare tutti i singoli caratteri o qualsiasi stringa.</li>\n<li>? utilizzato per rappresentare un singolo carattere</li>\n<li>[] utilizzato per rappresentare qualsiasi carattere all'interno delle parentesi quadre</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nQuesto copierà tutti i file con estensione .jpg nella tua directory corrente nella directory Pictures.\n\nUn comando utile è utilizzare il flag -r, questo copierà in modo ricorsivo i file e le directory all'interno di una directory. \n\nProva a fare una cp su una directory che contiene un paio di file nella tua directory Documenti. Non ha funzionato vero? Beh, questo perché dovrai copiare anche i file e le directory all'interno con il comando -r.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nUna cosa da notare, se copi un file in una directory che ha lo stesso nome del file, il file verrà sovrascritto con ciò che stai copiando. Questo non è buono se hai un file che non vuoi che venga sovrascritto accidentalmente. Puoi utilizzare il flag -i (interattivo) per chiederti conferma prima di sovrascrivere un file. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Quale flag devi specificare per copiare una directory?",
          "slug": "copycpcommand",
          "title": "cp (Copia)"
        },
        {
          "exercise": "Rinomina un file, poi sposta quel file in una directory diversa.",
          "id": 11,
          "lessonContent": "Usato per spostare file e rinominarli. Piuttosto simile al comando cp in termini di flag e funzionalità. \n\nPuoi rinominare i file in questo modo:\n\n<pre>$ mv vecchiofile nuovofile</pre>\n\nOppure puoi effettivamente spostare un file in una directory diversa: \n\n<pre>$ mv file2 /home/pete/Documents</pre>\n\nE spostare più di un file:\n\n<pre>$ mv file_1 file_2 /unadirectory</pre>\n\nPuoi rinominare anche delle directory:\n\n<pre>$ mv directory1 directory2</pre>\n\nCome cp, se sposti un file o una directory sovrascriverà qualsiasi cosa nella stessa directory. Quindi puoi usare il flag -i per chiederti prima di sovrascrivere qualcosa.\n\n<pre>mv -i directory1 directory2</pre>\n\nSupponiamo che tu voglia spostare un file per sovrascrivere quello precedente. Puoi anche fare un backup di quel file e semplicemente rinominare la vecchia versione con un ~. \n\n<pre>$ mv -b directory1 directory2</pre>",
          "quizAnswer": "mv gatto cane",
          "quizQuestion": "Come si rinomina un file chiamato gatto in cane?",
          "slug": "comandomv",
          "title": "mv (Sposta)"
        },
        {
          "exercise": "Crea un paio di directory e sposta alcuni file in quella directory.",
          "id": 12,
          "lessonContent": "Avremo bisogno di alcune directory per memorizzare tutti questi file su cui abbiamo lavorato. Il comando mkdir (Make Directory) è utile per questo, creerà una directory se non esiste già. Puoi anche creare più directory contemporaneamente.\n\n<pre>$ mkdir books paintings</pre>\n\nPuoi anche creare sottodirectory contemporaneamente con il flag -p (genitore).\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "Quale comando viene utilizzato per creare una directory?",
          "slug": "makedirectorymkdircommand",
          "title": "mkdir (Make Directory)"
        },
        {
          "exercise": "<ol>\n<li>Crea un file chiamato -file (non dimenticare il trattino!).</li>\n<li>Rimuovi quel file.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Ora penso che abbiamo troppi file, eliminiamo alcuni file. Per rimuovere i file puoi utilizzare il comando rm. Il comando rm (rimuovi) viene utilizzato per eliminare file e directory. \n\n<pre>$ rm file1</pre>\n\nFai attenzione quando usi rm, non c'è un cestino magico da cui puoi recuperare i file eliminati. Una volta che sono andati, sono andati per sempre, quindi fai attenzione. \n\nFortunatamente sono state adottate alcune misure di sicurezza, quindi il cittadino medio non può semplicemente eliminare un mucchio di file importanti. I file protetti dalla scrittura ti chiederanno conferma prima di eliminarli. Se una directory è protetta dalla scrittura, non sarà nemmeno facilmente rimossa. \n\nOra, se non ti interessa nulla di tutto ciò, puoi assolutamente eliminare un mucchio di file. \n\n<pre>$ rm -f file1</pre>\n\nL'opzione -f o forza dice a rm di rimuovere tutti i file, che siano protetti dalla scrittura o meno, senza chiedere conferma all'utente (a condizione di avere le autorizzazioni appropriate).\n\n<pre>$ rm -i file</pre>\n\nAggiungendo il flag -i come molti degli altri comandi, ti verrà chiesta una conferma su se vuoi effettivamente rimuovere i file o le directory. \n\n<pre>$ rm -r directory</pre>\n\nNon puoi semplicemente rimuovere una directory di default, dovrai aggiungere il flag -r (ricorsivo) per rimuovere tutti i file e eventuali sottodirectory che potrebbe avere.\n\nPuoi rimuovere una directory con il comando rmdir.\n\n<pre>$ rmdir directory</pre>",
          "quizAnswer": "",
          "quizQuestion": "Come si rimuove un file chiamato myfile?",
          "slug": "comandormrimuovi",
          "title": "rm (Rimuovi)"
        },
        {
          "exercise": "<ol>\n<li>Trova un file dalla directory principale che contenga la parola net.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Con tutti questi file che abbiamo sul sistema, può diventare un po' frenetico cercare un file specifico. Beh, c'è un comando che possiamo usare per questo, trova! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nCon trova dovrai specificare la directory in cui stai cercando, cosa stai cercando, in questo caso stiamo cercando un file chiamato puppies.jpg. \n\nPuoi specificare che tipo di file stai cercando. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nPuoi vedere che ho impostato il tipo di file che sto cercando come (d) per directory e sto comunque cercando per nome MyFolder. \n\nUna cosa interessante da notare è che trova non si ferma alla directory in cui stai cercando, guarderà anche all'interno di eventuali sottodirectory che quella directory potrebbe avere.",
          "quizAnswer": "-name",
          "quizQuestion": "Quale opzione dovrei specificare per trova se voglio cercare per nome?",
          "slug": "comandotrova",
          "title": "trova"
        },
        {
          "exercise": "Esegui help sul comando echo, sul comando logout e sul comando pwd.",
          "id": 15,
          "lessonContent": "Linux ha alcuni ottimi strumenti integrati per aiutarti a capire come utilizzare un comando o controllare quali opzioni sono disponibili per un comando. Uno strumento, help, è un comando bash integrato che fornisce assistenza per altri comandi bash (echo, logout, pwd, ecc).\n\n<pre>$ help echo</pre>\n\nQuesto ti fornirà una descrizione e le opzioni che puoi utilizzare quando vuoi eseguire echo. Per altri programmi eseguibili, è consuetudine avere un'opzione chiamata --help o qualcosa di simile. \n\n<pre>$ echo --help</pre>\n\nNon tutti gli sviluppatori che distribuiscono programmi eseguibili si attengono a questo standard, ma è probabilmente il tuo miglior punto di riferimento per trovare assistenza su un programma.",
          "quizAnswer": "help",
          "quizQuestion": "Come si ottiene rapidamente assistenza dalla riga di comando per i comandi bash integrati?",
          "slug": "comandohelp",
          "title": "aiuto"
        },
        {
          "exercise": "Esegui il comando man sul comando ls.",
          "id": 16,
          "lessonContent": "Gee vorrei che alcuni di questi programmi avessero un manuale in modo da poter vedere maggiori informazioni su di essi. Beh fortunatamente lo fanno! Chiamate aptamente pagine man, è possibile visualizzare i manuali per un comando con il comando man. \n\n<pre>$ man ls</pre>\n\nLe pagine man sono manuali che sono di default integrati nella maggior parte dei sistemi operativi Linux. Forniscono documentazione su comandi e altri aspetti del sistema. \n\nProvalo su alcuni comandi per ottenere maggiori informazioni su di essi.",
          "quizAnswer": "man",
          "quizQuestion": "Come si visualizzano i manuali per un comando?",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Esegui il comando whatis sul comando less.",
          "id": 17,
          "lessonContent": "Wow, abbiamo imparato parecchi comandi finora, se ti senti mai in dubbio su cosa faccia un comando, puoi usare il comando whatis. Il comando whatis fornisce una breve descrizione dei programmi a riga di comando. \n\n<pre>$ whatis cat</pre>\n\nLa descrizione proviene dalla pagina di manuale di ciascun comando. Se eseguissi whatis cat, vedresti che c'è un breve testo con una breve descrizione.",
          "quizAnswer": "whatis",
          "quizQuestion": "Quale comando puoi usare per vedere una breve descrizione di un comando?",
          "slug": "comandowhatis",
          "title": "cos'è"
        },
        {
          "exercise": "Crea un paio di alias e poi rimuovili.",
          "id": 18,
          "lessonContent": "A volte digitare comandi può diventare davvero ripetitivo, oppure se devi digitare un lungo comando molte volte, è meglio avere un alias che puoi usare per quello. Per creare un alias per un comando, devi semplicemente specificare un nome di alias e impostarlo sul comando. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nOra invece di digitare ls -la, puoi digitare foobar e eseguirà quel comando, roba piuttosto interessante. Tieni presente che questo comando non salverà il tuo alias dopo il riavvio, quindi dovrai aggiungere un alias permanente in:\n\n<pre>~/.bashrc</pre>\n\no file simili se vuoi che persista dopo il riavvio.\n\nPuoi rimuovere gli alias con il comando unalias: \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "Quale comando viene utilizzato per creare un alias?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Esci dalla shell e vedi cosa succede. Assicurati di non dover fare altro lavoro in quella shell.",
          "id": 19,
          "lessonContent": "Beh, hai fatto sicuramente un buon lavoro nel superare le basi. Abbiamo appena grattato la superficie, ora che hai imparato a strisciare, nei prossimi corsi ti insegnerò come camminare. \n\nPer ora, puoi darti una pacca sulla spalla e fare una pausa. Per uscire dalla shell, puoi utilizzare il comando di uscita\n\n<pre>$ exit</pre>\n\nO il comando di logout:\n\n<pre>$ logout</pre>\n\nOppure se stai lavorando da una GUI del terminale, puoi semplicemente chiudere il terminale, ci vediamo nel prossimo corso!",
          "quizAnswer": "exit",
          "quizQuestion": "Come puoi uscire dalla shell?",
          "slug": "exitcommand",
          "title": "uscita"
        }
      ],
      "slug": "commandline",
      "title": "Linea di comando"
    },
    {
      "description": "Impara la manipolazione di base del testo e la navigazione.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Prova un paio di comandi: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hello World > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "A questo punto, siamo diventati familiari con molti comandi e il loro output e questo ci porta al nostro prossimo argomento I/O (input/output) streams. Eseguiamo il seguente comando e discuteremo come funziona. \n\n<pre>$ echo Hello World > peanuts.txt</pre>\n\nCosa è appena successo? Controlla la directory in cui hai eseguito quel comando e dovresti vedere un file chiamato peanuts.txt, guardaci dentro e dovresti vedere il testo Hello World. Molte cose sono appena accadute in un solo comando, quindi analizziamolo. \n\nPrima analizziamo la prima parte: \n\n<pre>$ echo Hello World</pre>\n\nSappiamo che questo stampa Hello World sullo schermo, ma come? I processi utilizzano gli I/O streams per ricevere input e restituire output. Per impostazione predefinita, il comando echo prende l'input (standard input o stdin) dalla tastiera e restituisce l'output (standard output o stdout) allo schermo. Ecco perché quando digiti echo Hello World nel tuo terminale, ottieni Hello World sullo schermo. Tuttavia, la redirezione I/O ci permette di cambiare questo comportamento predefinito, offrendoci una maggiore flessibilità nei file. \n\nPassiamo alla parte successiva del comando: \n\n<pre> > </pre>\n\nIl > è un operatore di redirezione che ci permette di cambiare dove va l'output standard. Ci consente di inviare l'output di echo Hello World in un file anziché sullo schermo. Se il file non esiste già, lo creerà per noi. Tuttavia, se esiste, lo sovrascriverà (puoi aggiungere un flag del terminale per evitarlo a seconda del terminale che stai usando).\n\nE questo è fondamentalmente come funziona la redirezione stdout!\n\nImmaginiamo di non voler sovrascrivere il nostro peanuts.txt, fortunatamente c'è un operatore di redirezione anche per questo, >>: \n\n<pre>$ echo Hello World >> peanuts.txt</pre>\n\nQuesto aggiungerà Hello World alla fine del file peanuts.txt, se il file non esiste già, lo creerà per noi come ha fatto con il redirettore >!",
          "quizAnswer": ">>",
          "quizQuestion": "Quale operatore di redirezione si usa per aggiungere output a un file?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Prova un paio di comandi:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "Nella nostra lezione precedente abbiamo appreso che abbiamo diversi flussi stdout che possiamo utilizzare, come ad esempio un file o lo schermo. Beh, ci sono anche diversi flussi di input standard (stdin) che possiamo utilizzare. Sappiamo di avere stdin da dispositivi come la tastiera, ma possiamo utilizzare anche file, output da altri processi e il terminale, vediamo un esempio. \n\nUsiamo il file peanuts.txt nella lezione precedente per questo esempio, ricordiamo che conteneva il testo Hello World. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nProprio come avevamo <b>&gt;</b> per la redirezione dello stdout, possiamo usare <b>&lt;</b> per la redirezione dello stdin. \n\nNormalmente nel comando cat, invii un file ad esso e quel file diventa lo stdin, in questo caso, abbiamo redirezionato peanuts.txt per essere il nostro stdin. Quindi l'output di cat peanuts.txt che sarebbe Hello World viene redirezionato in un altro file chiamato banana.txt.",
          "quizAnswer": "<",
          "quizQuestion": "Quale redirector usi per redirigere lo stdin?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Standard In)"
        },
        {
          "exercise": "Cosa fa il seguente comando? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Proviamo qualcosa di un po' diverso ora, proviamo a elencare i contenuti di una directory che non esiste nel tuo sistema e reindirizzare di nuovo l'output nel file peanuts.txt.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nQuello che dovresti vedere è: \n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nProbabilmente ti starai chiedendo, non avrebbe dovuto quel messaggio essere inviato al file? In realtà c'è un altro flusso di I/O in gioco qui chiamato standard error (stderr). Per impostazione predefinita, stderr invia il suo output anche allo schermo, è un flusso completamente diverso rispetto a stdout. Quindi dovrai reindirizzare il suo output in modo diverso. \n\nSfortunatamente il reindirizzatore non è così bello come usare <b>&lt;</b> o <b>&gt;</b> ma è abbastanza simile. Dovremo usare i descrittori di file. Un descrittore di file è un numero non negativo che viene utilizzato per accedere a un file o a un flusso. Approfondiremo questo argomento più avanti, ma per ora sappi che il descrittore di file per stdin, stdout e stderr è rispettivamente 0, 1 e 2. \n\nQuindi ora se vogliamo reindirizzare il nostro stderr nel file possiamo fare così: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nDovresti vedere solo i messaggi di stderr in peanuts.txt. \n\nE se volessi vedere sia stderr che stdout nel file peanuts.txt? È possibile farlo anche con i descrittori di file: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nQuesto invia i risultati di ls /fake/directory nel file peanuts.txt e quindi reindirizza stderr nello stdout tramite 2>&1. L'ordine delle operazioni qui conta, 2>&1 invia stderr a ciò a cui stdout sta puntando. In questo caso stdout sta puntando a un file, quindi 2>&1 invia anche stderr a un file. Quindi se apri quel file peanuts.txt dovresti vedere sia stderr che stdout. Nel nostro caso, il comando sopra produce solo stderr.\n\nC'è un modo più breve per reindirizzare sia stdout che stderr in un file:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nE se non volessi tutto questo e volessi eliminare completamente i messaggi di stderr? Beh, puoi anche reindirizzare l'output in un file speciale chiamato /dev/null e scarterà qualsiasi input.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "Qual è il reindirizzatore per stderr?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Standard Error)"
        },
        {
          "exercise": "Prova i seguenti comandi: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Ora passiamo alla tubatura, non proprio ma quasi. Proviamo un comando: \n\n<pre>$ ls -la /etc</pre>\n\nDovresti vedere una lista molto lunga di elementi, è un po' difficile da leggere effettivamente. Invece di reindirizzare questo output in un file, non sarebbe bello se potessimo semplicemente vedere l'output in un altro comando come less? Beh, possiamo!\n\n<pre>$ ls -la /etc | less </pre>\n\nL'operatore di tubatura |, rappresentato da una barra verticale, ci consente di ottenere lo stdout di un comando e farlo diventare lo stdin di un altro processo. In questo caso, abbiamo preso lo stdout di ls -la /etc e poi lo abbiamo <i>tubato</i> al comando less. Il comando di tubatura è estremamente utile e continueremo ad usarlo per tutta l'eternità. \n\nE se volessi scrivere l'output del mio comando su due flussi diversi? Questo è possibile con il comando tee: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nDovresti vedere l'output di ls sullo schermo e se apri il file peanuts.txt dovresti vedere le stesse informazioni!",
          "quizAnswer": "|",
          "quizQuestion": "Quale tasto rappresenta l'operatore di tubatura?",
          "slug": "pipeteeredirect",
          "title": "pipe e tee"
        },
        {
          "exercise": "Cosa restituisce l'output seguente? Perché?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Esegui il seguente comando: \n\n<pre>$ echo $HOME</pre>\n\nDovresti vedere il percorso della tua directory home, il mio assomiglia a /home/pete. \n\nCosa succede con questo comando? \n\n<pre>$ echo $USER </pre>\n\nDovresti vedere il tuo nome utente!\n\nDa dove provengono queste informazioni? Provengono dalle tue variabili d'ambiente. Puoi visualizzarle digitando\n\n<pre>$ env </pre>\n\nQuesto restituisce molte informazioni sulle variabili d'ambiente attualmente impostate. Queste variabili contengono informazioni utili che la shell e altri processi possono utilizzare.\n\nEcco un breve esempio:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nUna variabile particolarmente importante è la variabile PATH. Puoi accedere a queste variabili inserendo un $ davanti al nome della variabile in questo modo:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nQuesto restituisce un elenco di percorsi separati da due punti che il tuo sistema cerca quando esegue un comando. Immaginiamo che tu scarichi e installi manualmente un pacchetto da internet e lo metti in una directory non standard e vuoi eseguire quel comando, digiti $ coolcommand e il prompt dice comando non trovato. Beh, è assurdo, stai guardando il binario in una cartella e sai che esiste. Quello che succede è che la variabile $PATH non controlla quella directory per questo binario quindi restituisce un errore. \n\nImmaginiamo che tu abbia un sacco di binari che vuoi eseguire da quella directory, puoi semplicemente modificare la variabile PATH per includere quella directory nella tua variabile d'ambiente PATH.",
          "quizAnswer": "env",
          "quizQuestion": "Come si visualizzano le variabili d'ambiente?",
          "slug": "envenvironment",
          "title": "env (Ambiente)"
        },
        {
          "exercise": "Cosa fa il seguente comando? Perché?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Stiamo per imparare un paio di comandi utili che puoi usare per elaborare il testo. Prima di iniziare, creiamo un file con cui lavoreremo. Copia e incolla il seguente comando, una volta fatto aggiungi una TAB tra lazy e dog (tieni premuto Ctrl-v + TAB).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nIl primo comando di cui parleremo è il comando cut. Estrae porzioni di testo da un file. \n\nPer estrarre i contenuti tramite un elenco di caratteri: \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nQuesto restituisce il 5° carattere in ogni riga del file. In questo caso è \"q\", nota che lo spazio conta anche come un carattere. \n\nPer estrarre i contenuti per un campo, dovremo fare una piccola modifica: \n\n<pre>$ cut -f 2 sample.txt</pre>\n\nIl flag -f o campo taglia il testo in base ai campi, di default utilizza i TAB come delimitatori, quindi tutto separato da un TAB è considerato un campo. Dovresti vedere \"dog\" come output.\n\nPuoi combinare il flag del campo con il flag del delimitatore per estrarre i contenuti tramite un delimitatore personalizzato: \n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nQuesto cambierà il delimitatore TAB in un delimitatore \";\" e poiché stiamo tagliando il primo campo, il risultato dovrebbe essere \"The quick brown\".",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "Quale comando useresti per ottenere il primo carattere di ogni riga in un file?",
          "slug": "comandotaglio",
          "title": "taglio"
        },
        {
          "exercise": "Prova a incollare insieme più file, cosa succede?",
          "id": 7,
          "lessonContent": "Il comando incolla è simile al comando cat, unisce le righe in un file. Creiamo un nuovo file con i seguenti contenuti: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nUniamo tutte queste righe in una sola riga: \n\n<pre>$ incolla -s sample2.txt</pre>\n\nIl delimitatore predefinito per incolla è il TAB, quindi ora c'è una riga con i TAB che separano ogni parola.\n\nModifichiamo questo delimitatore (-d) in qualcosa di più leggibile: \n\n<pre>$ incolla -d ' ' -s sample2.txt</pre>\n\nOra tutto dovrebbe essere su una riga delimitata da spazi.",
          "quizAnswer": "-s",
          "quizQuestion": "Quale flag usi con incolla per mettere tutto su una riga?",
          "slug": "comandoincolla",
          "title": "incolla"
        },
        {
          "exercise": "Cosa fa il seguente comando e perché? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Supponiamo di avere un file molto lungo, infatti ne abbiamo molti tra cui scegliere, vai avanti e visualizza /var/log/syslog. Dovresti vedere pagine su pagine di testo. E se volessi vedere solo le prime due righe in questo file di testo? Possiamo farlo con il comando head, di default il comando head ti mostrerà le prime 10 righe di un file.\n\n<pre>$ head /var/log/syslog</pre>\n\nPuoi anche modificare il conteggio delle righe a tuo piacimento, diciamo che voglio vedere le prime 15 righe invece. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nIl flag -n sta per numero di righe.",
          "quizAnswer": "-n",
          "quizQuestion": "Quale flag useresti per cambiare il numero di righe che desideri visualizzare per il comando head?",
          "slug": "headcommand",
          "title": "head"
        },
        {
          "exercise": "Guarda la pagina man di tail e leggi alcuni degli altri comandi di cui non abbiamo discusso. \n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Simile al comando head, il comando tail ti permette di vedere per impostazione predefinita le ultime 10 righe di un file.\n\n<pre>$ tail /var/log/syslog</pre>\n\nInsieme a head puoi cambiare il numero di righe che desideri vedere.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nUn'altra ottima opzione che puoi utilizzare è il flag -f (follow), questo seguirà il file mentre cresce. Prova e vedi cosa succede. \n\n<pre>$ tail -f /var/log/syslog</pre> \n\nIl tuo file syslog cambierà continuamente mentre interagisci con il sistema e usando tail -f puoi vedere tutto ciò che viene aggiunto a quel file.",
          "quizAnswer": "-f",
          "quizQuestion": "Qual è il flag utilizzato per seguire un file in tail?",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "Cosa succede se si digita semplicemente expand senza un input di file?",
          "id": 10,
          "lessonContent": "Nella nostra lezione sul comando cut, avevamo il nostro file sample.txt che conteneva una tabulazione. Normalmente le TAB dovrebbero mostrare una differenza evidente, ma alcuni file di testo potrebbero non mostrarla abbastanza chiaramente. Avere delle TAB in un file di testo potrebbe non essere lo spaziamento desiderato. Per cambiare le tue TAB in spazi, utilizza il comando expand. \n\n<pre>$ expand sample.txt</pre>\n\nIl comando sopra stamperà in output ogni TAB convertita in un gruppo di spazi. Per salvare questo output in un file, utilizza il reindirizzamento dell'output come mostrato di seguito.\n\n<pre>$ expand sample.txt > result.txt</pre>\n\nContrariamente a expand, possiamo convertire nuovamente ogni gruppo di spazi in una TAB con il comando unexpand: \n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "Quale comando viene utilizzato per convertire le TAB in spazi?",
          "slug": "comandoespandicomprimi",
          "title": "espandi e comprimi"
        },
        {
          "exercise": "Unisci due file con un numero diverso di righe in ciascun file, cosa succede?",
          "id": 11,
          "lessonContent": "Il comando join ti consente di unire più file insieme tramite un campo comune: \n\nImmagina di avere due file che desideri unire insieme:\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\nHai visto come ha unito i miei file? Sono stati uniti insieme per il primo campo per impostazione predefinita e i campi devono essere identici, altrimenti puoi ordinarli, quindi in questo caso i file sono uniti tramite 1, 2, 3. \n\nCome uniresti i seguenti file? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nPer unire questo file è necessario specificare quali campi stai unendo, in questo caso vogliamo il campo 2 su file1.txt e il campo 1 su file2.txt, quindi il comando sarebbe simile a questo:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 si riferisce a file1.txt e -2 si riferisce a file2.txt. Piuttosto interessante. Puoi anche dividere un file in file diversi con il comando split: \n\n<pre>$ split somefile</pre>\n\nQuesto lo dividerà in file diversi, per impostazione predefinita li dividerà una volta raggiunto un limite di 1000 righe. I file sono nominati x** per impostazione predefinita.",
          "quizAnswer": "join gatto cane mucca",
          "quizQuestion": "Quale comando useresti per unire i file chiamati gatto cane mucca?",
          "slug": "joinsplitcommand",
          "title": "join and split"
        },
        {
          "exercise": "Il vero potere di sort risiede nella sua capacità di essere combinato con altri comandi, prova il seguente comando e vedi cosa succede?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "Il comando sort è utile per ordinare le righe.\n\n<pre>\nfile1.txt\ncane\nmucca\ngatto\nelefante\nuccello\n\n$ sort file1.txt\nuccello\ngatto\nmucca\ncane\nelefante\n</pre>\n\nPuoi anche fare un ordinamento inverso: \n\n<pre>$ sort -r file1.txt\nelefante\ncane\nmucca\ngatto\nuccello\n</pre>\n\nE ordinare anche in base al valore numerico: \n\n<pre>$ sort -n file1.txt\nuccello\ngatto\nmucca\nelefante\ncane\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "Quale flag si utilizza per fare un ordinamento inverso?",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "Prova il seguente comando, cosa succede? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "Il comando tr (traduci) ti consente di tradurre un insieme di caratteri in un altro insieme di caratteri. Proviamo un esempio di traduzione di tutti i caratteri minuscoli in caratteri maiuscoli. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nCome puoi vedere, abbiamo trasformato l'intervallo da a-z in A-Z e tutto il testo che digitiamo in minuscolo viene trasformato in maiuscolo.",
          "quizAnswer": "tr",
          "quizQuestion": "Quale comando viene utilizzato per tradurre i caratteri?",
          "slug": "trtranslatecommand",
          "title": "tr (Traduci)"
        },
        {
          "exercise": "Che risultato otterresti se provassi uniq -uc?",
          "id": 14,
          "lessonContent": "Il comando uniq (unico) è un altro strumento utile per analizzare il testo.\n\nSupponiamo di avere un file con molti duplicati:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nE volete rimuovere i duplicati, potete utilizzare il comando uniq:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nOtteniamo il conteggio di quante volte appare una riga:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nOtteniamo solo i valori unici:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nOtteniamo solo i valori duplicati:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Nota</b>: uniq non rileva righe duplicate a meno che siano adiacenti. Ad esempio:\n\nSupponiamo di avere un file con duplicati non adiacenti:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nIl risultato restituito da uniq conterrà tutte le voci a differenza del primo esempio.\n\nPer superare questa limitazione di uniq possiamo utilizzare il comando sort in combinazione con uniq:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "Quale comando useresti per rimuovere i duplicati in un file?",
          "slug": "uniquniquecommand",
          "title": "uniq (Unico)"
        },
        {
          "exercise": "Come otterresti il conteggio totale delle righe utilizzando il file nl senza cercare attraverso l'intero output? Suggerimento: Utilizza alcuni degli altri comandi appresi in questo corso.",
          "id": 15,
          "lessonContent": "Il comando wc (word count) mostra il conteggio totale delle parole in un file. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nMostra rispettivamente il numero di righe, il numero di parole e il numero di byte.\n\nPer visualizzare solo il conteggio di un determinato campo, utilizzare rispettivamente -l, -w o -c. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nUn altro comando che puoi utilizzare per controllare il conteggio delle righe in un file è il comando nl (number lines). \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "Quale comando utilizzeresti per ottenere il numero totale di parole in un file e solo le parole?",
          "slug": "nlwccommand",
          "title": "wc e nl"
        },
        {
          "exercise": "Potresti aver sentito parlare di egrep o fgrep, questi sono chiamate grep deprecati e sono stati sostituiti da grep -E e grep -F. Leggi la pagina di manuale di grep per saperne di più.",
          "id": 16,
          "lessonContent": "Il comando grep è probabilmente il comando di elaborazione di testo più comune che userai. Ti consente di cercare nei file caratteri che corrispondono a un certo modello. E se volessi sapere se un file esiste in una determinata directory o se volessi vedere se una stringa è stata trovata in un file? Certamente non dovresti cercare in ogni riga di testo, dovresti usare grep!\n\nUsiamo il nostro file sample.txt come esempio: \n\n<pre>$ grep volpe sample.txt</pre>\n\nDovresti vedere che grep ha trovato volpe nel file sample.txt. \n\nPuoi anche cercare modelli insensibili alle maiuscole e minuscole con l'opzione -i: \n\n<pre>$ grep -i qualchepattern somefile</pre>\n\nPer diventare ancora più flessibili con grep, puoi combinarlo con altri comandi con |.\n\n<pre>$ env | grep -i Utente</pre>\n\nCome puoi vedere, grep è piuttosto versatile. Puoi persino usare espressioni regolari nel tuo modello: \n\n<pre>$ ls /somedir | grep '.txt$'</pre>\n\nDovrebbe restituire tutti i file che terminano con .txt in somedir.",
          "quizAnswer": "grep",
          "quizQuestion": "Quale comando usi per trovare un certo modello?",
          "slug": "comandogrep",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Naviga nel testo come una scimmia ragno Linux con vim ed emacs.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Prova a combinare le espressioni regolari con grep e cercare attraverso alcuni file.\n\n<pre>\ngrep [espressione regolare qui] [file]",
          "id": 1,
          "lessonContent": "Le espressioni regolari sono uno strumento potente per effettuare selezioni basate su pattern. Utilizzano notazioni speciali simili a quelle che abbiamo già incontrato, come il carattere jolly *. \n\nEsamineremo un paio delle espressioni regolari più comuni, che sono quasi universali con qualsiasi linguaggio di programmazione.\n\nUtilizzeremo questa frase come stringa di test:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. Inizio di una riga con ^</b>\n\n<pre>\n<b>^</b>by\ncorrisponderebbe alla riga \"by the seashore\"\n</pre>\n\n<b>2. Fine di una riga con $</b>\n\n<pre>\nseashore<b>$</b>\ncorrisponderebbe alla riga \"by the seashore\"\n</pre>\n\n<b>3. Corrispondenza con un singolo carattere con .</b>\n\n<pre>\nb<b>.</b>\ncorrisponderebbe a by\n</pre>\n\n<b>4. Notazione a parentesi quadre con [] e ()</b>\n\nQuesto può essere un po' complicato, le parentesi quadre ci permettono di specificare i caratteri trovati all'interno delle parentesi. \n\n<pre>\nd<b>[iou]</b>g\ncorrisponderebbe a: dig, dog, dug\n</pre>\n\nIl tag di ancoraggio precedente ^ quando usato in una parentesi quadra significa qualsiasi cosa tranne i caratteri all'interno delle parentesi. \n\n<pre>\nd<b>[^i]</b>g\ncorrisponderebbe a: dog e dug ma non a dig\n</pre>\n\nLe parentesi quadre possono anche utilizzare intervalli per aumentare il numero di caratteri che si desidera utilizzare. \n\n<pre>\nd<b>[a-c]</b>g\ncorrisponderà a pattern come dag, dbg e dcg\n</pre>\n\nFai attenzione perché le parentesi quadre sono sensibili alle maiuscole e minuscole:\n\n<pre>\nd<b>[A-C]</b>g\ncorrisponderà a dAg, dBg e dCg ma non a dag, dbg e dcg\n</pre>\n\nE queste sono alcune espressioni regolari di base.",
          "quizAnswer": ".",
          "quizQuestion": "Quale espressione regolare useresti per corrispondere a un singolo carattere?",
          "slug": "espressioniregolariregex",
          "title": "espressioni regolari (Regular Expressions)"
        },
        {
          "exercise": "Fai un breve tour di vim e emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Se metti un paio di utenti Linux incalliti in una stanza e chiedi loro qual è il miglior editor di testo da usare, sentirai un dibattito infinito sulla divinità di vim o emacs. Non provare nemmeno a menzionare l'uso di un editor GUI se tieni alla tua vita. \n\nVim e emacs sono editor di testo popolari che sono installati di default sulla maggior parte delle distribuzioni Linux e entrambi hanno i loro pro e contro. Se vuoi muoverti nel tuo sistema come un ninja, dovrai scegliere uno di questi editor di testo da utilizzare. Sono essenzialmente editor per la codifica, l'elaborazione di documenti di testo e praticamente tutto in uno.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continua!",
          "slug": "editor-testo-vim-emacs",
          "title": "Editor di testo"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Vim sta per vi (Migliorato) proprio come il suo nome sta per una versione migliorata del comando dell'editor di testo vi.\n\nÈ estremamente leggero, aprire e modificare un file con vim è veloce e facile. È anche quasi sempre disponibile, se avvii una distribuzione Linux casuale, è probabile che vim sia installato di default. \n\nPer avviare vim basta digitare: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continua!",
          "slug": "vimtexteditor",
          "title": "Vim (Vi Migliorato)"
        },
        {
          "exercise": "Gioca con il tasto di ricerca, apri un file di testo in vim con: vim [filediTesto] e inizia a cercare!",
          "id": 4,
          "lessonContent": "Per cercare un'espressione basta digitare il tasto / e poi il risultato della ricerca mentre sei in una sessione di vim. Una volta premuto invio, puoi premere \"n\" per andare avanti o \"N\" per andare indietro nei risultati della ricerca.\n\n<pre>\nIl mio file è molto bello.\n\n/bello\n\ntroverà le parole belle nel file di testo.\n</pre>\n\n\nIl comando di ricerca ? cercherà nel file di testo all'indietro, quindi nell'esempio precedente, l'ultima parola 'bello' verrebbe visualizzata per prima. \n<pre>\nIl mio file è molto bello.\n\n?bello\n\ntroverà le parole belle nel file di testo.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Quale tasto viene utilizzato per cercare in vim?",
          "slug": "vimsearchpatterns",
          "title": "Vim Search Patterns"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Ora potresti notare che il mouse non viene utilizzato qui. Per navigare un documento di testo in vim, utilizza i seguenti tasti: \n\n<ul>\n<li>h o la freccia sinistra - ti sposterà a sinistra di un carattere</li>\n<li>k o la freccia in alto - ti sposterà su di una riga</li>\n<li>j o la freccia in basso - ti sposterà giù di una riga</li>\n<li>l o la freccia destra - ti sposterà a destra di un carattere</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "Quale lettera viene utilizzata per spostarsi in basso?",
          "slug": "vimnavigation",
          "title": "Navigazione in Vim"
        },
        {
          "exercise": "Gioca con l'entrata e l'uscita dalla modalità di inserimento.",
          "id": 6,
          "lessonContent": "<p>Ora potresti aver notato che se provi a digitare qualcosa non sarai in grado di farlo. Questo perché sei in modalità comando. Questo può diventare piuttosto confuso soprattutto se vuoi semplicemente aprire un file e inserire del testo. La modalità comando è utilizzata quando si inseriscono comandi come h, j, k, l, ecc. Per inserire del testo dovrai prima entrare in modalità inserimento.</p><p></p><ul><br><li>i - inserisce testo prima del cursore</li><br><li>O - inserisce testo sulla riga precedente</li><br><li>o - inserisce testo sulla riga successiva</li><br><li>a - aggiunge testo dopo il cursore</li><br><li>A - aggiunge testo alla fine della riga</li><br></ul><p></p><p>Nota come quando digiti una qualsiasi di queste modalità di inserimento, vedrai che vim è entrato in modalità inserimento in fondo alla shell. Per uscire dalla modalità inserimento e tornare in modalità comando, basta premere il tasto Esc.</p>",
          "quizAnswer": "i",
          "quizQuestion": "Quale tasto viene utilizzato per inserire del testo prima del cursore?",
          "slug": "viminserimentoaggiungendotesto",
          "title": "Vim Aggiunta di Testo"
        },
        {
          "exercise": "So che questa lezione ha aggiunto alcune eccezioni, apri un editor di testo e gioca con queste.",
          "id": 7,
          "lessonContent": "Ora che abbiamo scritto un paio di righe, modifichiamole un po' e rimuoviamo un po' di spazzatura.<br><p></p><ul><br><li>x - utilizzato per tagliare il testo selezionato, utilizzato anche per eliminare caratteri</li><br><li>dd - utilizzato per eliminare la riga corrente</li><br><li>y - copia ciò che è selezionato</li><br><li>yy - copia la riga corrente</li><br><li>p - incolla il testo copiato prima del cursore</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "Quale carattere viene utilizzato per eliminare un'intera riga?",
          "slug": "modificainvim",
          "title": "Modifica in Vim"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 8,
          "lessonContent": "Ora che hai finito di modificare, è tempo di salvare e uscire da vim: \n\n<ul>\n<li>:w - scrive o salva il file</li>\n<li>:q - esce da vim</li>\n<li>:wq - scrive e poi esce</li>\n<li>:q! - esce da vim senza salvare il file</li>\n<li>ZZ - equivalente a :wq, ma un carattere più veloce</li>\n\n<li>u - annulla la tua ultima azione</li>\n<li>Ctrl-r - ripete la tua ultima azione</li>\n</ul>\n\nPotresti pensare che ZZ non sia necessario, ma alla fine vedrai che le tue dita potrebbero preferire questo piuttosto che :wq.\n\nWow, è stata molta informazione su Vim. Ora che conosci alcuni comandi di base e la navigazione, puoi iniziare a modificare alcuni file di testo. Ci sono molte altre opzioni che puoi utilizzare in vim per migliorare la tua capacità di padroneggiare questo editor di testo, vai alla guida online di Vim per dare un'occhiata.",
          "quizAnswer": ":q!",
          "quizQuestion": "Come si esce da vim senza salvare?",
          "slug": "salvataggiouscitavim",
          "title": "Salvataggio ed uscita da Vim"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 9,
          "lessonContent": "Emacs è per gli utenti che desiderano un editor di testo estremamente potente, il che potrebbe essere un eufemismo perché essenzialmente si vive in emacs. Puoi fare tutto il tuo editing di codice, manipolazione di file, ecc. tutto all'interno di emacs. È un po' più lento da avviare e la curva di apprendimento è un po' più ripida rispetto a vim, ma se desideri un editor potente che sia estremamente estensibile, questo è quello che fa per te. Quando dico estensibile, intendo letteralmente che puoi scrivere script per emacs che estendono la sua funzionalità.\n\nPer avviare emacs usa semplicemente:\n\n<pre>emacs</pre>\n\nDovresti essere accolto con il buffer di benvenuto predefinito.\n\nI buffer in emacs sono dove risiede il tuo testo. Quindi se apri un file, un buffer viene utilizzato per memorizzare il contenuto di quel file. Puoi avere aperti contemporaneamente più buffer e puoi passare facilmente da un buffer all'altro.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continua!",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Gioca con l'apertura e il salvataggio dei file.",
          "id": 10,
          "lessonContent": "In molti (se non tutti) i documenti di Emacs, vedrai la sintassi C-[lettera]. Questo significa semplicemente premere il tasto Ctrl-lettera, ma per scopi di abbreviazione, chiameremo Ctrl con C. Se vedi una sintassi come M-[lettera], significa utilizzare il tasto Meta, comunemente il tasto Alt.\n\n<b>Salvataggio dei file</b>\n\n<pre>\nC-x C-s - Salva un file\nC-x C-w - Salva il file come\nC-x s - Salva tutto\n</pre>\n\nLe opzioni di salvataggio del file ti chiederanno se desideri salvare ciascun file.\n\n<b>Apertura di un file</b>\n\n<pre>\nC-x C-f\n</pre>\n\nQuesto ti chiederà di digitare un nome file da aprire. Se non hai già un file esistente, ne creerà uno nuovo. Puoi caricare anche una directory.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "Quale comando viene utilizzato per aprire un file?",
          "slug": "emacsmanipulatefiles",
          "title": "Emacs Manipulate Files"
        },
        {
          "exercise": "Gioca con i buffer.",
          "id": 11,
          "lessonContent": "Per spostarti tra i buffer (o file che stai visitando) utilizza i seguenti comandi:\n\n<b>Cambiare buffer</b>\n\n<pre>\nC-x b - cambia buffer\nC-x freccia destra - ciclo a destra tra i buffer\nC-x freccia sinistra - ciclo a sinistra tra i buffer\n</pre>\n\n<b>Chiudere il buffer</b>\n\n<pre>C-x k</pre>\n\n<b>Dividere il buffer corrente</b>\n\n<pre>C-x 2</pre>\n\nQuesto ti consente di visualizzare più buffer su un'unica schermata. Per spostarti tra questi buffer utilizza: C-x o\n\n<b>Impostare un singolo buffer come schermata corrente</b>\n\n<pre>C-x 1</pre>\n\nSe hai mai usato un multiplexer di terminale come screen e tmux, i comandi del buffer ti sembreranno molto familiari.",
          "quizAnswer": "C-x k",
          "quizQuestion": "Come si elimina un buffer?",
          "slug": "emacsbuffernavigation",
          "title": "Navigazione del buffer di Emacs"
        },
        {
          "exercise": "Gioca con la navigazione del testo.",
          "id": 12,
          "lessonContent": "<b>Navigazione del testo</b>\n\n<pre>\nC-freccia su : spostarsi su di un paragrafo\nC-freccia giù: spostarsi giù di un paragrafo\nC-freccia sinistra: spostarsi di una parola a sinistra\nC-freccia destra: spostarsi di una parola a destra\nM-> : spostarsi alla fine del buffer\n</pre>\n\nCon la navigazione del testo, i tuoi pulsanti di testo regolari funzionano come dovrebbero, home, end, page up, page down e i tasti freccia, ecc.\n\n<b>Taglio e Incolla</b>\n\nPer tagliare (kill) o incollare (yank) in Emacs è necessario essere in grado di selezionare prima il testo. Per selezionare il testo, sposta il cursore dove vuoi tagliare o incollare e premi <pre>tasto C-space</pre> poi puoi usare i tasti di navigazione per selezionare il testo desiderato. Ora puoi fare il taglio e l'incolla in questo modo:\n\n<pre>\nC-w : taglia\nC-y : incolla\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "Come ti sposti alla fine del buffer?",
          "slug": "modificaemacs",
          "title": "Modifica di Emacs"
        },
        {
          "exercise": "Visita il sito di Emacs per imparare altri comandi. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Per chiudere Emacs</b>\n\n<pre>C-x C-c</pre>\n\nSe hai dei buffer aperti, ti chiederà di salvarli prima di chiudere Emacs.\n\n<b>Confuso?</b>\n\n<pre>C-h C-h : menu di aiuto</pre>\n\n<b>Annulla</b>\n\n<pre>C-x u</pre>\n\nCome puoi vedere, Emacs ha più parti in movimento, quindi la curva di apprendimento è un po' più ripida. In cambio, però, ottieni un editor di testo molto potente.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "Come si accede al menu di aiuto?",
          "slug": "emacsexitingandhelp",
          "title": "Emacs Uscita e Aiuto"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Advanced Text-Fu"
    },
    {
      "description": "Scopri i ruoli degli utenti e la gestione.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "In qualsiasi sistema operativo tradizionale, ci sono utenti e gruppi. Esistono esclusivamente per l'accesso e le autorizzazioni. Quando si esegue un processo, verrà eseguito come proprietario di quel processo, che sia Jane o Bob. L'accesso ai file e la proprietà dipendono anche dalle autorizzazioni. Non vorresti che Jane vedesse i documenti di Bob e viceversa. \n\nOgni utente ha la propria directory home dove vengono memorizzati i file specifici dell'utente, di solito situata in /home/nomeutente, ma può variare in diverse distribuzioni. \n\nIl sistema utilizza gli id utente (UID) per gestire gli utenti, i nomi utente sono il modo amichevole per associare gli utenti all'identificazione, ma il sistema identifica gli utenti dal loro UID. Il sistema utilizza anche i gruppi per gestire le autorizzazioni, i gruppi sono semplicemente insiemi di utenti con autorizzazioni impostate da quel gruppo, sono identificati dal sistema con il loro id gruppo (GID).\n\nIn Linux, avrai utenti oltre agli umani normali che utilizzano il sistema. A volte questi utenti sono demoni di sistema che eseguono continuamente processi per mantenere il sistema funzionante. Uno degli utenti più importanti è root o superutente, root è l'utente più potente del sistema, root può accedere a qualsiasi file e avviare e terminare qualsiasi processo. Per questo motivo, può essere pericoloso operare sempre come root, potresti potenzialmente rimuovere file critici di sistema. Fortunatamente, se è necessario l'accesso come root e un utente ha l'accesso come root, possono eseguire un comando come root invece con il comando sudo. Il comando sudo (superutente fare) viene utilizzato per eseguire un comando con accesso root, approfondiremo meglio come un utente riceve l'accesso root in una lezione successiva.\n\nProva a visualizzare un file protetto come /etc/shadow:\n\n<pre>$ cat /etc/shadow</pre>\n\nNota come ottieni un errore di permesso negato, guarda le autorizzazioni con: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nNon abbiamo ancora affrontato le autorizzazioni, ma cosa succede qui è che root è il proprietario del file e avrai bisogno di accesso root o far parte del gruppo shadow per leggere i contenuti. Ora esegui il comando con sudo:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nOra sarai in grado di vedere i contenuti del file!",
          "quizAnswer": "sudo",
          "quizQuestion": "Quale comando si utilizza per eseguire come root?",
          "slug": "utentiegruppi",
          "title": "Utenti e Gruppi"
        },
        {
          "exercise": "Apri il file /etc/sudoers e verifica quali permessi da superutente hanno gli altri utenti sulla macchina.",
          "id": 2,
          "lessonContent": "Abbiamo esaminato un modo per ottenere l'accesso come superutente utilizzando il comando sudo. È anche possibile eseguire comandi come superutente con il comando su. Questo comando \"sostituirà gli utenti\" e aprirà una shell di root se non viene specificato alcun nome utente. Puoi utilizzare questo comando per sostituirti a qualsiasi utente purché tu conosca la password. \n\n<pre>$ su</pre>\n\nCi sono alcuni svantaggi nell'utilizzare questo metodo: è molto più facile commettere un errore critico eseguendo tutto come root, non avrai registrazioni dei comandi che utilizzi per modificare le configurazioni di sistema, ecc. Fondamentalmente, se hai bisogno di eseguire comandi come superutente, attieniti a sudo.\n\nOra che sai quali comandi eseguire come superutente, la domanda è come sapere chi ha accesso a farlo? Il sistema non permette a ogni singolo utente di eseguire comandi come superutente, quindi come lo sa? Esiste un file chiamato file /etc/sudoers, questo file elenca gli utenti che possono eseguire sudo. Puoi modificare questo file con il comando <b>visudo</b>.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "Quale file mostra gli utenti che hanno accesso a sudo?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Guarda il tuo file /etc/passwd, dai un'occhiata ad alcuni degli utenti e nota gli accessi che hanno.",
          "id": 3,
          "lessonContent": "Ricorda che i nomi utente non sono realmente identificativi per gli utenti. Il sistema utilizza un ID utente (UID) per identificare un utente. Per scoprire a quale ID sono mappati gli utenti, guarda il file /etc/passwd. \n\n<pre>$ cat /etc/passwd</pre>\n\nQuesto file ti mostra un elenco di utenti e informazioni dettagliate su di loro. Ad esempio, la prima riga di questo file probabilmente assomiglia a questa:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nOgni riga visualizza informazioni sull'utente per un utente, più comunemente vedrai l'utente root come prima riga. Ci sono molti campi separati da due punti che forniscono informazioni aggiuntive sull'utente, vediamoli tutti:\n\n<ol>\n<li>Nome utente</li>\n<li>Password dell'utente - la password non è realmente memorizzata in questo file, di solito è memorizzata nel file /etc/shadow. Ne parleremo di più nella prossima lezione su /etc/shadow, ma per ora sappi che contiene password utente criptate. Puoi vedere molti simboli diversi in questo campo, se vedi una \"x\" significa che la password è memorizzata nel file /etc/shadow, un \"*\" significa che l'utente non ha accesso al login e se c'è un campo vuoto significa che l'utente non ha una password.</li>\n<li>L'ID utente - come puoi vedere root ha l'UID 0</li>\n<li>L'ID del gruppo</li>\n<li>Campo GECOS - Questo viene utilizzato per lasciare generalmente commenti sull'utente o sull'account come il loro vero nome o numero di telefono, è separato da virgole.</li>\n<li>Directory home dell'utente</li>\n<li>Shell dell'utente - probabilmente vedrai molti utenti che utilizzano bash come shell predefinita</li>\n</ol>\n\nNormalmente in una pagina di impostazioni dell'utente, ti aspetteresti di vedere solo utenti umani. Tuttavia, noterai che /etc/passwd contiene anche altri utenti. Ricorda che gli utenti sono realmente presenti nel sistema solo per eseguire processi con diverse autorizzazioni. A volte vogliamo eseguire processi con autorizzazioni predefinite. Ad esempio, l'utente daemon è utilizzato per i processi daemon.\n\nInoltre, dovresti notare che puoi modificare il file /etc/passwd a mano se desideri aggiungere utenti e modificare informazioni con lo strumento <b>vipw</b>, tuttavia è meglio lasciare queste operazioni agli strumenti di cui parleremo in una lezione successiva come useradd e userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Se un utente non ha accesso al login, come viene indicato in /etc/passwd?",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Dai un'occhiata al file /etc/shadow",
          "id": 4,
          "lessonContent": "Il file /etc/shadow viene utilizzato per memorizzare informazioni sull'autenticazione dell'utente. Richiede le autorizzazioni di lettura dell'amministratore di sistema. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nNoterai che assomiglia molto al contenuto del file /etc/passwd, tuttavia nel campo della password vedrai una password criptata. I campi sono separati dai due punti come segue:\n\n<ol>\n<li>Nome utente</li>\n<li>Password criptata</li>\n<li>Data dell'ultimo cambio di password - espressa come il numero di giorni trascorsi dal 1° gennaio 1970. Se c'è un 0 significa che l'utente dovrebbe cambiare la password la prossima volta che accede</li>\n<li>Età minima della password - Giorni che un utente dovrà attendere prima di poter cambiare nuovamente la password</li>\n<li>Età massima della password - Numero massimo di giorni prima che un utente debba cambiare la password</li>\n<li>Periodo di avviso sulla password - Numero di giorni prima che una password stia per scadere</li>\n<li>Periodo di inattività della password - Numero di giorni dopo che una password è scaduta per consentire l'accesso con la password</li>\n<li>Data di scadenza dell'account - data in cui l'utente non potrà effettuare l'accesso</li>\n<li>Campo riservato per utilizzi futuri</li>\n</ol>\n\nNella maggior parte delle distribuzioni odierna, l'autenticazione dell'utente non si basa solo sul file /etc/shadow, ci sono altri meccanismi in atto come PAM (Pluggable Authentication Modules) che sostituiscono l'autenticazione.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, prosegui!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Esegui il comando <b>groups</b>. Cosa vedi?",
          "id": 5,
          "lessonContent": "Un altro file utilizzato nella gestione degli utenti è il file /etc/group. Questo file consente di creare diversi gruppi con diverse autorizzazioni. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nMolto simile al campo /etc/password, i campi /etc/group sono i seguenti:\n\n<ol>\n<li>Nome del gruppo</li>\n<li>Password del gruppo - non c'è bisogno di impostare una password per il gruppo, l'uso di un privilegio elevato come sudo è standard. Un \"*\" verrà inserito come valore predefinito.</li>\n<li>ID del gruppo (GID)</li>\n<li>Elenco degli utenti - è possibile specificare manualmente gli utenti che si desidera nel gruppo specifico</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "Qual è l'ID del gruppo (GID) di root?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "Crea un nuovo utente, quindi cambia la loro password e accedi come il nuovo utente.",
          "id": 6,
          "lessonContent": "La maggior parte degli ambienti enterprise utilizza sistemi di gestione per gestire utenti, account e password. Tuttavia, su un singolo computer è possibile utilizzare comandi utili per gestire gli utenti.\n\n<b>Aggiunta di utenti</b>\n\nPuoi utilizzare il comando adduser o useradd. Il comando adduser contiene funzionalità più utili come la creazione di una directory home e altro ancora. Ci sono file di configurazione per l'aggiunta di nuovi utenti che possono essere personalizzati in base a ciò che si desidera assegnare a un utente predefinito. \n\n<pre>$ sudo useradd bob</pre>\n\nVedrai che il comando sopra crea un'entrata in /etc/passwd per bob, imposta gruppi predefiniti e aggiunge un'entrata al file /etc/shadow.\n\n<b>Rimozione degli utenti</b>\n\nPer rimuovere un utente, puoi utilizzare il comando userdel.\n\n<pre>$ sudo userdel bob</pre>\n\nQuesto cerca essenzialmente di annullare le modifiche apportate da useradd.\n\n<b>Cambio delle password</b>\n\n<pre>$ passwd bob</pre>\n\nQuesto ti permetterà di cambiare la password di te stesso o di un altro utente (se sei root).",
          "quizAnswer": "passwd",
          "quizQuestion": "Quale comando viene utilizzato per cambiare una password?",
          "slug": "strumetidigestioneutenti",
          "title": "Strumenti di gestione utenti"
        }
      ],
      "slug": "usermanagement",
      "title": "Gestione utenti"
    },
    {
      "description": "Scopri i livelli di permesso e la modifica dei permessi.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Usa il comando ls -l su più file e recita i loro permessi, utente e gruppo.",
          "id": 1,
          "lessonContent": "Come abbiamo imparato in precedenza, i file hanno diversi permessi o modalità file. Vediamo un esempio:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nCi sono quattro parti nei permessi di un file. La prima parte è il tipo di file, che è indicato dal primo carattere nei permessi, nel nostro caso poiché stiamo guardando una directory mostra <b>d</b> per il tipo di file. Più comunemente vedrai un <b>-</b> per un file regolare. \n\nLe tre parti successive della modalità file sono i permessi effettivi. I permessi sono raggruppati in 3 bit ciascuno. I primi 3 bit sono i permessi dell'utente, poi i permessi del gruppo e infine i permessi degli altri. Ho aggiunto il pipe per renderlo più facile da differenziare.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nOgni carattere rappresenta un permesso diverso: \n<ul>\n<li>r: leggibile</li>\n<li>w: scrivibile</li>\n<li>x: eseguibile (fondamentalmente un programma eseguibile)</li>\n<li>-: vuoto</li>\n</ul>\n\nQuindi nell'esempio sopra, vediamo che l'utente pete ha i permessi di lettura, scrittura ed esecuzione sul file. Il gruppo penguins ha i permessi di lettura ed esecuzione. E infine, gli altri utenti (tutti gli altri) hanno i permessi di lettura ed esecuzione.",
          "quizAnswer": "x",
          "quizQuestion": "Quale bit di permesso viene utilizzato per l'esecuzione?",
          "slug": "filepermissions",
          "title": "Permessi dei file"
        },
        {
          "exercise": "Modifica alcuni permessi di base di file di testo e osserva i bit che cambiano mentre esegui un ls -l.",
          "id": 2,
          "lessonContent": "La modifica dei permessi può essere facilmente eseguita con il comando <b>chmod</b>. \n\nPrima di tutto, scegli quale set di permessi desideri modificare, utente, gruppo o altri. Puoi aggiungere o rimuovere permessi con un <b>+</b> o un <b>-</b>, vediamo alcuni esempi.\n\n<b>Aggiunta di un bit di permesso su un file</b>\n<pre>$ chmod u+x myfile</pre>\n\nIl comando sopra si legge così: cambia il permesso su myfile aggiungendo il bit di permesso eseguibile al set dell'utente. Quindi ora l'utente ha il permesso eseguibile su questo file!\n\n<b>Rimozione di un bit di permesso su un file</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>Aggiunta di più bit di permesso su un file</b>\n<pre>$ chmod ug+w</pre>\n\nC'è un altro modo per modificare i permessi utilizzando il formato numerico. Questo metodo ti consente di modificare i permessi tutti in una volta. Invece di usare r, w o x per rappresentare i permessi, userai una rappresentazione numerica per un singolo set di permessi. Quindi non c'è bisogno di specificare il gruppo con g o l'utente con u.\n\nLe rappresentazioni numeriche sono viste di seguito:\n\n<ul>\n<li>4: permesso di lettura</li>\n<li>2: permesso di scrittura</li>\n<li>1: permesso di esecuzione</li>\n</ul>\n\nGuardiamo un esempio: \n\n<pre>$ chmod 755 myfile</pre>\n\nRiesci a indovinare quali permessi stiamo dando a questo file? Analizziamolo, quindi ora 755 copre i permessi per tutti i set. Il primo numero (7) rappresenta i permessi dell'utente, il secondo numero (5) rappresenta i permessi del gruppo e l'ultimo 5 rappresenta i permessi degli altri. \n\nAspetta un attimo, 7 e 5 non erano elencati sopra, da dove arrivano questi numeri? Ricorda che stiamo combinando tutti i permessi in un unico numero ora, quindi dovrai coinvolgere un po' di matematica.\n\n7 = 4 + 2 + 1, quindi 7 sono i permessi dell'utente e ha permessi di lettura, scrittura ed esecuzione\n\n5 = 4 + 1, il gruppo ha permessi di lettura ed esecuzione\n\n5 = 4 + 1, e tutti gli altri utenti hanno permessi di lettura ed esecuzione\n\nUna cosa da notare: non è una grande idea cambiare i permessi in modo casuale, potresti potenzialmente esporre un file sensibile a tutti per essere modificato, tuttavia molte volte vuoi legittimamente cambiare i permessi, basta prendere precauzioni quando si utilizza il comando chmod.",
          "quizAnswer": "4",
          "quizQuestion": "Quale numero rappresenta il permesso di lettura quando si utilizza il formato numerico?",
          "slug": "modificadeipermessi",
          "title": "Modifica dei permessi"
        },
        {
          "exercise": "Modifica il gruppo e l'utente di alcuni file di test. Successivamente controlla i permessi con ls -l.",
          "id": 3,
          "lessonContent": "Oltre a modificare i permessi sui file, è possibile modificare anche il gruppo e la proprietà dell'utente del file. \n\n<b>Modifica della proprietà dell'utente</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nQuesto comando imposterà il proprietario di myfile su patty.\n\n<b>Modifica della proprietà del gruppo</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nQuesto comando imposterà il gruppo di myfile su whales.\n\n<b>Modifica sia la proprietà dell'utente che del gruppo contemporaneamente</b>\nSe aggiungi due punti e il nome del gruppo dopo l'utente, puoi impostare contemporaneamente sia l'utente che il gruppo.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "Quale comando si utilizza per cambiare la proprietà dell'utente?",
          "slug": "ownershippermissions",
          "title": "Permessi di proprietà"
        },
        {
          "exercise": "<ol>\n<li>Crea un nuovo file, quindi annota i suoi permessi.</li>\n<li>Modifica l'umask e quindi crea un altro nuovo file.</li>\n<li>Controlla nuovamente i permessi sul nuovo file, cosa ti aspetti di vedere?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Ogni file che viene creato ha un insieme predefinito di permessi. Se desideri modificare tale insieme predefinito di permessi, puoi farlo con il comando umask. Questo comando prende l'insieme di permessi a 3 bit che vediamo nei permessi numerici.\n\nInvece di aggiungere questi permessi, però, umask toglie questi permessi.\n\n<pre>$ umask 021</pre>\n\nNell'esempio sopra, stiamo dichiarando che vogliamo che i permessi predefiniti dei nuovi file consentano agli utenti l'accesso a tutto, ma per i gruppi vogliamo togliere il permesso di scrittura e per gli altri vogliamo togliere il permesso di esecuzione. L'umask predefinito nella maggior parte delle distribuzioni è 022, il che significa accesso per tutti gli utenti, ma nessun accesso in scrittura per gruppi e altri utenti.\n\nQuando esegui il comando umask, verrà applicato quell'insieme predefinito di permessi su qualsiasi nuovo file che crei. Tuttavia, se desideri che persista, dovrai modificare il tuo file di avvio (.profile), ma ne parleremo in una lezione successiva.",
          "quizAnswer": "umask",
          "quizQuestion": "Quale comando viene utilizzato per modificare i permessi predefiniti dei file?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Guarda i permessi per /etc/passwd in dettaglio, noti qualcos'altro? I file con SUID abilitato sono facilmente distinguibili.",
          "id": 5,
          "lessonContent": "Ci sono molti casi in cui gli utenti normali hanno bisogno di un accesso elevato per fare cose. L'amministratore di sistema non può sempre essere presente per inserire una password di root ogni volta che un utente ha bisogno di accedere a un file protetto, quindi ci sono speciali bit di permessi sui file per consentire questo comportamento. Il Set User ID (SUID) consente a un utente di eseguire un programma come proprietario del file del programma anziché come se stessi.\n\nGuardiamo un esempio: \n\nImmaginiamo che voglio cambiare la mia password, semplice vero? Basta usare il comando passwd:\n\n<pre>$ passwd</pre>\n\nCosa fa il comando password? Sta modificando un paio di file, ma soprattutto sta modificando il file /etc/shadow. Diamo un'occhiata a quel file per un attimo: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nAspetta un attimo qui, questo file è di proprietà di root? Come è possibile che siamo in grado di modificare un file di proprietà di root? \n\nDiamo un'occhiata a un altro insieme di permessi, questa volta del comando che abbiamo eseguito: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nNoterai un nuovo bit di permesso qui <b>s</b>. Questo bit di permesso è il SUID, quando un file ha impostato questo permesso, consente agli utenti che hanno avviato il programma di ottenere i permessi del proprietario del file nonché i permessi di esecuzione, in questo caso root. Quindi essenzialmente mentre un utente sta eseguendo il comando password, sta eseguendo come root.\n\nEcco perché siamo in grado di accedere a un file protetto come /etc/shadow quando eseguiamo il comando passwd. Ora, se rimuovessi quel bit, vedresti che non sarai in grado di modificare /etc/shadow e quindi cambiare la tua password. \n\n<b>Modifica SUID</b>\n\nCome i permessi regolari, ci sono due modi per modificare i permessi SUID. \n\n<i>Modo simbolico:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Modo numerico:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nCome puoi vedere, il SUID è indicato da un 4 e preposto all'insieme di permessi. Potresti vedere il SUID indicato come una maiuscola <b>S</b>, questo significa che fa comunque la stessa cosa, ma non ha i permessi di esecuzione.",
          "quizAnswer": "4",
          "quizQuestion": "Quale numero rappresenta il SUID?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 6,
          "lessonContent": "Simile al bit di autorizzazione set user ID, esiste un bit di autorizzazione set group ID (SGID). Questo bit consente a un programma di eseguire come se fosse un membro di quel gruppo. \n\nGuardiamo un esempio: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nOra possiamo vedere che il bit di autorizzazione è nel set di autorizzazioni del gruppo. \n\n<b>Modifica di SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nLa rappresentazione numerica per SGID è 2.",
          "quizAnswer": "2",
          "quizQuestion": "Quale numero rappresenta il SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Non abbiamo ancora discusso i processi, possiamo comunque dare un'occhiata a questo cambiamento in tempo reale: \n\n<ol>\n<li>Apri una finestra del terminale e esegui il comando: <b>watch -n 1 \"ps aux | grep passwd\"</b>. Questo controllerà il processo passwd.</li>\n<li>Apri una seconda finestra del terminale e esegui: <b>passwd</b></li>\n<li>Guarda la prima finestra del terminale, vedrai comparire un processo per passwd. La prima colonna nella tabella dei processi è l'UID utente effettivo, ecco che è l'utente root!</li>\n</ol>",
          "id": 7,
          "lessonContent": "Passiamo ai permessi di processo per un attimo, ricordi quando ti ho detto che quando esegui il comando passwd con il bit di permesso SUID abilitato eseguirai il programma come root? Questo è vero, tuttavia ciò significa che essendo temporaneamente root puoi modificare le password di altri utenti? No, fortunatamente no!\n\nQuesto perché Linux implementa molti UID. Ci sono tre UID associati ad ogni processo:\n\nQuando avvii un processo, esso viene eseguito con gli stessi permessi dell'utente o del gruppo che lo ha avviato, questo è noto come <b>UID utente effettivo</b>. Questo UID viene utilizzato per concedere diritti di accesso a un processo. Quindi naturalmente se Bob ha avviato il comando touch, il processo verrà eseguito come lui e eventuali file creati saranno di sua proprietà.\n\nC'è un altro UID, chiamato <b>UID utente reale</b>, che è l'ID dell'utente che ha avviato il processo. Questi vengono utilizzati per rintracciare chi è l'utente che ha avviato il processo.\n\nUn ultimo UID è il <b>UID utente salvato</b>, che consente a un processo di passare tra l'UID utente effettivo e l'UID utente reale, viceversa. Questo è utile perché non vogliamo che il nostro processo venga eseguito con privilegi elevati tutto il tempo, è solo una buona pratica utilizzare privilegi speciali in momenti specifici. \n\nOra mettiamo insieme tutto questo guardando nuovamente il comando passwd. \n\nQuando si esegue il comando passwd, il tuo UID effettivo è il tuo ID utente, diciamo che è 500 per ora. Oh, ma aspetta, ricorda che il comando passwd ha abilitato il permesso SUID. Quindi quando lo esegui, il tuo UID effettivo è ora 0 (0 è l'UID di root). Ora questo programma può accedere ai file come root.\n\nDiciamo che ti prendi un po' di potere e vuoi modificare la password di Sally, Sally ha un UID di 600. Beh, sarai sfortunato, fortunatamente il processo ha anche il tuo UID reale in questo caso 500. Sa che il tuo UID è 500 e quindi non puoi modificare la password dell'UID 600. (Questo ovviamente viene sempre bypassato se sei un superutente su una macchina e puoi controllare e cambiare tutto).\n\nDato che hai eseguito passwd, avvierà il processo utilizzando il tuo UID reale e salverà l'UID del proprietario del file (UID effettivo), in modo da poter passare tra i due. Non c'è bisogno di modificare tutti i file con accesso root se non è necessario. \n\nNella maggior parte dei casi l'UID reale e l'UID effettivo sono gli stessi, ma in casi come il comando passwd cambieranno.",
          "quizAnswer": "effettivo",
          "quizQuestion": "Quale UID decide quali accessi concedere?",
          "slug": "permessidiprocesso",
          "title": "Permessi di processo"
        },
        {
          "exercise": "Quali altri file e directory pensi abbiano abilitato un bit sticky?",
          "id": 8,
          "lessonContent": "Un altro bit di permesso speciale di cui voglio parlare è il bit sticky. \n\nQuesto bit di permesso \"attacca un file/directory\", il che significa che solo il proprietario o l'utente root possono eliminare o modificare il file. Questo è molto utile per le directory condivise. Dai un'occhiata all'esempio qui sotto:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nVedrai un bit di permesso speciale alla fine qui <b>t</b>, questo significa che tutti possono aggiungere file, scrivere file, modificare file nella directory /tmp, ma solo root può eliminare la directory /tmp. \n\n<b>Modifica del bit sticky</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nLa rappresentazione numerica per il bit sticky è <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "Quale simbolo rappresenta il bit sticky?",
          "slug": "stickybit",
          "title": "Il bit sticky"
        }
      ],
      "slug": "permissions",
      "title": "Permessi"
    },
    {
      "description": "Scopri quali processi sono in esecuzione sul sistema.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Utilizza il comando ps con diverse opzioni e osserva come cambia l'output.",
          "id": 1,
          "lessonContent": "I processi sono i programmi che stanno eseguendo sulla tua macchina. Sono gestiti dal kernel e ogni processo ha un ID associato chiamato <b>process ID (PID).</b> Questo PID viene assegnato nell'ordine in cui i processi vengono creati. \n\nProva a eseguire il comando ps per vedere un elenco dei processi in esecuzione:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nQuesto ti mostra un rapido riepilogo dei processi attuali:\n\n<ul>\n<li>PID: Process ID</li>\n<li>TTY: Terminale di controllo associato al processo (ne parleremo dettagliatamente in seguito)</li>\n<li>STAT: Codice di stato del processo</li>\n<li>TIME: Tempo totale di utilizzo della CPU</li>\n<li>CMD: Nome dell'eseguibile/comando</li>\n</ul>\n\nSe guardi la pagina man per ps, vedrai che ci sono molte opzioni di comando che puoi passare, che varieranno a seconda delle opzioni che desideri utilizzare - BSD, GNU o Unix. Secondo me lo stile BSD è più popolare da usare, quindi andremo con quello. Se sei curioso, la differenza tra gli stili è la quantità di trattini che usi e le bandiere.\n\n<pre>$ ps aux</pre>\n\nIl <b>a</b> mostra tutti i processi in esecuzione, inclusi quelli eseguiti da altri utenti. Il <b>u</b> mostra maggiori dettagli sui processi. E infine il <b>x</b> elenca tutti i processi che non hanno un TTY associato, questi programmi mostreranno un ? nel campo TTY, sono più comuni nei processi daemon che vengono avviati come parte dell'avvio del sistema.\n\nNoterai che ora stai vedendo molti più campi, non c'è bisogno di memorizzarli tutti, in un corso successivo sui processi avanzati, ne ripasseremo alcuni di nuovo:\n\n<ul>\n<li>USER: L'utente effettivo (quello il cui accesso stiamo utilizzando)</li>\n<li>PID: Process ID</li>\n<li>%CPU: Tempo CPU utilizzato diviso per il tempo in cui il processo è stato in esecuzione</li>\n<li>%MEM: Rapporto tra la dimensione dell'insieme residente del processo e la memoria fisica sulla macchina</li>\n<li>VSZ: Utilizzo della memoria virtuale dell'intero processo</li>\n<li>RSS: Dimensione dell'insieme residente, la memoria fisica non scambiata che un'attività ha utilizzato</li>\n<li>TTY: Terminale di controllo associato al processo</li>\n<li>STAT: Codice di stato del processo</li>\n<li>START: Ora di avvio del processo</li>\n<li>TIME: Tempo totale di utilizzo della CPU</li>\n<li>COMMAND: Nome dell'eseguibile/comando</li>\n</ul>\n\nIl comando ps può diventare un po' disordinato da guardare, per ora i campi che guarderemo di più sono PID, STAT e COMMAND. \n\nUn altro comando molto utile è il comando <b>top</b>, top fornisce informazioni in tempo reale sui processi in esecuzione sul tuo sistema anziché uno snapshot. Per impostazione predefinita, otterrai un aggiornamento ogni 10 secondi. Top è uno strumento estremamente utile per vedere quali processi stanno utilizzando molte delle tue risorse. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "Quale opzione di ps viene utilizzata per visualizzare informazioni dettagliate sui processi?",
          "slug": "monitorprocessespscommand",
          "title": "ps (Processi)"
        },
        {
          "exercise": "Guarda il tuo output di ps e elenca tutti i valori TTY unici.",
          "id": 2,
          "lessonContent": "Abbiamo discusso di come ci sia un campo TTY nell'output di ps. Il TTY è il terminale che ha eseguito il comando.\n\nCi sono due tipi di terminali, dispositivi terminali regolari e dispositivi pseudoterminali. Un dispositivo terminale regolare è un dispositivo terminale nativo su cui puoi scrivere e inviare output al sistema, questo sembra simile all'applicazione terminale che hai usato per accedere alla tua shell, ma non lo è. \n\nAndremo avanti in modo che tu possa vedere questa azione, vai avanti e digita Ctrl-Alt-F1 per entrare in TTY1 (la prima console virtuale), noterai come non hai nulla tranne il terminale, nessuna grafica, ecc. Questo è considerato un dispositivo terminale regolare, puoi uscire da questo con Ctrl-Alt-F7. \n\nUn pseudoterminal è quello in cui sei abituato a lavorare, emulano terminali con la finestra del terminale della shell e sono indicati da PTS. Se guardi di nuovo ps, vedrai il tuo processo della shell sotto pts/*. \n\nOra, tornando al concetto di terminale di controllo, i processi di solito sono legati a un terminale di controllo. Ad esempio, se stavi eseguendo un programma sulla finestra della tua shell come find e chiudev i la finestra, anche il tuo processo verrebbe chiuso. \n\nCi sono processi come i processi daemon, che sono processi speciali che mantengono essenzialmente il sistema in esecuzione. Spesso vengono avviati all'avvio del sistema e di solito vengono terminati quando il sistema viene spento. Eseguono in background e poiché non vogliamo che questi processi speciali vengano terminati, non sono legati a un terminale di controllo. Nell'output di ps, il TTY è elencato come un ? significando che non ha un terminale di controllo.",
          "quizAnswer": "?",
          "quizQuestion": "Quale valore viene dato per un processo che non ha un terminale di controllo?",
          "slug": "controllingterminal",
          "title": "Controlling Terminal"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Prima di passare a applicazioni più pratiche dei processi, dobbiamo prima capire cosa sono e come funzionano. Questa parte può diventare confusa poiché ci addentriamo nei dettagli, quindi sentiti libero di tornare a questa lezione se non vuoi imparare ora. \n\nUn processo, come abbiamo detto prima, è un programma in esecuzione sul sistema, più precisamente è il sistema che alloca memoria, CPU, I/O per far funzionare il programma. Un processo è un'istanza di un programma in esecuzione, vai avanti e apri 3 finestre del terminale, in due finestre, esegui il comando <b>cat</b> senza passare alcuna opzione (il processo cat rimarrà aperto come processo perché si aspetta stdin). Ora nella terza finestra esegui: <b>ps aux | grep cat</b>. Vedrai che ci sono due processi per cat, anche se stanno chiamando lo stesso programma.\n\nIl kernel è responsabile dei processi, quando eseguiamo un programma il kernel carica il codice del programma in memoria, determina e alloca risorse e poi tiene d'occhio ogni processo, sa:\n\n<ul>\n<li>Lo stato del processo</li>\n<li>Le risorse che il processo sta utilizzando e ricevendo</li>\n<li>Il proprietario del processo</li>\n<li>Gestione dei segnali (ne parleremo più avanti)</li>\n<li>E praticamente tutto il resto</li>\n</ul>\n\nTutti i processi stanno cercando di assaggiare quella dolce torta di risorse, è compito del kernel assicurarsi che i processi ottengano la giusta quantità di risorse in base alle esigenze del processo. Quando un processo termina, le risorse che ha utilizzato vengono ora liberate per altri processi.",
          "quizAnswer": "kernel",
          "quizQuestion": "Cosa gestisce e controlla i processi?",
          "slug": "dettagliprocesso",
          "title": "Dettagli del processo"
        },
        {
          "exercise": "Guarda i tuoi processi in esecuzione, riesci a vedere quali altri processi hanno genitori?",
          "id": 4,
          "lessonContent": "Ancora una volta, questa lezione e la successiva forniscono informazioni per farti vedere cosa c'è sotto il cofano, sentiti libero di tornare su questo argomento una volta che avrai lavorato con i processi un po' di più.\n\nQuando viene creato un nuovo processo, un processo esistente si clona essenzialmente utilizzando qualcosa chiamato chiamata di sistema fork (le chiamate di sistema saranno discusse molto più avanti nel futuro). La chiamata di sistema fork crea un processo figlio quasi identico, questo processo figlio assume un nuovo ID processo (PID) e il processo originale diventa il suo processo genitore e ha qualcosa chiamato un ID processo genitore <b>PPID</b>. Successivamente, il processo figlio può continuare a utilizzare lo stesso programma che stava utilizzando il suo genitore prima o più spesso utilizzare la chiamata di sistema execve per avviare un nuovo programma. Questa chiamata di sistema distrugge la gestione della memoria che il kernel ha messo in atto per quel processo e ne imposta di nuove per il nuovo programma. \n\nPossiamo vedere questo in azione:\n\n<pre>$ ps l</pre>\n\nL'opzione l ci fornisce una vista \"formato lungo\" o ancora più dettagliata dei nostri processi in esecuzione. Vedrai una colonna etichettata <b>PPID</b>, che è l'ID del genitore. Ora guarda il tuo terminale, vedrai un processo in esecuzione che è la tua shell, quindi nel mio sistema ho un processo in esecuzione di bash. Ora ricorda che quando hai eseguito il comando ps l, lo hai eseguito dal processo che stava eseguendo bash. Ora vedrai che il <b>PID</b> della shell bash è il <b>PPID</b> del comando <b>ps l</b>.\n\nQuindi se ogni processo deve avere un genitore e sono solo cloni l'uno dell'altro, deve esserci una madre di tutti i processi, giusto? Hai ragione, quando il sistema si avvia, il kernel crea un processo chiamato <b>init</b>, ha un PID di 1. Il processo init non può essere terminato a meno che il sistema non venga spento. Viene eseguito con privilegi di root e avvia molti processi che mantengono il sistema in esecuzione. Esamineremo più da vicino init nel corso di avvio del sistema, per ora sappi solo che è il processo che genera tutti gli altri processi.",
          "quizAnswer": "fork",
          "quizQuestion": "Quale chiamata di sistema crea un nuovo processo?",
          "slug": "creazioneprocessi",
          "title": "Creazione di processi"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Ora che sappiamo cosa succede quando viene creato un processo, cosa succede quando non ne abbiamo più bisogno? Fate attenzione, a volte Linux può diventare un po' cupo...\n\nUn processo può uscire utilizzando la chiamata di sistema _exit, ciò libererà le risorse che il processo stava utilizzando per la riallocazione. Quindi quando un processo è pronto a terminare, comunica al kernel il motivo della sua terminazione con qualcosa chiamato stato di terminazione. Più comunemente uno stato di 0 significa che il processo ha avuto successo. Tuttavia, non è sufficiente per terminare completamente un processo. Il processo genitore deve riconoscere la terminazione del processo figlio utilizzando la chiamata di sistema wait e ciò che fa è controllare lo stato di terminazione del processo figlio. So che è brutale da pensare, ma la chiamata di wait è una necessità, dopotutto quale genitore non vorrebbe sapere come è morto il proprio figlio?\n\nC'è un altro modo per terminare un processo e coinvolge l'uso di segnali, di cui parleremo presto.\n\n<b>Processi Orfani</b>\n\nQuando un processo genitore muore prima di un processo figlio, il kernel sa che non riceverà una chiamata di wait, quindi invece rende questi processi \"orfani\" e li mette sotto la cura di init (ricordate la madre di tutti i processi). Init alla fine eseguirà la chiamata di sistema wait per questi orfani in modo che possano morire. \n\n<b>Processi Zombie</b>\n\nCosa succede quando un processo figlio termina e il processo genitore non ha ancora chiamato wait? Vogliamo comunque essere in grado di vedere come è terminato un processo figlio, quindi anche se il processo figlio è terminato, il kernel trasforma il processo figlio in un processo zombie. Le risorse utilizzate dal processo figlio sono ancora liberate per altri processi, tuttavia c'è ancora un'entrata nella tabella dei processi per questo zombie. I processi zombie non possono essere uccisi, poiché sono tecnicamente \"morti\", quindi non è possibile utilizzare segnali per ucciderli. Alla fine, se il processo genitore chiama la chiamata di sistema wait, lo zombie scomparirà, questo è conosciuto come \"reaping\". Se il genitore non esegue una chiamata di wait, init adotterà lo zombie ed eseguirà automaticamente wait e rimuoverà lo zombie. Può essere dannoso avere troppi processi zombie, poiché occupano spazio nella tabella dei processi e se si riempie impediranno ad altri processi di essere eseguiti.",
          "quizAnswer": "0",
          "quizQuestion": "Qual è lo stato di terminazione più comune per un processo che ha successo?",
          "slug": "terminazioneprocesso",
          "title": "Terminazione del processo"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 6,
          "lessonContent": "Un segnale è una notifica a un processo che qualcosa è accaduto.\n\n<b>Perché abbiamo i segnali</b>\n\nSono interruzioni software e hanno molti utilizzi:\n\n<ul>\n<li>Un utente può digitare uno dei caratteri speciali del terminale (Ctrl-C) o (Ctrl-Z) per terminare, interrompere o sospendere processi</li>\n<li>Possibili problemi hardware possono verificarsi e il kernel vuole notificare il processo</li>\n<li>Possibili problemi software possono verificarsi e il kernel vuole notificare il processo</li>\n<li>Sono essenzialmente modi in cui i processi possono comunicare</li>\n</ul>\n\n<b>Processo di segnale</b>\n\nQuando un segnale è generato da un evento, viene quindi consegnato a un processo, considerato in uno stato di attesa fino alla consegna. Quando il processo viene eseguito, il segnale verrà consegnato. Tuttavia, i processi hanno maschere di segnale e possono impostare la consegna del segnale come bloccata se specificato. Quando un segnale viene consegnato, un processo può fare molte cose:\n\n<ul>\n<li>Ignorare il segnale</li>\n<li>\"Catturare\" il segnale e eseguire una routine di gestione specifica</li>\n<li>Il processo può essere terminato, diversamente dalla normale chiamata di sistema di uscita</li>\n<li>Bloccare il segnale, a seconda della maschera di segnale</li>\n</ul>\n\n<b>Segnali comuni</b>\n\nOgni segnale è definito da interi con nomi simbolici che sono nella forma di SIGxxx. Alcuni dei segnali più comuni sono:\n\n<ul>\n<li>SIGHUP o HUP o 1: Chiusura</li>\n<li>SIGINT o INT o 2: Interruzione</li>\n<li>SIGKILL o KILL o 9: Termina</li>\n<li>SIGSEGV o SEGV o 11: Violazione di segmento</li>\n<li>SIGTERM o TERM o 15: Terminazione software</li>\n<li>SIGSTOP o STOP: Arresto</li>\n</ul>\n\nI numeri possono variare con i segnali, quindi di solito vengono indicati con i loro nomi.\n\nAlcuni segnali sono non bloccabili, un esempio è il segnale SIGKILL. Il segnale KILL distrugge il processo.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "Quale segnale è non bloccabile?",
          "slug": "segnalideiprocesso",
          "title": "Segnali"
        },
        {
          "exercise": "Terminare alcuni processi utilizzando diversi segnali.",
          "id": 7,
          "lessonContent": "È possibile inviare segnali che terminano i processi, un comando del genere è chiamato in modo appropriato il comando kill. \n\n<pre>$ kill 12445</pre>\n\nIl 12445 è il PID del processo che si desidera terminare. Per impostazione predefinita invia un segnale TERM. Il segnale SIGTERM viene inviato a un processo per richiederne la terminazione consentendogli di rilasciare pulitamente le sue risorse e salvare il suo stato. \n\nÈ anche possibile specificare un segnale con il comando kill: \n\n<pre>$ kill -9 12445</pre>\n\nQuesto eseguirà il segnale SIGKILL e terminerà il processo. \n\n<b>Differenze tra SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nQuesti segnali sembrano tutti abbastanza simili, ma hanno le loro differenze. \n\n<ul>\n<li>SIGHUP - Chiusura improvvisa, inviato a un processo quando il terminale di controllo viene chiuso. Ad esempio, se si chiude una finestra del terminale in cui stava eseguendo un processo, si riceverà un segnale SIGHUP. Quindi fondamentalmente ti hanno chiuso la comunicazione</li>\n<li>SIGINT - È un segnale di interruzione, quindi è possibile utilizzare Ctrl-C e il sistema cercherà di terminare il processo in modo corretto</li>\n<li>SIGTERM - Termina il processo, ma consente di eseguire alcune operazioni di pulizia prima</li>\n<li>SIGKILL - Termina il processo, lo termina immediatamente, senza eseguire alcuna operazione di pulizia</li>\n<li>SIGSTOP - Ferma/sospende un processo</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "Qual è il nome del segnale per il comando kill predefinito?",
          "slug": "terminareprocessi",
          "title": "kill (Terminare)"
        },
        {
          "exercise": "Quali processi non sono molto gradevoli e perché?",
          "id": 8,
          "lessonContent": "Quando esegui più cose sul tuo computer, come ad esempio Chrome, Microsoft Word o Photoshop contemporaneamente, potrebbe sembrare che questi processi stiano funzionando allo stesso tempo, ma non è esattamente vero. \n\nI processi utilizzano la CPU per un breve periodo di tempo chiamato fetta di tempo. Poi si mettono in pausa per millisecondi e un altro processo ottiene una piccola fetta di tempo. Per impostazione predefinita, la pianificazione dei processi avviene in questo modo a rotazione. Ogni processo ottiene abbastanza fette di tempo finché non ha finito di elaborare. Il kernel gestisce tutti questi passaggi di processi e lo fa abbastanza bene la maggior parte delle volte.\n\nI processi non sono in grado di decidere quando e per quanto tempo ottengono il tempo della CPU, se tutti i processi si comportassero normalmente ognuno otterrebbe (approssimativamente) la stessa quantità di tempo della CPU. Tuttavia, c'è un modo per influenzare l'algoritmo di pianificazione dei processi del kernel con un valore nice. Gradevolezza è un nome piuttosto strano, ma ciò che significa è che i processi hanno un numero per determinare la loro priorità per la CPU. Un numero alto significa che il processo è gradevole e ha una priorità più bassa per la CPU e un numero basso o negativo significa che il processo non è molto gradevole e vuole ottenere il più possibile della CPU. \n\n<pre>$ top</pre>\n\nPuoi vedere una colonna per NI in questo momento, che è il livello di gradevolezza di un processo.\n\nPer cambiare il livello di gradevolezza puoi utilizzare i comandi nice e renice:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nIl comando nice viene utilizzato per impostare la priorità per un nuovo processo. Il comando renice viene utilizzato per impostare la priorità su un processo esistente. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "più basso",
          "quizQuestion": "Se voglio che un processo ottenga una maggiore priorità della CPU, devo utilizzare un numero nice più basso o più alto?",
          "slug": "gradevolezzaprocessi",
          "title": "gradevolezza"
        },
        {
          "exercise": "Dai un'occhiata ai processi in esecuzione sul tuo sistema e controlla i loro stati di processo.",
          "id": 9,
          "lessonContent": "Diamo un'occhiata di nuovo al comando ps aux:\n\n<pre>$ ps aux</pre>\n\nNella colonna STAT, vedrai molti valori. Un processo Linux può trovarsi in diversi stati. I codici di stato più comuni che vedrai sono descritti di seguito:\n\n<ul>\n<li>R: in esecuzione o pronto, sta solo aspettando che la CPU lo processi</li>\n<li>S: sleep interrompibile, in attesa che un evento si completi, come l'input dal terminale</li>\n<li>D: sleep non interrompibile, processi che non possono essere uccisi o interrotti con un segnale, di solito per farli andare via devi riavviare o risolvere il problema</li>\n<li>Z: Zombie, abbiamo discusso in una lezione precedente che i zombie sono processi terminati in attesa di raccogliere i loro stati</li>\n<li>T: Stopped, un processo che è stato sospeso/arrestato</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "Quale codice STAT viene utilizzato per rappresentare uno sleep non interrompibile?",
          "slug": "stati-del-processo",
          "title": "Stati del processo"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 10,
          "lessonContent": "Ricorda che tutto in Linux è un file, anche i processi. Le informazioni sui processi sono memorizzate in un filesystem speciale noto come il filesystem /proc.\n\n<pre>$ ls /proc</pre>\n\nDovresti vedere più valori qui, ci sono sottodirectory per ogni PID. Se guardassi un PID nell'output di ps, potresti trovarlo nella directory /proc.\n\nVai avanti e inserisci uno dei processi e guarda quel file:\n\n<pre>$ cat /proc/12345/status</pre>\n\nDovresti vedere informazioni sullo stato del processo e informazioni più dettagliate. La directory /proc è come il kernel visualizza il sistema, quindi ci sono molte più informazioni qui rispetto a quelle che vedresti in ps.",
          "quizAnswer": "/proc",
          "quizQuestion": "Quale filesystem memorizza le informazioni sui processi?",
          "slug": "procfilesystem",
          "title": "/proc filesystem"
        },
        {
          "exercise": "Sposta alcuni lavori tra background e foreground",
          "id": 11,
          "lessonContent": "Immaginiamo di essere al lavoro su una singola finestra di terminale e di eseguire un comando che sta impiegando molto tempo. Non possiamo interagire con la shell finché non è completato, tuttavia vogliamo continuare a lavorare sulle nostre macchine, quindi abbiamo bisogno di tenere aperta quella shell. Fortunatamente possiamo controllare come i nostri processi vengono eseguiti con i lavori: \n\n<b>Invio di un lavoro in background</b>\n\nAggiungendo un simbolo di commerciale (&) al comando lo eseguirà in background in modo da poter comunque utilizzare la tua shell. Vediamo un esempio:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Visualizzazione di tutti i lavori in background</b>\n\nOra puoi visualizzare i lavori che hai appena inviato in background.\n\n<pre>$ jobs\n\n[1]    In esecuzione     sleep 1000 &\n[2]-   In esecuzione     sleep 1001 &\n[3]+   In esecuzione     sleep 1002 &\n\n</pre>\n\nTi verrà mostrato l'ID del lavoro nella prima colonna, quindi lo stato e il comando eseguito. Il simbolo <b>+</b> accanto all'ID del lavoro significa che è l'ultimo lavoro in background che è stato avviato. Il lavoro con il simbolo <b>-</b> è il secondo comando più recente.\n\n<b>Invio di un lavoro in background su un lavoro esistente</b>\n\nSe hai già eseguito un lavoro e desideri inviarlo in background, non è necessario terminarlo e ricominciare da capo. Sospendi prima il lavoro con Ctrl-Z, quindi esegui il comando <b>bg</b> per inviarlo in background.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Fermato     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    In esecuzione     sleep 1000 &\n[2]    In esecuzione     sleep 1001 &\n[3]-   In esecuzione     sleep 1002 &\n[4]+   In esecuzione     sleep 1003 &\n</pre>\n\n<b>Spostare un lavoro dal background al foreground</b>\n\nPer spostare un lavoro dal background al foreground, specifica semplicemente l'ID del lavoro desiderato. Se esegui fg senza alcuna opzione, riporterà indietro l'ultimo lavoro in background (il lavoro con il segno + accanto ad esso)\n\n<pre>$ fg %1</pre>\n\n<b>Uccidere i lavori in background</b>\n\nSimilmente allo spostamento dei lavori dal background, puoi utilizzare la stessa forma per terminare i processi utilizzando il loro ID del lavoro.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "Quale comando viene utilizzato per elencare i lavori in background?",
          "slug": "controllo-lavori",
          "title": "Controllo dei lavori"
        }
      ],
      "slug": "processi",
      "title": "Processi"
    },
    {
      "description": "Scopri tutto sui tool di gestione pacchetti dpkg, apt-get, rpm e yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Il tuo sistema è composto da molti pacchetti come browser internet, editor di testo, lettori multimediali, ecc. Questi pacchetti sono gestiti tramite gestori di pacchetti, che installano e mantengono il software sul tuo sistema. Non tutti i pacchetti vengono installati tramite gestori di pacchetti, è comune installare pacchetti direttamente dal codice sorgente (ne parleremo presto). Tuttavia, nella maggior parte dei casi utilizzerai un gestore di pacchetti per installare il software, le tipologie più comuni di pacchetti sono Debian (.deb) e Red Hat (.rpm). I pacchetti di tipo Debian sono utilizzati in distribuzioni come Debian, Ubuntu, LinuxMint, ecc. I pacchetti di tipo Red Hat sono presenti in Red Hat Enterprise Linux, Fedora, CentOS, ecc.\n\nCosa sono i pacchetti? Potresti conoscerli come Chrome, Photoshop, ecc. e lo sono, ma in realtà sono semplicemente molti file che sono stati compilati in uno. Le persone (o a volte una singola persona) che scrivono questo software sono conosciute come <b>fornitori upstream</b>, compilano il loro codice e scrivono come installarlo. Questi fornitori upstream lavorano per rilasciare nuovi software e aggiornare software esistenti. Quando sono pronti per rilasciarlo nel mondo, inviano il loro pacchetto ai <b>manutentori dei pacchetti</b>, che si occupano di mettere questo software nelle mani degli utenti. Questi manutentori dei pacchetti revisionano, gestiscono e distribuiscono questo software sotto forma di pacchetti.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continua!",
          "slug": "softwaredistribution",
          "title": "Distribuzione del software"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 2,
          "lessonContent": "Come fanno i pacchetti che vengono caricati su Internet a finire sui nostri computer? Vai alla pagina di download di ciascun pacchetto che desideri e fai clic su download e installa? Beh, in realtà puoi farlo, ma c'è qualcosa di meglio chiamato repository dei pacchetti. I repository sono semplicemente una posizione di archiviazione centrale per i pacchetti. Ci sono tonnellate di repository che contengono molti pacchetti e, cosa migliore di tutte, si trovano tutti su Internet, senza bisogno di dischi di installazione sciocchi. Il tuo computer non sa dove cercare questi repository a meno che tu non gli dica esplicitamente dove cercare.\n\nAd esempio, diciamo che voglio il software WackyWidgets sul mio computer. Beh, WackyWidgets gestisce i propri repository per i loro pacchetti widget, all'interno di questo repository ci sono 10 pacchetti, il pacchetto CoolWidget, il pacchetto SuperWidget, ecc. WackyWidgets ospita questo repository a un link di origine chiamato: http://download.widgets/linux/deb/\n\nOra, anziché andare direttamente al loro sito web per scaricare il pacchetto, puoi dire al tuo computer di trovare il software WackyWidgets dal link di origine. \n\nLa tua distribuzione già viene fornita con fonti preapprovate da cui ottenere i pacchetti ed è così che installa tutti i pacchetti di base che vedi sul tuo sistema. Su un sistema Debian, questo file di fonti è il file <b>/etc/apt/sources.list</b>. Il tuo computer saprà di cercare lì e controllare se hai aggiunto eventuali repository di origine.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Dove si trova il file delle fonti in un sistema Debian?",
          "slug": "repositorypacchetti",
          "title": "Repository dei pacchetti"
        },
        {
          "exercise": "Familiarizza con la documentazione di tar e guarda le altre opzioni disponibili nella pagina di manuale.",
          "id": 3,
          "lessonContent": "Prima di entrare nell'installazione dei pacchetti e nei diversi gestori, dobbiamo discutere dell'archiviazione e della compressione dei file, perché è probabile che tu incontri queste operazioni quando cerchi software su internet. \n\nProbabilmente sai già cos'è un archivio di file, probabilmente hai incontrato tipi di file come .rar e .zip. Questi sono un archivio di file, contengono molti file al loro interno, ma vengono presentati come un unico file noto come archivio.\n\n<b>Compressione dei file con gzip</b>\n\ngzip è un programma usato per comprimere file in Linux, con estensione .gz. \n\nPer comprimere un file:\n<pre>$ gzip mycoolfile</pre>\n\nPer decomprimere il file:\n<pre>$ gunzip mycoolfile.gz</pre>\n\n<b>Creazione di archivi con tar</b>\nSfortunatamente, gzip non può aggiungere più file in un unico archivio per noi. Per fortuna abbiamo il programma tar che può farlo. Quando crei un archivio usando tar, avrà estensione .tar. \n\n<pre>$ tar cvf mytarfile.tar mycoolfile1 mycoolfile2</pre>\n\n<ul>\n<li>c - crea</li>\n<li>v - indica al programma di essere verboso e farci vedere cosa sta facendo</li>\n<li>f - il nome del file tar deve seguire questa opzione, se stai creando un file tar dovrai scegliere un nome</li>\n</ul>\n\n<b>Estrarre archivi con tar</b>\n\nPer estrarre i contenuti di un file tar, usa: \n\n<pre>$ tar xvf mytarfile.tar</pre>\n\n<ul>\n<li>x - estrai</li>\n<li>v - indica al programma di essere verboso e farci vedere cosa sta facendo</li>\n<li>f - il file che vuoi estrarre</li>\n</ul>\n\n<b>Compressione/decompressione di archivi con tar e gzip</b>\n\nSpesso vedrai un file tar che è stato compresso come: mycompressedarchive.tar.gz, tutto ciò che devi fare è lavorare dall'esterno verso l'interno, quindi prima rimuovi la compressione con gunzip e poi puoi estrarre il file tar. Oppure puoi usare l'opzione <b>z</b> con tar, che indica di utilizzare l'utilità gzip o gunzip.\n\nCrea un file tar compresso:\n<pre>$ tar czf myfile.tar.gz</pre>\n\nDecomprimi ed estrai: \n<pre>$ tar xzf file.tar</pre>\n\nSe hai bisogno di aiuto, ricorda: e<b>X</b>trai tutti i <b>Z</b>ii <b>F</b>ile!\n\ntar è uno di quei comandi così importanti eppure non lo ricordi mai veramente, xkcd pertinente: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Altri Utilità</b>\n\nDurante il tuo percorso in Linux, incontrerai altri tipi di archiviazione e compressione come: bzip2, compress, zip, unzip, ecc. Sono un po' meno comuni, ma tieni presente che diverse utilità richiederanno comandi diversi.",
          "quizAnswer": "c",
          "quizQuestion": "Quale flag di tar viene utilizzato per creare archivi?",
          "slug": "archiviotarcompresso",
          "title": "tar e gzip"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "I pacchetti raramente funzionano da soli, sono più spesso accompagnati da dipendenze per aiutarli a funzionare. Ad esempio, immaginiamo di avere un gruppo di ristoranti, questi ristoranti preparano tutti cucine diverse, ma ottengono tutti gli ingredienti dalla stessa fattoria. Il cibo che servono dipende dagli approvvigionamenti della fattoria, se la fattoria smettesse improvvisamente di fornire cibo, allora i ristoranti sarebbero in uno stato piuttosto brutto. \n\nIn Linux, queste dipendenze sono spesso altri pacchetti o librerie condivise. Le librerie condivise sono librerie di codice che altri programmi vogliono utilizzare e non vogliono riscrivere da soli. Pensate di nuovo al ristorante, quanto lavoro sarebbe se ogni ristorante coltivasse anche il proprio cibo? Troppo. \n\nApprofondiremo ulteriormente le librerie condivise nel corso sul filesystem, quindi per ora ricordate solo che i pacchetti hanno dipendenze per aiutarli a funzionare, che siano altri pacchetti o librerie; se le dipendenze non sono presenti, il pacchetto finirà in uno stato rotto e nella maggior parte dei casi non si installerà nemmeno.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continuate!",
          "slug": "packagedependencies",
          "title": "Dipendenze dei pacchetti"
        },
        {
          "exercise": "Trova un programma che desideri installare sul tuo sistema come Google Chrome e installalo utilizzando uno di questi comandi.",
          "id": 5,
          "lessonContent": "Anche se la maggior parte di questo corso riguarda i sistemi di gestione dei pacchetti (i Batman della gestione dei pacchetti), non dobbiamo dimenticare i Robin. Anche se molto utili e affidabili, non vengono forniti con quella dolce batmobile e cintura utility.\n\nProprio come .exe è un singolo file eseguibile, lo sono anche .deb e .rpm. Normalmente non li vedresti se usi i repository dei pacchetti, ma se scarichi direttamente i pacchetti, è probabile che li ottieni in questi formati popolari. Ovviamente, sono esclusivi per le loro distribuzioni, .deb per Debian based e .rpm per Red Hat based.\n\nPer installare questi pacchetti diretti, puoi utilizzare i comandi di gestione dei pacchetti: rpm e dpkg. Questi strumenti vengono utilizzati per installare i file dei pacchetti, tuttavia non installeranno le dipendenze del pacchetto, quindi se il tuo pacchetto aveva 10 dipendenze, dovresti installare quei pacchetti separatamente e poi le loro dipendenze e così via. Come puoi vedere, questo è stato uno dei motivi che ha portato alla creazione dei sistemi di gestione completi di cui parleremo in seguito.\n\nTieni presente che ci saranno innumerevoli volte in cui avrai bisogno di installare, interrogare o verificare un pacchetto con uno di questi strumenti, quindi ricorda questi comandi. \n\n<b>Installare un pacchetto</b>\n\n<pre>\nDebian: $ dpkg -i some_deb_package.deb\nRPM: $ rpm -i some_rpm_package.rpm\n</pre>\n\nLa <b>i</b> sta per installare. Puoi anche utilizzare il formato più lungo di --install. \n\n<b>Rimuovere un pacchetto</b>\n\n<pre>\nDebian: $ dpkg -r some_deb_package.deb\nRPM: $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian: <b>r</b> per rimuovere\nRPM: <b>e</b> per cancellare\n\n<b>Elencare i pacchetti installati</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> per elenco\nRPM: <b>q</b> per interrogare e <b>a</b> per tutti",
          "quizAnswer": "dpkg",
          "quizQuestion": "Qual è lo strumento di gestione dei pacchetti per i file .deb?",
          "slug": "strumentiinstallazionepacchetti",
          "title": "rpm e dpkg"
        },
        {
          "exercise": "Esegui ciascuno di questi comandi relativi ai pacchetti e osserva l'output che ricevi.",
          "id": 6,
          "lessonContent": "Ah, i Batman del gestore di pacchetti, questi sistemi sono dotati di tutti gli strumenti per rendere più semplice l'installazione, la rimozione e le modifiche dei pacchetti, inclusa l'installazione delle dipendenze dei pacchetti. Due dei sistemi di gestione più popolari sono <b>yum</b> e <b>apt</b>. Yum è esclusivo della famiglia Red Hat e apt è esclusivo della famiglia Debian.\n\n<b>Installare un pacchetto da un repository</b>\n\n<pre>\nDebian: $ apt install nome_pacchetto\nRPM: $ yum install nome_pacchetto\n</pre>\n\n<b>Rimuovere un pacchetto</b>\n\n<pre>\nDebian: $ apt remove nome_pacchetto\nRPM: $ yum erase nome_pacchetto\n</pre>\n\n<b>Aggiornare i pacchetti di un repository</b>\n\nÈ sempre una pratica consigliata aggiornare i repository dei pacchetti in modo che siano aggiornati prima di installare e aggiornare un pacchetto. \n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Ottenere informazioni su un pacchetto installato</b>\n\n<pre>\nDebian: apt show nome_pacchetto\nRPM: yum info nome_pacchetto\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Quale comando viene utilizzato per mostrare le informazioni sul pacchetto in un sistema Debian?",
          "slug": "sistemi_gestione_pacchetti",
          "title": "yum and apt"
        },
        {
          "exercise": "Trova un programma di codice sorgente (da un sito affidabile) e installalo dal sorgente.",
          "id": 7,
          "lessonContent": "Spesso ti capiterà di incontrare un pacchetto oscuro che è disponibile solo sotto forma di codice sorgente puro. Dovrai utilizzare alcuni comandi per compilare e installare quel pacchetto di codice sorgente sul tuo sistema. \n\nPrima di tutto, avrai bisogno di un software per installare gli strumenti che ti permetteranno di compilare il codice sorgente. \n\n<pre>$ sudo apt install build-essential</pre>\n\nUna volta fatto ciò, estrai i contenuti del file del pacchetto, molto probabilmente un file .tar.gz. \n\n<pre>$ tar -xzvf package.tar.gz</pre>\n\nPrima di fare qualsiasi cosa, dai un'occhiata al file README o INSTALL all'interno del pacchetto. A volte ci saranno istruzioni di installazione specifiche. \n\nA seconda del metodo di compilazione utilizzato dallo sviluppatore, dovrai utilizzare comandi diversi, come cmake o altro.\n\nTuttavia, più comunemente vedrai la compilazione di base con make, quindi ne parleremo:\n\nAll'interno dei contenuti del pacchetto ci sarà uno script di configurazione, questo script controlla le dipendenze sul tuo sistema e se ti manca qualcosa, vedrai un errore e dovrai risolvere quelle dipendenze. \n\n<pre>$ ./configure</pre>\n\nIl <b>./</b> ti permette di eseguire uno script nella directory corrente. \n\n<pre>$ make</pre>\n\nAll'interno dei contenuti del pacchetto, c'è un file chiamato Makefile che contiene le regole per la costruzione del software. Quando esegui il comando make, guarda questo file per costruire il software.\n\n<pre>$ sudo make install</pre>\n\nQuesto comando installa effettivamente il pacchetto, copierà i file corretti nelle posizioni corrette sul tuo computer.\n\nSe desideri disinstallare il pacchetto, usa:\n\n<pre>$ sudo make uninstall</pre>\n\nFai attenzione quando usi make install, potresti non renderti conto di tutto ciò che sta effettivamente accadendo sullo sfondo. Se decidi di rimuovere questo pacchetto, potresti non rimuovere effettivamente tutto perché non ti sei reso conto di cosa è stato aggiunto al tuo sistema. Invece dimentica tutto ciò che ti ho appena spiegato su make install e usa il comando <b>checkinstall</b>. Questo comando creerà un file .deb per te che potrai facilmente installare e disinstallare. \n\n<pre>$ sudo checkinstall</pre> \n\nQuesto comando essenzialmente \"make install\" e costruirà un pacchetto .deb e lo installerà. Questo rende più facile rimuovere il pacchetto in seguito.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "Cosa dovresti usare sempre al posto di make install?",
          "slug": "compilarecodicesorgente",
          "title": "Compilare il codice sorgente"
        }
      ],
      "slug": "packages",
      "title": "Pacchetti"
    },
    {
      "description": "Scopri di più sui dispositivi Linux e su come interagiscono con il kernel e lo spazio utente.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Controlla i contenuti della directory /dev, riconosci qualche dispositivo familiare?",
          "id": 1,
          "lessonContent": "Quando si collega un dispositivo al proprio computer, di solito è necessario un driver del dispositivo per funzionare correttamente. È possibile interagire con i driver dei dispositivi tramite file di dispositivo o nodi di dispositivo, che sono file speciali che assomigliano a file regolari. Poiché questi file di dispositivo sono simili a file regolari, è possibile utilizzare programmi come ls, cat, ecc. per interagire con essi. Questi file di dispositivo sono generalmente memorizzati nella directory /dev. Prova a eseguire ls sulla directory /dev sul tuo sistema, vedrai un gran numero di file di dispositivi presenti sul tuo sistema. \n\n<pre>$ ls /dev </pre>\n\nAlcuni di questi dispositivi li hai già utilizzati e interagito con essi, come ad esempio /dev/null. Ricorda quando inviamo l'output a /dev/null, il kernel sa che questo dispositivo prende tutto il nostro input e lo scarta, quindi nulla viene restituito.\n\nIn passato, se volevi aggiungere un dispositivo al tuo sistema, aggiungevi il file del dispositivo in /dev e probabilmente lo dimenticavi. Beh, ripeti questo un paio di volte e capirai dove c'era un problema. La directory /dev si riempiva di file di dispositivo statici di dispositivi che avevi da tempo aggiornato, smesso di usare, ecc. I dispositivi vengono anche assegnati file di dispositivo nell'ordine in cui il kernel li trova. Quindi se ogni volta che riavvi il sistema, i dispositivi potrebbero avere file di dispositivo diversi a seconda di quando sono stati scoperti.\n\nFortunatamente non usiamo più quel metodo, ora abbiamo qualcosa che utilizziamo per aggiungere e rimuovere dinamicamente i dispositivi attualmente in uso sul sistema e ne parleremo nelle prossime lezioni.",
          "quizAnswer": "/dev",
          "quizQuestion": "Dove vengono memorizzati i file di dispositivo sul sistema?",
          "slug": "devdirectory",
          "title": "/dev directory"
        },
        {
          "exercise": "Guarda nella tua directory /dev e scopri quali tipi di dispositivi puoi vedere.",
          "id": 2,
          "lessonContent": "Prima di parlare di come i dispositivi vengono gestiti, diamo un'occhiata effettiva ad alcuni dispositivi.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nLe colonne sono le seguenti da sinistra a destra:\n\n<ul>\n<li>Permessi</li>\n<li>Proprietario</li>\n<li>Gruppo</li>\n<li>Numero di dispositivo principale</li>\n<li>Numero di dispositivo minore</li>\n<li>Timestamp</li>\n<li>Nome del dispositivo</li>\n</ul>\n\nRicorda che nel comando ls puoi vedere il tipo di file con il primo bit su ogni riga. I file di dispositivo sono indicati come segue: \n\n<ul>\n<li>c - carattere</li>\n<li>b - blocco</li>\n<li>p - pipe</li>\n<li>s - socket</li>\n</ul>\n\n<b>Dispositivo Carattere</b>\n\nQuesti dispositivi trasferiscono dati, ma uno alla volta. Vedrai molti dispositivi pseudo (/dev/null) come dispositivi carattere, questi dispositivi non sono realmente fisicamente collegati alla macchina, ma consentono al sistema operativo una maggiore funzionalità. \n\n<b>Dispositivo Blocco</b>\n\nQuesti dispositivi trasferiscono dati, ma in blocchi di dimensioni fisse. Vedrai più comunemente dispositivi che utilizzano blocchi dati come dispositivi blocco, come ad esempio hard disk, filesystem, ecc. \n\n<b>Dispositivo Pipe</b>\n\nLe pipe nominate consentono a due o più processi di comunicare tra loro, sono simili ai dispositivi carattere, ma anziché inviare l'output a un dispositivo, viene inviato a un altro processo. \n\n<b>Dispositivo Socket</b>\n\nI dispositivi socket facilitano la comunicazione tra processi, simili ai dispositivi pipe ma possono comunicare con molti processi contemporaneamente. \n\n<b>Caratterizzazione del Dispositivo</b>\n\nI dispositivi vengono caratterizzati utilizzando due numeri, il <b>numero di dispositivo principale</b> e il <b>numero di dispositivo minore</b>. Puoi vedere questi numeri nell'esempio di ls sopra, sono separati da una virgola. Ad esempio, supponiamo che un dispositivo avesse i numeri di dispositivo: <b>8, 0</b>:\n\nIl numero di dispositivo principale rappresenta il driver del dispositivo che viene utilizzato, in questo caso 8, che è spesso il numero principale per i dispositivi a blocchi sd. Il numero minore indica al kernel quale dispositivo unico è in questa classe di driver, in questo caso 0 viene utilizzato per rappresentare il primo dispositivo (a).",
          "quizAnswer": "c",
          "quizQuestion": "Qual è il simbolo per i dispositivi carattere nel comando ls -l?",
          "slug": "tipididispositivi",
          "title": "tipi di dispositivi"
        },
        {
          "exercise": "Scrivi sui dispositivi pseudo e vedi cosa succede, fai attenzione a non scrivere sui tuoi dischi su quei dispositivi!",
          "id": 3,
          "lessonContent": "Ecco i nomi dei dispositivi più comuni che incontrerai: \n\n<b>Dispositivi SCSI</b>\n\nSe hai qualche tipo di archiviazione di massa sul tuo computer, è probabile che stia utilizzando il protocollo SCSI (pronunciato \"scuzzy\"). SCSI sta per Small Computer System Interface, è un protocollo utilizzato per consentire la comunicazione tra dischi, stampanti, scanner e altri dispositivi periferici al tuo sistema. Potresti aver sentito parlare di dispositivi SCSI che non vengono effettivamente utilizzati nei sistemi moderni, tuttavia i nostri sistemi Linux corrispondono i dischi SCSI con i dischi rigidi in /dev. Sono rappresentati da un prefisso sd (disco SCSI):\n\nFile di dispositivi SCSI comuni:\n\n<ul>\n<li>/dev/sda - Primo disco rigido</li>\n<li>/dev/sdb - Secondo disco rigido</li>\n<li>/dev/sda3 - Terza partizione sul primo disco rigido</li>\n</ul>\n\n<b>Dispositivi Pseudo</b>\n\nCome discusso in precedenza, i dispositivi pseudo non sono fisicamente connessi al tuo sistema, i dispositivi pseudo più comuni sono i dispositivi carattere: \n\n<ul>\n<li>/dev/zero - accetta e scarta tutti gli input, produce un flusso continuo di byte NULL (valore zero)</li>\n<li>/dev/null - accetta e scarta tutti gli input, non produce alcun output</li>\n<li>/dev/random - produce numeri casuali</li>\n</ul>\n\n<b>Dispositivi PATA</b>\n\nA volte, nei sistemi più vecchi, potresti vedere i dischi rigidi essere indicati con un prefisso hd: \n\n<ul>\n<li>/dev/hda - Primo disco rigido</li>\n<li>/dev/hdd2 - Seconda partizione sul quarto disco rigido</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "Qual è comunemente il nome del dispositivo per la prima partizione sul secondo disco SCSI?",
          "slug": "nomidispositivi",
          "title": "Nomi dei Dispositivi"
        },
        {
          "exercise": "Controlla i contenuti della directory /sys e vedi quali file sono presenti lì.",
          "id": 4,
          "lessonContent": "Sysfs è stato creato tempo fa per gestire meglio i dispositivi sul nostro sistema che la directory /dev non riusciva a fare. Sysfs è un filesystem virtuale, montato più spesso nella directory /sys. Ci fornisce informazioni più dettagliate rispetto a quelle che potremmo vedere nella directory /dev. Entrambe le directory /sys e /dev sembrano essere molto simili e lo sono in alcuni aspetti, ma hanno delle differenze significative. Fondamentalmente, la directory /dev è semplice, consente ad altri programmi di accedere direttamente ai dispositivi, mentre il filesystem /sys è utilizzato per visualizzare informazioni e gestire il dispositivo. \n\nIl filesystem /sys contiene fondamentalmente tutte le informazioni su tutti i dispositivi del sistema, come il produttore e il modello, dove il dispositivo è collegato, lo stato del dispositivo, la gerarchia dei dispositivi e altro ancora. I file che vedi qui non sono nodi dei dispositivi, quindi non interagisci direttamente con i dispositivi dalla directory /sys, piuttosto li stai gestendo. \n\nDai un'occhiata ai contenuti della directory /sys:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "Quale directory viene utilizzata per visualizzare informazioni dettagliate sui dispositivi?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Esegui il comando udevadm fornito e controlla l'input.",
          "id": 5,
          "lessonContent": "In passato e ancora oggi, se davvero volevi farlo, avresti creato nodi di dispositivo utilizzando un comando come: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nQuesto comando creerà un nodo di dispositivo /dev/sdb1 e lo renderà un dispositivo a blocchi (b) con un numero maggiore di 8 e un numero minore di 3.\n\nPer rimuovere un dispositivo, basta <b>rm</b> il file del dispositivo nella directory /dev. \n\nFortunatamente, non abbiamo davvero bisogno di farlo più a causa di udev. Il sistema udev crea e rimuove dinamicamente i file di dispositivo per noi a seconda che siano collegati o meno. C'è un demone udevd che è in esecuzione sul sistema e ascolta i messaggi del kernel sui dispositivi collegati al sistema. Udevd analizzerà quelle informazioni e le abbinerà alle regole specificate in /etc/udev/rules.d, a seconda di quelle regole probabilmente creerà nodi di dispositivo e collegamenti simbolici per i dispositivi. Puoi scrivere le tue regole udev, ma questo esula un po' dall'argomento di questa lezione. Fortunatamente, il tuo sistema è già dotato di molte regole udev, quindi potresti non aver mai bisogno di scriverne di nuove.\n\nPuoi anche visualizzare il database udev e sysfs utilizzando il comando <b>udevadm</b>. Questo strumento è molto utile, ma a volte può diventare molto complicato, un semplice comando per visualizzare le informazioni per un dispositivo sarebbe:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "Cosa aggiunge e rimuove dinamicamente i dispositivi?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Prova ciascuno di questi comandi e osserva l'output che ricevi.",
          "id": 6,
          "lessonContent": "Proprio come usiamo il comando ls per elencare file e directory, possiamo utilizzare strumenti simili che forniscono informazioni sui dispositivi.\n\n<b>Elenco dei dispositivi USB</b>\n\n<pre>$ lsusb </pre>\n\n<b>Elenco dei dispositivi PCI</b>\n\n<pre>$ lspci </pre>\n\n<b>Elenco dei dispositivi SCSI</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "Quale comando può essere utilizzato per visualizzare i dispositivi USB?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Usa il comando dd per fare un backup del tuo drive e imposta l'output su un file .img.",
          "id": 7,
          "lessonContent": "Lo strumento dd è estremamente utile per convertire e copiare dati. Legge l'input da un file o da uno stream di dati e lo scrive su un file o su uno stream di dati. \n\nConsidera il seguente comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nQuesto comando sta copiando i contenuti di backup.img su /dev/sdb. Copierà i dati a blocchi di 1024 byte finché non ci saranno più dati da copiare. \n\n<ul>\n<li>if=file - File di input, legge da un file anziché dall'input standard</li>\n<li>of=file - File di output, scrive su un file anziché sull'output standard</li>\n<li>bs=bytes - Dimensione del blocco, legge e scrive questo numero di byte di dati alla volta. Puoi utilizzare diverse metriche di dimensione indicando la dimensione con k per kilobyte, m per megabyte, ecc., quindi 1024 byte corrisponde a 1k</li>\n<li>count=number - Numero di blocchi da copiare.</li>\n</ul>\n\nVedrai alcuni comandi dd che utilizzano l'opzione count, di solito con dd se vuoi copiare un file di 1 megabyte, di solito vorrai vedere quel file come 1 megabyte una volta che è stato copiato. Supponiamo di eseguire il seguente comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nIl nostro file backup.img è di 10M, tuttavia, stiamo dicendo in questo comando di copiare 1M 2 volte, quindi verranno copiati solo 2M, lasciando i nostri dati copiati incompleti. Count può essere utile in molte situazioni, ma se stai solo copiando dati, puoi praticamente omettere count e anche bs. Se vuoi davvero ottimizzare i tuoi trasferimenti di dati, allora vorrai iniziare a utilizzare quelle opzioni.\n\ndd è estremamente potente, puoi usarlo per fare backup di qualsiasi cosa, inclusi interi dischi, ripristinare immagini di dischi e altro ancora. Attenzione, quell'utensile potente può avere un prezzo se non sei sicuro di ciò che stai facendo.",
          "quizAnswer": "bs",
          "quizQuestion": "Qual è l'opzione dd per la dimensione del blocco?",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Dispositivi"
    },
    {
      "description": "Scopri di più sul filesystem di Linux, sui diversi tipi di filesystem, sulla partizionatura e altro ancora.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Guarda dentro la tua directory /usr, che tipo di informazioni sono presenti lì?",
          "id": 1,
          "lessonContent": "A questo punto, probabilmente sei ben familiare con la struttura delle directory del tuo sistema, se non lo sei lo sarai presto. I filesystem possono variare nella loro struttura, ma per la maggior parte dovrebbero conformarsi allo Standard della Gerarchia del Filesystem. \n\nVai avanti e esegui un <b>ls -l /</b> per vedere le directory elencate sotto la directory radice, la tua potrebbe essere diversa dalla mia, ma le directory dovrebbero per la maggior parte assomigliare alle seguenti:\n\n<ul>\n<li>/ - La directory radice dell'intera gerarchia del filesystem, tutto è annidato sotto questa directory.</li>\n<li>/bin - Programmi essenziali pronti all'uso (binari), include i comandi più basilari come ls e cp.</li>\n<li>/boot - Contiene i file del caricatore di avvio del kernel.</li>\n<li>/dev - File dei dispositivi.</li>\n<li>/etc - Directory di configurazione di sistema principale, dovrebbe contenere solo file di configurazione e non binari.</li>\n<li>/home - Directory personali per gli utenti, contiene i tuoi documenti, file, impostazioni, ecc.</li>\n<li>/lib - Contiene file di librerie che i binari possono utilizzare.</li>\n<li>/media - Usato come punto di attacco per supporti rimovibili come le chiavette USB.</li>\n<li>/mnt - Filesystem temporaneamente montati.</li>\n<li>/opt - Pacchetti software applicativi opzionali.</li>\n<li>/proc - Informazioni sui processi attualmente in esecuzione.</li>\n<li>/root - La directory home dell'utente root.</li>\n<li>/run - Informazioni sul sistema in esecuzione dall'ultimo avvio.</li>\n<li>/sbin - Contiene binari di sistema essenziali, di solito possono essere eseguiti solo dall'utente root.</li>\n<li>/srv - Dati specifici del sito serviti dal sistema.</li>\n<li>/tmp - Archivio per file temporanei.</li>\n<li>/usr - Purtroppo è denominato in modo fuorviante, spesso non contiene file degli utenti nel senso di una cartella home. È destinato al software e alle utility installate dall'utente, tuttavia ciò non impedisce di aggiungere directory personali al suo interno. All'interno di questa directory ci sono sottodirectory per /usr/bin, /usr/local, ecc.</li>\n<li>/var - Directory variabile, utilizzata per il logging di sistema, il tracciamento degli utenti, le cache, ecc. Fondamentalmente tutto ciò che è soggetto a cambiamenti continuamente.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "In quale directory vengono memorizzati i log?",
          "slug": "gerarchiafilesystem",
          "title": "Gerarchia del Filesystem"
        },
        {
          "exercise": "Fai un po' di ricerca online sugli altri tipi di file system: ReiserFS, ZFS, JFS e altri che puoi trovare.",
          "id": 2,
          "lessonContent": "Ci sono molte implementazioni di file system disponibili. Alcuni sono più veloci di altri, alcuni supportano storage di capacità maggiore e altri funzionano solo su storage di capacità inferiore. I diversi file system hanno modi diversi di organizzare i loro dati e approfondiremo quali tipi di file system esistono. Poiché ci sono molte implementazioni diverse disponibili, le applicazioni hanno bisogno di un modo per gestire le diverse operazioni. Quindi c'è qualcosa chiamato livello di astrazione del File System Virtuale (VFS). È uno strato tra le applicazioni e i diversi tipi di file system, quindi indipendentemente dal file system che hai, le tue applicazioni saranno in grado di lavorarci. \n\nPuoi avere molti file system sui tuoi dischi, a seconda di come sono partizionati e ne parleremo in una prossima lezione.\n\n<b>Journaling</b>\n\nIl journaling è presente per impostazione predefinita sulla maggior parte dei tipi di file system, ma nel caso non lo fosse, è importante sapere cosa fa. Immagina di copiare un file grande e improvvisamente perdi corrente. Beh, se sei su un file system non journaling, il file finirebbe corrotto e il tuo file system sarebbe inconsistente e quindi, al riavvio, il sistema eseguirebbe un controllo del file system per assicurarsi che tutto sia a posto. Tuttavia, le riparazioni potrebbero richiedere del tempo a seconda di quanto grande fosse il tuo file system. \n\nOra, se fossi su un sistema con journaling, prima che la tua macchina inizi a copiare il file, scriverà ciò che stai per fare in un file di log (journal). Ora, quando copi effettivamente il file, una volta completato, il journal segna quel compito come completato. Il file system è sempre in uno stato consistente grazie a questo, quindi saprà esattamente dove ti sei interrotto se la tua macchina si spegne improvvisamente. Questo riduce anche il tempo di avvio perché anziché controllare l'intero file system, guarda solo il tuo journal.\n\n<b>Tipi di File System Desktop Comuni</b>\n\n<ul>\n<li>ext4 - Questa è la versione più recente dei file system nativi di Linux. È compatibile con le versioni precedenti ext2 ed ext3. Supporta volumi di disco fino a 1 exabyte e dimensioni dei file fino a 16 terabyte e molto altro. È la scelta standard per i file system Linux.</li>\n<li>Btrfs - \"Better or Butter FS\", è un nuovo file system per Linux che offre snapshot, backup incrementali, aumento delle prestazioni e molto altro. È ampiamente disponibile, ma non ancora del tutto stabile e compatibile.</li>\n<li>XFS - File system di journaling ad alte prestazioni, ottimo per un sistema con file di grandi dimensioni come un server multimediale.</li>\n<li>NTFS e FAT - File system di Windows</li>\n<li>HFS+ - File system di Macintosh</li>\n</ul>\n\nControlla quali file system sono presenti sulla tua macchina: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nIl comando <b>df</b> riporta l'utilizzo dello spazio disco del file system e altri dettagli sul tuo disco, ne parleremo meglio più avanti.",
          "quizAnswer": "ext4",
          "quizQuestion": "Qual è il tipo di file system Linux comune?",
          "slug": "tipi-di-file-system",
          "title": "Tipi di File System"
        },
        {
          "exercise": "Esegui <b>parted -l</b> sulla tua macchina e valuta i risultati.",
          "id": 3,
          "lessonContent": "I dischi rigidi possono essere suddivisi in partizioni, creando essenzialmente più dispositivi a blocchi. Ricorda esempi come, /dev/sda1 e /dev/sda2, /dev/sda è l'intero disco, ma /dev/sda1 è la prima partizione su quel disco. Le partizioni sono estremamente utili per separare i dati e se hai bisogno di un determinato filesystem, puoi facilmente creare una partizione invece di rendere l'intero disco di un solo tipo di filesystem.\n\n<b>Tabella delle Partizioni</b>\n\nOgni disco avrà una tabella delle partizioni, questa tabella indica al sistema come è partizionato il disco. Questa tabella ti dice dove iniziano e finiscono le partizioni, quali partizioni sono avviabili, a quali settori del disco sono allocate le varie partizioni, ecc. Ci sono due principali schemi di tabella delle partizioni utilizzati, Master Boot Record (MBR) e GUID Partition Table (GPT).\n\n<b>Partizione</b>\n\nI dischi sono composti da partizioni che ci aiutano ad organizzare i nostri dati. Puoi avere più partizioni su un disco e non possono sovrapporsi tra loro. Se c'è spazio non allocato a una partizione, allora è noto come spazio libero. I tipi di partizioni dipendono dalla tua tabella delle partizioni. All'interno di una partizione, puoi avere un filesystem o dedicare una partizione ad altre cose come lo swap (ne parleremo presto).\n\n<i>MBR</i>\n\n<ul>\n<li>Tabella delle partizioni tradizionale, era usata come standard</li>\n<li>Può avere partizioni primarie, estese e logiche</li>\n<li>MBR ha un limite di quattro partizioni primarie</li>\n<li>Ulteriori partizioni possono essere create trasformando una partizione primaria in una partizione estesa (può esserci solo una partizione estesa su un disco). Poi all'interno della partizione estesa aggiungi partizioni logiche. Le partizioni logiche sono utilizzate come qualsiasi altra partizione. Un po' sciocco lo so.</li> \n<li>Supporta dischi fino a 2 terabyte</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>La GUID Partition Table (GPT) sta diventando lo standard per la partizionamento dei dischi</li>\n<li>Ha un solo tipo di partizione e ne puoi creare molte</li>\n<li>Ogni partizione ha un ID univoco globale (GUID)</li>\n<li>Usata principalmente in combinazione con l'avvio basato su UEFI (ne parleremo nei dettagli in un altro corso)</li> \n</ul>\n\n<b>Struttura del Filesystem</b>\n\nSappiamo dalla nostra lezione precedente che un filesystem è una raccolta organizzata di file e directory. Nella sua forma più semplice, è composto da un database per gestire i file e i file stessi, tuttavia andremo un po' più in dettaglio. \n\n<ul>\n<li>Blocco di avvio - Questo si trova nei primi settori del filesystem, e non è realmente utilizzato dal filesystem. Piuttosto, contiene informazioni utilizzate per avviare il sistema operativo. È necessario un solo blocco di avvio per il sistema operativo. Se hai più partizioni, avranno blocchi di avvio, ma molti di essi non vengono utilizzati.</li>\n<li>Blocco super - Questo è un singolo blocco che viene dopo il blocco di avvio, e contiene informazioni sul filesystem, come la dimensione della tabella degli inode, la dimensione dei blocchi logici e la dimensione del filesystem.</li>\n<li>Tabella degli inode - Pensala come il database che gestisce i nostri file (abbiamo una lezione intera sugli inode, quindi non preoccuparti). Ogni file o directory ha un'entrata univoca nella tabella degli inode e contiene varie informazioni sul file.</li>\n<li>Blocchi dati - Questi sono i dati effettivi per i file e le directory.</li>\n</ul>\n \nDiamo un'occhiata alle diverse tabelle delle partizioni. Di seguito è riportato un esempio di una partizione utilizzando la tabella delle partizioni MBR (msdos). Puoi vedere le partizioni primarie, estese e logiche sulla macchina.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModello: Seagate (scsi)\nDisco /dev/sda: 21.5GB\nDimensione settore (logico/fisico): 512B/512B\nTabella delle partizioni: msdos\n\nNumero  Inizio   Fine     Dimensione  Tipo      File system     Flag\n 1      1049kB  6860MB  6859MB     primaria  ext4            avvio\n 2      6861MB  21.5GB  14.6GB     estesa\n 5      6861MB  7380MB  519MB      logica    linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB     logica    xfs\n</pre>\n\n\nQuesto esempio è GPT, utilizzando un ID univoco per le partizioni.\n\n<pre>\nModello: Thumb Drive (scsi)\nDisco /dev/sdb: 4041MB\nDimensione settore (logico/fisico): 512B/512B\nTabella delle partizioni: gpt\n\nNumero  Inizio   Fine     Dimensione  File system  Nome        Flag\n 1      17.4kB  1000MB  1000MB                 primo\n 2      1000MB  4040MB  3040MB                 secondo\n</pre>",
          "quizAnswer": "estesa",
          "quizQuestion": "Quale tipo di partizione viene utilizzato per creare più di 4 partizioni nello schema di partizionamento MBR?",
          "slug": "anatomia-di-un-disco",
          "title": "Anatomia di un Disco"
        },
        {
          "exercise": "Partiziona un'unità USB con metà dell'unità come ext4 e l'altra metà come spazio libero.",
          "id": 4,
          "lessonContent": "Facciamo alcune attività pratiche con i filesystem lavorando sul processo su un'unità USB. Se non ne hai una, non preoccuparti, puoi comunque seguire le prossime lezioni. \n\nPrima di tutto dovremo partizionare il nostro disco. Ci sono molti strumenti disponibili per farlo: \n\n<ul>\n<li>fdisk - strumento di partizionamento di base da riga di comando, non supporta GPT</li>\n<li>parted - questo è uno strumento da riga di comando che supporta sia la partizione MBR che GPT</li>\n<li>gparted - questa è la versione GUI di parted</li>\n<li>gdisk - fdisk, ma non supporta MBR solo GPT</li>\n</ul>\n\nUsiamo parted per fare la nostra partizione. Diciamo che collego il dispositivo USB e vediamo che il nome del dispositivo è /dev/sdb2. \n\n<b>Avvia parted</b>\n\n<pre>$ sudo parted</pre>\n\nVerrai inserito nello strumento parted, qui puoi eseguire comandi per partizionare il tuo dispositivo. \n\n<b>Seleziona il dispositivo</b>\n\n<pre>select /dev/sdb2</pre>\n\nPer selezionare il dispositivo con cui lavorerai, selezionalo dal suo nome di dispositivo.\n\n<b>Visualizza la tabella delle partizioni corrente</b>\n\n<pre>\n(parted) print                                                            \nModello: Seagate (scsi)\nDisco /dev/sda: 21,5 GB\nDimensione settore (logico/fisico): 512B/512B\nTabella delle partizioni: msdos\n\nNumero  Inizio   Fine     Dimensione  Tipo      File system     Flag\n 1      1049kB  6860MB  6859MB     primaria  ext4            boot\n 2      6861MB  21,5GB  14,6GB     estesa\n 5      6861MB  7380MB  519MB      logica    linux-swap(v1)\n 6      7381MB  21,5GB  14,1GB     logica    xfs\n</pre>\n\nQui vedrai le partizioni disponibili sul dispositivo. I punti di <b>inizio</b> e <b>fine</b> indicano dove le partizioni occupano spazio sull'hard disk, dovrai trovare una buona posizione di inizio e fine per le tue partizioni. \n\n<b>Partiziona il dispositivo</b>\n\n<pre>mkpart primaria 123 4567</pre>\n\nOra basta scegliere un punto di inizio e fine e creare la partizione, dovrai specificare il tipo di partizione a seconda della tabella che hai usato. \n\n<b>Ridimensiona una partizione</b>\n\nPuoi anche ridimensionare una partizione se non hai spazio. \n\n<pre>resize 2 1245 3456</pre>\n\nSeleziona il numero di partizione e quindi i punti di inizio e fine in cui desideri ridimensionarla. \n\nParted è uno strumento molto potente e dovresti fare attenzione quando partizioni i tuoi dischi.",
          "quizAnswer": "mkpart",
          "quizQuestion": "Qual è il comando di parted per creare una partizione?",
          "slug": "partizionamentodisco",
          "title": "Partizionamento del disco"
        },
        {
          "exercise": "Crea un filesystem ext4 sull'unità USB.",
          "id": 5,
          "lessonContent": "Ora che hai effettivamente partizionato un disco, creiamo un filesystem!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nSemplice come quello! Lo strumento <b>mkfs</b> (make filesystem) ci permette di specificare il tipo di filesystem che desideriamo e dove lo vogliamo. Vorrai creare un filesystem solo su un disco appena partizionato o se stai ripartizionando uno vecchio. Molto probabilmente lascerai il filesystem in uno stato corrotto se cerchi di crearne uno sopra uno esistente.",
          "quizAnswer": "mkfs",
          "quizQuestion": "Quale comando viene utilizzato per creare un filesystem?",
          "slug": "creazionefilesystem",
          "title": "Creazione di filesystem"
        },
        {
          "exercise": "Guarda la pagina di manuale per mount e umount e vedi quali altre opzioni puoi utilizzare.",
          "id": 6,
          "lessonContent": "Prima di poter visualizzare i contenuti del tuo filesystem, dovrai montarlo. Per fare ciò avrò bisogno della posizione del dispositivo, del tipo di filesystem e di un punto di mount, il punto di mount è una directory nel sistema dove il filesystem verrà collegato. Quindi fondamentalmente vogliamo montare il nostro dispositivo su un punto di mount. \n\nPrima crea il punto di mount, nel nostro caso <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nSemplice come quello! Ora quando andiamo su /mydrive possiamo vedere i contenuti del nostro filesystem, il <b>-t</b> specifica il tipo di filesystem, poi abbiamo la posizione del dispositivo, quindi il punto di mount. \n\nPer smontare un dispositivo da un punto di mount: \n\n<pre>$ sudo umount /mydrive \no \n$ sudo umount /dev/sdb2</pre>\n\nRicorda che il kernel nomina i dispositivi nell'ordine in cui li trova. Cosa succede se il nome del nostro dispositivo cambia per qualche motivo dopo averlo montato? Beh fortunatamente, puoi utilizzare l'ID univoco universale (UUID) di un dispositivo invece di un nome.\n\nPer visualizzare gli UUID sul tuo sistema per i dispositivi di blocco:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nPossiamo vedere i nomi dei nostri dispositivi, i rispettivi tipi di filesystem e i loro UUID. Ora quando vogliamo montare qualcosa, possiamo usare:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nLa maggior parte delle volte non avrai bisogno di montare i dispositivi tramite i loro UUID, è molto più facile usare il nome del dispositivo e spesso il sistema operativo saprà montare dispositivi comuni come le chiavette USB. Se hai bisogno di montare automaticamente un filesystem all'avvio come ad esempio se hai aggiunto un secondo hard disk, vorrai utilizzare l'UUID e ne parleremo nella prossima lezione.",
          "quizAnswer": "mount",
          "quizQuestion": "Quale comando viene utilizzato per collegare un filesystem?",
          "slug": "montaggioesmontaggiodeisistemi",
          "title": "montaggio e smontaggio"
        },
        {
          "exercise": "Aggiungi il drive USB su cui stiamo lavorando come voce in /etc/fstab, quando riavvii dovresti vederlo ancora montato.",
          "id": 7,
          "lessonContent": "Quando vogliamo montare automaticamente i filesystem all'avvio, possiamo aggiungerli a un file chiamato /etc/fstab (pronunciato \"eff es tab\" non \"eff stab\") abbreviazione di filesystem table. Questo file contiene un elenco permanente dei filesystem montati.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nOgni riga rappresenta un filesystem, i campi sono: \n\n<ul>\n<li>UUID - Identificatore del dispositivo</li>\n<li>Punto di montaggio - Directory in cui il filesystem è montato</li>\n<li>Tipo di filesystem</li>\n<li>Opzioni - altre opzioni di montaggio, vedere la pagina man per ulteriori dettagli</li>\n<li>Dump - utilizzato dall'utilità dump per decidere quando effettuare un backup, si dovrebbe semplicemente impostare su 0</li>\n<li>Pass - Utilizzato da fsck per decidere in che ordine i filesystem devono essere controllati, se il valore è 0, non verrà controllato</li>\n</ul>\n\nPer aggiungere una voce, modificare direttamente il file /etc/fstab utilizzando la sintassi della voce sopra. Fare attenzione quando si modifica questo file, potresti potenzialmente rendere la tua vita un po' più difficile se commetti errori.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "Quale file viene utilizzato per definire come devono essere montati i filesystem?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Partizionare lo spazio libero sull'unità USB per lo spazio di swap.",
          "id": 8,
          "lessonContent": "Nel nostro esempio precedente, ti ho mostrato come visualizzare la tabella delle partizioni, rivediamo quell'esempio, più specificamente questa riga:\n\n<pre>\nNumero  Inizio   Fine     Dimensione    Tipo      Sistema di file     Flag\n 5      6861MB  7380MB  519MB   logico   linux-swap(v1)\n</pre>\n\nCos'è questa partizione di swap? Beh, lo swap è ciò che usiamo per allocare memoria virtuale al nostro sistema. Se hai poco memoria, il sistema utilizza questa partizione per \"scambiare\" pezzi di memoria di processi inattivi sul disco, in modo da non restare senza memoria.\n\n<b>Utilizzo di una partizione per lo spazio di swap</b>\n\nDiciamo che vogliamo impostare la nostra partizione /dev/sdb2 per essere utilizzata come spazio di swap. \n\n<ol>\n<li>Prima assicuriamoci che non ci sia nulla sulla partizione</li>\n<li>Esegui: mkswap /dev/sdb2 per inizializzare le aree di swap</li>\n<li>Esegui: swapon /dev/sdb2 questo abiliterà il dispositivo di swap</li>\n<li>Se vuoi che la partizione di swap persista all'avvio, devi aggiungere un'voce al file /etc/fstab. sw è il tipo di filesystem che userai.</li>\n<li>Per rimuovere lo swap: swapoff /dev/sdb2</li>\n</ol>\n\nIn generale dovresti allocare circa il doppio dello spazio di swap rispetto alla memoria disponibile. Ma i sistemi moderni di oggi sono di solito abbastanza potenti e hanno abbastanza RAM come è.",
          "quizAnswer": "swapon",
          "quizQuestion": "Qual è il comando per abilitare lo spazio di swap su un dispositivo?",
          "slug": "spaziodiscambio",
          "title": "swap"
        },
        {
          "exercise": "Guarda l'utilizzo del disco e lo spazio libero con entrambi du e df.",
          "id": 9,
          "lessonContent": "Ci sono alcuni strumenti che puoi utilizzare per vedere l'utilizzo dei tuoi dischi: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocks    Used Available Use% Mounted on\n/dev/sda1       6.2G  2.3G  3.6G  40% /\n</pre>\n\nIl comando df ti mostra l'utilizzo dei filesystem attualmente montati. Il flag -h ti fornisce un formato leggibile dall'essere umano. Puoi vedere quale dispositivo è, e quanto spazio è utilizzato e disponibile. \n\nSupponiamo che il tuo disco si stia riempiendo e vuoi sapere quali file o directory stanno occupando quello spazio, per questo puoi utilizzare il comando <b>du</b>. \n\n<pre>$ du -h</pre>\n\nQuesto ti mostra l'utilizzo del disco della directory corrente in cui ti trovi, puoi dare un'occhiata alla directory principale con <b>du -h /</b> ma potrebbe diventare un po' confusionario.\n\nEntrambi questi comandi sono così simili nella sintassi che può essere difficile ricordare quale usare, per controllare quanto spazio del tuo <b>disco</b> è <b>libero</b> usa df. Per controllare l'<b>utilizzo del disco</b>, usa du.",
          "quizAnswer": "df",
          "quizQuestion": "Quale comando viene utilizzato per mostrare quanto spazio è libero sul tuo disco?",
          "slug": "utilizzodisco",
          "title": "Utilizzo del disco"
        },
        {
          "exercise": "Guarda la pagina di manuale di fsck per vedere cos'altro può fare.",
          "id": 10,
          "lessonContent": "A volte il nostro filesystem non è sempre nella migliore condizione, se abbiamo un arresto improvviso, i nostri dati possono diventare corrotti. È compito del sistema cercare di riportarci in uno stato funzionante (anche se possiamo provare da soli).\n\nIl comando <b>fsck</b> (filesystem check) viene utilizzato per verificare la coerenza di un filesystem e può persino provare a ripararlo per noi. Di solito quando avvii un disco, fsck verrà eseguito prima che il disco venga montato per assicurarsi che tutto sia a posto. A volte però, il tuo disco è così danneggiato che dovrai farlo manualmente. Tuttavia, assicurati di farlo mentre sei in un disco di soccorso o in un luogo in cui puoi accedere al tuo filesystem senza che sia montato.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "Quale comando viene utilizzato per verificare l'integrità di un filesystem?",
          "slug": "riparazionefilesystem",
          "title": "Riparazione del filesystem"
        },
        {
          "exercise": "Osserva alcuni numeri di inode per file diversi, quali vengono di solito creati per primi?",
          "id": 11,
          "lessonContent": "Ricordi come il nostro filesystem è composto da tutti i nostri file effettivi e da un database che gestisce questi file? Il database è noto come tabella degli inode. \n\n<b>Cos'è un inode?</b>\n\nUn inode (nodo di indice) è un'entrata in questa tabella e ce n'è uno per ogni file. Descrive tutto riguardo al file, come ad esempio:\n\n<ul>\n<li>Tipo di file - file regolare, directory, dispositivo carattere, ecc</li>\n<li>Proprietario</li>\n<li>Gruppo</li>\n<li>Permessi di accesso</li>\n<li>Timestamps - mtime (ora dell'ultima modifica del file), ctime (ora dell'ultima modifica degli attributi), atime (ora dell'ultimo accesso)</li>\n<li>Numero di collegamenti hard al file</li>\n<li>Dimensione del file</li>\n<li>Numero di blocchi allocati al file</li>\n<li>Puntatori ai blocchi dati del file - molto importanti!</li>\n</ul>\n\nFondamentalmente gli inode memorizzano tutto riguardo al file, tranne il nome del file e il file stesso!\n\n<b>Quando vengono creati gli inode?</b>\n\nQuando viene creato un filesystem, viene allocato spazio anche per gli inode. Ci sono algoritmi che determinano di quanto spazio inode hai bisogno in base al volume del disco e altro. Probabilmente hai visto in passato errori per problemi di spazio su disco esaurito. Beh, lo stesso può accadere anche per gli inode (anche se meno comunemente), puoi esaurire gli inode e quindi non essere in grado di creare più file. Ricorda che lo spazio di archiviazione dei dati dipende sia dai dati che dal database (inode). \n\nPer vedere quanti inode sono rimasti sul tuo sistema, usa il comando <b>df -i</b>\n\n<b>Informazioni sugli inode</b>\n\nGli inode sono identificati da numeri, quando viene creato un file gli viene assegnato un numero di inode, il numero viene assegnato in ordine sequenziale. Tuttavia, a volte potresti notare che quando crei un nuovo file, ottiene un numero di inode più basso rispetto agli altri, questo perché una volta che gli inode vengono eliminati, possono essere riutilizzati da altri file. Per visualizzare i numeri di inode esegui <b>ls -li</b>:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nIl primo campo in questo comando elenca il numero di inode.\n\nPuoi anche vedere informazioni dettagliate su un file con stat, ti fornisce informazioni anche sull'inode.\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  File: ‘/home/pete/Desktop/’\n  Size: 6               Blocks: 0          IO Block: 4096   directory\nDevice: 806h/2054d      Inode: 140         Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAccess: 2016-01-20 20:13:50.647435982 -0800\nModify: 2016-01-20 20:13:06.191675843 -0800\nChange: 2016-01-20 20:13:06.191675843 -0800\n Birth: -\n</pre>\n\n\n<b>Come gli inode individuano i file?</b>\n\nSappiamo che i nostri dati sono là fuori sul disco da qualche parte, sfortunatamente probabilmente non sono stati memorizzati in modo sequenziale, quindi dobbiamo usare gli inode. Gli inode puntano ai blocchi dati effettivi dei tuoi file. In un filesystem tipico (non tutti funzionano allo stesso modo), ogni inode contiene 15 puntatori, i primi 12 puntatori puntano direttamente ai blocchi dati. Il 13° puntatore punta a un blocco contenente puntatori ad altri blocchi, il 14° puntatore punta a un altro blocco nidificato di puntatori, e il 15° puntatore punta ancora a un altro blocco di puntatori! Confuso, lo so! Il motivo per cui è fatto in questo modo è mantenere la struttura dell'inode uguale per ogni inode, ma essere in grado di fare riferimento a file di dimensioni diverse. Se hai un file piccolo, puoi trovarlo più velocemente con i primi 12 puntatori diretti, i file più grandi possono essere trovati con i nidificati di puntatori. In ogni caso la struttura dell'inode è la stessa.",
          "quizAnswer": "df -i",
          "quizQuestion": "Come si fa a vedere quanti inode sono rimasti sul tuo sistema?",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "Gioca con la creazione di collegamenti simbolici e collegamenti fisici, elimina un paio e vedi cosa succede.",
          "id": 12,
          "lessonContent": "Utilizziamo un esempio precedente di informazioni sull'inode: \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nPotresti aver notato che abbiamo trascurato il terzo campo nel comando ls, quel campo è il conteggio dei link. Il conteggio dei link è il numero totale di collegamenti fisici che un file ha, ma questo non significa nulla per te al momento. Quindi parliamo prima dei link. \n\n<b>Collegamenti simbolici</b>\n\nNel sistema operativo Windows, ci sono cose note come collegamenti, i collegamenti sono solo alias ad altri file. Se fai qualcosa al file originale, potresti potenzialmente rompere il collegamento. In Linux, l'equivalente dei collegamenti sono i collegamenti simbolici (o collegamenti soft o collegamenti simbolici). I collegamenti simbolici ci permettono di collegarci a un altro file tramite il suo nome file. Un altro tipo di collegamenti trovati in Linux sono i collegamenti fisici, che sono effettivamente un altro file con un collegamento a un inode. Vediamo cosa intendo in pratica partendo dai collegamenti simbolici.\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n</pre>\n\nPuoi vedere che ho creato un collegamento simbolico chiamato myfilelink che punta a myfile. I collegamenti simbolici sono indicati da ->. Nota come ho ottenuto un nuovo numero di inode, i collegamenti simbolici sono solo file che puntano a nomi file. Quando modifichi un collegamento simbolico, il file viene anche modificato. I numeri di inode sono univoci per i filesystem, non puoi avere due numeri di inode uguali in un singolo filesystem, il che significa che non puoi fare riferimento a un file in un filesystem diverso tramite il suo numero di inode. Tuttavia, se usi i collegamenti simbolici, non usano numeri di inode, usano nomi file, quindi possono essere referenziati attraverso diversi filesystem. \n\n<b>Collegamenti fisici</b>\n\nVediamo un esempio di collegamento fisico:\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myhardlink\n</pre>\n\nUn collegamento fisico crea semplicemente un altro file con un collegamento allo stesso inode. Quindi se modificassi i contenuti di myfile2 o myhardlink, la modifica sarebbe visibile su entrambi, ma se eliminassi myfile2, il file sarebbe comunque accessibile tramite myhardlink. Qui è dove entra in gioco il conteggio dei link nel comando ls. Il conteggio dei link è il numero di collegamenti fisici che un inode ha, quando rimuovi un file, questo diminuirà il conteggio dei link. L'inode viene eliminato solo quando tutti i collegamenti fisici all'inode sono stati eliminati. Quando crei un file, il suo conteggio dei link è 1 perché è l'unico file che punta a quell'inode. A differenza dei collegamenti simbolici, i collegamenti fisici non si estendono su diversi filesystem perché gli inode sono univoci per il filesystem. \n\n<b>Creazione di un collegamento simbolico</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nPer creare un collegamento simbolico, si utilizza il comando ln con -s per simbolico e si specifica un file di destinazione e quindi un nome di collegamento. \n\n<b>Creazione di un collegamento fisico</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nSimile alla creazione di un collegamento simbolico, tranne che questa volta si omette il -s.",
          "quizAnswer": "ln -s",
          "quizQuestion": "Qual è il comando utilizzato per creare un collegamento simbolico?",
          "slug": "symlinks",
          "title": "symlinks"
        }
      ],
      "slug": "thefilesystem",
      "title": "Il Filesystem"
    },
    {
      "description": "Scopri le fasi del processo di avvio di Linux.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Riavvia il tuo sistema e vedi se riesci a individuare ogni passaggio mentre il tuo computer si avvia.",
          "id": 1,
          "lessonContent": "Ora che abbiamo acquisito una buona comprensione di alcuni dei componenti importanti di Linux, mettiamoli insieme imparando come il sistema si avvia. Quando accendi il tuo computer, fa alcune cose interessanti come mostrarti lo schermo del logo, eseguire una serie di messaggi diversi e alla fine ti viene presentata una finestra di accesso. Beh, in realtà ci sono un sacco di cose che accadono tra quando premi il pulsante di accensione e quando effettui l'accesso e ne discuteremo in questo corso. \n\nIl processo di avvio di Linux può essere suddiviso in 4 semplici fasi: \n\n<b>1. BIOS</b>\n\nIl BIOS (acronimo di \"Basic Input/Output System\") inizializza l'hardware e si assicura con un test di accensione (POST) che tutto l'hardware sia pronto per l'uso. Il compito principale del BIOS è caricare il bootloader.\n\n<b>2. Bootloader</b>\n\nIl bootloader carica il kernel in memoria e avvia quindi il kernel con un insieme di parametri del kernel. Uno dei bootloader più comuni è GRUB, che è uno standard universale per Linux. \n\n<b>3. Kernel</b>\n\nQuando il kernel viene caricato, inizializza immediatamente dispositivi e memoria. Il compito principale del kernel è caricare il processo init. \n\n<b>4. Init</b>\n\nRicorda che il processo init è il primo processo che viene avviato, init avvia e arresta i processi di servizio essenziali nel sistema. Esistono tre implementazioni principali di init nelle distribuzioni Linux. Ne parleremo brevemente e poi approfondiremo in un altro corso.\n\nEcco la (molto) semplice spiegazione del processo di avvio di Linux. Approfondiremo queste fasi nelle prossime lezioni.",
          "quizAnswer": "init",
          "quizQuestion": "Qual è l'ultima fase nel processo di avvio di Linux?",
          "slug": "panoramica-processo-avvio",
          "title": "Panoramica del processo di avvio"
        },
        {
          "exercise": "Entra nel menu del BIOS e verifica se hai abilitato l'avvio UEFI.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nIl primo passo nel processo di avvio di Linux è il BIOS che esegue controlli sull'integrità del sistema. Il BIOS è un firmware che si trova più comunemente nei computer compatibili con IBM PC, il tipo di computer dominante oggi. Probabilmente hai usato il firmware del BIOS per cambiare l'ordine di avvio dei tuoi dischi rigidi, controllare l'orario di sistema, l'indirizzo MAC della tua macchina, ecc. L'obiettivo principale del BIOS è trovare il bootloader di sistema.\n\nQuindi una volta che il BIOS avvia il disco rigido, cerca il blocco di avvio per capire come avviare il sistema. A seconda di come hai partizionato il disco, cercherà il master boot record (MBR) o GPT. Il MBR si trova nel primo settore del disco rigido, i primi 512 byte. Il MBR contiene il codice per caricare un altro programma da qualche parte sul disco, questo programma a sua volta avvia effettivamente il nostro bootloader.\n\nOra, se hai partizionato il disco con GPT, la posizione del bootloader cambia leggermente.\n\n<b>UEFI</b>\n\nC'è un altro modo per avviare il sistema invece di utilizzare il BIOS e si tratta di UEFI (acronimo di \"Unified extensible firmware interface\"). UEFI è stato progettato per essere il successore del BIOS, la maggior parte dell'hardware attuale è dotata di firmware UEFI integrato. Le macchine Macintosh utilizzano l'avvio EFI da anni e Windows ha spostato quasi tutto il loro sistema su avvio UEFI. Il formato GPT è stato pensato per essere utilizzato con EFI. Non è necessario avere EFI se si avvia un disco GPT. Il primo settore di un disco GPT è riservato a un \"MBR protettivo\" per consentire l'avvio di una macchina basata su BIOS.\n\nUEFI memorizza tutte le informazioni sull'avvio in un file .efi. Questo file è memorizzato su una partizione speciale chiamata partizione di sistema EFI sull'hardware. All'interno di questa partizione sarà presente il bootloader. UEFI porta molte migliorie rispetto al tradizionale firmware del BIOS. Tuttavia, poiché stiamo utilizzando Linux, la maggior parte di noi sta utilizzando il BIOS. Quindi tutte queste lezioni seguiranno questa premessa.",
          "quizAnswer": "bootloader",
          "quizQuestion": "Cosa carica il BIOS?",
          "slug": "processo-di-avvio-bios",
          "title": "Processo di avvio: BIOS"
        },
        {
          "exercise": "Se avete GRUB come bootloader, accedete al menu di GRUB con 'e' e date un'occhiata alle impostazioni.",
          "id": 3,
          "lessonContent": "I principali compiti del bootloader sono:\n\n<ul>\n<li>Avviare un sistema operativo, può anche essere utilizzato per avviare sistemi operativi non basati su Linux</li>\n<li>Selezionare un kernel da utilizzare</li>\n<li>Specificare i parametri del kernel</li>\n</ul>\n\nIl bootloader più comune per Linux è GRUB, è molto probabile che lo stiate utilizzando sul vostro sistema. Ci sono molti altri bootloader che è possibile utilizzare come LILO, efilinux, coreboot, SYSLINUX e altri. Tuttavia, lavoreremo solo con GRUB come nostro bootloader. \n\nSappiamo quindi che l'obiettivo principale del bootloader è caricare il kernel, ma dove trova il kernel? Per trovarlo, dovremo esaminare i nostri parametri del kernel. I parametri possono essere trovati accedendo al menu di GRUB all'avvio utilizzando il tasto 'e'. Se non avete GRUB, non preoccupatevi, esamineremo i parametri di avvio che vedrete:\n\n<ul>\n<li>initrd - Specifica la posizione del disco RAM iniziale (ne parleremo meglio nella prossima lezione).</li>\n<li>BOOT_IMAGE - Qui si trova l'immagine del kernel</li>\n<li>root - La posizione del filesystem radice, il kernel cerca all'interno di questa posizione per trovare init. Spesso è rappresentato dal suo UUID o dal nome del dispositivo come ad esempio /dev/sda1.</li>\n<li>ro - Questo parametro è abbastanza standard, monta il filesystem in modalità di sola lettura.</li>\n<li>quiet - Viene aggiunto per evitare di visualizzare i messaggi di avvio che si verificano sullo sfondo durante l'avvio.</li>\n<li>splash - Consente di visualizzare la schermata di avvio.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "Quale parametro del kernel fa sì che non si vedano i messaggi di avvio?",
          "slug": "processo-di-avvio-bootloader",
          "title": "Processo di avvio: Bootloader"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "Ora che il nostro bootloader ha passato i parametri necessari, vediamo come viene avviato:\n\n<b>Initrd vs Initramfs</b>\n\nC'è un po' di un problema del tipo uovo e gallina quando parliamo dell'avvio del kernel. Il kernel gestisce l'hardware dei nostri sistemi, tuttavia non tutti i driver sono disponibili per il kernel durante l'avvio. Quindi dipendiamo da un filesystem root temporaneo che contiene solo i moduli essenziali di cui il kernel ha bisogno per accedere al resto dell'hardware. Nelle versioni più vecchie di Linux, questo compito era affidato all'initrd (disco ram iniziale). Il kernel montava l'initrd, ottenendo i driver di avvio necessari, poi quando aveva caricato tutto ciò di cui aveva bisogno, sostituiva l'initrd con il filesystem root effettivo. Oggi abbiamo qualcosa chiamato initramfs, che è un filesystem root temporaneo incorporato nel kernel stesso per caricare tutti i driver necessari per il vero filesystem root, quindi non è più necessario individuare il file initrd. \n\n<b>Montaggio del filesystem root</b>\n\nOra il kernel ha tutti i moduli di cui ha bisogno per creare un dispositivo root e montare la partizione root. Prima di procedere oltre, la partizione root viene effettivamente montata in modalità di sola lettura in modo che fsck possa essere eseguito in modo sicuro e controllare l'integrità del sistema. Successivamente remonta il filesystem root in modalità di scrittura. Poi il kernel individua il programma init ed esegue l'avvio.",
          "quizAnswer": "initramfs",
          "quizQuestion": "Cosa viene utilizzato nei sistemi moderni per caricare un filesystem root temporaneo?",
          "slug": "processoavviokernel",
          "title": "Processo di avvio: Kernel"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Abbiamo discusso di init nelle lezioni precedenti e sappiamo che è il primo processo che viene avviato e avvia tutti gli altri servizi essenziali sul nostro sistema. Ma come?\n\nIn realtà ci sono tre principali implementazioni di init in Linux: \n\n<b>System V init (sysv)</b>\n\nQuesto è il sistema init tradizionale. Avvia e ferma sequenzialmente i processi, basandosi sugli script di avvio. Lo stato della macchina è indicato dai runlevel, ciascun runlevel avvia o ferma una macchina in modo diverso. \n\n<b>Upstart</b>\n\nQuesto è l'init che troverai nelle vecchie installazioni di Ubuntu. Upstart utilizza l'idea di job ed eventi e funziona avviando job che eseguono determinate azioni in risposta agli eventi. \n\n<b>Systemd</b>\n\nQuesto è il nuovo standard per init, è orientato agli obiettivi. Fondamentalmente hai un obiettivo che vuoi raggiungere e systemd cerca di soddisfare le dipendenze dell'obiettivo per completarlo. \n\nAbbiamo un intero corso sui sistemi di Init dove approfondiremo ciascuno di questi sistemi in modo più dettagliato.",
          "quizAnswer": "systemd",
          "quizQuestion": "Qual è il nuovo standard per init?",
          "slug": "processodiavvioinit",
          "title": "Processo di avvio: Init"
        }
      ],
      "slug": "bootthesystem",
      "title": "Avvia il sistema"
    },
    {
      "description": "La parte più importante del sistema Linux, scopri come funziona e come configurarlo.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Come avrai appreso fino a questo punto, il kernel è il nucleo del sistema operativo. Abbiamo parlato delle altre parti del sistema operativo ma non abbiamo ancora mostrato come lavorino tutte insieme. Il sistema operativo Linux può essere organizzato in tre diversi livelli di astrazione.\n\nIl livello più basilare è l'hardware, che include la CPU, la memoria, i dischi rigidi, le porte di rete, ecc. Il livello fisico che effettivamente calcola ciò che la nostra macchina sta facendo.\n\nIl livello successivo è il kernel, che gestisce i processi e la gestione della memoria, la comunicazione dei dispositivi, le chiamate di sistema, imposta il nostro filesystem, ecc. Il compito del kernel è parlare con l'hardware per assicurarsi che faccia ciò che vogliamo che facciano i nostri processi.\n\nE il livello con cui sei familiare è lo spazio utente, che include la shell, i programmi che esegui, la grafica, ecc.\n\nIn questo corso, ci concentreremo sul kernel e impareremo le sue complessità.",
          "quizAnswer": "kernel",
          "quizQuestion": "Quale livello del sistema operativo gestisce i dispositivi?",
          "slug": "kerneloverview",
          "title": "Panoramica del Kernel"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 2,
          "lessonContent": "Le prossime lezioni diventano piuttosto teoriche, quindi se stai cercando qualcosa di pratico puoi saltare avanti e tornare indietro più tardi.\n\nPerché abbiamo diversi livelli di astrazione per lo spazio utente e il kernel? Perché non è possibile combinare entrambi i poteri in un unico livello? Beh, c'è una buona ragione per cui questi due livelli esistono separatamente. Entrambi operano in modalità diversa, il kernel opera in modalità kernel e lo spazio utente opera in modalità utente. \n\nIn modalità kernel, il kernel ha accesso completo all'hardware, controlla tutto. In modalità spazio utente, c'è una quantità molto limitata di memoria sicura e CPU a cui si può accedere. Fondamentalmente, quando vogliamo fare qualcosa che coinvolge l'hardware, leggere dati dai nostri dischi, scrivere dati sui nostri dischi, controllare la nostra rete, ecc., tutto ciò avviene in modalità kernel. Perché è necessario questo? Immagina se il tuo computer fosse infettato da spyware, non vorresti che avesse accesso diretto all'hardware del tuo sistema. Potrebbe accedere a tutti i tuoi dati, alla tua webcam, ecc. e questo non va bene. \n\nQueste diverse modalità sono chiamate livelli di privilegio (chiamati in modo appropriato per i livelli di privilegio ottenuti) e sono spesso descritti come anelli di protezione. Per rendere più facile dipingere questa immagine, diciamo che scopri che Britney Spears è in città al tuo locale klerb, è protetta dai suoi fan, poi dalle sue guardie del corpo personali, poi dal buttafuori fuori dal klerb. Vuoi prendere il suo autografo (perché no?), ma non riesci a raggiungerla perché è fortemente protetta. Gli anelli funzionano allo stesso modo, l'anello più interno corrisponde al livello di privilegio più alto. Ci sono due livelli o modalità principali in un'architettura computerizzata x86. L'anello n. 3 è il privilegio in cui vengono eseguite le applicazioni in modalità utente, l'anello n. 0 è il privilegio in cui viene eseguito il kernel. L'anello n. 0 può eseguire qualsiasi istruzione di sistema e ha piena fiducia. Ora che sappiamo come funzionano quei livelli di privilegio, come facciamo a scrivere qualcosa sull'hardware? Non saremo sempre in una modalità diversa rispetto al kernel? \n\nLa risposta è con le chiamate di sistema, le chiamate di sistema ci permettono di eseguire un'istruzione privilegiata in modalità kernel e poi tornare in modalità utente.",
          "quizAnswer": "0",
          "quizQuestion": "Quale numero di anello ha i privilegi più alti?",
          "slug": "kernelprivilegelevels",
          "title": "Livelli di privilegio"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Ricordi Britney nella lezione precedente? Diciamo che vogliamo vederla e prendere qualcosa da bere insieme, come facciamo a passare dall'essere fuori tra la folla di persone all'interno del suo cerchio più intimo? Useremmo le chiamate di sistema. Le chiamate di sistema sono come i pass VIP che ti portano a una porta segreta che conduce direttamente a Britney.\n\nLe chiamate di sistema (syscall) forniscono ai processi dello spazio utente un modo per richiedere al kernel di fare qualcosa per noi. Il kernel mette a disposizione determinati servizi tramite l'API delle chiamate di sistema. Questi servizi ci permettono di leggere o scrivere su un file, modificare l'uso della memoria, modificare la nostra rete, ecc. Il numero di servizi è fisso, quindi non puoi aggiungere chiamate di sistema a caso, il tuo sistema ha già una tabella delle chiamate di sistema esistenti e ogni chiamata di sistema ha un ID univoco. \n\nNon entrerò nei dettagli delle chiamate di sistema, poiché ciò richiederebbe che tu conosca un po' di C, ma il concetto di base è che quando chiami un programma come ls, il codice all'interno di questo programma contiene un wrapper di chiamata di sistema (quindi non la chiamata di sistema effettiva ancora). All'interno di questo wrapper viene invocata la chiamata di sistema che eseguirà una trappola, questa trappola viene quindi intercettata dal gestore delle chiamate di sistema e quindi fa riferimento alla chiamata di sistema nella tabella delle chiamate di sistema. Diciamo che stiamo cercando di chiamare la chiamata di sistema stat(), essa è identificata da un ID di chiamata di sistema e lo scopo della chiamata di sistema stat() è interrogare lo stato di un file. Ora ricorda, stavate eseguendo il programma ls in modalità non privilegiata. Quindi ora vede che stai cercando di fare una chiamata di sistema, ti passa quindi alla modalità kernel, lì fa molte cose ma soprattutto cerca il numero della tua chiamata di sistema, lo trova in una tabella basata sull'ID della chiamata di sistema e quindi esegue la funzione che volevi eseguire. Una volta completato, tornerà alla modalità utente e il tuo processo riceverà uno stato di ritorno se è stato eseguito con successo o se ha avuto un errore. I dettagli delle chiamate di sistema diventano molto approfonditi, ti consiglierei di cercare informazioni online se vuoi saperne di più. \n\nPuoi effettivamente visualizzare le chiamate di sistema che un processo effettua con il comando strace. Il comando strace è utile per il debug di come un programma è stato eseguito. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "chiamata di sistema",
          "quizQuestion": "Cosa viene utilizzato per passare dalla modalità utente alla modalità kernel?",
          "slug": "chiamatedisistema",
          "title": "Chiamate di sistema"
        },
        {
          "exercise": "<ol>\n<li>Scopri quale versione del kernel hai.</li>\n<li>Ricerca le diverse versioni di kernel disponibili</li>\n</ol>",
          "id": 4,
          "lessonContent": "Ok, ora che abbiamo finito con tutte quelle noiose informazioni, parliamo dell'effettiva installazione e modifica dei kernel. È possibile installare più kernel sul proprio sistema, ricordi la nostra lezione sul processo di avvio? Nel menu GRUB possiamo scegliere quale kernel avviare. \n\nPer vedere quale versione del kernel hai sul tuo sistema, utilizza il seguente comando:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nIl comando uname stampa le informazioni di sistema, il comando -r stamperà tutta la versione di rilascio del kernel.\n\nÈ possibile installare il kernel Linux in modi diversi, è possibile scaricare il pacchetto sorgente e compilare da sorgente oppure è possibile installarlo utilizzando gli strumenti di gestione dei pacchetti.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\ne poi riavviare nel kernel che hai installato. Semplice, vero? In parte sì, dovrai anche installare altri pacchetti Linux come linux-headers, linux-image-generic, ecc.). È anche possibile specificare il numero di versione, quindi il comando sopra può apparire come, <b>sudo apt install 3.19.0-43-generic</b>\n\nIn alternativa, se desideri solo la versione aggiornata del kernel, utilizza semplicemente dist-upgrade, che esegue aggiornamenti a tutti i pacchetti sul tuo sistema:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nCi sono molte versioni diverse del kernel, alcune sono utilizzate come LTS (supporto a lungo termine), alcune sono le ultime e migliori, la compatibilità può essere molto diversa tra le versioni del kernel quindi potresti voler provare diversi kernel.",
          "quizAnswer": "uname -r",
          "quizQuestion": "Come si visualizza la versione del kernel del proprio sistema?",
          "slug": "installazionekernel",
          "title": "Installazione del Kernel"
        },
        {
          "exercise": "Vai nella tua directory /boot e guarda quali file ci sono all'interno.",
          "id": 5,
          "lessonContent": "Cosa succede quando si installa un nuovo kernel? Beh, in realtà vengono aggiunti un paio di file al sistema, questi file vengono di solito aggiunti alla directory /boot. \n\nVedrai diversi file per diverse versioni del kernel:\n\n<ul>\n<li>vmlinuz - questo è il vero kernel di Linux</li>\n<li>initrd - come abbiamo discusso in precedenza, l'initrd viene utilizzato come un filesystem temporaneo, utilizzato prima del caricamento del kernel</li>\n<li>System.map - tabella di ricerca simbolica</li>\n<li>config - impostazioni di configurazione del kernel, se stai compilando il tuo kernel, puoi impostare quali moduli possono essere caricati</li>\n</ul>\n\nSe la tua directory /boot si riempie, puoi sempre eliminare le vecchie versioni di questi file o semplicemente utilizzare un gestore di pacchetti, ma fai attenzione quando fai manutenzione in questa directory e non eliminare accidentalmente il kernel che stai utilizzando.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "Come si chiama l'immagine del kernel in /boot?",
          "slug": "kernellocation",
          "title": "Posizione del Kernel"
        },
        {
          "exercise": "Scarica il modulo bluetooth con modprobe e vedi cosa succede. Come lo risolveresti?",
          "id": 6,
          "lessonContent": "Immaginiamo di avere un'auto personalizzata, su cui abbiamo investito molto tempo e denaro. Aggiungiamo un alettone, un gancio traino, un portabici e altre cose casuali. Questi componenti non modificano effettivamente la funzionalità principale dell'auto e possiamo rimuoverli e aggiungerli molto facilmente. Il kernel utilizza lo stesso concetto con i moduli del kernel.\n\nIl kernel in sé è un pezzo monolitico di software, quando vogliamo aggiungere il supporto per un nuovo tipo di tastiera, non scriviamo direttamente questo codice nel codice del kernel. Proprio come non salderemmo un portabici alla nostra auto (beh, forse alcune persone lo farebbero). I moduli del kernel sono pezzi di codice che possono essere caricati e scaricati nel kernel su richiesta. Ci permettono di estendere la funzionalità del kernel senza aggiungere effettivamente al codice del kernel principale. Possiamo anche aggiungere moduli e non dobbiamo riavviare il sistema (nella maggior parte dei casi).\n\n<b>Visualizza un elenco dei moduli attualmente caricati</b>\n\n<pre>$ lsmod</pre>\n\n<b>Carica un modulo</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe prova a caricare il modulo da <b>/lib/modules/(versione del kernel)/kernel/drivers</b>. I moduli del kernel possono anche avere dipendenze, modprobe carica le dipendenze del nostro modulo se non sono già caricate. \n\n<b>Rimuovi un modulo</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Carica all'avvio</b>\n\nPuoi anche caricare moduli durante l'avvio del sistema, invece di caricarli temporaneamente con modprobe (che verranno scaricati quando riavvii). Basta modificare la directory <b>/etc/modprobe.d</b> e aggiungere un file di configurazione al suo interno in questo modo:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nopzioni burro_di_arachidi tipo=mandorla\n</pre>\n\nUn esempio un po' stravagante, ma se avessi un modulo chiamato burro_di_arachidi e volessi aggiungere un parametro del kernel per tipo=mandorla, puoi farlo caricare all'avvio usando questo file di configurazione. Nota anche che i moduli del kernel hanno i propri parametri del kernel, quindi dovrai leggere specificamente sul modulo per saperne di più.\n\n<b>Non caricare all'avvio</b>\n\nPuoi anche assicurarti che un modulo non venga caricato all'avvio aggiungendo un file di configurazione in questo modo:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nlista_nera burro_di_arachidi\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "Quale comando viene utilizzato per scaricare un modulo?",
          "slug": "modulikernel",
          "title": "Moduli del kernel"
        }
      ],
      "slug": "kernel",
      "title": "Kernel"
    },
    {
      "description": "Scopri i diversi sistemi di init, SysV, Upstart e systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Se stai utilizzando System V, cambia il runlevel predefinito della tua macchina con qualcos'altro e guarda cosa succede.",
          "id": 1,
          "lessonContent": "Lo scopo principale di init è avviare e fermare processi essenziali sul sistema. Ci sono tre principali implementazioni di init in Linux, System V, Upstart e systemd. In questa lezione, esamineremo la versione più tradizionale di init, System V init o Sys V (pronunciato come 'System Five'). \n\nPer scoprire se stai utilizzando l'implementazione Sys V init, se hai un file /etc/inittab è probabile che tu stia eseguendo Sys V. \n\nSys V avvia e ferma i processi in modo sequenziale, quindi diciamo che se volessi avviare un servizio chiamato foo-a, prima che foo-b possa funzionare, devi assicurarti che foo-a sia già in esecuzione. Sys V lo fa con degli script, questi script avviano e fermano i servizi per noi, possiamo scrivere i nostri script o la maggior parte delle volte utilizzare quelli già integrati nel sistema operativo e utilizzati per caricare servizi essenziali. \n\nI vantaggi nell'utilizzare questa implementazione di init sono che è relativamente facile risolvere le dipendenze, poiché sai che foo-a viene prima di foo-b, tuttavia le prestazioni non sono eccellenti perché di solito una cosa si avvia o si ferma alla volta. \n\nQuando si utilizza Sys V, lo stato della macchina è definito dai runlevel che vanno da 0 a 6. Queste diverse modalità varieranno a seconda della distribuzione, ma nella maggior parte dei casi assomiglieranno a quanto segue: \n\n<ul>\n<li>0: Arresto</li>\n<li>1: Modalità utente singolo</li>\n<li>2: Modalità multiutente senza connessione di rete</li>\n<li>3: Modalità multiutente con connessione di rete</li>\n<li>4: Non utilizzato</li>\n<li>5: Modalità multiutente con connessione di rete e interfaccia grafica</li>\n<li>6: Riavvio</li>\n</ul>\n\nQuando il sistema si avvia, controlla in quale runlevel ti trovi ed esegue gli script situati all'interno di quella configurazione di runlevel. Gli script si trovano in <b>/etc/rc.d/rc[numero runlevel].d/</b> o <b>/etc/init.d</b>. Gli script che iniziano con S (avvio) o K (kill) verranno eseguiti all'avvio e allo spegnimento, rispettivamente. I numeri accanto a questi caratteri indicano la sequenza in cui vengono eseguiti. \n\nAd esempio:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nVediamo che quando passiamo al runlevel 0 o modalità di spegnimento, la nostra macchina cercherà di eseguire uno script per fermare i servizi di aggiornamento e quindi openvpn. Per scoprire in quale runlevel si avvia la tua macchina, puoi vedere il runlevel predefinito nel file /etc/inittab. Puoi anche modificare il runlevel predefinito in questo file. \n\nDa notare, System V sta lentamente venendo sostituito, forse non oggi, o neanche tra anni. Tuttavia, potresti vedere runlevel emergere in altre implementazioni di init, principalmente per supportare quei servizi che vengono avviati o fermati solo utilizzando script di init di System V.",
          "quizAnswer": "0",
          "quizQuestion": "Quale runlevel viene di solito utilizzato per lo spegnimento?",
          "slug": "panoramica-sysv",
          "title": "Panoramica di System V"
        },
        {
          "exercise": "Gestire un paio di servizi e cambiare i loro stati, cosa osservi?",
          "id": 2,
          "lessonContent": "Ci sono molti strumenti a riga di comando che puoi utilizzare per gestire i servizi Sys V. \n\n<b>Elencare i servizi</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Avviare un servizio</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Arrestare un servizio</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Riavviare un servizio</b>\n\n<pre>$ sudo service networking restart</pre>\n\nQuesti comandi non sono specifici per i sistemi di inizializzazione Sys V, puoi utilizzarli anche per gestire i servizi Upstart. Poiché Linux sta cercando di allontanarsi dagli script di inizializzazione Sys V più tradizionali, ci sono ancora strumenti disponibili per aiutare in questa transizione.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Qual è il comando per arrestare un servizio chiamato peanut con Sys V?",
          "slug": "sysvservices",
          "title": "Servizio System V"
        },
        {
          "exercise": "Se stai utilizzando Upstart, vedi se riesci a capire le configurazioni di lavoro in /etc/init.",
          "id": 3,
          "lessonContent": "Upstart è stato sviluppato da Canonical, quindi è stata l'implementazione di init su Ubuntu per un po', tuttavia nelle installazioni moderne di Ubuntu viene ora utilizzato systemd. Upstart è stato creato per migliorare i problemi di Sys V, come i rigorosi processi di avvio, il blocco dei compiti, ecc. Il modello basato su eventi e lavori di Upstart gli consente di rispondere agli eventi man mano che si verificano. \n\nPer scoprire se stai utilizzando Upstart, se hai una directory /usr/share/upstart è un indicatore abbastanza buono. \n\nI lavori sono le azioni che Upstart esegue e gli eventi sono messaggi ricevuti da altri processi per attivare i lavori. Per vedere un elenco dei lavori e delle loro configurazioni:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nAll'interno di queste configurazioni di lavoro, verranno incluse informazioni su come avviare i lavori e quando avviare i lavori.\n\nAd esempio, nel file networking.conf, potrebbe dire qualcosa di semplice come:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nQuesto significa che inizierà a configurare la rete su runlevel 2, 3 o 5 e interromperà la rete su runlevel 0. Ci sono molti modi per scrivere il file di configurazione e scoprirai questo quando guarderai le diverse configurazioni di lavoro disponibili. \n\nIl modo in cui funziona Upstart è il seguente: \n\n<ol>\n<li>Prima, carica le configurazioni di lavoro da /etc/init</li>\n<li>Una volta che si verifica un evento di avvio, eseguirà i lavori attivati da quell'evento.</li>\n<li>Questi lavori creeranno nuovi eventi e poi quegli eventi attiveranno ulteriori lavori</li>\n<li>Upstart continua a fare questo fino a quando completa tutti i lavori necessari</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Qual è l'implementazione di init utilizzata da Ubuntu?",
          "slug": "panoramicaupstart",
          "title": "Panoramica di Upstart"
        },
        {
          "exercise": "Osserva il tuo elenco di lavori Upstart, ora cambia lo stato del lavoro con uno dei comandi che abbiamo imparato oggi. Cosa noti dopo?",
          "id": 4,
          "lessonContent": "Upstart può attivare molti eventi e lavori da eseguire, purtroppo non c'è un modo facile per vedere da dove proviene un evento o un lavoro, quindi dovrai esaminare le configurazioni dei lavori in /etc/init. La maggior parte delle volte, non avrai mai bisogno di guardare i file di configurazione dei lavori di Upstart, ma vorrai controllare più facilmente alcuni lavori specifici. Ci sono molti comandi utili che puoi utilizzare in un sistema Upstart. \n\n<b>Visualizza i lavori</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nVedrai un elenco di lavori Upstart con diversi stati applicati ad essi. In ogni riga, il nome del lavoro è il primo valore e il secondo campo (prima dello /) è effettivamente l'obiettivo del lavoro, il terzo valore (dopo lo /) è lo stato attuale. Quindi vediamo che il nostro lavoro di spegnimento alla fine vuole fermarsi, ma attualmente si trova in uno stato di attesa. Lo stato e gli obiettivi del lavoro cambieranno mentre avvii o fermi i lavori. \n\n<b>Visualizza un lavoro specifico</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nNon entreremo nei dettagli su come scrivere una configurazione di lavoro Upstart, tuttavia sappiamo già che i lavori vengono fermati, avviati e riavviati in queste configurazioni. Questi lavori emettono anche eventi, quindi possono avviare altri lavori. Esamineremo i comandi manuali dell'operazione Upstart, ma se sei curioso, dovresti approfondire i file .conf in modo più dettagliato.\n\n<b>Avvia manualmente un lavoro</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Ferma manualmente un lavoro</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Riavvia manualmente un lavoro</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Emetti manualmente un evento</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Come posso riavviare manualmente un lavoro Upstart chiamato peanuts?",
          "slug": "upstartjobs",
          "title": "Upstart Jobs"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Systemd sta lentamente diventando lo standard emergente per l'inizializzazione. Se hai una directory /usr/lib/systemd, è molto probabile che tu stia usando systemd.\n\nSystemd utilizza degli obiettivi per avviare il sistema. Fondamentalmente hai un target che desideri raggiungere e questo target ha anche delle dipendenze che dobbiamo soddisfare. Systemd è estremamente flessibile e robusto, non segue una sequenza rigida per avviare i processi. Ecco cosa succede durante l'avvio tipico di systemd:\n\n<ol>\n<li>Prima, systemd carica i suoi file di configurazione, di solito situati in /etc/systemd/system o /usr/lib/systemd/system</li>\n<li>Poi determina il suo obiettivo di avvio, che di solito è default.target</li>\n<li>Systemd individua le dipendenze del target di avvio e le attiva</l>\n</ol>\n\nSimilmente ai runlevel di Sys V, systemd avvia in diversi target:\n\n<ul>\n<li>poweroff.target - spegnimento del sistema</li>\n<li>rescue.target - modalità utente singolo</li>\n<li>multi-user.target - multiutente con rete</li>\n<li>graphical.target - multiutente con rete e interfaccia grafica</li>\n<li>reboot.target - riavvio</li>\n</ul>\n\nIl target di avvio predefinito di default.target di solito punta a graphical.target. \n\nL'oggetto principale con cui systemd lavora sono conosciuti come unità. Systemd non si limita a fermare e avviare servizi, può montare filesystem, monitorare le tue prese di rete, ecc e a causa di questa robustezza ha diversi tipi di unità con cui opera. Le unità più comuni sono:\n\n<ul>\n<li>Unità di servizio - sono i servizi che abbiamo avviato e fermato, questi file di unità terminano in .service</li>\n<li>Unità di montaggio - Queste montano filesystem, questi file di unità terminano in .mount</li>\n<li>Unità di target - Queste raggruppano altre unità, i file terminano in .target</li>\n</ul>\n\nAd esempio, diciamo che avviamo il nostro default.target, bene questo target raggruppa l'unità networking.service, l'unità crond.service, ecc, quindi una volta attivata un'unità singola, tutto ciò che si trova sotto quella unità viene attivato anche.",
          "quizAnswer": "target",
          "quizQuestion": "Quale unità viene utilizzata per raggruppare altre unità?",
          "slug": "panoramica-systemd",
          "title": "Panoramica di Systemd"
        },
        {
          "exercise": "Visualizza gli stati delle unità e avvia e arresta alcuni servizi. Cosa osservi?",
          "id": 6,
          "lessonContent": "Non entreremo nei dettagli della scrittura dei file di unità di systemd. Tuttavia faremo una breve panoramica di un file di unità e di come controllare manualmente le unità. \n\nEcco un file di unità di servizio di base: foobar.service\n\n<pre>\n[Unit]\nDescription=My Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nQuesto è un semplice file di unità di servizio, all'inizio del file vediamo una sezione per [Unit], che ci permette di dare al nostro file di unità una descrizione e controllare l'ordine di attivazione dell'unità. La parte successiva è la sezione [Service], qui possiamo avviare, fermare o ricaricare un servizio. E la sezione [Install] è utilizzata per le dipendenze. Questo è solo la punta dell'iceberg per la scrittura dei file di systemd, quindi ti esorto a leggere ulteriormente sull'argomento se desideri saperne di più. \n\nOra, vediamo alcuni comandi che puoi utilizzare con le unità di systemd: \n\n<b>Elencare le unità</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Visualizzare lo stato dell'unità</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Avviare un servizio</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Arrestare un servizio</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Riavviare un servizio</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Abilitare un'unità</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Disabilitare un'unità</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nAncora, non hai ancora visto quanto approfondito possa essere systemd, quindi leggi ulteriormente se desideri saperne di più.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "Qual è il comando per avviare un servizio chiamato peanut.service?",
          "slug": "systemdgoals",
          "title": "Obiettivi di Systemd"
        },
        {
          "exercise": "Cosa pensi stia succedendo con init quando spegni la tua macchina?",
          "id": 7,
          "lessonContent": "È difficile credere che non abbiamo ancora discusso dei modi per controllare lo stato del sistema tramite la riga di comando, ma quando parliamo di init, non parliamo solo delle modalità che ci permettono di avviare il sistema, ma anche di quelle che lo fermano.\n\nPer spegnere il sistema:\n\n<pre>$ sudo shutdown -h now</pre>\n\nQuesto arresterà il sistema (lo spegnerà), è necessario specificare anche un momento in cui si desidera che ciò avvenga. È possibile aggiungere un tempo in minuti che spegnerà il sistema in quel lasso di tempo.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nQuesto spegnerà il sistema in due minuti. È anche possibile riavviare con il comando di spegnimento: \n\n<pre>$ sudo shutdown -r now</pre>\n\nOppure utilizzare semplicemente il comando di riavvio:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "Qual è il comando per spegnere il sistema tra 4 minuti?",
          "slug": "powerstates",
          "title": "Stati di alimentazione"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Impara il monitoraggio delle risorse con top, load averages, iostat e altro ancora!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Gioca con il comando top e vedi quali processi stanno utilizzando più risorse.",
          "id": 1,
          "lessonContent": "In questo corso, esamineremo come leggere e analizzare l'utilizzo delle risorse sul tuo sistema, questa lezione mostra alcuni ottimi strumenti da utilizzare quando hai bisogno di tracciare cosa sta facendo un processo. \n\n<b>top</b>\n\nAbbiamo già discusso di top in precedenza, ma approfondiremo i dettagli di ciò che effettivamente sta visualizzando. Ricorda che top è lo strumento che abbiamo utilizzato per ottenere una visualizzazione in tempo reale dell'utilizzo del sistema da parte dei nostri processi:\n\n<pre>\ntop - 18:06:26 up 6 giorni,  4:07,  2 utenti,  media di caricamento: 0.92, 0.62, 0.59\nCompiti: 389 totali,   1 in esecuzione, 387 in attesa,   0 in pausa,   1 zombie\n%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  32870888 totale, 27467976 utilizzati,  5402912 liberi,   518808 buffer\nKiB Swap: 33480700 totale,    39892 utilizzati, 33440808 liberi. 19454152 memoria cache Mem\n\n  PID UTENTE      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TEMPO+ COMANDO                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nEsaminiamo cosa significa questa uscita, non è necessario memorizzare tutto, ma torna a questo quando hai bisogno di un riferimento.\n\n<b>1a riga: Queste sono le stesse informazioni che vedresti eseguendo il comando uptime (altro in arrivo)</b>\n\nI campi sono da sinistra a destra:\n<ol>\n<li>Ora attuale</li>\n<li>Da quanto tempo il sistema è in esecuzione</li>\n<li>Quanti utenti sono attualmente loggati</li>\n<li>Media di caricamento del sistema (altro in arrivo)</li>\n</ol>\n\n<b>2a riga: Compiti in esecuzione, in attesa, in pausa e zombie</b>\n\n<b>3a riga: Informazioni sulla CPU</b>\n\n<ol>\n<li>us: tempo CPU utente - Percentuale di tempo CPU trascorso nell'esecuzione dei processi degli utenti che non sono nice.</li>\n<li>sy: tempo CPU di sistema - Percentuale di tempo CPU trascorso nell'esecuzione del kernel e dei processi del kernel</li>\n<li>ni: tempo CPU nice - Percentuale di tempo CPU trascorso nell'esecuzione di processi nice</li>\n<li>id: tempo CPU inattivo - Percentuale di tempo CPU trascorso inattivo</li>\n<li>wa: attesa I/O - Percentuale di tempo CPU trascorso in attesa di I/O. Se questo valore è basso, il problema probabilmente non è l'I/O su disco o di rete</li> \n<li>hi: interruzioni hardware - Percentuale di tempo CPU trascorso a servire interruzioni hardware</li>\n<li>si: interruzioni software - Percentuale di tempo CPU trascorso a servire interruzioni software</li>\n<li>st: tempo di furto - Se stai eseguendo macchine virtuali, questa è la percentuale di tempo CPU che ti è stato sottratto per altre attività</li>\n</ol>\n\n<b>4a e 5a riga: Utilizzo della memoria e utilizzo della swap</b>\n\n<b>Elenco dei processi attualmente in uso</b>\n\n<ol>\n<li>PID: Id del processo</li>\n<li>UTENTE: utente che è il proprietario del processo</li>\n<li>PR: Priorità del processo</li>\n<li>NI: Il valore nice</li>\n<li>VIRT: Memoria virtuale utilizzata dal processo</li>\n<li>RES: Memoria fisica utilizzata dal processo</li>\n<li>SHR: Memoria condivisa del processo</li>\n<li>S: Indica lo stato del processo: S=in pausa, R=in esecuzione, Z=zombie,D=non interrompibile,T=in pausa</li>\n<li>%CPU - questa è la percentuale di CPU utilizzata da questo processo</li>\n<li>%MEM - percentuale di RAM utilizzata da questo processo</li>\n<li>TEMPO+ - tempo totale di attività di questo processo</li>\n<li>COMANDO - nome del processo</li>\n</ol>\n\nPuoi anche specificare un ID di processo se desideri tracciare determinati processi:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "Quale comando visualizza lo stesso output della prima riga in top?",
          "slug": "tracciamentoprocessitop",
          "title": "Tracciamento processi: top"
        },
        {
          "exercise": "Leggi le pagine di manuale per lsof e fuser, ci sono molte informazioni che non abbiamo coperto che ti consentono di avere una maggiore flessibilità con questi strumenti.",
          "id": 2,
          "lessonContent": "Immagina di aver inserito un'unità USB e di aver iniziato a lavorare su alcuni file; una volta terminato, provi a smontare il dispositivo USB e ricevi un errore \"Dispositivo o risorsa occupata\". Come faresti a scoprire quali file sull'unità USB sono ancora in uso? Ci sono effettivamente due strumenti che puoi utilizzare per questo: \n\n<b>lsof</b>\n\nRicorda che i file non sono solo file di testo, immagini, ecc., ma sono tutto ciò che è presente nel sistema, dischi, pipe, socket di rete, dispositivi, ecc. Per vedere cosa è in uso da un processo, puoi utilizzare il comando lsof (abbreviazione di \"list open files\"), che ti mostrerà un elenco di tutti i file aperti e il relativo processo associato. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nOra posso vedere quali processi stanno attualmente tenendo aperto il dispositivo/file. Nel nostro esempio con l'USB, puoi anche terminare questi processi in modo da poter smontare questa fastidiosa unità.\n\n<b>fuser</b>\n\nUn altro modo per tracciare un processo è il comando fuser (abbreviazione di \"file user\"), che ti mostrerà informazioni sul processo che sta utilizzando il file o l'utente del file. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nPossiamo vedere quali processi stanno attualmente utilizzando la nostra directory /home/pete. Gli strumenti lsof e fuser sono molto simili, familiarizzati con questi strumenti e prova a usarli la prossima volta che hai bisogno di tracciare un file o un processo.",
          "quizAnswer": "lsof",
          "quizQuestion": "Quale comando viene utilizzato per elencare i file aperti e le informazioni sul processo ad essi associato?",
          "slug": "tracciareprocessilsoffuser",
          "title": "lsof e fuser"
        },
        {
          "exercise": "Esegui il comando <b>ps m</b> e vedi quali processi in esecuzione sono multi-threaded.",
          "id": 3,
          "lessonContent": "Potresti aver sentito parlare dei termini processi single-threaded e multi-threaded. I thread sono molto simili ai processi, nel senso che vengono utilizzati per eseguire lo stesso programma, spesso vengono definiti come processi leggeri. Se un processo ha un solo thread è single-threaded e se un processo ha più di un thread è multi-threaded. Tuttavia, tutti i processi hanno almeno un thread. \n\nI processi operano con le proprie risorse di sistema isolate, mentre i thread possono condividere facilmente queste risorse tra di loro, rendendo più semplice la comunicazione tra di loro e a volte è più efficiente avere un'applicazione multi-threaded rispetto a un'applicazione multi-processo.\n\nFondamentalmente, diciamo che apri LibreOffice Writer e Chrome, ognuno è il proprio processo separato. Ora entri in Writer e inizi a modificare il testo, quando modifichi il testo viene salvato automaticamente. Questi due processi paralleli \"leggeri\" di salvataggio e modifica sono thread. \n\nPer visualizzare i thread dei processi, puoi utilizzare: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nI processi sono indicati con ciascun PID e sotto i processi ci sono i loro thread (indicati da --). Quindi puoi vedere che i processi sopra sono entrambi single-threaded.",
          "quizAnswer": "Vero",
          "quizQuestion": "Vero o falso, tutti i processi iniziano come single-threaded.",
          "slug": "processthreads",
          "title": "Process Threads"
        },
        {
          "exercise": "Controlla la media di carico del tuo sistema e vedi cosa sta facendo.",
          "id": 4,
          "lessonContent": "Esaminiamo un comando utile, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 up 1 giorno,  5:59,  2 utenti,  media di carico: 0.00, 0.02, 0.05\n</pre>\n\nAbbiamo parlato di uptime nella prima lezione di questo corso, ma non abbiamo ancora affrontato il campo della media di carico. Le medie di carico sono un buon modo per vedere il carico della CPU sul tuo sistema. Questi numeri rappresentano la media del carico della CPU in intervalli di 1, 5 e 15 minuti. Cosa intendo per carico della CPU, il carico della CPU è il numero medio di processi che stanno aspettando di essere eseguiti dalla CPU.\n\nImmagina di avere una CPU single-core, pensa a questo core come a una corsia singola nel traffico. Se è l'ora di punta sull'autostrada, questa corsia sarà molto trafficata e il traffico sarà al 100% o un carico di 1. Ora il traffico è diventato così intenso da bloccare l'autostrada e rendere le strade normali affollate di due volte il numero di auto, possiamo dire che il tuo carico è del 200% o un carico di 2. Ora diciamo che si libera un po' e ci sono solo la metà delle auto sulla corsia dell'autostrada, possiamo dire che il carico della corsia è 0.5. Quando il traffico è inesistente e possiamo tornare a casa più velocemente, il carico dovrebbe idealmente essere molto basso, come il traffico delle 2 del mattino. Le auto in questo caso sono i processi e questi processi stanno solo aspettando di uscire dall'autostrada e tornare a casa.\n\nOra, solo perché hai una media di carico di 1 non significa che il tuo computer stia lavorando lentamente. La maggior parte delle macchine moderne oggi hanno più core. Se avessi un processore quad core (4 core) e la tua media di carico è 1, sta influenzando solo il 25% della tua CPU. Pensa a ogni core come a una corsia nel traffico. Puoi visualizzare il numero di core che hai sul tuo sistema con <b>cat /proc/cpuinfo</b>.\n\nQuando osservi la media di carico, devi tenere conto del numero di core, se scopri che la tua macchina sta sempre utilizzando un carico superiore alla media, potrebbe esserci qualcosa che non va.",
          "quizAnswer": "uptime",
          "quizQuestion": "Quale comando puoi utilizzare per vedere la media di carico?",
          "slug": "monitoraggiocpu",
          "title": "Monitoraggio della CPU"
        },
        {
          "exercise": "Usa iostat per visualizzare l'utilizzo del disco.",
          "id": 5,
          "lessonContent": "Possiamo anche monitorare l'utilizzo della CPU e monitorare l'utilizzo del disco con uno strumento utile noto come <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nLa prima parte è l'informazione sulla CPU:\n\n<ul>\n<li>%user - Mostra la percentuale di utilizzo della CPU che è avvenuta durante l'esecuzione a livello utente (applicazione)</li>\n<li>%nice - Mostra la percentuale di utilizzo della CPU che è avvenuta durante l'esecuzione a livello utente con priorità nice. Utilizzo della CPU utente con priorità nice</li>\n<li>%system - Mostra la percentuale di utilizzo della CPU che è avvenuta durante l'esecuzione a livello di sistema (kernel).</li>\n<li>%iowait - Mostra la percentuale di tempo in cui la CPU o le CPU erano inattive durante le quali il sistema aveva una richiesta di I/O su disco in sospeso.</li>\n<li>%steal - Mostra la percentuale di tempo trascorso in attesa involontaria dalla CPU virtuale o dalle CPU mentre l'hypervisor stava servendo un altro processore virtuale.</li>\n<li>%idle - Mostra la percentuale di tempo in cui la CPU o le CPU erano inattive e il sistema non aveva una richiesta di I/O su disco in sospeso.</li>\n</ul>\n\nLa seconda parte è l'utilizzo del disco:\n\n<ul>\n<li>tps - Indica il numero di trasferimenti al secondo che sono stati emessi al dispositivo. Un trasferimento è una richiesta di I/O al dispositivo. Più richieste logiche possono essere combinate in una singola richiesta di I/O al dispositivo. Un trasferimento ha dimensione indeterminata.</li>\n<li>kB_read/s - Indica la quantità di dati letti dal dispositivo espressa in kilobyte al secondo.</li>\n<li>kB_wrtn/s - Indica la quantità di dati scritti sul dispositivo espressa in kilobyte al secondo.</li>\n<li>kB_read - Il numero totale di kilobyte letti.</li>\n<li>kB_wrtn - Il numero totale di kilobyte scritti.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "Quale comando può essere utilizzato per visualizzare l'utilizzo di I/O e CPU?",
          "slug": "monitoraggio-io",
          "title": "Monitoraggio I/O"
        },
        {
          "exercise": "Guarda l'utilizzo della memoria con vmstat.",
          "id": 6,
          "lessonContent": "Oltre al monitoraggio della CPU e al monitoraggio dell'I/O, è possibile monitorare l'utilizzo della memoria con <b>vmstat</b>\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nI campi sono i seguenti:\n\n<b>procs</b>\n<ul>\n<li>r - Numero di processi in esecuzione</li>\n<li>b - Numero di processi in stato di sleep non interrompibile</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - Quantità di memoria virtuale utilizzata</li>\n<li>free - Quantità di memoria libera</li>\n<li>buff - Quantità di memoria utilizzata come buffer</li>\n<li>cache - Quantità di memoria utilizzata come cache</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Quantità di memoria scambiata dal disco</li>\n<li>so - Quantità di memoria scambiata verso il disco</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Quantità di blocchi ricevuti da un dispositivo a blocchi</li>\n<li>bo - Quantità di blocchi inviati a un dispositivo a blocchi</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - Numero di interruzioni al secondo</li>\n<li>cs - Numero di cambi di contesto al secondo</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Tempo trascorso in tempo utente</li>\n<li>sy - Tempo trascorso in tempo di kernel</li>\n<li>id - Tempo trascorso inattivo</li>\n<li>wa - Tempo trascorso in attesa di I/O</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "Quale strumento viene utilizzato per visualizzare l'utilizzo della memoria?",
          "slug": "monitoraggiomemoria",
          "title": "Monitoraggio della memoria"
        },
        {
          "exercise": "Installa sar sul tuo sistema e inizia a raccogliere e analizzare l'utilizzo delle risorse del sistema.",
          "id": 7,
          "lessonContent": "Questi strumenti di monitoraggio sono utili per controllare quando la tua macchina ha problemi, ma cosa succede alle macchine che hanno problemi quando non stai guardando. Per queste situazioni, avrai bisogno di utilizzare uno strumento di monitoraggio continuo, qualcosa che raccolga, segnali e salvi le informazioni sull'attività del sistema. In questa lezione esamineremo un ottimo strumento da utilizzare <b>sar</b>.\n\n<b>Installazione di sar</b>\nSar è uno strumento utilizzato per fare analisi storiche sul tuo sistema, assicurati prima di averlo installato installando il pacchetto sysstat <b>sudo apt install sysstat</b>.\n\n<b>Configurazione della raccolta dati</b>\nDi solito, una volta installato sysstat, il tuo sistema inizierà automaticamente a raccogliere dati, se non lo fa, puoi abilitarlo modificando il campo ENABLED in /etc/default/sysstat.\n\n<b>Utilizzo di sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nQuesto comando elencherà i dettagli dall'inizio della giornata.\n\n<pre>$ sudo sar -r</pre>\n\nQuesto elencherà i dettagli dell'utilizzo della memoria dall'inizio della giornata.\n\n<pre>$ sudo sar -P</pre>\n\nQuesto elencherà i dettagli dell'utilizzo della CPU. \n\nPer vedere una vista di un giorno diverso, puoi accedere a /var/log/sysstat/saXX dove XX è il giorno che desideri visualizzare. \n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "Qual è un buon strumento da utilizzare per monitorare le risorse di sistema?",
          "slug": "monitoraggiocontinuo",
          "title": "Monitoraggio Continuo"
        },
        {
          "exercise": "Crea un cron job che desideri eseguire in un orario programmato.",
          "id": 8,
          "lessonContent": "Anche se abbiamo parlato dell'utilizzo delle risorse, penso che questo sia un buon momento per menzionare uno strumento interessante in Linux che viene utilizzato per pianificare compiti utilizzando cron. Esiste un servizio che esegue programmi per te all'orario che hai programmato. Questo è davvero utile se hai uno script che vuoi eseguire una volta al giorno e che deve eseguire qualcosa per te. \n\nAd esempio, diciamo che ho uno script situato in /home/pete/scripts/change_wallpaper. Utilizzo questo script ogni mattina per cambiare l'immagine che uso come sfondo, ma ogni mattina devo eseguire manualmente questo script. Invece posso creare un cron job che esegue il mio script tramite cron. Posso specificare l'orario in cui voglio che questo cron job venga eseguito ed eseguire il mio script. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nI campi sono i seguenti da sinistra a destra:\n<ul>\n<li>Minuto - (0-59)</li>\n<li>Ora - (0-23)</li>\n<li>Giorno del mese - (1-31)</li>\n<li>Mese - (1-12)</li>\n<li>Giorno della settimana - (0-7). 0 e 7 indicano la Domenica</li>\n</ul>\n\nL'asterisco nel campo significa corrispondere a ogni valore. Quindi nel mio esempio sopra, voglio che questo venga eseguito ogni giorno di ogni mese alle 8:30 del mattino.\n\nPer creare un cron job, basta modificare il file crontab:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "Qual è il comando per modificare i tuoi cron job?",
          "slug": "cronjobs",
          "title": "Cron Jobs"
        }
      ],
      "slug": "processutilization",
      "title": "Utilizzo del processo"
    },
    {
      "description": "Scopri di più sui log di sistema e sulla directory /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Guarda il tuo file /var/log/syslog e vedi cosa sta succedendo sul tuo computer.",
          "id": 1,
          "lessonContent": "I servizi, il kernel, i demoni, ecc. sul tuo sistema stanno costantemente facendo qualcosa, questi dati vengono effettivamente inviati per essere salvati sul tuo sistema sotto forma di log. Questo ci consente di avere un registro leggibile dall'essere umano degli eventi che si verificano sul nostro sistema. Questi dati di solito sono conservati nella directory /var, la directory /var è dove conserviamo i nostri dati variabili, come i log!\n\nCome vengono ricevuti questi messaggi sul tuo sistema? C'è un servizio chiamato syslog che invia queste informazioni al registro di sistema. \n\nSyslog contiene effettivamente molti componenti, uno dei più importanti è un demone in esecuzione chiamato syslogd (le distribuzioni Linux più recenti utilizzano rsyslogd), che aspetta che si verifichino messaggi di evento e filtra quelli di cui vuole essere informato e, a seconda di cosa deve fare con quel messaggio, lo invierà a un file, alla tua console o non farà nulla.\n\nPenseresti che questo registro di sistema sia il luogo centralizzato per gestire i log, ma sfortunatamente non lo è. Vedrai molte applicazioni che scrivono le proprie regole di registrazione e generano file di log diversi, tuttavia in generale il formato dei log dovrebbe includere un timestamp e i dettagli dell'evento. \n\nEcco un esempio di una riga da syslog:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nQui possiamo vedere che il 27 gennaio alle 07:41:32 il nostro servizio cron ha eseguito il lavoro cron.weekly. Puoi visualizzare tutti i messaggi di evento che syslog raccoglie nel file /var/log/syslog.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "Qual è il demone che gestisce i log nei sistemi Linux più recenti?",
          "slug": "registrazione-di-sistema",
          "title": "Registrazione di sistema"
        },
        {
          "exercise": "Guarda il tuo file di configurazione /etc/rsyslog.d e vedi cos'altro viene registrato tramite il logger di sistema.",
          "id": 2,
          "lessonContent": "Il servizio syslog gestisce ed invia i log al logger di sistema. Rsyslog è una versione avanzata di syslog, la maggior parte delle distribuzioni Linux dovrebbero utilizzare questa nuova versione. L'output di tutti i log raccolti dal servizio syslog può essere trovato in /var/log/syslog (ogni messaggio tranne i messaggi di autenticazione).\n\nPer scoprire quali file sono gestiti dal nostro logger di sistema, guarda i file di configurazione in /etc/rsyslog.d:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nQueste regole per i file di log sono indicate dal selettore nella colonna di sinistra e dall'azione nella colonna di destra. L'azione ci dice dove inviare le informazioni di log, in un file, console, ecc. Ricorda che non tutte le applicazioni e servizi utilizzano rsyslog per gestire i loro log, quindi se vuoi sapere specificamente cosa viene registrato dovrai guardare all'interno di questa directory.\n\nVediamo effettivamente il logging in azione, puoi inviare manualmente un log con il comando logger:\n\n<pre>\nlogger -s Hello\n</pre>\n\nOra guarda dentro il tuo /var/log/syslog e dovresti vedere questa voce nei tuoi log!",
          "quizAnswer": "logger",
          "quizQuestion": "Quale comando puoi usare per registrare manualmente un messaggio?",
          "slug": "syslog",
          "title": "Prima alcuni file di log standard. Log per facility."
        },
        {
          "exercise": "Guarda i tuoi file /var/log/messages e /var/log/syslog e vedi quali sono le differenze.",
          "id": 3,
          "lessonContent": "Ci sono molti file di log che puoi visualizzare sul tuo sistema, molti importanti si trovano sotto /var/log. Non li esamineremo tutti, ma discuteremo un paio dei principali. \n\nCi sono due file di log generali che puoi visualizzare per avere un'idea di cosa stia facendo il tuo sistema:\n\n<b>/var/log/messages</b>\n\nQuesto log contiene tutti i messaggi non critici e non di debug, include i messaggi registrati durante l'avvio (dmesg), auth, cron, daemon, ecc. Molto utile per avere un'idea di come si comporta la tua macchina. \n\n<b>/var/log/syslog</b>\n\nQuesto registra tutto tranne i messaggi di autenticazione, è estremamente utile per individuare errori sulla tua macchina. \n\nQuesti due log dovrebbero essere più che sufficienti quando si riscontrano problemi con il sistema. Tuttavia, se desideri visualizzare solo un componente di log specifico, ci sono anche log separati per quelli.",
          "quizAnswer": "syslog",
          "quizQuestion": "Quale file di log registra tutto tranne i messaggi di autenticazione?",
          "slug": "registrazione-generale",
          "title": "Registrazione generale"
        },
        {
          "exercise": "Guarda i tuoi log di dmesg e kern, quali differenze noti?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nAll'avvio, il sistema registra informazioni sul buffer ad anello del kernel. Questo ci mostra informazioni sui driver hardware, informazioni sul kernel e stato durante l'avvio e altro ancora. Questo file di log si trova in /var/log/dmesg e viene azzerato ad ogni avvio, potresti non vedere alcun utilizzo al momento, ma se dovessi mai avere problemi durante l'avvio o un problema hardware, dmesg è il posto migliore in cui guardare. Puoi anche visualizzare questo log usando il comando dmesg. \n\n<b>/var/log/kern.log</b>\nUn altro log che puoi usare per visualizzare informazioni sul kernel è il file /var/log/kern.log, questo registra le informazioni e gli eventi del kernel sul tuo sistema, registra anche l'output di dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "Quale comando può essere utilizzato per visualizzare i messaggi di avvio del kernel?",
          "slug": "kernellogging",
          "title": "Registrazione del kernel"
        },
        {
          "exercise": "Effettua alcuni tentativi di accesso falliti e poi uno riuscito, controlla il tuo /var/log/auth.log e vedi cosa è successo.",
          "id": 5,
          "lessonContent": "La registrazione dell'autenticazione può essere molto utile da esaminare se si riscontrano problemi di accesso. \n\n<b>/var/log/auth.log</b>\n\nQuesto file contiene i log di autorizzazione di sistema, come il login dell'utente e il metodo di autenticazione utilizzato. \n\nEsempio di frammento:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "Quale log viene utilizzato per l'autenticazione dell'utente?",
          "slug": "authenticationlogging",
          "title": "Registrazione dell'autenticazione"
        },
        {
          "exercise": "Guarda il tuo file di configurazione di logrotate e osserva come gestisce alcuni dei tuoi log.",
          "id": 6,
          "lessonContent": "I file di log generano molte informazioni e memorizzano questi dati sui tuoi dischi rigidi, tuttavia ci sono molti problemi legati a questo, per la maggior parte vogliamo semplicemente essere in grado di visualizzare i log più recenti, vogliamo anche gestire in modo efficiente lo spazio su disco, quindi come possiamo fare tutto questo? La risposta è con logrotate. \n\nL'utilità logrotate gestisce i log per noi. Ha un file di configurazione che ci permette di specificare quanti e quali log mantenere, come comprimere i nostri log per risparmiare spazio e altro ancora. Lo strumento logrotate di solito viene eseguito tramite cron una volta al giorno e i file di configurazione possono essere trovati in /etc/logrotate.d. \n\nCi sono altri strumenti di rotazione dei log che puoi utilizzare per gestire i tuoi log, ma logrotate è il più comune.",
          "quizAnswer": "logrotate",
          "quizQuestion": "Quale utilità viene utilizzata per gestire i log?",
          "slug": "gestionefilelog",
          "title": "Gestione dei file di log"
        }
      ],
      "slug": "logging",
      "title": "Registrazione"
    },
    {
      "description": "Scopri la condivisione di rete con rsync, scp, nfs e altro ancora.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Prova a copiare un file con scp da una macchina all'altra.",
          "id": 1,
          "lessonContent": "Di solito non sei l'unico computer sulla tua rete, questo è particolarmente vero se stai lavorando in un ambiente commerciale. Quando vogliamo trasferire dati da una macchina all'altra, a volte può essere più facile collegare un'unità USB e copiarli manualmente. Ma per la maggior parte, se stai lavorando con macchine sulla stessa rete, il modo per trasferire dati è attraverso la condivisione di file di rete. \n\nIn questo corso esamineremo un paio di metodi diversi per copiare dati da e verso macchine diverse sulla tua rete. Discuteremo alcune semplici copie di file, poi parleremo del montaggio di intere directory sulla tua macchina che agiscono come un'unità separata. \n\nUno strumento semplice per la condivisione di file è il comando <b>scp</b>. Il comando scp sta per copia sicura, funziona esattamente come il comando cp, ma ti consente di copiare da un host all'altro host sulla stessa rete. Funziona tramite ssh quindi tutte le tue azioni utilizzano la stessa autenticazione e sicurezza di ssh. \n\n<b>Per copiare un file da host locale a host remoto</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>Per copiare un file da un host remoto al tuo host locale</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>Per copiare una directory dal tuo host locale a un host remoto</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "Quale comando puoi usare per copiare file in modo sicuro da un host a un altro?",
          "slug": "condivisionefileinrete",
          "title": "Panoramica della condivisione di file"
        },
        {
          "exercise": "Usa rsync per sincronizzare una directory con un'altra directory, assicurati di non sovrascrivere una directory importante!",
          "id": 2,
          "lessonContent": "Un altro strumento utilizzato per copiare dati da host diversi è rsync (abbreviazione di sincronizzazione remota). Rsync è molto simile a scp, ma ha una differenza importante. Rsync utilizza un algoritmo speciale che controlla in anticipo se ci sono già dati che stai copiando e copierà solo le differenze. Ad esempio, supponiamo che tu stia copiando un file e la tua rete venga interrotta, quindi la copia si interrompe a metà. Invece di ricopiare tutto dall'inizio, rsync copierà solo le parti che non sono state copiate.\n\nVerifica anche l'integrità di un file che stai copiando con checksum. Queste piccole ottimizzazioni consentono una maggiore flessibilità nel trasferimento dei file e rendono rsync ideale per la sincronizzazione di directory in remoto e localmente, il backup dei dati, i trasferimenti di grandi dimensioni e altro ancora.\n\nAlcune opzioni di rsync comunemente utilizzate:\n\n<ul>\n<li>v - output dettagliato</li>\n<li>r - ricorsivo nelle directory</li>\n<li>h - output leggibile dall'utente</li>\n<li>z - compresso per un trasferimento più facile, ottimo per connessioni lente</li>\n</ul>\n\n<b>Copia/sincronizzazione dei file sullo stesso host</b>\n\n<pre>$ rsync -zvr /mia/directory/locale/uno /mia/directory/locale/due</pre>\n\n<b>Copia/sincronizzazione dei file sull'host locale da un host remoto</b>\n\n<pre>$ rsync /directory/locale username@remotehost.com:/directory/remota</pre>\n\n<b>Copia/sincronizzazione dei file su un host remoto da un host locale</b>\n\n<pre>$ rsync username@remotehost.com:/directory/remota /directory/locale</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "Quale comando sarebbe utile per i backup dei dati?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "Prova a configurare un SimpleHTTPServer!",
          "id": 3,
          "lessonContent": "Python ha uno strumento super utile per servire file tramite HTTP. Questo è ottimo se desideri semplicemente creare una condivisione di rete rapida a cui possono accedere altre macchine sulla tua rete. Per farlo, vai alla directory che desideri condividere ed esegui:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nQuesto imposta un server web di base a cui puoi accedere tramite l'indirizzo localhost. Quindi prendi l'indirizzo IP della macchina su cui hai eseguito questo comando e poi su un'altra macchina accedilo nel browser con: http://INDIRIZZO_IP:8000. Sulla tua stessa macchina, puoi visualizzare i file disponibili digitando: http://localhost:8000 nel tuo browser web.\n\nPuoi fare lo stesso anche con node o, se stai eseguendo Python 3, la sintassi sarà leggermente diversa.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Quale strumento puoi utilizzare per creare un server http semplice con python?",
          "slug": "simplehttpserver",
          "title": "Server HTTP Semplice"
        },
        {
          "exercise": "Leggi la pagina di manuale di NFS per saperne di più.",
          "id": 4,
          "lessonContent": "Il file share di rete più standard per Linux è NFS (Network File System), NFS consente a un server di condividere directory e file con uno o più client tramite la rete. \n\nNon entreremo nei dettagli su come creare un server NFS in quanto può diventare complesso, tuttavia discuteremo della configurazione dei client NFS.\n\n<b>Configurazione del client NFS</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>Automounting</b>\n\nSupponiamo che tu utilizzi spesso il server NFS e desideri mantenerlo montato in modo permanente, di solito penseresti di modificare il file /etc/fstab, ma potresti non sempre ottenere una connessione al server e ciò potrebbe causare problemi all'avvio. Invece, ciò che desideri fare è configurare l'automounting in modo da poterti connettere al server NFS quando ne hai bisogno. Questo viene fatto con lo strumento <b>automount</b> o nelle versioni più recenti di Linux con <b>amd</b>. Quando un file viene accesso in una directory specificata, automount cercherà il server remoto e lo monta automaticamente.",
          "quizAnswer": "automount",
          "quizQuestion": "Quale strumento viene utilizzato per gestire automaticamente i punti di mount?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Configura una condivisione Samba, se non ne hai una, apri smb.conf e familiarizza con le opzioni nel file di configurazione.",
          "id": 5,
          "lessonContent": "Nei primi giorni dell'informatica, è diventato necessario che i computer Windows condividessero file con i computer Linux, da qui è nato il protocollo Server Message Block (SMB). SMB veniva utilizzato per la condivisione di file tra sistemi operativi Windows (Mac ha anche la condivisione di file con SMB) e successivamente è stato ripulito e ottimizzato nella forma del protocollo Common Internet File System (CIFS).\n\nSamba è ciò che chiamiamo le utility Linux per lavorare con CIFS su Linux. Oltre alla condivisione di file, è possibile condividere risorse come stampanti.\n\n<b>Crea una condivisione di rete con Samba</b>\n\nVediamo i passaggi di base per creare una condivisione di rete a cui può accedere un computer Windows:\n\n<b>Installa Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Configura smb.conf</b>\n\nIl file di configurazione per Samba si trova in /etc/samba/smb.conf, questo file dovrebbe indicare al sistema quali directory devono essere condivise, i permessi di accesso e altre opzioni. Il smb.conf predefinito contiene già molto codice commentato e puoi usarlo come esempio per scrivere le tue configurazioni.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Imposta una password per Samba</b>\n\n<pre>$ sudo smbpasswd -a [nomeutente]</pre>\n\n<b>Crea una directory condivisa</b>\n\n<pre>$ mkdir /mia/directory/da/condividere</pre>\n\n<b>Riavvia il servizio Samba</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Accesso a una condivisione Samba da Windows</b>\n\nIn Windows, basta digitare la connessione di rete nel prompt dei comandi: \\\\HOST\\nomedellacondivisione.\n\n<b>Accesso a una condivisione Samba/Windows da Linux</b>\n\n<pre>$ smbclient //HOST/directory -U utente</pre>\n\nIl pacchetto Samba include uno strumento a riga di comando chiamato <b>smbclient</b> che puoi utilizzare per accedere a qualsiasi server Windows o Samba. Una volta connesso alla condivisione, puoi navigare e trasferire file.\n\n<b>Collega una condivisione Samba al tuo sistema</b>\n\nInvece di trasferire file uno per uno, puoi semplicemente montare la condivisione di rete sul tuo sistema.\n\n<pre>$ sudo mount -t cifs nomeserver:directory punto di mount -o utente=nomeutente,password=password</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Qual è l'ultimo protocollo utilizzato per il trasferimento di file tra Windows e Linux?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Condivisione di rete"
    },
    {
      "description": "Scopri le nozioni di base di networking e il modello TCP/IP.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Diamo un'occhiata a una tipica rete domestica, che è composta da diversi componenti. \n\n<ul>\n<li>ISP - Il tuo fornitore di servizi Internet, l'azienda a cui paghi per avere Internet a casa tua.</li>\n<li>Router - Il router consente a ogni dispositivo sulla tua rete di connettersi a Internet. Nella maggior parte dei router moderni, puoi connetterti tramite wireless o un cavo Ethernet.</li>\n<li>WAN - Wide Area Network, è la rete che comprende tutto ciò che si trova tra il tuo router e una rete più ampia come Internet.</li>\n<li>WLAN - Wireless Local Area Network, è la rete tra il tuo router e eventuali dispositivi wireless che potresti avere, come laptop.</li>\n<li>LAN - Local Area Network, è la rete tra il tuo router e eventuali dispositivi cablati come PC desktop.</li>\n<li>Hosts - Ogni dispositivo su una rete è conosciuto come host.</li>\n</ul>\n\nI dati e le informazioni trasmessi attraverso le reti sono conosciuti come pacchetti e alla fine della sezione Networking Nomad, capirai dettagliatamente come un pacchetto viaggia da e verso gli host.",
          "quizAnswer": "LAN",
          "quizQuestion": "Come è conosciuta la rete locale?",
          "slug": "concetti-di-base-di-rete",
          "title": "Concetti di base di rete"
        },
        {
          "exercise": "Leggi di più sul modello OSI: <a href=\"https://en.wikipedia.org/wiki/OSI_model\">https://en.wikipedia.org/wiki/OSI_model</a>",
          "id": 2,
          "lessonContent": "Prima di poter esaminare alcune cose pratiche sulla rete, dobbiamo passare attraverso alcuni noiosi termini tecnici che probabilmente hai già sentito in passato. Il modello OSI (Open Systems Interconnection) è un modello teorico di rete. Questo modello ci mostra come un pacchetto attraversa una rete in sette diverse layer. Non entrerò nei dettagli di questo modello, poiché la maggior parte di questi corsi di rete si concentrerà sul modello TCP/IP, ma va menzionato che esiste un tale modello teorico di rete che ha effettivamente giocato un ruolo importante nel modello di rete TCP/IP che usiamo oggi.",
          "quizAnswer": "OSI",
          "quizQuestion": "Cosa viene utilizzato come modello teorico di rete?",
          "slug": "modello-osi",
          "title": "Modello OSI"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Il modello OSI ha dato origine a ciò che alla fine è diventato il modello TCP/IP e questo modello è effettivamente su cui si basa Internet. È l'effettiva implementazione delle reti. Il modello TCP/IP utilizza la suite di protocolli TCP/IP, comunemente chiamata TCP/IP. Questi protocolli lavorano insieme per specificare come i dati devono essere raccolti, indirizzati, trasmessi e instradati attraverso una rete. Utilizzando il modello TCP/IP, possiamo vedere come questi protocolli vengono utilizzati per mostrare la suddivisione di come un pacchetto viaggia attraverso la rete.\n\n<b>Strato Applicativo</b>\n\nIl livello superiore del modello TCP/IP. Determina come i programmi del computer (come il browser web) interagiscono con i servizi del livello di trasporto per visualizzare i dati inviati o ricevuti.\n\nQuesto livello utilizza:\n<ul>\n<li>HTTP (Hypertext Transfer Protocol) - utilizzato per le pagine web su Internet.</li>\n<li>SMTP (Simple Mail Transfer Protocol) - trasmissione di posta elettronica (email)</li>\n</ul>\n\n<b>Strato di Trasporto</b>\n\nCome i dati verranno trasmessi, include il controllo delle porte corrette, l'integrità dei dati e fondamentalmente la consegna dei nostri pacchetti.\n\nQuesto livello utilizza:\n<ul>\n<li>TCP (Transmission Control Protocol) - consegna affidabile dei dati</li>\n<li>UDP (User Datagram Protocol) - consegna non affidabile dei dati</li>\n</ul>\n\n<b>Strato di Rete</b>\n\nQuesti livelli specificano come spostare i pacchetti tra host e attraverso le reti.\n\nQuesto livello utilizza:\n<ul>\n<li>IP (Internet Protocol) - Aiuta a instradare i pacchetti da una macchina all'altra.</li>\n<li>ICMP (Internet Control Message Protocol) - Aiuta a dirci cosa sta succedendo, come messaggi di errore e informazioni di debug.</li>\n</ul>\n\n<b>Strato di Collegamento</b>\n\nQuesto livello specifica come inviare dati attraverso un pezzo fisico di hardware. Come dati che viaggiano attraverso Ethernet, fibra, ecc.\n\nGli elenchi dei protocolli che ciascun livello utilizza non sono esaustivi e incontrerai molti altri protocolli che entrano in gioco.\n\nNelle lezioni seguenti, approfondiremo ciascuno di questi livelli e discuteremo come il nostro pacchetto attraversa la rete agli occhi del modello TCP/IP (ci sono molte prospettive su come un pacchetto viaggia attraverso le reti, non ne esamineremo tutte, ma sii consapevole che esistono).",
          "quizAnswer": "Applicativo",
          "quizQuestion": "Qual è il livello superiore del modello TCP/IP?",
          "slug": "modello-tcpip",
          "title": "Modello TCP/IP"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "Prima di vedere come un pacchetto si muove attraverso una rete, dobbiamo familiarizzare con alcuni termini. Quando invii una lettera, devi sapere a chi è destinata e da dove proviene. I pacchetti hanno bisogno delle stesse informazioni, i nostri host e gli altri host vengono identificati utilizzando gli indirizzi MAC (media access control) e gli indirizzi IP, per semplificarci la vita usiamo i nomi host per identificare un host.\n\n<b>Indirizzi MAC</b>\n\nUn indirizzo MAC è un identificatore univoco utilizzato come indirizzo hardware. Questo indirizzo non cambierà mai. Quando vuoi accedere a Internet, il tuo computer deve avere un dispositivo chiamato scheda di rete. Questo adattatore di rete ha il suo proprio indirizzo hardware che viene utilizzato per identificare il tuo computer. Un indirizzo MAC per un dispositivo Ethernet assomiglia a qualcosa del genere 00:C4:B5:45:B2:43. Gli indirizzi MAC vengono assegnati alle schede di rete quando vengono prodotte. Ogni produttore ha un identificatore univoco organizzativo (OUI) per identificarli come produttore. Questo OUI è indicato dai primi 3 byte dell'indirizzo MAC. Ad esempio, Dell ha 00-14-22, quindi un adattatore di rete di Dell potrebbe avere un indirizzo MAC come: 00-14-22-34-B2-C2. \n\n<b>Indirizzi IP</b>\n\nUn indirizzo IP viene utilizzato per identificare un dispositivo in una rete, sono indipendenti dall'hardware e possono variare nella sintassi a seconda che tu stia utilizzando IPv4 o IPv6 (ne parleremo più avanti). Per ora assumiamo che tu stia utilizzando IPv4, quindi un tipico indirizzo IP potrebbe assomigliare a: 10.24.12.4. Gli indirizzi IP vengono utilizzati sul lato software delle reti. Ogni volta che un sistema è connesso a Internet dovrebbe avere un indirizzo IP. Possono anche cambiare se la tua rete cambia e sono univoci per l'intero Internet (questo non è sempre vero una volta che apprendiamo NAT). \n\nRicorda che sono necessari sia software che hardware per far muovere i pacchetti attraverso le reti, quindi abbiamo due identificatori per ognuno, MAC (hardware) e IP (software).\n\n<b>Nomi host</b>\n\nUn ultimo modo per identificare i tuoi dispositivi è tramite il nome host. I nomi host prendono il tuo indirizzo IP e ti permettono di associare quell'indirizzo a un nome leggibile dall'uomo. Invece di ricordare 192.12.41.4 puoi semplicemente ricordare myhost.com.",
          "quizAnswer": "4",
          "quizQuestion": "Quanti byte ci sono in un indirizzo IPv4?",
          "slug": "indirizzodirete",
          "title": "Indirizzamento di rete"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Immaginiamo di voler inviare una email a Patty. Esamineremo ciascuno dei livelli TCP/IP per vedere questo in azione. \n\nRicorda che i pacchetti vengono utilizzati per trasmettere dati attraverso le reti, un pacchetto è composto da un'intestazione e un payload. L'intestazione contiene informazioni su dove il pacchetto sta andando e da dove proviene. Il payload è il dato effettivo che viene trasferito. Mentre il nostro pacchetto attraversa la rete, ogni livello aggiunge un po' di informazioni all'intestazione del pacchetto. Tieni presente che i diversi livelli utilizzano un termine diverso per il nostro \"pacchetto\". Nel livello di trasporto essenzialmente incapsuliamo i nostri dati in un segmento e nel livello di collegamento ci riferiamo a questo come frame, ma sappi che il termine pacchetto può essere utilizzato per indicare la stessa cosa.\n\nIniziamo con lo strato di applicazione. Quando inviamo la nostra email attraverso il nostro client di posta elettronica, lo strato di applicazione incapsulerà questi dati. Lo strato di applicazione comunica con lo strato di trasporto tramite una porta specifica e tramite questa porta invia i suoi dati. Vogliamo inviare una email tramite il protocollo SMTP (simple mail transfer protocol) dello strato di applicazione. I dati vengono inviati attraverso il nostro protocollo di trasporto che apre una connessione a questa porta (la porta 25 è utilizzata per SMTP), quindi otteniamo questi dati inviati attraverso questa porta e quei dati vengono inviati allo strato di trasporto per essere incapsulati in segmenti.",
          "quizAnswer": "Applicazione",
          "quizQuestion": "Quale livello viene utilizzato per presentare i dati del pacchetto in un formato user friendly?",
          "slug": "stratoapplicazione",
          "title": "Strato di Applicazione"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 6,
          "lessonContent": "Lo strato di trasporto ci aiuta a trasferire i nostri dati in modo che le reti possano leggerli. Suddivide i nostri dati in frammenti che verranno trasportati e ricomposti nell'ordine corretto. Questi frammenti sono noti come segmenti. I segmenti facilitano il trasporto dei dati attraverso le reti. \n\n<b>Porte</b>\n\nAnche se sappiamo dove stiamo inviando i nostri dati tramite gli indirizzi IP, essi non sono sufficientemente specifici per inviare i nostri dati a determinati processi o servizi. Servizi come HTTP utilizzano un canale di comunicazione tramite porte. Se vogliamo inviare dati di una pagina web, dobbiamo inviarli sulla porta HTTP (porta 80). Oltre a formare i segmenti, lo strato di trasporto aggiornerà anche le porte di origine e destinazione al segmento, quindi quando il ricevente riceverà il pacchetto finale saprà quale porta utilizzare. \n\n<b>UDP</b>\n\nCi sono due protocolli di trasporto popolari: UDP e TCP. Discuteremo brevemente di UDP e trascorreremo la maggior parte del tempo su TCP, poiché è il più comunemente utilizzato.\n\nUDP non è un metodo affidabile per il trasporto dei dati, infatti non gli importa davvero se ricevi tutti i tuoi dati originali. Questo potrebbe sembrare terribile, ma ha le sue utilità, ad esempio per lo streaming multimediale, va bene se si perdono alcuni frame in cambio di una consegna più rapida dei dati. \n\n<b>TCP</b>\n\nTCP fornisce una connessione affidabile e orientata alla connessione di flussi di dati. TCP utilizza le porte per inviare dati da e verso gli host. Un'applicazione apre una connessione da una porta sul proprio host a un'altra porta su un host remoto. Per stabilire la connessione, utilizziamo la procedura di handshake TCP. \n\n<ul>\n<li>Il client (processo di connessione) invia un segmento SYN al server per richiedere una connessione</li>\n<li>Il server invia al client un segmento SYN-ACK per confermare la richiesta di connessione del client</li>\n<li>Il client invia un ACK al server per confermare la richiesta di connessione del server</li>\n</ul>\n\nUna volta stabilita questa connessione, i dati possono essere scambiati su una connessione TCP. I dati vengono inviati in diversi segmenti e vengono tracciati con numeri di sequenza TCP in modo che possano essere ordinati correttamente quando vengono consegnati. Nell'esempio della posta elettronica, lo strato di trasporto aggiunge la porta di destinazione (25) alla porta di origine dell'host sorgente.",
          "quizAnswer": "TCP",
          "quizQuestion": "Qual è un protocollo di trasporto affidabile?",
          "slug": "stratoditrasporto",
          "title": "Strato di trasporto"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 7,
          "lessonContent": "Lo strato di rete determina il percorso dei nostri pacchetti dal nostro host sorgente a un host di destinazione. Fortunatamente nel nostro esempio, il nostro pacchetto viaggia solo all'interno della stessa rete, ma Internet è composta da molte reti. Queste reti più piccole che compongono Internet sono conosciute come subnet. Tutte le subnet sono collegate tra loro in qualche modo, motivo per cui siamo in grado di raggiungere www.google.com anche se si trova sulla sua rete. Non entrerò nei dettagli in quanto abbiamo un intero corso dedicato alle subnet, ma per ora per quanto riguarda il nostro strato di rete, sappiate che gli indirizzi IP definiscono le regole per viaggiare verso diverse subnet. \n\nNello strato di rete, riceve il segmento proveniente dallo strato di trasporto e incapsula questo segmento in un pacchetto IP, quindi attacca l'indirizzo IP dell'host sorgente e l'indirizzo IP dell'host di destinazione all'intestazione del pacchetto. Quindi a questo punto, il nostro pacchetto ha informazioni su dove sta andando e da dove proviene. Ora invia il nostro pacchetto allo strato hardware fisico.",
          "quizAnswer": "subnet",
          "quizQuestion": "Come vengono chiamate le reti più piccole che compongono Internet?",
          "slug": "stratodirete",
          "title": "Strato di rete"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 8,
          "lessonContent": "In fondo al modello TCP/IP si trova il Livello di collegamento. Questo livello è il livello specifico dell'hardware.\n\nNel livello di collegamento, il nostro pacchetto viene nuovamente incapsulato in qualcosa chiamato frame. L'intestazione del frame attacca gli indirizzi MAC di origine e destinazione dei nostri host, i checksum e i separatori di pacchetti in modo che il ricevitore possa capire quando termina un pacchetto. \n\nFortunatamente siamo sulla stessa rete, quindi il nostro pacchetto non dovrà viaggiare troppo lontano. Prima, il livello di collegamento attacca il mio indirizzo MAC di origine all'intestazione del frame, ma deve conoscere anche l'indirizzo MAC di Patty. Come fa a saperlo e come posso trovarlo dato che non è su Internet? Usiamo ARP!\n\n<b>ARP (Protocollo di risoluzione degli indirizzi)</b>\n\nARP trova l'indirizzo MAC associato a un indirizzo IP. ARP è utilizzato all'interno della stessa rete. Se Patty non fosse sulla stessa rete, useremmo un sistema di instradamento per determinare il prossimo router che riceverebbe il pacchetto e una volta che fossimo sulla stessa rete, potremmo usare ARP. \n\nUna volta sulla stessa rete, i sistemi utilizzano prima la tabella di ricerca ARP che memorizza informazioni su quali indirizzi IP sono associati a quali indirizzi MAC. Se il valore non è presente, allora viene utilizzato ARP. Poi il sistema invierà un messaggio di broadcast alla rete utilizzando il protocollo ARP per scoprire quale host ha l'IP 10.10.1.4. Un messaggio di broadcast è un messaggio speciale inviato a tutti gli host di una rete (chiamato in modo appropriato per l'invio di un broadcast). Qualsiasi macchina con l'indirizzo IP richiesto risponderà con un pacchetto ARP contenente l'indirizzo IP e l'indirizzo MAC.\n\nOra che abbiamo tutti i dati necessari, indirizzo IP e indirizzi MAC, il nostro livello di collegamento inoltra questo frame attraverso la nostra scheda di interfaccia di rete, fino al dispositivo successivo e trova la rete di Patty. Questo passaggio è un po' più complesso di come l'ho appena spiegato, ma discuteremo ulteriori dettagli nel corso sull'Instradamento.\n\nEd ecco un attraversamento semplice (o non così semplice) del pacchetto lungo il modello TCP/IP. Tieni presente che i pacchetti non viaggiano in un'unica direzione in questo modo. Non siamo ancora arrivati alla rete di Patty! Quando si viaggia attraverso le reti, è necessario passare attraverso il modello TCP/IP almeno due volte prima che venga inviato o ricevuto qualsiasi dato. In realtà, l'aspetto di questo pacchetto sarebbe qualcosa del genere: \n\n<b>Attraversamento del pacchetto</b>\n\n<ol>\n<li>Pete invia un'email a Patty: questi dati vengono inviati al livello di trasporto.</li>\n<li>Il livello di trasporto incapsula i dati in un'intestazione TCP o UDP per formare un segmento, il segmento attacca le porte TCP o UDP di destinazione e di origine, quindi il segmento viene inviato al livello di rete.</li>\n<li>Il livello di rete incapsula il segmento TCP all'interno di un pacchetto IP, attacca gli indirizzi IP di origine e destinazione. Poi instrada il pacchetto al livello di collegamento.</li>\n<li>Il pacchetto raggiunge quindi l'hardware fisico di Pete e viene incapsulato in un frame. Gli indirizzi MAC di origine e destinazione vengono aggiunti al frame.</li>\n<li>Patty riceve questo frame dati attraverso il suo livello fisico e controlla ogni frame per l'integrità dei dati, quindi de-incapsula i contenuti del frame e invia il pacchetto IP al livello di rete.</li>\n<li>Il livello di rete legge il pacchetto per trovare gli indirizzi IP di origine e destinazione che erano stati precedentemente allegati. Controlla se il suo IP è lo stesso dell'IP di destinazione, che lo è! De-incapsula il pacchetto e invia il segmento al livello di trasporto.</li>\n<li>Il livello di trasporto de-incapsula i segmenti, controlla i numeri di porta TCP o UDP e stabilisce una connessione al livello dell'applicazione in base a quei numeri di porta.</li>\n<li>Il livello dell'applicazione riceve i dati dal livello di trasporto sulla porta specificata e li presenta a Patty sotto forma del messaggio di posta elettronica finale</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Cosa viene utilizzato per trovare l'indirizzo MAC sulla stessa rete?",
          "slug": "livellodicollegamento",
          "title": "Livello di collegamento"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 9,
          "lessonContent": "Un importante concetto di rete che non abbiamo ancora affrontato è il DHCP (Dynamic Host Configuration Protocol)\n\nIl DHCP assegna indirizzi IP, maschere di sottorete e gateway alle nostre macchine. Ad esempio, diciamo che hai un cellulare e vuoi ottenere un numero di cellulare per iniziare a parlare con le persone. Devi chiamare il tuo operatore telefonico e loro ti daranno un numero. Finché paghi le bollette, puoi continuare a usare il cellulare. Il DHCP è l'operatore telefonico in questo caso, ti fornisce un indirizzo IP in modo che tu possa parlare con altri indirizzi IP. Ti viene anche concesso in affitto un indirizzo IP, che dura per un certo periodo di tempo e poi verrà rinnovato in base alle impostazioni del contratto di locazione. \n\nIl DHCP è ottimo per molte ragioni, consente a un amministratore di rete di non preoccuparsi di assegnare indirizzi IP e impedisce anche la configurazione di indirizzi IP duplicati. Ogni rete fisica dovrebbe avere il proprio server DHCP in modo che un host possa richiedere un indirizzo IP. In un ambiente domestico normale, di solito il router funge da server DHCP.\n\nIl modo in cui il DHCP ottiene tutte le informazioni dinamiche dell'host è il seguente:\n\n<ol>\n<li>DHCP DISCOVER - Questo messaggio viene trasmesso in broadcast per cercare un server DHCP.</li>\n<li>DHCP OFFER - Il server DHCP nella rete risponde con un messaggio di offerta. L'offerta contiene un pacchetto con il tempo di locazione DHCP, la maschera di sottorete, l'indirizzo IP, ecc.</li>\n<li>DHCP REQUEST - Il client invia un altro broadcast per far sapere a tutti i server DHCP quale offerta ha accettato.</li>\n<li>DHCP ACK - Viene inviata l'accettazione da parte del server.</li>\n</ol>\n\nIl DHCP diventa più complesso di così, ma questa è la sostanza.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "Quali sono i passaggi in una richiesta DHCP?",
          "slug": "panoramica-dhcp",
          "title": "Panoramica di DHCP"
        }
      ],
      "slug": "networkbasics",
      "title": "Nozioni di base di rete"
    },
    {
      "description": "Scopri di più sui subnet e su come fare l'aritmetica dei subnet!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Trova il tuo indirizzo IP con ifconfig.",
          "id": 1,
          "lessonContent": "Ogni host di rete ha un indirizzo univoco, e ciascun indirizzo univoco può essere utilizzato per individuare l'host all'interno della rete. Questi indirizzi univoci sono noti come 'indirizzi IP'. Un indirizzo IPv4 ha un aspetto simile a questo:\n\n<pre>204.23.124.23</pre>\n\nQuesto indirizzo contiene effettivamente due parti: la parte di rete (che identifica a quale rete appartiene) e la parte di host (che identifica l'host). Per questo corso, parleremo principalmente degli indirizzi IPv4, che sono quelli che comunemente si vedono quando si fa riferimento agli 'indirizzi IP'.\n\nUn indirizzo IP è separato in ottetti dai punti. Ci sono 4 ottetti in un indirizzo IPv4. Se conosci un po' di informatica, saprai che un ottetto è composto da 8 bit e saprai che 8 bit equivalgono effettivamente a 1 byte. Questo significa che un indirizzo IPv4 ha 4 byte. Usiamo frequentemente i bit quando trattiamo subnet e indirizzi IP.\n\nPuoi visualizzare il tuo indirizzo IP con il comando 'ifconfig -a':\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nCome puoi vedere, il mio indirizzo IPv4 è: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "Quanti byte ci sono in un indirizzo IPv4?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Usa ifconfig per visualizzare la tua maschera di sottorete.",
          "id": 2,
          "lessonContent": "Come posso capire se sono sulla stessa rete di Patty? Beh, possiamo semplicemente guardare alla sottorete, abbreviata in subnet. Una subnet è un gruppo di host con indirizzi IP simili in un certo modo. Questi host di solito si trovano in una posizione prossima l'uno all'altro e puoi facilmente inviare dati da e verso gli host sulla stessa subnet. Pensaci come inviare posta nello stesso codice postale, è molto più facile che inviare posta a uno stato diverso. \n\nPer esempio, tutti gli host con un indirizzo IP che inizia con 123.45.67 sarebbero sulla stessa subnet. Il mio host ha un IP di 123.45.67.8 e quello di Patty ha un IP di 123.45.67.9. I numeri comuni sono il mio prefisso di rete e gli 8 e 9 sono i nostri host, quindi la mia rete è la stessa di quella di Patty. Una subnet è divisa in un prefisso di rete, come ad esempio 123.45.67.0 e una maschera di sottorete.\n\n<b>Maschere di Sottorete</b>\n\nLe maschere di sottorete determinano quale parte del tuo indirizzo IP è la parte di rete e quale parte è la parte di host. \n\nUna tipica maschera di sottorete può apparire così:\n\n<pre>255.255.255.0</pre>\n\nLa parte 255 è effettivamente la nostra maschera. Per rendere questo concetto un po' più facile da capire, ricorda come ci riferiamo a ciascun ottetto come 8 bit? In informatica un bit è indicato da un 0 o un 1 in forma binaria. Quando vengono utilizzati numeri binari, 1 significa acceso e 0 spento. Quindi cosa equivalgono 8 0 o 1?\n\nInserisci su Google \"calcolatrice da binario a decimale\" e converti 11111111 in forma decimale. Cosa ottieni? 255! Quindi un ottetto va da 0 a 255. Quindi se avessimo una maschera di sottorete di 255.255.255.0 e un indirizzo IP di 192.168.1.0, quanti host ci sono in quella subnet? Scopriremo la risposta in questa lezione di matematica delle subnet.\n\nInoltre, quando parliamo della nostra subnet, comunemente la indichiamo con il prefisso di rete seguito dalla maschera di sottorete:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>Perché?</b>\n\nPerché diamine creiamo sottoreti? La suddivisione in sottoreti è utilizzata per segmentare le reti e controllare il flusso del traffico all'interno di quella rete. Quindi un host su una subnet non può interagire con un altro host su una subnet diversa. \n\nMa aspetta un attimo, e se volessi connettermi ad altri host come yahoo.com? Allora devi connettere le sottoreti insieme. Per connettere le sottoreti devi semplicemente trovare gli host che sono collegati a più di una subnet. Ad esempio, se il mio host a 192.168.1.129 è collegato a una rete locale di 192.168.1.129/24 può raggiungere tutti gli host su quella rete. Per raggiungere gli host nel resto di Internet, deve comunicare attraverso il router. Tradizionalmente, nella maggior parte delle reti con una maschera di sottorete di 255.255.255.0, il router si trova di solito all'indirizzo 1 della subnet, quindi 192.168.1.1. Ora quel router avrà una porta che lo collega a un'altra subnet (più dettagli nel corso sul Routing). Certi indirizzi IP (reti private) non sono visibili su Internet, e abbiamo cose come il NAT in atto (più su questo in seguito).",
          "quizAnswer": "Vero",
          "quizQuestion": "Vero o falso, una subnet è composta da una maschera di sottorete e un prefisso di rete.",
          "slug": "sottoreti",
          "title": "Sottoreti"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Ok, sappiamo che le maschere di sottorete sono importanti per capire quanti host possiamo avere sulla nostra subnet. Quanti host potrebbero essere? \n\nDiciamo che ho un indirizzo IP di <b>192.168.1.0</b> e una maschera di sottorete di <b>255.255.255.0</b>, ora allineiamo questi numeri in forma binaria. Per ora utilizza un calcolatore online per convertire questi valori da decimale a binario.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nL'indirizzo IP è mascherato dalla nostra maschera di sottorete, quando vedi un 1, è mascherato e facciamo finta di non vederlo. Quindi gli unici host possibili che possiamo avere sono nella regione 00000000. Ricorda che 11111111 in forma binaria corrisponde a 255, consideriamo anche 0 come numero di host, quindi ci sono 256 opzioni possibili. Tuttavia, potrebbe sembrare che abbiamo 256 opzioni possibili, ma in realtà sottraiamo 2 host perché dobbiamo considerare l'indirizzo di broadcast e l'indirizzo di sottorete, lasciandoci con 254 host possibili sulla nostra subnet. Quindi sappiamo che possiamo avere host con indirizzi IP che vanno da 192.168.1.1 a 192.168.1.254.",
          "quizAnswer": "11111111",
          "quizQuestion": "Qual è l'equivalente binario di 255?",
          "slug": "subnetmath",
          "title": "Matematica delle subnet"
        },
        {
          "exercise": "Guarda il tuo indirizzo IP e la subnet mask e vedi quanti host puoi avere sulla tua subnet.",
          "id": 4,
          "lessonContent": "Odio dover aggiungere questa sezione, nel mondo reale molto probabilmente non dovrai mai fare calcoli di subnet a mano, tuttavia se ti stessero intervistando su questo, dovrai sapere come convertire da e verso la forma binaria per il subnetting. Per fortuna ci sono alcuni trucchi aritmetici che puoi memorizzare. \n\nPrima di tutto memorizza i tuoi calcoli in base 2, fallo semplicemente:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Tabella decimale-binaria</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nCi sono molte ragioni per cui la tabella seguente ha questo aspetto, se sei curioso su come funziona ci sono molte risorse online.\n\nOk, hai memorizzato tutto questo? Facciamo una rapida conversione da decimale a binario:\n\n<b>Converti 192.168.23.43 in binario</b>\n\nRicorda: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nFacciamo la conversione del primo ottetto in binario e capirai come funziona il resto.\n\n<ol>\n<li>Puoi sottrarre 192 - 128? Sì, quindi il primo bit è 1</li>\n<li>192 - 128 = 64, il numero successivo nella tabella è 64, puoi sottrarre 64 - 64? Sì, quindi il secondo bit è 1</li>\n<li>Siamo arrivati alla fine delle sottrazioni, quindi la forma binaria di 192 è 11000000</li>\n</ol>\n\n<b>Converti il binario 11000000 in decimale</b>\n\nPer la conversione da binario a decimale si sommano i numeri che hanno un 1, quindi:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "Qual è la conversione binaria di 123?",
          "slug": "subnettingcheats",
          "title": "Trucchi di subnetting"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "CIDR (classless inter-domain routing) viene utilizzato per rappresentare una maschera di sottorete in modo più compatto. È possibile trovare sottoreti indicate in notazione CIDR, dove una sottorete come 10.42.3.0/255.255.255.0 viene scritta come 10.42.3.0/24, il che significa che include sia il prefisso della sottorete che la maschera di sottorete.\n\nRicorda che un indirizzo IP è composto da 4 byte o 32 bit, CIDR indica la quantità di bit utilizzati come prefisso di rete. Quindi 123.12.24.0/23 significa che i primi 23 bit sono utilizzati. Cosa significa questo? Quanti host sono inclusi? \n\nUn semplice trucco è sottrarre il totale dei bit che un indirizzo IP può avere (32) dall'indirizzo CIDR (23), quindi rimangono 9 bit, 2^9 = 512, ma dobbiamo rimuovere 2 indirizzi (indirizzo di sottorete e indirizzo di broadcast) quindi abbiamo 510 host utilizzabili.",
          "quizAnswer": "",
          "quizQuestion": "Nessuna domanda, continua!",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 6,
          "lessonContent": "Abbiamo già menzionato il NAT (traduzione degli indirizzi di rete) in precedenza, ma non ci siamo soffermati su di esso. Quando lavoriamo sulla nostra rete, significa che Internet può vedere il nostro indirizzo IP? Non esattamente.\n\nIl NAT fa sì che un dispositivo come il nostro router agisca come intermediario tra Internet e la rete privata. Quindi è necessario un solo indirizzo IP unico per rappresentare un intero gruppo di computer.\n\nPensa al NAT come a una receptionist in un grande ufficio: se qualcuno vuole contattarti, conosce solo il numero dell'intero ufficio, la receptionist dovrà quindi cercare il tuo numero di estensione e inoltrare la chiamata a te.\n\n<b>Come funziona?</b>\n\nUn caso semplice sarebbe il seguente:\n\n<ol>\n<li>Patty vuole connettersi a www.google.com, quindi il suo computer invia questa richiesta attraverso il router</li>\n<li>Il router prende quella richiesta e apre la propria connessione a google.com, quindi invia la richiesta di Patty una volta stabilita la connessione</li>\n<li>Il router è l'intermediario tra Patty e www.google.com. Google non sa nulla di Patty, tutto ciò che può vedere è il router.</li>\n</ol>\n\nIl NAT e il routing dei pacchetti in generale possono diventare piuttosto complessi, ma non approfondiremo nei dettagli.",
          "quizAnswer": "NAT",
          "quizQuestion": "Cosa viene utilizzato per rappresentare un singolo indirizzo privato su Internet?",
          "slug": "traduzioneindirizziretedirete",
          "title": "NAT"
        },
        {
          "exercise": "Controlla ifconfig per vedere se hai un indirizzo IPv6 elencato.",
          "id": 7,
          "lessonContent": "Abbiamo sentito il termine IPv6 qua e là, ma cos'è? Ogni dispositivo che si connette a Internet ottiene il proprio indirizzo IP, beh, questo accade ad un numero finito che stiamo per raggiungere in quest'era digitale. IPv6 è stato creato per consentirci di connettere più host a Internet, arriva con ulteriori miglioramenti degli IP, tuttavia la sua adozione è piuttosto lenta. Non è destinato a sostituire IPv4, sono destinati a integrarsi l'uno con l'altro. I due protocolli IP sono molto simili e se conosci IPv4 capirai IPv6, la differenza principale è nel modo in cui l'indirizzo è scritto. Ecco come appare un tipico indirizzo IPv6:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "Quale indirizzo IP viene utilizzato per aumentare il numero di host che possono connettersi a Internet?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Subnetting"
    },
    {
      "description": "Impara come i pacchetti vengono instradati attraverso le reti!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Abbiamo già utilizzato il termine router in precedenza, speriamo che tu sappia cosa sia, dato che probabilmente ne hai uno a casa. Un router consente alle macchine in una rete di comunicare tra loro e con altre reti. Su un router tipico, avrai porte LAN che consentono alle tue macchine di connettersi alla stessa rete locale e avrai anche una porta di collegamento a Internet che ti connette a Internet, a volte vedrai questa porta etichettata come WAN, perché ti sta essenzialmente connettendo a una rete più ampia. Quando facciamo qualsiasi tipo di attività di rete, deve passare attraverso il router. Il router decide dove vanno i nostri pacchetti di rete e quali arrivano. Instrada i nostri pacchetti tra più reti per passare dall'host di origine all'host di destinazione. \n\n<b>Come funziona un router?</b>\n\nPensa al routing allo stesso modo della consegna della posta, abbiamo un indirizzo a cui vogliamo inviare una lettera, quando la inviamo all'ufficio postale, loro prendono la lettera e vedono, oh questa va in California, la metterò sul camion diretto in California (sinceramente non ho idea di come funzioni il sistema postale). La lettera viene quindi inviata a San Francisco, all'interno di San Francisco ci sono diversi codici postali, e poi in quei codici postali ci sono codici di indirizzo più piccoli, fino a quando qualcuno è in grado di consegnare la tua lettera all'indirizzo desiderato. D'altra parte, se già vivi a San Francisco e nello stesso codice postale, il fattorino probabilmente saprà esattamente dove deve andare la lettera senza passarla a nessun altro. \n\nQuando instradiamo i pacchetti, utilizzano 'percorsi' di indirizzo simili, ad esempio per raggiungere la rete A, invia questi pacchetti alla rete B. Quando non abbiamo un percorso impostato per quello, abbiamo un percorso predefinito che i nostri pacchetti utilizzeranno. Questi percorsi sono impostati su una tabella di routing che il nostro sistema utilizza per navigarci attraverso le reti.\n\n<b>Hops</b>\n\nMentre i pacchetti si spostano attraverso le reti, viaggiano in hop, un hop è come misuriamo approssimativamente la distanza che il pacchetto deve percorrere per passare dalla sorgente alla destinazione. Diciamo che ho due router che collegano l'host A all'host B, quindi diciamo che ci sono due hop tra l'host A e l'host B. Ogni hop è un dispositivo intermedio come i router che dobbiamo attraversare.\n\n<b>Comprendere la differenza di base tra Switching, Routing e Flooding?</b>\nLo SWITCHING dei pacchetti consiste essenzialmente nel ricevere, elaborare e inoltrare i dati al dispositivo di destinazione.\nIl ROUTING è un processo di creazione della tabella di routing, in modo da poter fare SWITCHING in modo migliore.\nPrima del routing, veniva utilizzato il FLOODING. Se un router non sa in quale direzione inviare un pacchetto, allora ogni pacchetto in arrivo viene inviato attraverso ogni collegamento in uscita tranne quello in cui è arrivato.",
          "quizAnswer": "hop",
          "quizQuestion": "Come misurano i pacchetti la distanza?",
          "slug": "cosèunrouter",
          "title": "Cos'è un router?"
        },
        {
          "exercise": "Guarda la tua tabella di routing e vedi dove possono andare i tuoi pacchetti.",
          "id": 2,
          "lessonContent": "Guarda la tabella di routing della tua macchina:\n\n<pre>\npete@icebox:~$ sudo route -n\nTabella di routing IP del kernel\nDestinazione     Gateway         Maschera di rete         Flag Metric Ref    Use Interfaccia\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destinazione</b>\n\nNel primo campo, abbiamo un indirizzo IP di destinazione di 192.168.224.0, questo indica che qualsiasi pacchetto che cerca di raggiungere questa rete, esce tramite il mio cavo Ethernet (eth0). Se fossi 192.168.224.5 e volessi raggiungere 192.168.224.7, utilizzerei direttamente l'interfaccia di rete eth0.\n\nNota che abbiamo degli indirizzi di <b>0.0.0.0</b>, questo significa che nessun indirizzo è specificato o è sconosciuto. Quindi, ad esempio, se volessi inviare un pacchetto all'indirizzo IP 151.123.43.6, la nostra tabella di routing non sa dove mandarlo, quindi lo indica come 0.0.0.0 e quindi instrada il nostro pacchetto al Gateway.\n\n<b>Gateway</b>\n\nSe stiamo inviando un pacchetto che non è nella stessa rete, verrà inviato a questo indirizzo Gateway. Che è giustamente chiamato come un Gateway verso un'altra rete.\n\n<b>Maschera di rete</b>\n\nQuesta è la maschera di sottorete, utilizzata per capire quali indirizzi IP corrispondono a quale destinazione.\n\n<b>Flag</b>\n\n<ul>\n<li>UG - La rete è attiva ed è un Gateway</li>\n<li>U - La rete è attiva</li>\n</ul>\n\n<b>Interfaccia</b>\n\nQuesta è l'interfaccia attraverso la quale il nostro pacchetto uscirà, eth0 di solito sta per il primo dispositivo Ethernet sul tuo sistema.",
          "quizAnswer": "Gateway",
          "quizQuestion": "Dove vengono instradati i pacchetti se la nostra tabella di routing non lo sa?",
          "slug": "routingtable",
          "title": "Tabella di routing"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "<b>Vediamo come un pacchetto viaggia all'interno della propria rete locale</b>\n\n<ol>\n<li>Prima la macchina locale confronta l'indirizzo IP di destinazione per vedere se è nella stessa subnet guardando la sua subnet mask.</li>\n<li>Quando i pacchetti vengono inviati devono avere un indirizzo MAC di origine, un indirizzo MAC di destinazione, un indirizzo IP di origine e un indirizzo IP di destinazione, a questo punto non conosciamo ancora l'indirizzo MAC di destinazione.</li>\n<li>Per raggiungere l'host di destinazione, utilizziamo ARP per diffondere una richiesta sulla rete locale per trovare l'indirizzo MAC dell'host di destinazione.</li>\n<li>Ora il pacchetto può essere inviato con successo!</li>\n</ol>\n\n<b>Vediamo come un pacchetto viaggia al di fuori della propria rete</b>\n\n<ol>\n<li>Prima la macchina locale confronta l'indirizzo IP di destinazione, poiché è al di fuori della nostra rete, non vede l'indirizzo MAC dell'host di destinazione. E non possiamo utilizzare ARP perché la richiesta ARP è una diffusione a host connessi localmente.</li>\n<li>Quindi il nostro pacchetto guarda ora la tabella di instradamento, non conosce l'indirizzo dell'IP di destinazione, quindi lo invia al gateway predefinito (un altro router). Ora il nostro pacchetto contiene il nostro IP di origine, l'IP di destinazione e il MAC di origine, tuttavia non abbiamo un MAC di destinazione. Ricorda che gli indirizzi MAC sono raggiunti solo attraverso la stessa rete. Cosa fa quindi? Invia una richiesta ARP per ottenere l'indirizzo MAC del gateway predefinito.</li>\n<li>Il router guarda il pacchetto e conferma l'indirizzo MAC di destinazione, ma non è l'indirizzo IP di destinazione finale, quindi continua a guardare la tabella di instradamento per inoltrare il pacchetto a un altro indirizzo IP che può aiutare il pacchetto a proseguire verso la sua destinazione. Ogni volta che il pacchetto si sposta, elimina i vecchi indirizzi MAC di origine e di destinazione e aggiorna il pacchetto con i nuovi indirizzi MAC di origine e di destinazione.</li>\n<li>Una volta che il pacchetto viene inoltrato alla stessa rete, utilizziamo ARP per trovare l'indirizzo MAC di destinazione finale</li>\n<li>Durante questo processo, il nostro pacchetto non cambia l'indirizzo IP di origine o di destinazione.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "Come possiamo trovare l'indirizzo MAC di un indirizzo IP?",
          "slug": "percorso-di-un-pacchetto",
          "title": "Percorso di un Pacchetto"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "Sarebbe un problema dover configurare manualmente le route su una tabella di routing per ogni dispositivo sulla tua rete, quindi invece utilizziamo ciò che sono conosciuti come protocolli di routing. I protocolli di routing sono utilizzati per aiutare il nostro sistema adattarsi ai cambiamenti di rete, apprende percorsi diversi, li costruisce nella tabella di routing e quindi instrada i nostri pacchetti in quel modo. Ci sono due tipi principali di protocolli di routing, protocolli a vettore di distanza e protocolli a stato di collegamento.\n\n<b>Convergenza</b>\n\nPrima di parlare dei protocolli, dovremmo spiegare un termine utilizzato nel routing conosciuto come convergenza. Quando si utilizzano protocolli di routing, i router comunicano con altri router per raccogliere ed scambiare informazioni sulla rete. Quando concordano su come dovrebbe apparire una rete, ogni tabella di routing mappa l'intera topologia della rete, quindi \"converge\". Quando avviene qualcosa nella topologia di rete, la convergenza si interromperà temporaneamente fino a quando tutti i router sono a conoscenza di questo cambiamento.",
          "quizAnswer": "convergenza",
          "quizQuestion": "Qual è il termine utilizzato quando tutte le tabelle di routing conoscono la topologia di rete?",
          "slug": "protocollidirouting",
          "title": "Protocolli di routing"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "I protocolli a vettore distanza determinano il percorso di altre reti utilizzando il conteggio di hop che un pacchetto compie attraverso la rete. Se la rete A fosse distante 3 hop e la rete B fosse accanto alla rete A, allora assumiamo che debba essere distante 4 hop. Nei protocolli a vettore distanza, il percorso successivo sarà quello con il minor numero di hop.\n\nI protocolli a vettore distanza sono ottimi per reti di piccole dimensioni, ma quando le reti iniziano a scalare, ci vuole più tempo per la convergenza dei router perché periodicamente inviano l'intera tabella di routing a ogni router. Un altro svantaggio dei protocolli a vettore distanza è l'efficienza, sceglie percorsi che sono più vicini in termini di hop, ma potrebbe non sempre scegliere il percorso più efficiente.\n\nUno dei comuni protocolli a vettore distanza è RIP (Routing Information Protocol), che trasmette la tabella di routing a ogni router nella rete ogni 30 secondi. Per una rete di grandi dimensioni, questo può richiedere molta potenza, per questo RIP limita il conteggio di hop a 15.",
          "quizAnswer": "falso",
          "quizQuestion": "Vero o falso, i protocolli a distanza utilizzano il percorso con il minor numero di banda?",
          "slug": "protocollivettoredistanza",
          "title": "Protocolli a Vettore Distanza"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 6,
          "lessonContent": "I protocolli a stato di collegamento sono ottimi per reti di grandi dimensioni, sono più complessi dei protocolli a vettore di distanza, tuttavia un grande vantaggio è la loro capacità di convergere rapidamente, questo perché anziché inviare periodicamente l'intera tabella di routing, inviano solo gli aggiornamenti alle rotte vicine. Utilizzano un algoritmo diverso per calcolare il percorso più breve e costruiscono la topologia della rete sotto forma di un grafo per mostrare quali router sono collegati ad altri router.\n\nUno dei protocolli a stato di collegamento più comuni è OSPF (Open Shortest Path First), aggiorna solo le tabelle di routing se c'è stato un cambiamento di rete. Non ha un limite di hop.",
          "quizAnswer": "OSPF",
          "quizQuestion": "Qual è uno dei protocolli a stato di collegamento più comuni?",
          "slug": "protocollistatocollegamento",
          "title": "Protocolli a stato di collegamento"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 7,
          "lessonContent": "L'ultimo importante protocollo di cui parleremo è BGP, BGP è fondamentalmente come funziona Internet. Viene utilizzato per raccogliere e scambiare informazioni di routing tra sistemi autonomi. Pensate a un sistema autonomo come a un fornitore di servizi Internet, un'azienda, un'università, un'organizzazione, ecc. Senza BGP, questi sistemi non saprebbero come comunicare tra loro, sarebbero semplicemente isolati. Invece di instradare all'interno di questi sistemi autonomi, BGP instrada tra di essi.\n\nImmaginiamo che tu sia nella tua rete domestica e io stia lavorando da Starbucks, voglio essere in grado di comunicare con te, quindi invio una email e il pacchetto di rete viaggia attraverso la rete di Starbucks, rimbalza lì intorno e passa attraverso le tabelle di routing nella rete di Starbucks fino a raggiungere infine un punto al confine della rete di Starbucks e lo passa a un router Border Gateway. Questo router contiene le informazioni per far uscire il mio pacchetto dalla rete di Starbucks e attraversare altre reti.",
          "quizAnswer": "BGP",
          "quizQuestion": "Quale protocollo fondamentalmente fa funzionare Internet?",
          "slug": "bgpbordergatewayprotocol",
          "title": "Border Gateway Protocol"
        }
      ],
      "slug": "routing",
      "title": "Routing"
    },
    {
      "description": "Scopri come configurare la rete utilizzando gli strumenti Linux!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Prova a cambiare lo stato delle tue interfacce di rete sia su up che su down e osserva cosa succede.\n\nPuoi cambiare le interfacce di rete con entrambi i comandi ifconfig e ip?",
          "id": 1,
          "lessonContent": "Un'interfaccia di rete è il modo in cui il kernel collega il lato software del networking al lato hardware. Abbiamo già visto un esempio di questo: \n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> Il comando ifconfig</b>\n\nIl tool <b>ifconfig</b> ci permette di configurare le nostre interfacce di rete, se non abbiamo alcuna interfaccia di rete configurata, i driver dei dispositivi del kernel e la rete non sapranno come comunicare tra di loro. Ifconfig viene eseguito all'avvio e configura le nostre interfacce tramite file di configurazione, ma possiamo anche modificarle manualmente. L'output di ifconfig mostra il nome dell'interfaccia sul lato sinistro e sul lato destro mostra informazioni dettagliate. Vedrai più comunemente interfacce chiamate eth0 (prima scheda Ethernet nella macchina), wlan0 (interfaccia wireless), lo (interfaccia loopback). L'interfaccia loopback viene utilizzata per rappresentare il tuo computer, ti riporta semplicemente a te stesso. Questo è utile per il debug o per connettersi a server in esecuzione in locale. \n\nLo stato delle interfacce può essere up o down, come puoi immaginare se vuoi \"disattivare\" un'interfaccia puoi impostarla su down. I campi a cui probabilmente guarderai di più nell'output di ifconfig sono HWaddr (indirizzo MAC dell'interfaccia), inet address (indirizzo IPv4) e inet6 (indirizzo IPv6). Naturalmente puoi vedere che la subnet mask e l'indirizzo di broadcast sono presenti. Puoi anche visualizzare le informazioni sull'interfaccia in /etc/network/interfaces.\n\n<b>Per creare un'interfaccia e attivarla</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nQuesto assegna un indirizzo IP e una netmask all'interfaccia eth0 e la attiva.\n\n<b>Per attivare o disattivare un'interfaccia</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> Il comando ip </b>\n\nIl comando <b>ip</b> ci consente anche di manipolare lo stack di networking di un sistema. A seconda della distribuzione che stai utilizzando, potrebbe essere il metodo preferito per manipolare le impostazioni di rete. \n\nEcco alcuni esempi del suo utilizzo:\n\n<b>Per mostrare le informazioni sull'interfaccia per tutte le interfacce </b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Per mostrare le statistiche di un'interfaccia</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>Per mostrare gli indirizzi IP assegnati alle interfacce</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>Per attivare e disattivare le interfacce</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Per aggiungere un indirizzo IP a un'interfaccia</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "Qual è il comando per configurare le nostre interfacce di rete?",
          "slug": "interfaccedirete",
          "title": "Interfacce di rete"
        },
        {
          "exercise": "Non ci sono esercizi per questa lezione, ma puoi leggere ulteriori informazioni sui comandi discussi qui nelle pagine di manuale\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Abbiamo già discusso della visualizzazione delle nostre tabelle di routing con il comando route, se desideri aggiungere o rimuovere percorsi puoi farlo manualmente.\n\n<b>Aggiungi un nuovo percorso</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Elimina un percorso</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nPuoi anche effettuare queste modifiche con il comando <b>ip</b>:\n\n<b>Per aggiungere un percorso</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Per eliminare un percorso</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\no\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "Qual è il flag del comando per eliminare un percorso?",
          "slug": "route",
          "title": "route"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Abbiamo discusso di DHCP in precedenza e nella maggior parte dei casi non sarà necessario impostare staticamente gli indirizzi IP, le maschere di sottorete, ecc. Invece si utilizzerà DHCP! Il dhclient si avvia all'avvio e ottiene un elenco delle interfacce di rete dal file dhclient.conf. Per ciascuna interfaccia elencata cerca di configurare l'interfaccia utilizzando il protocollo DHCP.\n\nNel file dhclient.leases, dhclient tiene traccia di un elenco di lease attraverso i riavvii di sistema, dopo aver letto dhclient.conf, viene letto il file dhclient.leases per farlo sapere quali lease ha già assegnato.\n\n<b>Per ottenere un nuovo IP</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "Chi cerca di assegnare gli indirizzi IP con il protocollo DHCP?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "Naturalmente, se desideri che la rete del tuo sistema sia attiva e funzionante automaticamente, c'è già qualcosa in grado di farlo. La maggior parte delle distribuzioni utilizza il demone NetworkManager per configurare automaticamente le proprie reti. \n\nNoterai NetworkManager sotto forma di un'applicazione da qualche parte nella barra delle applicazioni del desktop se stai utilizzando un'interfaccia grafica. Come puoi vedere, gestisce l'hardware di rete e le informazioni di connessione. Ad esempio, all'avvio, NetworkManager raccoglierà le informazioni sull'hardware di rete, cercherà connessioni wireless, cablate, ecc. e le attiverà.\n\nCi sono anche strumenti da riga di comando per interagire con NetworkManager:\n\n<b>nm-tool</b>\n\nnm-tool riporta lo stato di NetworkManager e i suoi dispositivi\n\n<pre>\npete@icebox:/$ nm-tool\nStrumento NetworkManager\n\nStato: connesso (globale)\n\n- Dispositivo: eth0  [Connessione cablata 1] -------------------------------------------\n  Tipo:              Cablato\n  Driver:            pcnet32\n  Stato:             connesso\n  Predefinito:       sì\n  Indirizzo HW:      12:3D:45:56:7D:CC\n\n  Capacità:\n    Rilevamento del carrier:  sì\n\n  Proprietà cablate\n    Carrier:         attivo\n\n  Impostazioni IPv4:\n    Indirizzo:         192.168.22.1\n    Prefisso:          24 (255.255.255.0)\n    Gateway:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nIl comando nmcli ti consente di controllare e modificare NetworkManager, consulta la pagina man per ulteriori dettagli.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "Qual è il comando per visualizzare le informazioni di NetworkManager?",
          "slug": "networkmanager",
          "title": "Gestore di rete"
        },
        {
          "exercise": "Osserva cosa succede alla tua cache ARP quando riavvii la tua macchina e poi fai qualcosa sulla rete.",
          "id": 5,
          "lessonContent": "Ricordi quando cerchiamo un indirizzo MAC con ARP, prima controlla la cache ARP memorizzata localmente sul nostro sistema, puoi effettivamente visualizzare questa cache: \n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nLa cache ARP è effettivamente vuota quando una macchina si avvia, viene popolata man mano che vengono inviati pacchetti ad altri host. Se inviamo un pacchetto a una destinazione che non è nella cache ARP, succede quanto segue:\n\n<ol>\n<li>L'host sorgente crea il frame Ethernet con un pacchetto di richiesta ARP</li>\n<li>L'host sorgente diffonde questo frame sull'intera rete</li>\n<li>Se uno degli host sulla rete conosce il corretto indirizzo MAC, invierà un pacchetto di risposta e un frame contenente l'indirizzo MAC</li>\n<li>L'host sorgente aggiunge la mappatura IP con l'indirizzo MAC alla cache ARP e poi procede con l'invio del pacchetto</li>\n</ol>\n\nPuoi anche visualizzare la tua cache arp tramite il comando ip:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "Quale comando puoi usare per visualizzare la tua cache ARP?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Configurazione di rete"
    },
    {
      "description": "Scopri gli strumenti di rete comuni per aiutarti a diagnosticare e risolvere i problemi!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Il Protocollo di messaggio di controllo Internet (ICMP) fa parte della suite di protocolli TCP/IP, viene utilizzato per inviare aggiornamenti e messaggi di errore ed è un protocollo estremamente utile utilizzato per il debug di problemi di rete come una consegna di pacchetti fallita.\n\nOgni messaggio ICMP contiene un campo tipo, codice e checksum. Il campo tipo è il tipo di messaggio ICMP, il codice è un sotto-tipo e fornisce ulteriori informazioni sul messaggio e il checksum viene utilizzato per rilevare eventuali problemi di integrità del messaggio.\n\nDiamo un'occhiata ad alcuni tipi ICMP comuni:\n\n<ul>\n<li>Tipo 0 - Echo Reply</li>\n<li>Tipo 3 - Destinazione non raggiungibile</li>\n<li>Tipo 8 - Echo Request</li>\n<li>Tipo 11 - Tempo scaduto</li>\n</ul>\n\nQuando un pacchetto non può raggiungere una destinazione, viene generato un messaggio ICMP di Tipo 3, all'interno del Tipo 3 ci sono 16 valori di codice che descriveranno ulteriormente il motivo per cui non può raggiungere la destinazione: \n\n<ul>\n<li>Codice 0 - Rete non raggiungibile</li>\n<li>Codice 1 - Host non raggiungibile</li>\netc..etc..\n</ul>\n\nQuesti messaggi avranno più senso mentre utilizziamo alcuni strumenti di risoluzione dei problemi di rete.",
          "quizAnswer": "8",
          "quizQuestion": "Qual è il tipo ICMP per la richiesta di eco?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Fai un ping su un sito web e guarda l'output che ricevi.",
          "id": 2,
          "lessonContent": "Uno degli strumenti di rete più semplici <b>ping</b>, è utilizzato per testare se un pacchetto può raggiungere un host. Funziona inviando pacchetti di richiesta di eco ICMP (Tipo 8) all'host di destinazione e attende una risposta di eco ICMP (Tipo 0). Il ping ha successo quando un host invia il pacchetto di richiesta e riceve una risposta dal destinatario. Vediamo un esempio: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) byte di dati.\n64 byte da nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 byte da nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 byte da nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nIn questo esempio, stiamo usando il ping per verificare se possiamo raggiungere www.google.com. Il flag -c (count) viene utilizzato per smettere di inviare pacchetti di richiesta di eco dopo che il conteggio è stato raggiunto. \n\nLa prima parte indica che stiamo inviando pacchetti da 64 byte a 74.125.239.112 (google.com) e il resto ci mostra i dettagli del viaggio. Di default invia un pacchetto al secondo.\n\n<b>icmp_seq</b>\n\nIl campo icmp_seq viene utilizzato per mostrare il numero di sequenza dei pacchetti inviati, quindi in questo caso, ho inviato 3 pacchetti e possiamo vedere che 3 pacchetti sono tornati. Se fai un ping e ti mancano alcuni numeri di sequenza, significa che si sta verificando un problema di connettività e non tutti i tuoi pacchetti stanno passando. Se il numero di sequenza è fuori ordine, la tua connessione è probabilmente molto lenta poiché i tuoi pacchetti superano il default di un secondo. \n\n<b>ttl</b>\n\nIl campo Time To Live (ttl) viene utilizzato come contatore di hop, man mano che fai hop, il contatore viene decrementato di uno e una volta che il contatore hop raggiunge 0, il nostro pacchetto muore. Questo serve a dare al pacchetto una durata di vita, non vogliamo che i nostri pacchetti viaggino per sempre.\n\n<b>time</b>\n\nIl tempo di andata e ritorno che è passato dal momento in cui hai inviato il pacchetto di richiesta di eco al momento in cui hai ricevuto una risposta di eco.",
          "quizAnswer": "ms",
          "quizQuestion": "Qual è l'unità di misura del tempo di andata e ritorno?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Esegui il comando traceroute sulla tua macchina e osserva l'output.",
          "id": 3,
          "lessonContent": "Il comando traceroute viene utilizzato per vedere come vengono instradati i pacchetti. Funziona inviando pacchetti con valori TTL crescenti, a partire da 1. Quindi il primo router riceve il pacchetto e decrementa il valore TTL di uno, facendo cadere il pacchetto. Il router ci invia indietro un messaggio ICMP di tempo scaduto. E poi il pacchetto successivo ottiene un TTL di 2, quindi supera il primo router, ma quando arriva al secondo router il TTL è 0 e restituisce un altro messaggio ICMP di tempo scaduto. Traceroute funziona in questo modo perché inviando e facendo cadere i pacchetti costruisce una lista di router che i pacchetti attraversano, fino a quando finalmente arriva alla sua destinazione e riceve un messaggio ICMP di risposta all'eco. \n\nEcco un piccolo frammento di un traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute verso google.com (216.58.216.174), massimo 30 salti, pacchetti da 60 byte                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nOgni riga è un router o una macchina che si trova tra me e il mio obiettivo. Mostra il nome dell'obiettivo e il suo indirizzo IP e le ultime tre colonne corrispondono al tempo di andata e ritorno di un pacchetto per raggiungere quel router. Per impostazione predefinita, inviamo tre pacchetti lungo il percorso.",
          "quizAnswer": "ttl",
          "quizQuestion": "Cosa viene decrementato di uno durante gli hop attraverso la rete?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Guarda la pagina di manuale di netstat e scopri tutte le funzionalità che offre.",
          "id": 4,
          "lessonContent": "<b>Porte ben note</b>\n\nAbbiamo discusso della trasmissione dei dati attraverso le porte sulla nostra macchina, vediamo alcune porte ben note.\n\nPuoi ottenere un elenco delle porte ben note guardando il file <b>/etc/services</b>: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..ecc..\n</pre>\n\nLa prima colonna è il nome del servizio, quindi il numero di porta e il protocollo del livello di trasporto che utilizza.\n\n<b>netstat</b>\n\nUno strumento estremamente utile per ottenere informazioni dettagliate sulla tua rete è <b>netstat</b>. Netstat visualizza varie informazioni relative alla rete come connessioni di rete, tabelle di routing, informazioni sulle interfacce di rete e altro ancora, è il coltellino svizzero degli strumenti di rete. Ci concentreremo principalmente su una funzionalità di netstat e cioè lo stato delle connessioni di rete. Prima di guardare un esempio, parliamo prima di socket e porte. Un socket è un'interfaccia che consente ai programmi di inviare e ricevere dati mentre una porta viene utilizzata per identificare quale applicazione dovrebbe inviare o ricevere dati. L'indirizzo del socket è la combinazione dell'indirizzo IP e della porta. Ogni connessione tra un host e una destinazione richiede un socket univoco. Ad esempio, HTTP è un servizio che funziona sulla porta 80, tuttavia possiamo avere molte connessioni HTTP e per mantenere ogni connessione viene creato un socket per connessione.\n\n<pre>\npete@icebox:~$ netstat -at\nConnessioni Internet attive (server e stabilite)\nProto Recv-Q Send-Q Indirizzo Locale           Indirizzo Remoto         Stato      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nIl comando netstat -a mostra i socket in ascolto e non in ascolto per le connessioni di rete, il flag -t mostra solo le connessioni tcp. \n\nLe colonne sono le seguenti da sinistra a destra:\n\n<ul>\n<li>Proto: Protocollo utilizzato, TCP o UDP.</li>\n<li>Recv-Q: Dati in coda da ricevere</li>\n<li>Send-Q: Dati in coda da inviare</li>\n<li>Indirizzo Locale: Host connesso localmente</li>\n<li>Indirizzo Remoto: Host connesso remotamente</li>\n<li>Stato: Lo stato del socket</li>\n</ul>\n\nConsulta la pagina di manuale per un elenco degli stati del socket, ma ecco alcuni:\n\n<ul>\n<li>LISTENING: Il socket è in ascolto per connessioni in ingresso, ricorda che quando stabiliamo una connessione TCP la nostra destinazione deve essere in ascolto per noi prima che possiamo connetterci.</li>\n<li>SYN_SENT: Il socket sta cercando attivamente di stabilire una connessione.</li>\n<li>ESTABLISHED: Il socket ha una connessione stabilita</li>\n<li>CLOSE_WAIT: L'host remoto si è disconnesso e stiamo aspettando che il socket si chiuda</li>\n<li>TIME_WAIT: Il socket sta aspettando dopo la chiusura per gestire i pacchetti ancora in rete</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "Quale porta viene utilizzata per HTTPS?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Scarica e installa lo strumento Wireshark e gioca con l'interfaccia.",
          "id": 5,
          "lessonContent": "L'argomento dell'analisi dei pacchetti potrebbe riempire un intero corso a sé stante e ci sono molti libri scritti solo sull'analisi dei pacchetti. Tuttavia, oggi impareremo solo le basi. Ci sono due analizzatori di pacchetti estremamente popolari, Wireshark e tcpdump. Questi strumenti scansionano le interfacce di rete, catturano l'attività dei pacchetti, analizzano i pacchetti e ci forniscono le informazioni in output. Ci permettono di entrare nei dettagli dell'analisi di rete e di approfondire le cose a basso livello. Utilizzeremo tcpdump poiché ha un'interfaccia più semplice, tuttavia se dovessi scegliere l'analisi dei pacchetti per il tuo set di strumenti, ti consiglierei di dare un'occhiata a Wireshark.\n\n<b>Installare tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Catturare dati del pacchetto su un'interfaccia</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: output dettagliato soppresso, utilizzare -v o -vv per la decodifica completa del protocollo\nin ascolto su wlan0, tipo di collegamento EN10MB (Ethernet), dimensione di cattura 65535 byte\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: richiesta di eco ICMP, id 1901, seq 2, lunghezza 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: risposta di eco ICMP, id 1901, seq 2, lunghezza 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: richiesta di eco ICMP, id 1901, seq 3, lunghezza 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: risposta di eco ICMP, id 1901, seq 3, lunghezza 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: richiesta di eco ICMP, id 1901, seq 4, lunghezza 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: risposta di eco ICMP, id 1901, seq 4, lunghezza 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: richiesta di eco ICMP, id 1901, seq 5, lunghezza 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: risposta di eco ICMP, id 1901, seq 5, lunghezza 64\n11:28:30.674953 ARP, richiesta di who-has 172.254.1.0 a ThePickleParty.lan, lunghezza 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, lunghezza 306\n</pre>\n\nNoterai molte cose succedere quando esegui una cattura di pacchetti, beh è normale ci sono molte attività di rete in background. Nel mio esempio sopra, ho preso solo un frammento della mia cattura specificamente quando ho deciso di fare ping a www.google.com. \n\n<b>Comprendere l'output</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: richiesta di eco ICMP, id 1901, seq 2, lunghezza 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: risposta di eco ICMP, id 1901, seq 2, lunghezza 64\n</pre>\n\n<ul>\n<li>Il primo campo è un timestamp dell'attività di rete</li>\n<li>IP, contiene le informazioni sul protocollo</li>\n<li>Successivamente, vedrai l'indirizzo sorgente e di destinazione: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, questo è il numero di sequenza di inizio e fine dei pacchetti TCP</li>\n<li>lunghezza, lunghezza in byte</li>\n</ul>\n\nCome puoi vedere dal nostro output di tcpdump, stiamo inviando un pacchetto di richiesta di eco ICMP a www.google.com e ricevendo in cambio un pacchetto di risposta di eco ICMP! Nota anche che pacchetti diversi produrranno informazioni diverse, consulta il manuale per vedere quali sono.\n\n<b>Scrivere l'output di tcpdump su un file</b>\n\n<pre>\n$ sudo tcpdump -w /some/file\n</pre>\n\nAlcune considerazioni finali: abbiamo appena grattato la superficie dell'argomento dell'analisi dei pacchetti. C'è così tanto su cui puoi concentrarti e non abbiamo nemmeno toccato l'approfondimento con l'output Hex e ASCII. Ci sono molte risorse online per aiutarti a imparare di più sugli analizzatori di pacchetti e ti incoraggio a trovarle!",
          "quizAnswer": "-i",
          "quizQuestion": "Qual è il flag per catturare una specifica interfaccia con tcpdump?",
          "slug": "analisi-dei-pacchetti",
          "title": "Analisi dei pacchetti"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Risoluzione dei problemi"
    },
    {
      "description": "Tutto e di più che volevi sapere su DNS.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 1,
          "lessonContent": "Immagina se ogni volta che volevi fare una ricerca su Google dovessi digitare http://192.78.12.4 invece di www.google.com. Beh, senza il DNS (\"Domain Name System\") è esattamente ciò che accadrebbe. La rete a basso livello comprende solo l'indirizzo IP grezzo per identificare un host. Il DNS ci permette agli umani di tenere traccia dei siti web e degli host per nome invece di un indirizzo IP. È come una rubrica per Internet. Se conosci il nome di qualcuno ma non conosci il suo numero di telefono, puoi semplicemente cercarlo nella tua rubrica.\n\nIl DNS è fondamentalmente un database distribuito di nomi di host e indirizzi IP, gestiamo il nostro database in modo che le persone sappiano come raggiungere il nostro sito/dominio, e altrove un'altra persona sta gestendo il proprio database in modo che gli altri possano raggiungere il loro dominio. Questi domini sono quindi in grado di comunicare tra loro e costruire una vasta rubrica di contatti di Internet.\n\nIn questo corso, affronteremo alcuni concetti di base del DNS, ma sii consapevole che il DNS è un argomento esaustivo e se vuoi davvero approfondire, dovrai fare ulteriori ricerche.",
          "quizAnswer": "falso",
          "quizQuestion": "Vero o falso, il DNS ci aiuta a trovare gli indirizzi MAC per i nomi di host?",
          "slug": "cosedns",
          "title": "Cos'è il DNS?"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 2,
          "lessonContent": "Il database DNS di Internet si basa su siti e organizzazioni che forniscono parte di tale database. Per fare ciò, hanno bisogno di:\n\n<b>Name Server</b>\n\nConfiguriamo il DNS tramite \"name server\", i name server caricano le nostre impostazioni e configurazioni DNS e rispondono a eventuali domande da parte dei clienti o di altri server che desiderano sapere cose come \"Chi è google.com?\". Se il name server non conosce la risposta a quella query, reindirizzerà la richiesta ad altri name server. I name server possono essere \"autoritativi\", il che significa che contengono i record DNS effettivi che stai cercando, oppure \"ricorsivi\", il che significa che chiederebbero ad altri server e quei server chiederebbero ad altri server fino a trovare un server autoritativo che conteneva i record DNS. I server ricorsivi possono anche avere le informazioni che desideriamo memorizzate invece di raggiungere un server autoritativo.\n\n<b>File di Zona</b>\n\nAll'interno di un name server si trova qualcosa chiamata file di zona. I file di zona sono come il name server memorizza le informazioni sul dominio o su come raggiungere il dominio se non lo conosce. \n\n<b>Record delle Risorse</b>\n\nUn file di zona è composto da voci di record delle risorse. Ogni riga è un record e contiene informazioni su host, name server, altre risorse, ecc. I campi consistono dei seguenti: \n\n<ul>\n<li>Nome del Record</li>\n<li>TTL - Il tempo dopo il quale scartiamo il record e otteniamo un nuovo, in DNS il TTL è indicato dal tempo, quindi i record potrebbero avere un TTL di un'ora. Il motivo per cui facciamo questo è perché Internet cambia costantemente, un minuto un host può essere mappato su un indirizzo IP X e il successivo su un indirizzo IP Y</li>\n<li>Classe - Namespace delle informazioni del record, comunemente viene utilizzato IN per Internet</li>\n<li>Tipo - Tipo di informazione memorizzata nei dati del record. Non entreremo nei tipi di record, ma probabilmente hai visto tipi comuni come A per indirizzo, MX o mail exchanger, ecc.</li>\n<li>Dati - Questo campo può contenere un indirizzo IP se si tratta di un record A o qualcos'altro a seconda del tipo di record.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "Che tipo di record delle risorse viene utilizzato per gli scambi di posta?",
          "slug": "componentidns",
          "title": "Componenti DNS"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 3,
          "lessonContent": "Vediamo un esempio di come il tuo host trova un dominio (catzontheinterwebz.com) con DNS. Fondamentalmente, ci facciamo strada fino a raggiungere il server DNS che conosce quel dominio.\n\n<b>Server DNS locale</b>\n\nPrima il nostro host chiede: \"Dov'è catzontheinterwebz.com?\", il nostro server DNS locale non lo sa quindi inizia dall'inizio del processo per chiedere ai Root Server. Tieni presente che il nostro host non sta facendo queste richieste per trovare direttamente catzontheinterwebz.com, la maggior parte degli utenti parla con un server DNS ricorsivo fornito dai loro ISP e a quel server viene quindi assegnato il compito di trovare la posizione di catzontheinterwebz.com.\n\n<b>Root Server</b>\n\nCi sono 13 Root Server per Internet, sono replicati e distribuiti in tutto il mondo per gestire le richieste DNS per Internet, quindi ci sono davvero centinaia di server che stanno lavorando, sono controllati da diverse organizzazioni e contengono informazioni sui domini di primo livello. I domini di primo livello sono quelli che conosci come indirizzi .org, .com, .net, ecc. Quindi il Root Server non sa dove si trova catzontheinterwebz.com, quindi ci dice di chiedere al server DNS del Dominio di primo livello .com a un indirizzo IP che ci fornisce. \n\n<b>Dominio di primo livello</b>\n\nOra inviamo un'altra richiesta al server che conosce gli indirizzi \".com\" e chiediamo se sa dove si trova catzontheinterwebz.com? Il Dominio di primo livello non ha catzontheinterwebz.com nei suoi file di zona, ma vede un record per il server di nomi per catzontheinterwebz.com. Quindi ci fornisce l'indirizzo IP di quel server di nomi e ci dice di guardare lì.\n\n<b>Server DNS autoritativo</b>\n\nOra inviamo una richiesta finale al server DNS che ha effettivamente il record che vogliamo. Il server di nomi vede che ha un file di zona per catzontheinterwebz.com e c'è un record di risorsa per 'www' per questo host. Quindi ci fornisce l'indirizzo IP di questo host e possiamo finalmente vedere alcuni gatti su Internet.",
          "quizAnswer": "TLD",
          "quizQuestion": "Qual è l'abbreviazione per i server di nomi dove si trovano gli indirizzi .com, .net, .org, ecc?",
          "slug": "processodns",
          "title": "Processo DNS"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 4,
          "lessonContent": "<p>Prima che la nostra macchina effettivamente contatti il DNS per fare una query, prima guarda localmente sulle nostre macchine. </p><br><p><b>/etc/hosts</b></p><p>Il file /etc/hosts contiene mapping di alcuni nomi host a indirizzi IP. I campi sono abbastanza autoesplicativi, c'è uno per l'indirizzo IP, il nome host e quindi eventuali alias per l'host. </p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>Vedrai tipicamente il tuo indirizzo localhost elencato come predefinito in questo file. Puoi anche gestire l'accesso agli host modificando i file /etc/hosts.deny o /etc/hosts.allow. Tuttavia, se sei attento alla sicurezza, questo non è davvero il modo giusto e dovresti modificare invece le regole del firewall. </p><p>Vediamo un esempio divertente di /etc/hosts. Modifica il file e aggiungi una riga per:</p><pre>123.45.6.7  www.google.com</pre><p>Salva il file e vai su www.google.com. Hai dei problemi, vero? Beh, questo perché abbiamo appena mappato www.google.com su un indirizzo IP completamente sbagliato. Poiché i nostri host cercano prima localmente i mapping degli indirizzi IP, non raggiungono mai il DNS per trovare google.com. </p><p><b>/etc/resolv.conf</b></p><p>Tradizionalmente, abbiamo usato un file chiamato /etc/resolv.conf per mappare i server di nomi DNS per ricerche più efficienti, tuttavia con i miglioramenti apportati al DNS questo file è spesso irrilevante, infatti, puoi vedere nel mio esempio qui sotto che /etc/resolv.conf non è gestito manualmente. Fai riferimento alle impostazioni specifiche della tua distribuzione per gestire i mapping dei server di nomi DNS.</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     NON MODIFICARE QUESTO FILE MANUALMENTE -- LE TUE MODIFICHE SARANNO SOVRASCRITTE<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "Quale file viene utilizzato per mappare i nomi host agli indirizzi IP sulle nostre macchine?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "Nessun esercizio per questa lezione.",
          "id": 5,
          "lessonContent": "Non affronteremo la configurazione di un server DNS, poiché sarebbe un tutorial piuttosto lungo. Invece, ecco un rapido elenco comparativo dei server DNS popolari da utilizzare con Linux.\n\n<b>BIND</b>\n\nIl server DNS più popolare su Internet, è lo standard utilizzato dalle distribuzioni Linux. È stato originariamente sviluppato presso l'Università della California a Berkeley, da qui il nome BIND (Berkeley Internet Name Domain). Se hai bisogno di potenza e flessibilità complete, non puoi sbagliare con BIND.\n\n<b>DNSmasq</b>\n\nLeggero e molto più facile da configurare rispetto a BIND. Se desideri semplicità e non hai bisogno di tutte le funzionalità di BIND, utilizza DNSmasq. Viene fornito con tutti gli strumenti necessari per configurare DHCP e DNS, consigliato per una rete più piccola.\n\n<b>PowerDNS</b>\n\nCompleto e simile a BIND, ti offre un po' più di flessibilità con le opzioni. Legge informazioni da più database come MySQL, PostgreSQL, ecc. per una gestione più semplice. Solo perché BIND è stato il modo in cui facciamo le cose, non significa che debba rimanere così.\n\nQuesto non è un elenco completo, ma dovrebbe darti un'idea di dove guardare se stai configurando il tuo server DNS.",
          "quizAnswer": "BIND",
          "quizQuestion": "Qual è il server DNS de facto per Linux?",
          "slug": "configurazionedns",
          "title": "Configurazione DNS"
        },
        {
          "exercise": "Leggi il manuale per dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nLo strumento \"name server lookup\" viene utilizzato per interrogare i name server al fine di trovare informazioni sui record di risorse. Scopriamo dove si trova il name server per google.com:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nRisposta non autoritativa:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (domain information groper) è uno strumento potente per ottenere informazioni sui name server DNS, è più flessibile di nslookup ed è ottimo per risolvere i problemi DNS.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; opzioni globali: +cmd\n;; Risposta ricevuta:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; SEZIONE DOMANDA:\n;www.google.com.                        IN      A\n\n;; SEZIONE RISPOSTA:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Tempo di interrogazione: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; QUANDO: Sun Feb 07 10:14:00 PST 2016\n;; DIMENSIONE MSG  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "Quale strumento viene utilizzato per ottenere informazioni dettagliate sui name server DNS?",
          "slug": "dnstools",
          "title": "Strumenti DNS"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Contenuto",
      "exerciseAndQuiz": "Esercizio e quiz"
    },
    "exerciseBox": {
      "exercise": "Esercizio"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Una nuova vita per LinuxJourney, che ha aiutato così tante persone a fare i primi passi nel mondo di Linux.",
      "title": "Sblocca il potere di Linux"
    },
    "navbar": {
      "home": "Home",
      "language": "Lingua",
      "lessons": "Lezioni",
      "resources": "Risorse",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Torna ai capitoli",
      "checkAnswer": "Controlla Risposta",
      "correctAnswer": "Risposta corretta: ",
      "nextLesson": "Lezione successiva",
      "placeholderAnswer": "Digita la tua risposta qui",
      "quiz": "Quiz",
      "showCorrectAnswer": "Mostra risposta corretta"
    },
    "resources": {
      "data": [
        {
          "description": "Una guida passo dopo passo per principianti che spiega la storia del terminale e i comandi di base",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Tutorial ufficiale di Ubuntu"
        },
        {
          "description": "Una panoramica chiara su come funziona il terminale, come eseguire comandi e navigare nel filesystem.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "Uno dei libri più raccomandati!",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "How Linux Works"
        },
        {
          "description": "Libro estremamente completo per ogni SysAdmin.",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "UNIX and Linux System Administration Handbook"
        },
        {
          "description": "Ottima guida completa allo scripting della shell.",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Linux Command Bible"
        },
        {
          "description": "Per utenti Linux seri, ottimo inizio nella programmazione del kernel.",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "The Linux Programming Interface: A Linux and UNIX System"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Scopri libri selezionati, tutorial e strumenti per approfondire la tua conoscenza di Linux.",
        "title": "Risorse"
      },
      "title": "Risorse"
    }
  }
}