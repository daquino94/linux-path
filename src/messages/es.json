{
  "chapters": [
    {
      "description": "¿Qué es Linux? Comienza eligiendo una distribución e instalación.",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "Lectura adicional:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "¡Hola novato! ¿Así que decidiste sumergirte en este maravilloso mundo conocido como Linux? Bueno, más te vale abrocharte el cinturón, porque va a ser un camino largo y difícil. Mi nombre es Pingüino Pete y estoy aquí para guiarte en este viaje. Empecemos con un poco de historia sobre Linux. \n\nPara conocer cómo surgió Linux, retrocedamos al principio, en 1969, cuando Ken Thompson y Dennis Ritchie de Bell Laboratories desarrollaron el sistema operativo UNIX. Más tarde fue reescrito en C para hacerlo más portable y eventualmente se convirtió en un sistema operativo ampliamente utilizado. \n\nUna década más tarde, Richard Stallman comenzó a trabajar en el proyecto GNU (GNU is Not UNIX), el núcleo GNU llamado Hurd, que desafortunadamente nunca se completó. La Licencia Pública General de GNU (GPL), una licencia de software libre, también se creó como resultado de esto.\n\nEl núcleo es la pieza más importante en el sistema operativo. Permite que el hardware se comunique con el software. También hace muchas otras cosas, pero profundizaremos en eso en un curso diferente. Por ahora, solo debes saber que el núcleo controla prácticamente todo lo que sucede en tu sistema. \n\nDurante este tiempo, se desarrollaron otros esfuerzos como BSD, MINIX, etc. para ser sistemas similares a UNIX. Sin embargo, una cosa que todos estos sistemas similares a UNIX tenían en común era la falta de un núcleo unificado. \n\nLuego, en 1991, un joven llamado Linus Torvalds comenzó a desarrollar lo que hoy conocemos como el núcleo Linux.",
          "quizAnswer": "Linus Torvalds",
          "quizQuestion": "¿Quién desarrolló el núcleo de Linux?",
          "slug": "historialinux",
          "title": "Historia"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 2,
          "lessonContent": "En la lección anterior, aprendimos sobre el kernel de Linux que alimenta millones de dispositivos al día. Antes de seguir adelante, hay algo que debemos aclarar, el término Linux es en realidad un error, ya que se refiere al kernel de Linux. Sin embargo, muchas distribuciones utilizan el kernel de Linux y por lo tanto son comúnmente conocidas como sistemas operativos Linux. \n\nUn sistema Linux se divide en tres partes principales:\n\n<ul>\n<li>Hardware - Esto incluye todo el hardware en el que se ejecuta su sistema, así como la memoria, CPU, discos, etc.</li>\n<li>Kernel de Linux - Como discutimos anteriormente, el kernel es el núcleo del sistema operativo. Administra el hardware y le indica cómo interactuar con el sistema.</li>\n<li>Espacio de usuario - Aquí es donde los usuarios como usted interactuarán directamente con el sistema.</li>\n</ul>\n\nPor lo tanto, el primer paso que debemos tomar es instalar Linux en su máquina. Tiene muchas opciones para elegir y este curso le ayudará a informarse y comenzar a elegir una distribución de Linux. \n\nHay muchas distribuciones de Linux para elegir, solo revisaremos las opciones más populares.",
          "quizAnswer": "",
          "quizQuestion": "¡Sin preguntas, pasa adelante!",
          "slug": "elegirunadistribuciondelinux",
          "title": "Elegir una distribución de Linux"
        },
        {
          "exercise": "Si estás interesado en tener Debian como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>Descripción</b>\nDebian es un sistema operativo compuesto enteramente de software libre y de código abierto. Es ampliamente conocido y ha estado en desarrollo durante más de 20 años. Hay tres ramas que puedes utilizar, Estable, Pruebas e Inestable. \n\nEstable es una buena rama en general para estar. Pruebas e Inestable son lanzamientos continuos. Esto significa que cualquier cambio incremental en esas ramas eventualmente se convertirá en Estable. Por ejemplo, si quisieras pasar a la siguiente actualización de Windows 8 a Windows 10, tendrías que hacer una instalación completa de Windows 10. Sin embargo, estando en el lanzamiento de Pruebas, recibirás automáticamente actualizaciones hasta que se convierta en la siguiente versión del sistema operativo sin tener que hacer una instalación completa. \n\n<b>Gestión de paquetes</b>\nDebian también utiliza herramientas de gestión de paquetes de Debian. Cada distribución de Linux instala y gestiona paquetes de manera diferente y utiliza diferentes herramientas de gestión de paquetes. Nos adentraremos más en esto en un curso posterior. \n\n<b>Configurabilidad</b>\nDebian puede que no reciba las últimas actualizaciones, pero es extremadamente estable. Si deseas un buen sistema operativo \"central\", este es el adecuado para ti.\n\n<b>Usos</b>\nDebian es en general un gran sistema operativo para cualquier plataforma.",
          "quizAnswer": "Continuo",
          "quizQuestion": "¿Qué tipo de lanzamiento tienen Pruebas e Inestable?",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "Si estás interesado en tener RHEL como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>Resumen</b>\nRed Hat Enterprise Linux comúnmente conocido como RHEL es desarrollado por Red Hat. RHEL tiene reglas estrictas para restringir la redistribución gratuita aunque aún proporciona el código fuente de forma gratuita.\n\n<b>Gestión de paquetes</b>\nRHEL utiliza un gestor de paquetes diferente a Debian, el gestor de paquetes RPM, del que eventualmente también aprenderemos.\n\n<b>Configurabilidad</b>\nLos sistemas operativos basados en RHEL difieren ligeramente de los sistemas operativos basados en Debian, principalmente en la gestión de paquetes. Si decides optar por RHEL, probablemente sea mejor que sepas que trabajarás con él.\n\n<b>Usos</b>\nComo su nombre lo indica, se utiliza principalmente en empresas, por lo que si necesitas un sistema operativo de servidor sólido, este sería una buena opción.",
          "quizAnswer": "RPM",
          "quizQuestion": "¿Qué gestor de paquetes utiliza RHEL?",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Si estás interesado en tener Ubuntu como tu sistema operativo, dirígete a la sección de instalación e inténtalo: \n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>Visión general</b>\nUna de las distribuciones de Linux más populares para máquinas personales es Ubuntu. Ubuntu también lanza su propio gestor de entorno de escritorio Unity de forma predeterminada. \n\n<b>Administración de paquetes</b>\nUbuntu es un sistema operativo basado en Debian desarrollado por Canonical. Por lo tanto, utiliza un sistema central de gestión de paquetes de Debian.\n\n<b>Configurabilidad</b>\nUbuntu es una excelente opción para un principiante que quiere adentrarse en Linux. Ubuntu ofrece facilidad de uso y una gran experiencia de interfaz de usuario que ha llevado a su amplia adopción. Es ampliamente utilizado y compatible y se asemeja más a otros sistemas operativos como OSX y Windows en términos de usabilidad.\n\n<b>Usos</b>\nIdeal para cualquier plataforma, escritorio, portátil y servidor.",
          "quizAnswer": "Debian",
          "quizQuestion": "¿En qué sistema operativo está basado Ubuntu?",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Si estás interesado en tener Fedora como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>Descripción</b>\nRespaldado por Red Hat, el Proyecto Fedora es impulsado por la comunidad y contiene software de código abierto y gratuito. Red Hat Enterprise Linux se ramifica a partir de Fedora, por lo que piensa en Fedora como un sistema operativo RHEL ascendente. Eventualmente, RHEL recibirá actualizaciones de Fedora después de pruebas exhaustivas y aseguramiento de calidad. Piensa en Fedora como un equivalente a Ubuntu que utiliza un backend de Red Hat en lugar de Debian.\n\n<b>Gestión de Paquetes</b>\nUtiliza el gestor de paquetes de Red Hat.\n\n<b>Configurabilidad</b>\nSi deseas utilizar un sistema operativo basado en Red Hat, esta es una versión amigable para el usuario.\n\n<b>Usos</b>\nFedora es excelente si deseas un sistema operativo basado en Red Hat sin la etiqueta de precio. Recomendado para escritorio y portátil.",
          "quizAnswer": "Fedora",
          "quizQuestion": "¿De qué se ramifica RHEL?",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Si estás interesado en tener Linux Mint como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>Descripción</b>\nLinux Mint se basa en Ubuntu. Utiliza los repositorios de software de Ubuntu, por lo que los mismos paquetes están disponibles en ambas distribuciones. Linux Mint es preferido por otros sobre Ubuntu porque no incluye algunos de los software propietarios que Ubuntu incluye, como Unity.\n\n<b>Gestión de paquetes</b>\nDado que Linux Mint se basa en Ubuntu, utiliza el gestor de paquetes Debian.\n\n<b>Configurabilidad</b>\nGran interfaz de usuario, ideal para principiantes y menos sobrecargado que Ubuntu. En este curso, estaré utilizando Linux Mint, pero se puede utilizar cualquier otra distribución. \n\n<b>Usos</b>\nIdeal para escritorio y portátil.",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "¿En qué se basa Linux Mint?",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Si estás interesado en tener Gentoo como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>Visión general</b>\nGentoo ofrece una flexibilidad ridícula con el sistema operativo a un precio. Está hecho para usuarios avanzados que no les importa ensuciarse las manos con el sistema.\n\n<b>Gestión de paquetes</b>\nGentoo utiliza su propio sistema de gestión de paquetes, Portage. El sistema de gestión de paquetes Portage es muy modular y fácil de mantener, lo que juega un papel importante en que el sistema operativo en su conjunto sea muy flexible.\n\n<b>Configurabilidad</b>\nSi estás empezando con Linux y quieres tomar un camino más difícil, elige Gentoo o Arch Linux como tu distribución.\n\n<b>Usos</b>\nGenial para escritorio y portátil.",
          "quizAnswer": "Portage",
          "quizQuestion": "¿Qué sistema de gestión de paquetes utiliza Gentoo?",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Si estás interesado en tener Arch como tu sistema operativo, dirígete a la sección de instalación e inténtalo: <a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>Visión general</b>\nArch es una distribución de Linux ligera y flexible impulsada al 100% por la comunidad. Similar a Debian, Arch utiliza un modelo de lanzamiento continuo, por lo que las actualizaciones incrementales eventualmente se convierten en la versión estable. Realmente necesitas ensuciarte las manos para entender el sistema y sus funciones, pero a cambio obtienes un control completo y total de tu sistema.\n\n<b>Gestión de paquetes</b>\nUtiliza su propio gestor de paquetes, Pacman, para instalar, actualizar y gestionar paquetes. \n\n<b>Configurabilidad</b>\nSi deseas un sistema operativo ligero y realmente quieres entender Linux, ¡usa Arch! Hay una curva de aprendizaje, pero para los usuarios avanzados de Linux, esta es una excelente elección.\n\n<b>Usos</b>\nIdeal para escritorio y portátil. Si también tienes un dispositivo pequeño como una Raspberry Pi y necesitas instalar un sistema operativo ligero en él, no te equivocarás con Arch.",
          "quizAnswer": "Pacman",
          "quizQuestion": "¿Qué gestor de paquetes utiliza Arch Linux?",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "Si estás interesado en tener openSUSE como tu sistema operativo, dirígete a la página de descargas y pruébalo: <a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>Visión general</b>\nopenSUSE Linux es creado por el Proyecto openSUSE. Una comunidad que promueve el uso de Linux en todas partes, trabajando juntos de manera abierta, transparente y amigable como parte de la comunidad mundial de Software Libre y de Código Abierto. openSUSE es la segunda distribución de Linux más antigua que aún está en funcionamiento y comparte el sistema base con los galardonados productos SUSE Linux Enterprise de SUSE.\n\n<b>Gestión de paquetes</b>\nUtiliza el gestor de paquetes RPM.\n\n<b>Configurabilidad</b>\nopenSUSE es una excelente opción para un nuevo usuario de Linux. Ofrece una aplicación de instalación/administración gráfica fácil de usar (<a href=\"http://yast.github.io/\">YaST</a>) y un sistema base ordenado, fácil de modificar. openSUSE incluye todo lo que necesitas para disfrutar de Internet sin preocuparte por virus/malware y para dar rienda suelta a tu creatividad, ya sea con tus fotos, videos, música o código.\n\n<b>Usos</b>\nopenSUSE Leap es totalmente capaz de ser utilizado en una PC de escritorio y una computadora portátil.",
          "quizAnswer": "yast",
          "quizQuestion": "¿Cuál es el nombre de la herramienta de Administración/Instalación de openSUSE?",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "Empezando"
    },
    {
      "description": "Aprende los fundamentos de la línea de comando, navegando archivos, directorios y más.",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "Intenta algunos otros comandos de Linux y observa qué es lo que imprimen:\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "El mundo es tu ostra, o realmente la cáscara es tu ostra. ¿Qué es la cáscara? La cáscara es básicamente un programa que toma tus comandos del teclado y los envía al sistema operativo para que los ejecute. Si alguna vez has usado una GUI, probablemente hayas visto programas como \"Terminal\" o \"Consola\", que son solo programas que inician una cáscara para ti. A lo largo de todo este curso estaremos aprendiendo sobre las maravillas de la cáscara. \n\nEn este curso utilizaremos el programa de cáscara bash (Bourne Again shell), casi todas las distribuciones de Linux usarán por defecto la cáscara bash. Hay otras cáscaras disponibles como ksh, zsh, tsch, pero no nos adentraremos en ninguna de esas. \n\n¡Comencemos! Dependiendo de la distribución, tu indicador de cáscara podría cambiar, pero en su mayoría debería seguir el siguiente formato:\n<pre>nombredeusuario@nombredehost:directorioactual\npete@icebox:/home/pete $</pre>\n\n¿Notas el $ al final del indicador? Diferentes cáscaras tendrán indicadores diferentes, en nuestro caso el $ es para un usuario normal que usa Bash, Bourne o Korn shell, no agregas el símbolo del indicador cuando escribes el comando, solo debes saber que está ahí.\n\nComencemos con un comando simple, echo. El comando echo simplemente imprime los argumentos de texto en la pantalla.\n\n<pre>$ echo Hola Mundo</pre>",
          "quizAnswer": "Hola Mundo",
          "quizQuestion": "¿Qué debería imprimirse en la pantalla cuando escribes echo Hola Mundo?",
          "slug": "lashell",
          "title": "La Shell"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 2,
          "lessonContent": "Todo en Linux es un archivo. A medida que te adentres más en Linux, comprenderás esto, pero por ahora solo tenlo en cuenta. Cada archivo se organiza dentro de un árbol jerárquico de directorios. El primer directorio en el sistema de archivos se llama acertadamente el 'directorio raíz'. El directorio raíz tiene muchas carpetas y archivos, en los cuales puedes almacenar más carpetas y archivos, y así sucesivamente. Aquí tienes un ejemplo de cómo se ve el árbol de directorios: \n\n<pre>/\n|-- bin\n|   |-- archivo1\n|   |-- archivo2\n|-- etc\n|   |-- archivo3\n|   `-- directorio1\n|       |-- archivo4\n|       `-- archivo5\n|-- home\n|-- var\n</pre>\n\nLas ubicaciones de estos archivos y directorios se denominan 'rutas'. Si tuvieras una carpeta llamada 'home' que tuviera una carpeta dentro llamada 'pete' y otra carpeta en esa carpeta llamada 'Movies', esa ruta se vería así: '/home/pete/Movies'. Bastante simple, ¿verdad?\n\nNavegar por el sistema de archivos, al igual que navegar en la vida real, es más fácil si sabes dónde estás y a dónde vas. Para ver dónde estás, puedes usar el comando 'pwd'. Este comando significa 'imprimir directorio de trabajo' y te muestra en qué directorio te encuentras. Ten en cuenta que la ruta parte del directorio raíz.\n\n<pre>$ pwd</pre>\n\n¿Dónde estás? ¿Dónde estoy? Pruébalo.",
          "quizAnswer": "pwd",
          "quizQuestion": "¿Cómo puedo saber en qué directorio te encuentras actualmente?",
          "slug": "comandoprintworkingdirectorypwd",
          "title": "pwd (Imprimir Directorio de Trabajo)"
        },
        {
          "exercise": "<ol>\n<li>Ejecuta el comando cd sin ninguna bandera, ¿a dónde te lleva?</li>\n</ol>",
          "id": 3,
          "lessonContent": "Ahora que sabes dónde estás, veamos si podemos movernos un poco por el sistema de archivos. Recuerda que necesitaremos navegar usando rutas. Hay dos formas diferentes de especificar una ruta, con rutas absolutas y relativas. \n\n<ul>\n<li>Ruta absoluta: Esta es la ruta desde el directorio raíz. El raíz es el jefe supremo. El directorio raíz comúnmente se muestra como una barra inclinada. Cada vez que tu ruta comienza con / significa que estás partiendo desde el directorio raíz. Por ejemplo, /home/pete/Desktop.</li>\n\n<li>Ruta relativa: Esta es la ruta desde donde te encuentras actualmente en el sistema de archivos. Si estuviera en la ubicación /home/pete/Documents y quisiera ir a un directorio dentro de Documents llamado taxes, no tengo que especificar toda la ruta desde la raíz como /home/pete/Documents/taxes, puedo simplemente ir a taxes/ en su lugar.</li>\n</ul>\n\nAhora que sabes cómo funcionan las rutas, solo necesitamos algo que nos ayude a cambiar al directorio que queremos. Afortunadamente, tenemos cd o “cambiar directorio” para hacer eso. \n\n<pre>$ cd /home/pete/Pictures</pre> \n\nAsí que ahora he cambiado mi ubicación de directorio a /home/pete/Pictures.\n\nAhora desde este directorio tengo una carpeta adentro llamada Hawaii, puedo navegar a esa carpeta con:\n\n<pre>$ cd Hawaii</pre>\n\n¿Notaste cómo solo usé el nombre de la carpeta? Es porque ya estaba en /home/pete/Pictures.\n\nPuede ser bastante agotador navegar con rutas absolutas y relativas todo el tiempo, afortunadamente hay algunos atajos para ayudarte. \n\n<ul>\n<li>. (directorio actual). Este es el directorio en el que te encuentras actualmente. </li>\n<li>.. (directorio anterior). Te lleva al directorio encima de tu actual.</li>\n<li>~ (directorio de inicio). Este directorio se establece por defecto en tu “directorio de inicio”. Como /home/pete.</li>\n<li>- (directorio anterior). Esto te llevará al directorio anterior en el que estabas justo antes.</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\n¡Pruébalos!",
          "quizAnswer": "cd ..",
          "quizQuestion": "Si estás en /home/pete/Pictures y quieres ir a /home/pete, ¿cuál es un buen atajo para usar?",
          "slug": "cambiardirectoriocomandocd",
          "title": "cd (Cambiar Directorio)"
        },
        {
          "exercise": "Ejecuta ls con diferentes banderas y observa la salida que recibes.",
          "id": 4,
          "lessonContent": "Ahora que sabemos cómo movernos por el sistema, ¿cómo averiguamos qué está disponible para nosotros? En este momento es como si estuviéramos moviéndonos a ciegas. Bueno, podemos usar el maravilloso comando ls para listar el contenido de directorios. El comando ls mostrará directorios y archivos en el directorio actual por defecto, sin embargo, puedes especificar la ruta de la cual deseas listar los directorios.\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nls es una herramienta bastante útil, también te muestra información detallada sobre los archivos y directorios que estás viendo.\n\nTambién ten en cuenta que no todos los archivos en un directorio serán visibles. Los nombres de archivo que comienzan con . están ocultos, sin embargo, puedes verlos con el comando ls y pasarle la bandera -a (a por todos).\n\n<pre>$ ls -a</pre>\n\nTambién hay una bandera ls más útil, -l para largo, esto muestra una lista detallada de archivos en un formato largo. Esto te mostrará información detallada, comenzando desde la izquierda: permisos de archivo, número de enlaces, nombre del propietario, grupo del propietario, tamaño del archivo, marca de tiempo de la última modificación y nombre de archivo/directorio.\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nLos comandos tienen cosas llamadas banderas (o argumentos u opciones, como quieras llamarlo) para agregar más funcionalidad. Observa cómo agregamos -a y -l, bueno, puedes agregarlos juntos con -la. El orden de las banderas determina en qué orden va, la mayoría de las veces esto no importa realmente, por lo que también puedes hacer ls -al y seguirá funcionando.\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "¿Qué comando usarías para ver archivos ocultos?",
          "slug": "listdirectorieslscommand",
          "title": "ls (Listar Directorios)"
        },
        {
          "exercise": "<ol>\n<li>Crear un nuevo archivo</li>\n<li>Tomar nota de la marca de tiempo</li>\n<li>Touchear el archivo y verificar la marca de tiempo nuevamente</li>\n</ol>",
          "id": 5,
          "lessonContent": "Aprendamos cómo crear algunos archivos. Una forma muy simple es usar el comando touch. Touch te permite crear nuevos archivos vacíos.\n\n<pre>$ touch mysuperduperfile</pre>\n\n¡Y boom, nuevo archivo! \n\nTouch también se utiliza para cambiar marcas de tiempo en archivos y directorios existentes. Pruébalo, haz un ls -l en un archivo y toma nota de la marca de tiempo, luego toca ese archivo y se actualizará la marca de tiempo. \n\nHay muchas otras formas de crear archivos que involucran otras cosas como redirección y editores de texto, pero llegaremos a eso en el curso de Manipulación de Texto.",
          "quizAnswer": "touch myfile",
          "quizQuestion": "¿Cómo se crea un archivo llamado myfile?",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "Ejecuta el comando file en varios directorios y archivos diferentes y toma nota de la salida.",
          "id": 6,
          "lessonContent": "En la lección anterior aprendimos sobre touch, volvamos a eso por un momento. ¿Notaste que el nombre de archivo no se ajustaba a la nomenclatura estándar como probablemente has visto en otros sistemas operativos como Windows? Normalmente esperarías un archivo llamado banana.jpeg y esperarías un archivo de imagen JPEG. \n\nEn Linux, los nombres de archivo no están obligados a representar el contenido del archivo. Puedes crear un archivo llamado funny.gif que en realidad no sea un GIF. \n\nPara averiguar de qué tipo de archivo se trata, puedes usar el comando file. Te mostrará una descripción del contenido del archivo.\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "¿Qué comando puedes usar para encontrar el tipo de archivo de un archivo?",
          "slug": "comandofile",
          "title": "archivo"
        },
        {
          "exercise": "Ejecuta cat en diferentes archivos y directorios. Luego intenta concatenar varios archivos.",
          "id": 7,
          "lessonContent": "Estamos casi terminando de navegar por los archivos, pero primero aprendamos cómo leer un archivo. Un comando simple para usar es el comando gato, abreviatura de concatenar, no solo muestra el contenido del archivo sino que también puede combinar varios archivos y mostrarte la salida de ellos. \n\n<pre>$ cat archivo_perro archivo_pajaro</pre>\n\nNo es ideal para ver archivos grandes y solo está pensado para contenido breve. Hay muchas otras herramientas que usamos para ver archivos de texto más grandes que discutiremos en la próxima lección.",
          "quizAnswer": "cat",
          "quizQuestion": "¿Cuál es una buena manera de ver el contenido de un archivo?",
          "slug": "comandogato",
          "title": "gato"
        },
        {
          "exercise": "Ejecuta less en un archivo, luego páginas arriba y alrededor del archivo. Intenta buscar una palabra específica. Navega rápidamente al principio o al final del archivo.",
          "id": 8,
          "lessonContent": "Si estás viendo archivos de texto más grandes que una simple salida, menos es más. (De hecho, hay un comando llamado more que hace algo similar, así que esto es irónico). El texto se muestra de forma paginada, por lo que puedes navegar a través de un archivo de texto página por página. \n\nAdelante y mira el contenido de un archivo con less. Una vez que estés en el comando less, puedes usar otros comandos de teclado para navegar en el archivo. \n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nUtiliza el siguiente comando para navegar a través de less: \n\n<ul>\n<li>q - Se utiliza para salir de less y volver a tu shell.</li>\n<li>Página arriba, Página abajo, Arriba y Abajo - Navega usando las teclas de flecha y las teclas de página.</li>\n<li>g - Se mueve al principio del archivo de texto.</li>\n<li>G - Se mueve al final del archivo de texto.</li>\n<li>/búsqueda - Puedes buscar texto específico dentro del documento de texto. Antecede las palabras que deseas buscar con /</li>\n<li>h - Si necesitas un poco de ayuda sobre cómo usar less mientras estás en less, utiliza help.</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "¿Cómo sales de un comando less?",
          "slug": "lesscommand",
          "title": "less"
        },
        {
          "exercise": "Navega a través de tu historial de comandos anteriores con las teclas de arriba y abajo. Juega con la búsqueda inversa ctrl-R.",
          "id": 9,
          "lessonContent": "En tu shell, hay un historial de los comandos que ingresaste previamente, puedes revisar estos comandos. Esto es bastante útil cuando quieres encontrar y ejecutar un comando que usaste previamente sin tener que escribirlo de nuevo.\n\n<pre>$ history</pre>\n\n¿Quieres ejecutar el mismo comando que hiciste antes? Simplemente presiona la flecha hacia arriba. \n\n¿Quieres ejecutar el comando anterior sin tener que escribirlo de nuevo? Usa !!. Si escribiste cat file1 y quieres ejecutarlo de nuevo, simplemente escribe !! y se ejecutará el último comando que ejecutaste. \n\nOtro atajo de historial es ctrl-R, este es el comando de búsqueda inversa, si presionas ctrl-R y comienzas a escribir partes del comando que deseas, te mostrará coincidencias y puedes navegar a través de ellas presionando nuevamente la tecla ctrl-R. Una vez que encuentres el comando que deseas usar nuevamente, simplemente presiona la tecla Enter.\n\n¿Nuestro terminal está un poco desordenado, verdad? Hagamos una pequeña limpieza, usa el comando clear para limpiar tu pantalla.\n\n<pre>$ clear</pre>\n\n¡Ahí, eso se ve mejor, ¿verdad? \n\nMientras hablamos de cosas útiles, una de las características más útiles en cualquier entorno de línea de comandos es la autocompletado de pestañas. Si comienzas a escribir el inicio de un comando, archivo, directorio, etc. y presionas la tecla Tab, se autocompletará según lo que encuentre en el directorio que estás buscando siempre y cuando no tengas otros archivos que comiencen con esas letras. Por ejemplo, si estabas intentando ejecutar el comando chrome, puedes escribir chr y presionar Tab y se autocompletará chrome.",
          "quizAnswer": "clear",
          "quizQuestion": "¿Cuál es el comando para limpiar el terminal?",
          "slug": "comandohistorial",
          "title": "historia"
        },
        {
          "exercise": "Copia un par de archivos, ten cuidado de no sobrescribir algo importante.",
          "id": 10,
          "lessonContent": "Comencemos haciendo algunas copias de estos archivos. Al igual que copiar y pegar archivos en otros sistemas operativos, la terminal nos ofrece una forma aún más simple de hacerlo. \n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile es el archivo que deseas copiar y /home/pete/Documents/cooldocs es a dónde estás copiando el archivo.\n\nTambién puedes copiar varios archivos y directorios, así como usar comodines. Un comodín es un carácter que puede ser sustituido por una selección basada en patrones, lo que te brinda más flexibilidad en las búsquedas. Puedes usar comodines en cada comando para mayor flexibilidad.\n\n<ul>\n<li>* el comodín de los comodines, se utiliza para representar todos los caracteres individuales o cualquier cadena.</li>\n<li>? utilizado para representar un carácter</li>\n<li>[] utilizado para representar cualquier carácter dentro de los corchetes</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nEsto copiará todos los archivos con la extensión .jpg en tu directorio actual al directorio Pictures.\n\nUn comando útil es usar la bandera -r, esto copiará de forma recursiva los archivos y directorios dentro de un directorio. \n\nIntenta hacer un cp en un directorio que contenga un par de archivos a tu directorio Documents. ¿No funcionó, verdad? Bueno, eso es porque necesitarás copiar también los archivos y directorios internos con el comando -r.\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\nUna cosa a tener en cuenta, si copias un archivo a un directorio que tiene el mismo nombre de archivo, el archivo se sobrescribirá con lo que estás copiando. Esto no es bueno si tienes un archivo que no quieres que se sobrescriba accidentalmente. Puedes usar la bandera -i (interactivo) para que te pregunte antes de sobrescribir un archivo. \n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "¿Qué bandera necesitas especificar para copiar un directorio?",
          "slug": "copycpcommand",
          "title": "cp (Copiar)"
        },
        {
          "exercise": "Renombra un archivo y luego muévelo a un directorio diferente.",
          "id": 11,
          "lessonContent": "Se utiliza para mover archivos y también renombrarlos. Bastante similar al comando cp en términos de banderas y funcionalidad. \n\nPuedes renombrar archivos de esta manera:\n\n<pre>$ mv archivo_antiguo archivo_nuevo</pre>\n\nO puedes realmente mover un archivo a un directorio diferente: \n\n<pre>$ mv archivo2 /home/pete/Documents</pre>\n\nY mover más de un archivo:\n\n<pre>$ mv archivo_1 archivo_2 /algundirectorio</pre>\n\nTambién puedes renombrar directorios:\n\n<pre>$ mv directorio1 directorio2</pre>\n\nAl igual que cp, si mueves un archivo o directorio, sobrescribirá cualquier cosa en el mismo directorio. Por lo tanto, puedes usar la bandera -i para que te pregunte antes de sobrescribir algo.\n\n<pre>mv -i directorio1 directorio2</pre>\n\nDigamos que realmente deseas mover un archivo para sobrescribir el anterior. También puedes hacer una copia de seguridad de ese archivo y simplemente renombrará la versión anterior con un ~. \n\n<pre>$ mv -b directorio1 directorio2</pre>",
          "quizAnswer": "mv gato perro",
          "quizQuestion": "¿Cómo se renombra un archivo llamado gato a perro?",
          "slug": "comandomvmover",
          "title": "mv (Mover)"
        },
        {
          "exercise": "Crea un par de directorios y mueve algunos archivos a ese directorio.",
          "id": 12,
          "lessonContent": "Vamos a necesitar algunos directorios para almacenar todos estos archivos en los que hemos estado trabajando. El comando mkdir (Make Directory) es útil para eso, creará un directorio si aún no existe. Incluso puedes crear varios directorios al mismo tiempo.\n\n<pre>$ mkdir books paintings</pre>\n\nTambién puedes crear subdirectorios al mismo tiempo con la bandera -p (padre).\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "¿Qué comando se utiliza para crear un directorio?",
          "slug": "makedirectorymkdircommand",
          "title": "mkdir (Crear directorio)"
        },
        {
          "exercise": "<ol>\n<li>Crea un archivo llamado -archivo (¡no olvides el guion!).</li>\n<li>Elimina ese archivo.</li>\n</ol>",
          "id": 13,
          "lessonContent": "Ahora creo que tenemos demasiados archivos, vamos a eliminar algunos archivos. Para eliminar archivos, puedes usar el comando rm. El comando rm (remove) se utiliza para borrar archivos y directorios. \n\n<pre>$ rm archivo1</pre>\n\nTen cuidado al usar rm, no hay una papelera mágica de la que puedas recuperar los archivos eliminados. Una vez que se han ido, se han ido para siempre, así que ten cuidado. \n\nAfortunadamente, se han implementado algunas medidas de seguridad, por lo que el usuario común no puede simplemente eliminar un montón de archivos importantes. Los archivos protegidos contra escritura te pedirán confirmación antes de eliminarlos. Si un directorio está protegido contra escritura, tampoco se eliminará fácilmente. \n\nAhora, si no te importa nada de eso, puedes eliminar absolutamente un montón de archivos. \n\n<pre>$ rm -f archivo1</pre>\n\nLa opción -f o force le indica a rm que elimine todos los archivos, ya estén protegidos contra escritura o no, sin pedirle confirmación al usuario (siempre que tengas los permisos adecuados).\n\n<pre>$ rm -i archivo</pre>\n\nAgregar la bandera -i como muchos de los otros comandos, te dará un aviso sobre si realmente deseas eliminar los archivos o directorios. \n\n<pre>$ rm -r directorio</pre>\n\nNo puedes simplemente usar rm en un directorio por defecto, necesitarás agregar la bandera -r (recursivo) para eliminar todos los archivos y cualquier subdirectorio que pueda tener.\n\nPuedes eliminar un directorio con el comando rmdir.\n\n<pre>$ rmdir directorio</pre>",
          "quizAnswer": "",
          "quizQuestion": "¿Cómo eliminas un archivo llamado myfile?",
          "slug": "removermcommand",
          "title": "rm (Eliminar)"
        },
        {
          "exercise": "<ol>\n<li>Encuentra un archivo desde el directorio raíz que tenga la palabra net en él.</li>\n</ol>",
          "id": 14,
          "lessonContent": "Con todos estos archivos que tenemos en el sistema, puede ser un poco agitado tratar de encontrar uno específico. Bueno, ¡hay un comando que podemos usar para eso, find! \n\n<pre>$ find /home -name puppies.jpg</pre>\n\nCon find tendrás que especificar el directorio en el que buscarás, lo que estás buscando, en este caso estamos tratando de encontrar un archivo con el nombre puppies.jpg. \n\nPuedes especificar qué tipo de archivo estás tratando de encontrar. \n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nPuedes ver que establecí el tipo de archivo que estoy tratando de encontrar como (d) para directorio y aún estoy buscando por el nombre de MyFolder. \n\nUna cosa genial a tener en cuenta es que find no se detiene en el directorio que estás buscando, también buscará dentro de cualquier subdirectorio que ese directorio pueda tener.",
          "quizAnswer": "-name",
          "quizQuestion": "¿Qué opción debo especificar para find si quiero buscar por nombre?",
          "slug": "findcommand",
          "title": "find"
        },
        {
          "exercise": "Ejecuta ayuda en el comando echo, comando logout y comando pwd.",
          "id": 15,
          "lessonContent": "Linux tiene algunas herramientas integradas excelentes para ayudarte a aprender cómo usar un comando o verificar qué banderas están disponibles para un comando. Una herramienta, ayuda, es un comando bash integrado que proporciona ayuda para otros comandos bash (echo, logout, pwd, etc).\n\n<pre>$ ayuda echo</pre>\n\nEsto te dará una descripción y las opciones que puedes usar cuando quieras ejecutar echo. Para otros programas ejecutables, es una convención tener una opción llamada --help o algo similar. \n\n<pre>$ echo --help</pre>\n\nNo todos los desarrolladores que distribuyen ejecutables se ajustarán a este estándar, pero probablemente sea tu mejor opción para encontrar algo de ayuda sobre un programa.",
          "quizAnswer": "ayuda",
          "quizQuestion": "¿Cómo obtienes ayuda rápida en la línea de comandos para los comandos bash integrados?",
          "slug": "comandoayuda",
          "title": "ayuda"
        },
        {
          "exercise": "Ejecuta el comando man en el comando ls.",
          "id": 16,
          "lessonContent": "Vaya, desearía que algunos de estos programas tuvieran un manual para que pudiéramos ver más información sobre ellos. ¡Pues afortunadamente lo tienen! Llamadas páginas de manual, puedes ver los manuales de un comando con el comando man. \n\n<pre>$ man ls</pre>\n\nLas páginas de manual son manuales que vienen incorporados por defecto en la mayoría de los sistemas operativos Linux. Proporcionan documentación sobre comandos y otros aspectos del sistema. \n\nPruébalo en algunos comandos para obtener más información sobre ellos.",
          "quizAnswer": "man",
          "quizQuestion": "¿Cómo se ven los manuales de un comando?",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Ejecuta el comando whatis en el comando less.",
          "id": 17,
          "lessonContent": "¡Uf, hemos aprendido bastantes comandos hasta ahora! Si alguna vez tienes dudas sobre lo que hace un comando, puedes usar el comando whatis. El comando whatis proporciona una breve descripción de los programas de línea de comandos. \n\n<pre>$ whatis cat</pre>\n\nLa descripción se obtiene de la página del manual de cada comando. Si ejecutaras whatis cat, verías que hay un pequeño párrafo con una breve descripción.",
          "quizAnswer": "whatis",
          "quizQuestion": "¿Qué comando puedes usar para ver una breve descripción de un comando?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "Crea un par de alias y luego elimínalos.",
          "id": 18,
          "lessonContent": "A veces escribir comandos puede volverse realmente repetitivo, o si necesitas escribir un comando largo muchas veces, es mejor tener un alias que puedas usar para eso. Para crear un alias para un comando, simplemente especificas un nombre de alias y lo asignas al comando. \n\n<pre>$ alias foobar='ls -la'</pre>\n\nAhora, en lugar de escribir ls -la, puedes escribir foobar y ejecutará ese comando, cosas bastante interesantes. Ten en cuenta que este comando no guardará tu alias después de reiniciar, por lo que necesitarás agregar un alias permanente en:\n\n<pre>~/.bashrc</pre>\n\nu otros archivos similares si deseas que persista después de reiniciar.\n\nPuedes eliminar alias con el comando unalias: \n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "¿Qué comando se utiliza para crear un alias?",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "Sal del shell y observa qué sucede. Asegúrate de que no necesitas hacer más trabajo en ese shell.",
          "id": 19,
          "lessonContent": "Buen trabajo llegando a través de los conceptos básicos. Apenas hemos arañado la superficie, ahora que has aprendido a gatear, en el próximo conjunto de cursos, te enseñaré a caminar. \n\nPor ahora, puedes darte palmaditas en la espalda y tomar un descanso. Para salir del shell, puedes usar el comando exit\n\n<pre>$ exit</pre>\n\nO el comando logout:\n\n<pre>$ logout</pre>\n\nO si estás trabajando en una interfaz gráfica de usuario de terminal, simplemente puedes cerrar el terminal, ¡nos vemos en el próximo curso!",
          "quizAnswer": "exit",
          "quizQuestion": "¿Cómo puedes salir del shell?",
          "slug": "comandoexit",
          "title": "salida"
        }
      ],
      "slug": "commandline",
      "title": "Línea de Comando"
    },
    {
      "description": "Aprende manipulación básica de texto y navegación.",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "Intenta un par de comandos: \n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hello World > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "Hasta ahora, nos hemos familiarizado con muchos comandos y su salida, lo que nos lleva a nuestro próximo tema: flujos de E/S (entrada/salida). Ejecutemos el siguiente comando y discutiremos cómo funciona. \n\n<pre>$ echo Hello World > peanuts.txt</pre>\n\n¿Qué acaba de suceder? Bueno, verifica el directorio donde ejecutaste ese comando y verás un archivo llamado peanuts.txt, ábrelo y deberías ver el texto Hello World. Muchas cosas acaban de suceder en un solo comando, así que vamos a analizarlo. \n\nPrimero desglosemos la primera parte: \n\n<pre>$ echo Hello World</pre>\n\nSabemos que esto imprime Hello World en la pantalla, pero ¿cómo? Los procesos utilizan flujos de E/S para recibir entrada y devolver salida. Por defecto, el comando echo toma la entrada (entrada estándar o stdin) del teclado y devuelve la salida (salida estándar o stdout) a la pantalla. Por eso, cuando escribes echo Hello World en tu terminal, obtienes Hello World en la pantalla. Sin embargo, la redirección de E/S nos permite cambiar este comportamiento predeterminado y nos brinda una mayor flexibilidad con los archivos. \n\nPasemos a la siguiente parte del comando: \n\n<pre> > </pre>\n\nEl > es un operador de redirección que nos permite cambiar a dónde va la salida estándar. Nos permite enviar la salida de echo Hello World a un archivo en lugar de a la pantalla. Si el archivo aún no existe, lo creará para nosotros. Sin embargo, si ya existe, lo sobrescribirá (puedes agregar una bandera de terminal para evitar esto dependiendo del shell que estés utilizando).\n\n¡Y básicamente así es como funciona la redirección de stdout!\n\nBueno, digamos que no quiero sobrescribir mi peanuts.txt, afortunadamente también hay un operador de redirección para eso, >>: \n\n<pre>$ echo Hello World >> peanuts.txt</pre>\n\nEsto añadirá Hello World al final del archivo peanuts.txt, si el archivo aún no existe, lo creará para nosotros, como lo hizo con el operador de redirección >!",
          "quizAnswer": ">>",
          "quizQuestion": "¿Qué operador de redirección utilizas para añadir la salida a un archivo?",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "Prueba un par de comandos:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "En nuestra lección anterior aprendimos que tenemos diferentes flujos de salida stdout que podemos usar, como un archivo o la pantalla. Bueno, también hay diferentes flujos de entrada estándar (stdin) que podemos usar. Sabemos que tenemos stdin de dispositivos como el teclado, pero también podemos usar archivos, la salida de otros procesos y el terminal, veamos un ejemplo. \n\nUsemos el archivo peanuts.txt en la lección anterior para este ejemplo, recuerda que tenía el texto Hola Mundo en él. \n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nAsí como teníamos <b>&gt;</b> para la redirección de stdout, podemos usar <b>&lt;</b> para la redirección de stdin. \n\nNormalmente en el comando cat, envías un archivo y ese archivo se convierte en stdin, en este caso, redirigimos peanuts.txt para que sea nuestro stdin. Luego, la salida de cat peanuts.txt que sería Hola Mundo se redirige a otro archivo llamado banana.txt.",
          "quizAnswer": "<",
          "quizQuestion": "¿Qué redireccionador utilizas para redirigir stdin?",
          "slug": "stdinstandardinredirect",
          "title": "stdin (Entrada estándar)"
        },
        {
          "exercise": "¿Qué está haciendo el siguiente comando? \n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "Intentemos algo un poco diferente ahora, intentemos listar el contenido de un directorio que no existe en tu sistema y redirigir la salida al archivo peanuts.txt nuevamente.\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\nLo que deberías ver es: \n\n<pre>ls: no se puede acceder a /fake/directory: No existe el archivo o directorio</pre>\n\nAhora probablemente estés pensando, ¿no debería ese mensaje haber sido enviado al archivo? En realidad, hay otro flujo de E/S en juego aquí llamado error estándar (stderr). Por defecto, stderr envía su salida también a la pantalla, es un flujo completamente diferente que stdout. Así que necesitarás redirigir su salida de una manera diferente. \n\nDesafortunadamente, el redireccionador no es tan agradable como usar <b>&lt;</b> o <b>&gt;</b> pero es bastante cercano. Tendremos que usar descriptores de archivo. Un descriptor de archivo es un número no negativo que se utiliza para acceder a un archivo o flujo. Profundizaremos en esto más adelante, pero por ahora debes saber que el descriptor de archivo para stdin, stdout y stderr es 0, 1 y 2 respectivamente. \n\nEntonces, si queremos redirigir nuestro stderr al archivo podemos hacer esto: \n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\nDeberías ver solo los mensajes de stderr en peanuts.txt. \n\n¿Y si quisiera ver tanto stderr como stdout en el archivo peanuts.txt? Es posible hacer esto también con descriptores de archivo: \n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nEsto envía los resultados de ls /fake/directory al archivo peanuts.txt y luego redirige stderr a stdout a través de 2>&1. El orden de las operaciones aquí importa, 2>&1 envía stderr a donde stdout está apuntando. En este caso, stdout está apuntando a un archivo, por lo que 2>&1 también envía stderr a un archivo. Así que si abres ese archivo peanuts.txt deberías ver tanto stderr como stdout. En nuestro caso, el comando anterior solo muestra stderr.\n\nHay una forma más corta de redirigir tanto stdout como stderr a un archivo:\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\n¿Y si no quiero nada de eso y quiero deshacerme por completo de los mensajes de stderr? Bueno, también puedes redirigir la salida a un archivo especial llamado /dev/null y descartará cualquier entrada.\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "¿Cuál es el redireccionador para stderr?",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Error Estándar)"
        },
        {
          "exercise": "Intenta los siguientes comandos: \n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "Vamos a adentrarnos un poco en la fontanería ahora, no realmente pero más o menos. Vamos a probar un comando: \n\n<pre>$ ls -la /etc</pre>\n\nDeberías ver una lista muy larga de elementos, en realidad es un poco difícil de leer. En lugar de redirigir esta salida a un archivo, ¿no sería agradable si pudiéramos ver la salida en otro comando como less? ¡Bueno, podemos hacerlo!\n\n<pre>$ ls -la /etc | less </pre>\n\nEl operador de tubería |, representado por una barra vertical, nos permite obtener la salida estándar de un comando y hacerla la entrada estándar de otro proceso. En este caso, tomamos la salida estándar de ls -la /etc y luego la <i>tuberizamos</i> al comando less. El comando de tubería es extremadamente útil y seguiremos usándolo por toda la eternidad. \n\n¿Y si quisiera escribir la salida de mi comando en dos flujos diferentes? Eso es posible con el comando tee: \n\n<pre>$ ls | tee peanuts.txt</pre>\n\nDeberías ver la salida de ls en tu pantalla y si abres el archivo peanuts.txt deberías ver la misma información!",
          "quizAnswer": "|",
          "quizQuestion": "¿Qué tecla representa el operador de tubería?",
          "slug": "pipeteeredirect",
          "title": "tubería y tee"
        },
        {
          "exercise": "¿Qué muestra la siguiente salida? ¿Por qué?\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "Ejecuta el siguiente comando: \n\n<pre>$ echo $HOME</pre>\n\nDeberías ver la ruta de tu directorio de inicio, la mía se ve así: /home/pete. \n\n¿Qué pasa con este comando? \n\n<pre>$ echo $USER </pre>\n\n¡Deberías ver tu nombre de usuario!\n\n¿De dónde provienen esta información? Proviene de tus variables de entorno. Puedes verlas escribiendo\n\n<pre>$ env </pre>\n\nEsto muestra una gran cantidad de información sobre las variables de entorno que tienes actualmente configuradas. Estas variables contienen información útil que el shell y otros procesos pueden utilizar.\n\nAquí tienes un ejemplo corto:\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\nUna variable particularmente importante es la Variable PATH. Puedes acceder a estas variables colocando un $ delante del nombre de la variable de la siguiente manera:\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nEsto devuelve una lista de rutas separadas por dos puntos que tu sistema busca cuando ejecuta un comando. Digamos que descargas e instalas manualmente un paquete de internet y lo colocas en un directorio no estándar y quieres ejecutar ese comando, escribes $ coolcommand y el indicador dice comando no encontrado. Bueno, es absurdo, estás viendo el binario en una carpeta y sabes que existe. Lo que sucede es que la variable $PATH no verifica ese directorio para este binario, por lo que arroja un error. \n\nDigamos que tienes un montón de binarios que deseas ejecutar desde ese directorio, simplemente puedes modificar la variable PATH para incluir ese directorio en tu variable de entorno PATH.",
          "quizAnswer": "env",
          "quizQuestion": "¿Cómo ves tus variables de entorno?",
          "slug": "envenvironment",
          "title": "env (Entorno)"
        },
        {
          "exercise": "¿Qué hace el siguiente comando? ¿Por qué?\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "Vamos a aprender un par de comandos útiles que puedes usar para procesar texto. Antes de comenzar, creemos un archivo con el que trabajaremos. Copia y pega el siguiente comando, una vez que lo hagas agrega un TAB entre lazy y dog (mantén presionado Ctrl-v + TAB).\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\nEl primer comando que aprenderemos es el comando cut. Extrae porciones de texto de un archivo. \n\nPara extraer contenidos por una lista de caracteres: \n\n<pre>$ cut -c 5 sample.txt</pre>\n\nEsto muestra el quinto carácter en cada línea del archivo. En este caso es \"q\", ten en cuenta que el espacio también cuenta como un carácter. \n\nPara extraer los contenidos por un campo, necesitaremos hacer una pequeña modificación: \n\n<pre>$ cut -f 2 sample.txt</pre>\n\nLa bandera -f o de campo corta el texto basado en campos, por defecto utiliza los TAB como delimitadores, por lo que todo separado por un TAB se considera un campo. Deberías ver \"dog\" como tu salida.\n\nPuedes combinar la bandera de campo con la bandera de delimitador para extraer los contenidos por un delimitador personalizado: \n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nEsto cambiará el delimitador de TAB a un delimitador \";\" y como estamos cortando el primer campo, el resultado debería ser \"The quick brown\".",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "¿Qué comando usarías para obtener el primer carácter de cada línea en un archivo?",
          "slug": "comandocut",
          "title": "cortar"
        },
        {
          "exercise": "Intenta pegar varios archivos juntos, ¿qué sucede?",
          "id": 7,
          "lessonContent": "El comando pegar es similar al comando cat, fusiona líneas juntas en un archivo. Creemos un nuevo archivo con el siguiente contenido: \n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nVamos a combinar todas estas líneas en una línea: \n\n<pre>$ pegar -s sample2.txt</pre>\n\nEl delimitador predeterminado para pegar es TAB, por lo que ahora hay una línea con TABs separando cada palabra.\n\nCambiamos este delimitador (-d) a algo un poco más legible: \n\n<pre>$ pegar -d ' ' -s sample2.txt</pre>\n\nAhora todo debería estar en una línea delimitada por espacios.",
          "quizAnswer": "-s",
          "quizQuestion": "¿Qué bandera usas con pegar para que todo vaya en una línea?",
          "slug": "comandopegar",
          "title": "pegar"
        },
        {
          "exercise": "¿Qué hace el siguiente comando y por qué? \n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "Imaginemos que tenemos un archivo muy largo, de hecho tenemos muchos para elegir, adelante y cat /var/log/syslog. Deberías ver páginas y páginas de texto. ¿Qué pasa si solo quiero ver las primeras líneas de este archivo de texto? Bueno, podemos hacer eso con el comando head, por defecto el comando head te mostrará las primeras 10 líneas de un archivo.\n\n<pre>$ head /var/log/syslog</pre>\n\nTambién puedes modificar el recuento de líneas a lo que elijas, digamos que quiero ver las primeras 15 líneas en su lugar. \n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\nLa bandera -n significa número de líneas.",
          "quizAnswer": "-n",
          "quizQuestion": "¿Qué bandera usarías para cambiar el número de líneas que deseas ver para el comando head?",
          "slug": "headcommand",
          "title": "head"
        },
        {
          "exercise": "Mira la página del manual de tail y lee algunos de los otros comandos que no discutimos. \n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "Similar al comando head, el comando tail te permite ver las últimas 10 líneas de un archivo de forma predeterminada.\n\n<pre>$ tail /var/log/syslog</pre>\n\nJunto con head, puedes cambiar el número de líneas que deseas ver.\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nOtra gran opción que puedes usar es el indicador -f (seguir), esto seguirá el archivo a medida que crece. Pruébalo y mira qué sucede. \n\n<pre>$ tail -f /var/log/syslog</pre> \n\nTu archivo syslog cambiará continuamente mientras interactúas con tu sistema y usando tail -f puedes ver todo lo que se agrega a ese archivo.",
          "quizAnswer": "-f",
          "quizQuestion": "¿Cuál es el indicador utilizado para seguir un archivo en tail?",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "¿Qué sucede si simplemente escribes expandir sin entrada de archivo?",
          "id": 10,
          "lessonContent": "En nuestra lección sobre el comando cut, teníamos nuestro archivo sample.txt que contenía una tabulación. Normalmente, las TABs suelen mostrar una diferencia notable, pero algunos archivos de texto no muestran eso lo suficientemente bien. Tener TABs en un archivo de texto puede que no sea el espaciado deseado que deseas. Para cambiar tus TABs a espacios, utiliza el comando expandir. \n\n<pre>$ expandir sample.txt</pre>\n\nEl comando anterior imprimirá la salida con cada TAB convertida en un grupo de espacios. Para guardar esta salida en un archivo, utiliza la redirección de salida como se muestra a continuación.\n\n<pre>$ expandir sample.txt > resultado.txt</pre>\n\nContrario a expandir, podemos convertir de vuelta cada grupo de espacios a una TAB con el comando contraer: \n\n<pre>$ contraer -a resultado.txt</pre>",
          "quizAnswer": "expandir",
          "quizQuestion": "¿Qué comando se utiliza para convertir TABs en espacios?",
          "slug": "comandoexpandircontraer",
          "title": "expandir y contraer"
        },
        {
          "exercise": "¿Qué sucede al unir dos archivos con un número diferente de líneas en cada archivo?",
          "id": 11,
          "lessonContent": "El comando join te permite unir varios archivos por un campo común: \n\nDigamos que tengo dos archivos que quiero unir:\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n¿Ves cómo unió mis archivos? Se unen por defecto a través del primer campo y los campos deben ser idénticos, si no lo son, puedes ordenarlos, así que en este caso los archivos se unen a través de 1, 2, 3. \n\n¿Cómo uniríamos los siguientes archivos? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nPara unir este archivo necesitas especificar qué campos estás uniendo, en este caso queremos el campo 2 de file1.txt y el campo 1 de file2.txt, por lo que el comando se vería así:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 se refiere a file1.txt y -2 se refiere a file2.txt. Bastante genial. También puedes dividir un archivo en diferentes archivos con el comando split: \n\n<pre>$ split somefile</pre>\n\nEsto lo dividirá en diferentes archivos, por defecto los dividirá una vez que alcancen un límite de 1000 líneas. Los archivos se nombran x** por defecto.",
          "quizAnswer": "join gato perro vaca",
          "quizQuestion": "¿Qué comando usarías para unir los archivos llamados gato perro vaca?",
          "slug": "comandounirdividir",
          "title": "unir y dividir"
        },
        {
          "exercise": "El verdadero poder de sort radica en su capacidad para combinarse con otros comandos, prueba el siguiente comando y observa qué sucede?\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "El comando sort es útil para ordenar líneas.\n\n<pre>\nfile1.txt\nperro\nvaca\ngato\nelefante\npájaro\n\n$ sort file1.txt\npájaro\ngato\nvaca\nperro\nelefante\n</pre>\n\nTambién puedes hacer una ordenación inversa: \n\n<pre>$ sort -r file1.txt\nelefante\nperro\nvaca\ngato\npájaro\n</pre>\n\nY también ordenar por valor numérico: \n\n<pre>$ sort -n file1.txt\npájaro\ngato\nvaca\nelefante\nperro\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "¿Qué bandera utilizas para hacer una ordenación inversa?",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "Prueba el siguiente comando, ¿qué sucede? \n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "El comando tr (traducir) te permite traducir un conjunto de caracteres a otro conjunto de caracteres. Intentemos un ejemplo de traducir todos los caracteres en minúsculas a caracteres en mayúsculas. \n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\nComo puedes ver, hicimos que los rangos de a-z se convirtieran en A-Z y todo el texto que escribimos en minúsculas se convierte en mayúsculas.",
          "quizAnswer": "tr",
          "quizQuestion": "¿Qué comando se utiliza para traducir caracteres?",
          "slug": "trtranslatecommand",
          "title": "tr (Traducir)"
        },
        {
          "exercise": "¿Qué resultado obtendrías si intentaras uniq -uc?",
          "id": 14,
          "lessonContent": "El comando uniq (único) es otra herramienta útil para analizar texto.\n\nDigamos que tenías un archivo con muchas duplicaciones:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nY querías eliminar las duplicaciones, puedes usar el comando uniq:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\nObtengamos el conteo de cuántas veces aparece una línea:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nObtengamos solo los valores únicos:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\nObtengamos solo los valores duplicados:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>Nota</b>: uniq no detecta líneas duplicadas a menos que estén adyacentes. Por ejemplo:\n\nDigamos que tenías un archivo con duplicados que no son adyacentes:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nEl resultado devuelto por uniq contendrá todas las entradas a diferencia del primer ejemplo.\n\nPara superar esta limitación de uniq, podemos usar sort en combinación con uniq:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "¿Qué comando usarías para eliminar duplicados en un archivo?",
          "slug": "uniquniquecommand",
          "title": "uniq (Único)"
        },
        {
          "exercise": "¿Cómo obtendrías el recuento total de líneas usando el archivo nl sin buscar a través de toda la salida? Pista: Utiliza algunos de los otros comandos que aprendiste en este curso.",
          "id": 15,
          "lessonContent": "El comando wc (word count) muestra el recuento total de palabras en un archivo. \n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nMuestra el número de líneas, número de palabras y número de bytes, respectivamente.\n\nPara ver solo el recuento de un campo específico, use -l, -w o -c respectivamente. \n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nOtro comando que puedes usar para verificar el recuento de líneas en un archivo es el comando nl (number lines). \n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "¿Qué comando usarías para obtener el número total de palabras en un archivo y solo las palabras?",
          "slug": "nlwccommand",
          "title": "wc and nl"
        },
        {
          "exercise": "Puede que hayas oído hablar de egrep o fgrep, estos son llamadas de grep obsoletas y han sido reemplazadas por grep -E y grep -F. Lee la página de manual de grep para aprender más.",
          "id": 16,
          "lessonContent": "El comando grep es posiblemente el comando de procesamiento de texto más común que utilizarás. Te permite buscar archivos en busca de caracteres que coincidan con un cierto patrón. ¿Qué pasaría si quisieras saber si un archivo existe en un directorio determinado o si quisieras ver si se encontraba una cadena en un archivo? Seguramente no revisarías cada línea de texto, ¡usarías grep!\n\nVeamos nuestro archivo sample.txt como ejemplo: \n\n<pre>$ grep zorro sample.txt</pre>\n\nDeberías ver que grep encontró zorro en el archivo sample.txt. \n\nTambién puedes buscar patrones que no distingan entre mayúsculas y minúsculas con la bandera -i: \n\n<pre>$ grep -i algunpatron algunarchivo</pre>\n\nPara ser aún más flexible con grep, puedes combinarlo con otros comandos con |.\n\n<pre>$ env | grep -i Usuario</pre>\n\nComo puedes ver, grep es bastante versátil. Incluso puedes usar expresiones regulares en tu patrón: \n\n<pre>$ ls /algundir | grep '.txt$'</pre>\n\nDebería devolver todos los archivos que terminan con .txt en algundir.",
          "quizAnswer": "grep",
          "quizQuestion": "¿Qué comando utilizas para encontrar un cierto patrón?",
          "slug": "comandogrep",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "Navega por el texto como un mono araña de Linux con vim y emacs.",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "Intenta combinar expresiones regulares con grep y buscar a través de algunos archivos.\n\n<pre>\ngrep [expresión regular aquí] [archivo]",
          "id": 1,
          "lessonContent": "Las expresiones regulares son una herramienta poderosa para hacer selección basada en patrones. Utiliza notaciones especiales similares a las que ya hemos encontrado, como el comodín *. \n\nRepasaremos un par de las expresiones regulares más comunes, estas son casi universales en cualquier lenguaje de programación.\n\nUsaremos esta frase como nuestra cadena de prueba:\n<pre>\nsally vende conchas \nen la orilla del mar\n</pre>\n\n<b>1. Inicio de una línea con ^</b>\n\n<pre>\n<b>^</b>en\ncoincidiría con la línea \"en la orilla del mar\"\n</pre>\n\n<b>2. Fin de una línea con $</b>\n\n<pre>\nmar<b>$</b>\ncoincidiría con la línea \"en la orilla del mar\"\n</pre>\n\n<b>3. Coincidir con cualquier carácter individual con .</b>\n\n<pre>\nc<b>.</b>\ncoincidiría con con\n</pre>\n\n<b>4. Notación de corchetes con [] y ()</b>\n\nEsto puede ser un poco complicado, los corchetes nos permiten especificar los caracteres encontrados dentro del corchete. \n\n<pre>\nc<b>[aei]</b>l\ncoincidiría con: cal, cel, cil\n</pre>\n\nLa etiqueta de anclaje anterior ^ cuando se usa en un corchete significa cualquier cosa excepto los caracteres dentro del corchete. \n\n<pre>\nc<b>[^a]</b>l\ncoincidiría con: cel y cil pero no cal\n</pre>\n\nLos corchetes también pueden usar rangos para aumentar la cantidad de caracteres que deseas usar. \n\n<pre>\nc<b>[a-c]</b>l\ncoincidirá con patrones como cal, cbl y ccl\n</pre>\n\nTen cuidado, ya que los corchetes distinguen entre mayúsculas y minúsculas:\n\n<pre>\nc<b>[A-C]</b>l\ncoincidirá con cAl, cBl y cCl pero no cal, cbl y ccl\n</pre>\n\nY esas son algunas expresiones regulares básicas.",
          "quizAnswer": ".",
          "quizQuestion": "¿Qué expresión regular usarías para coincidir con un solo carácter?",
          "slug": "expresionesregularesregex",
          "title": "regex (Expresiones Regulares)"
        },
        {
          "exercise": "Haz un pequeño recorrido por vim y emacs:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "Si reúnes a un par de usuarios acérrimos de Linux en una habitación y les preguntas cuál es el mejor editor de texto para usar, escucharás un interminable debate sobre la divinidad de vim o emacs. Ni siquiera intentes mencionar el uso de un editor GUI si valoras tu vida. \n\nVim y emacs son editores de texto populares que vienen instalados por defecto en la mayoría de las distribuciones de Linux y ambos tienen sus pros y sus contras. Si quieres manejarte en tu sistema como un ninja, necesitarás elegir uno de estos editores de texto para usar. Básicamente son editores que sirven para programar, procesar documentos de texto y en general son todo en uno.",
          "quizAnswer": "",
          "quizQuestion": "¡Sin preguntas, sigue adelante!",
          "slug": "editorestextovimoremacs",
          "title": "Editores de texto"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "Vim significa vi (Mejorado) tal como su nombre lo indica, es una versión mejorada del comando del editor de texto vi.\n\nEs muy ligero, abrir y editar un archivo con vim es rápido y fácil. Además, casi siempre está disponible, si inicias una distribución de Linux al azar, es probable que vim esté instalado por defecto. \n\nPara iniciar vim solo escribe: <pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "¡No hay preguntas, sigue adelante!",
          "slug": "editorvimtexto",
          "title": "Vim (Vi Mejorado)"
        },
        {
          "exercise": "¡Juega con la tecla de búsqueda, abre un archivo de texto en vim con: vim [archivo de texto] y comienza a buscar!",
          "id": 4,
          "lessonContent": "Para buscar una expresión, simplemente escribe la tecla / y luego tu resultado de búsqueda mientras estás en una sesión de vim. Una vez que presionas enter, puedes presionar \"n\" para avanzar o \"N\" para retroceder en tus resultados de búsqueda.\n\n<pre>\nMi archivo bonito es muy bonito.\n\n/bonito\n\nencontrará las palabras bonitas en el archivo de texto.\n</pre>\n\n\nEl comando de búsqueda ? buscará el archivo de texto hacia atrás, por lo que en el ejemplo anterior, la última palabra bonita aparecería primero. \n<pre>\nMi archivo bonito es muy bonito.\n\n?bonito\n\nencontrará las palabras bonitas en el archivo de texto.\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "¿Qué tecla se utiliza para buscar en vim?",
          "slug": "patronesbusquedavim",
          "title": "Patrones de búsqueda en Vim"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Ahora puedes notar que el mouse no se utiliza aquí. Para navegar por un documento de texto en vim, utiliza las siguientes teclas: \n\n<ul>\n<li>h o la flecha izquierda - te moverá a la izquierda un carácter</li>\n<li>k o la flecha arriba - te moverá hacia arriba una línea</li>\n<li>j o la flecha abajo - te moverá hacia abajo una línea</li>\n<li>l o la flecha derecha - te moverá a la derecha un carácter</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "¿Qué letra se utiliza para moverse hacia abajo?",
          "slug": "vimnavigation",
          "title": "Navegación en Vim"
        },
        {
          "exercise": "Juega con entrar y salir del modo inserción.",
          "id": 6,
          "lessonContent": "<p>Ahora puede haber notado que si intentaba escribir algo, no podría hacerlo. Eso se debe a que está en modo comando. Esto puede ser bastante confuso, especialmente si solo desea abrir un archivo e ingresar texto. El modo comando se utiliza cuando se ingresan comandos como h, j, k, l, etc. Para insertar texto, primero deberá ingresar al modo inserción.</p><p></p><ul><br><li>i - insertar texto antes del cursor</li><br><li>O - insertar texto en la línea anterior</li><br><li>o - insertar texto en la línea siguiente</li><br><li>a - añadir texto después del cursor</li><br><li>A - añadir texto al final de la línea</li><br></ul><p></p><p>Observe cómo al escribir cualquiera de estos modos de inserción, verá que Vim ha ingresado al modo inserción en la parte inferior de la terminal. Para salir del modo inserción y volver al modo comando, simplemente presione la tecla Esc.</p>",
          "quizAnswer": "i",
          "quizQuestion": "¿Qué tecla se utiliza para insertar texto antes del cursor?",
          "slug": "viminsertingappendingtext",
          "title": "Añadiendo texto en Vim"
        },
        {
          "exercise": "Sé que esta lección añadió algunas rarezas, abre un editor de texto y juega con estos comandos.",
          "id": 7,
          "lessonContent": "Ahora que tenemos un par de líneas escritas, editémoslas un poco más y eliminemos algo de desorden.<br><p></p><ul><br><li>x - se utiliza para cortar el texto seleccionado y también para eliminar caracteres</li><br><li>dd - se utiliza para eliminar la línea actual</li><br><li>y - copiar lo que sea seleccionado</li><br><li>yy - copiar la línea actual</li><br><li>p - pegar el texto copiado antes del cursor</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "¿Qué caracter se utiliza para eliminar una línea entera?",
          "slug": "edicionenvim",
          "title": "Edición en Vim"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 8,
          "lessonContent": "Ahora que has terminado de editar, es hora de guardar y salir de vim: \n\n<ul>\n<li>:w - escribe o guarda el archivo</li>\n<li>:q - salir de vim</li>\n<li>:wq - escribir y luego salir</li>\n<li>:q! - salir de vim sin guardar el archivo</li>\n<li>ZZ - equivalente a :wq, pero un carácter más rápido</li>\n\n<li>u - deshacer tu última acción</li>\n<li>Ctrl-r - rehacer tu última acción</li>\n</ul>\n\nPuede que no pienses que ZZ sea necesario, pero eventualmente verás que tus dedos tienden a inclinarse hacia esto en lugar de :wq.\n\nUf, esa fue mucha información sobre Vim. Ahora que conoces algunos comandos básicos y la navegación, puedes comenzar a editar algunos archivos de texto. Hay muchas más opciones que puedes usar en vim para mejorar tu capacidad de dominar este editor de texto, dirígete a la guía en línea de Vim para echar un vistazo.",
          "quizAnswer": ":q!",
          "quizQuestion": "¿Cómo sales de vim sin guardar?",
          "slug": "guardadoysalidaenvim",
          "title": "Guardado y salida en Vim"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 9,
          "lessonContent": "Emacs es para usuarios que desean un editor de texto extremadamente potente, lo cual puede ser una subestimación porque básicamente vives en emacs. Puedes realizar toda tu edición de código, manipulación de archivos, etc., todo dentro de emacs. Es un poco más lento para cargar y la curva de aprendizaje es un poco más pronunciada que la de vim, pero si deseas un editor potente que sea extremadamente extensible, este es el adecuado para ti. Cuando digo extensible, literalmente me refiero a que puedes escribir scripts para emacs que amplíen su funcionalidad.\n\nPara iniciar emacs simplemente usa:\n\n<pre>emacs</pre>\n\nDeberías ser recibido con el buffer de bienvenida predeterminado.\n\nEn emacs, los buffers son donde reside tu texto. Por lo tanto, si abres un archivo, se utiliza un buffer para almacenar el contenido de ese archivo. Puedes tener varios buffers abiertos al mismo tiempo y puedes cambiar fácilmente entre buffers.",
          "quizAnswer": "",
          "quizQuestion": "¡No hay preguntas, sigue adelante!",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "Juega con la apertura y el guardado de archivos.",
          "id": 10,
          "lessonContent": "En mucha (si no toda) la documentación de Emacs, verás la sintaxis C-[letra]. Esto simplemente significa presionar Ctrl-letra, pero para abreviar, llamaremos a Ctrl con C. Si ves sintaxis como M-[letra], eso significa usar la tecla Meta, comúnmente la tecla Alt.\n\n<b>Guardando archivos</b>\n\n<pre>\nC-x C-s - Guardar un archivo\nC-x C-w - Guardar archivo como\nC-x s - Guardar todo\n</pre>\n\nLas opciones de guardar archivo te preguntarán si deseas guardar cada archivo.\n\n<b>Abriendo un archivo</b>\n\n<pre>\nC-x C-f\n</pre>\n\nEsto te pedirá que escribas un nombre de archivo para abrirlo. Si no tienes un archivo que ya exista, creará un archivo nuevo. También puedes cargar un directorio.",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "¿Qué comando se utiliza para abrir un archivo?",
          "slug": "emacsmanipulatefiles",
          "title": "Emacs Manipular Archivos"
        },
        {
          "exercise": "Juega con los buffers.",
          "id": 11,
          "lessonContent": "Para moverse entre buffers (o archivos que estás visitando) usa los siguientes comandos:\n\n<b>Cambiar buffers</b>\n\n<pre>\nC-x b - cambiar de buffer\nC-x flecha derecha - ciclo hacia la derecha a través de los buffers\nC-x flecha izquierda - ciclo hacia la izquierda a través de los buffers\n</pre>\n\n<b>Cerrar el buffer</b>\n\n<pre>C-x k</pre>\n\n<b>Dividir el buffer actual</b>\n\n<pre>C-x 2</pre>\n\nEsto te permite ver múltiples buffers en una sola pantalla. Para moverte entre estos buffers usa: C-x o\n\n<b>Establecer un solo buffer como la pantalla actual</b>\n\n<pre>C-x 1</pre>\n\nSi alguna vez has usado un multiplexor de terminal como screen y tmux, los comandos de buffer te resultarán muy familiares.",
          "quizAnswer": "C-x k",
          "quizQuestion": "¿Cómo eliminas un buffer?",
          "slug": "navegacionbuffersemacs",
          "title": "Navegación de buffers en Emacs"
        },
        {
          "exercise": "Juega con la navegación de texto.",
          "id": 12,
          "lessonContent": "<b>Navegación de texto</b>\n\n<pre>\nC-flecha arriba : mover hacia arriba un párrafo\nC-flecha abajo: mover hacia abajo un párrafo\nC-flecha izquierda: mover una palabra a la izquierda\nC-flecha derecha: mover una palabra a la derecha\nM-> : mover al final del búfer\n</pre>\n\nCon la navegación de texto, tus botones de texto regulares funcionan como deberían, inicio, fin, página arriba, página abajo y las teclas de flecha, etc.\n\n<b>Cortar y pegar</b>\n\nPara cortar (eliminar) o pegar (insertar) en Emacs primero necesitarás ser capaz de seleccionar texto. Para seleccionar texto, mueve tu cursor a donde quieras cortar o pegar y presiona <pre>tecla C-espacio</pre> luego puedes usar las teclas de navegación para seleccionar el texto que desees. Ahora puedes cortar y pegar de la siguiente manera:\n\n<pre>\nC-w : cortar\nC-y : pegar\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "¿Cómo te mueves al final del búfer?",
          "slug": "emacsediting",
          "title": "Edición en Emacs"
        },
        {
          "exercise": "Visita el sitio de Emacs para aprender más comandos. <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Para cerrar Emacs</b>\n\n<pre>C-x C-c</pre>\n\nSi tienes buffers abiertos, te pedirá que los guardes antes de salir de Emacs.\n\n<b>¿Confundido?</b>\n\n<pre>C-h C-h : menú de ayuda</pre>\n\n<b>Deshacer</b>\n\n<pre>C-x u</pre>\n\nComo puedes ver, Emacs tiene más partes móviles, por lo que la curva de aprendizaje es un poco más pronunciada. Sin embargo, a cambio obtienes un editor de texto muy potente.",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "¿Cómo se accede al menú de ayuda?",
          "slug": "emacsexitingandhelp",
          "title": "Salir de Emacs y Ayuda"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Advanced Text-Fu"
    },
    {
      "description": "Aprende sobre roles de usuario y gestión.",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "En cualquier sistema operativo tradicional, existen usuarios y grupos. Estos existen únicamente para el acceso y los permisos. Cuando se ejecuta un proceso, se ejecutará como el propietario de ese proceso, ya sea Jane o Bob. El acceso a archivos y la propiedad también dependen de los permisos. No querrías que Jane vea los documentos de Bob y viceversa. \n\nCada usuario tiene su propio directorio personal donde se almacenan sus archivos específicos de usuario, esto suele estar ubicado en /home/nombredeusuario, pero puede variar en diferentes distribuciones. \n\nEl sistema utiliza identificadores de usuario (UID) para gestionar usuarios, los nombres de usuario son la forma amigable de asociar usuarios con identificación, pero el sistema identifica a los usuarios por su UID. El sistema también utiliza grupos para gestionar permisos, los grupos son simplemente conjuntos de usuarios con permisos establecidos por ese grupo, son identificados por el sistema con su identificador de grupo (GID).\n\nEn Linux, tendrás usuarios además de los humanos normales que utilizan el sistema. A veces, estos usuarios son demonios del sistema que ejecutan procesos continuamente para mantener el sistema funcionando. Uno de los usuarios más importantes es root o superusuario, root es el usuario más poderoso en el sistema, root puede acceder a cualquier archivo y iniciar y finalizar cualquier proceso. Por esa razón, puede ser peligroso operar siempre como root, podrías potencialmente eliminar archivos críticos del sistema. Afortunadamente, si se necesita acceso de root y un usuario tiene acceso de root, pueden ejecutar un comando como root en su lugar con el comando sudo. El comando sudo (superusuario hacer) se utiliza para ejecutar un comando con acceso de root, profundizaremos más en cómo un usuario recibe acceso de root en una lección posterior.\n\nIntenta ver un archivo protegido como /etc/shadow:\n\n<pre>$ cat /etc/shadow</pre>\n\nObserva cómo obtienes un error de permiso denegado, mira los permisos con: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nAún no hemos revisado los permisos, pero lo que está sucediendo aquí es que root es el propietario del archivo y necesitarás acceso de root o ser parte del grupo shadow para leer el contenido. Ahora ejecuta el comando con sudo:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\n¡Ahora podrás ver el contenido del archivo!",
          "quizAnswer": "sudo",
          "quizQuestion": "¿Qué comando utilizas para ejecutar como root?",
          "slug": "usuariosygrupos",
          "title": "Usuarios y Grupos"
        },
        {
          "exercise": "Abre el archivo /etc/sudoers y verifica qué permisos de superusuario tienen otros usuarios en la máquina.",
          "id": 2,
          "lessonContent": "Hemos visto una forma de obtener acceso de superusuario usando el comando sudo. También puedes ejecutar comandos como superusuario con el comando su. Este comando \"sustituirá usuarios\" y abrirá un shell de root si no se especifica un nombre de usuario. Puedes usar este comando para sustituir a cualquier usuario siempre y cuando conozcas la contraseña. \n\n<pre>$ su</pre>\n\nHay algunas desventajas al usar este método: es mucho más fácil cometer un error crítico ejecutando todo como root, no tendrás registros de los comandos que uses para cambiar configuraciones del sistema, etc. Básicamente, si necesitas ejecutar comandos como superusuario, simplemente usa sudo.\n\nAhora que sabes qué comandos ejecutar como superusuario, la pregunta es ¿cómo sabes quién tiene acceso para hacer eso? El sistema no permite que cualquier Joe Schmoe ejecute comandos como superusuario, ¿cómo lo sabe? Existe un archivo llamado /etc/sudoers, este archivo lista los usuarios que pueden ejecutar sudo. Puedes editar este archivo con el comando <b>visudo</b>.",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "¿Qué archivo muestra los usuarios que tienen acceso a sudo?",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "Mira tu archivo /etc/passwd, observa algunos de los usuarios y toma nota de los accesos que tienen.",
          "id": 3,
          "lessonContent": "Recuerda que los nombres de usuario no son realmente identificaciones para los usuarios. El sistema utiliza un ID de usuario (UID) para identificar a un usuario. Para averiguar a qué ID están mapeados los usuarios, mira el archivo /etc/passwd. \n\n<pre>$ cat /etc/passwd</pre>\n\nEste archivo te muestra una lista de usuarios e información detallada sobre ellos. Por ejemplo, la primera línea de este archivo probablemente se vea así:\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\nCada línea muestra información del usuario, comúnmente verás al usuario root como la primera línea. Hay muchos campos separados por dos puntos que te dan información adicional sobre el usuario, veámoslos todos:\n\n<ol>\n<li>Nombre de usuario</li>\n<li>Contraseña del usuario: la contraseña no se almacena realmente en este archivo, generalmente se almacena en el archivo /etc/shadow. Hablaremos más en la próxima lección sobre /etc/shadow, pero por ahora, debes saber que contiene contraseñas de usuario encriptadas. Puedes ver muchos símbolos diferentes en este campo, si ves una \"x\" significa que la contraseña se almacena en el archivo /etc/shadow, un \"*\" significa que el usuario no tiene acceso de inicio de sesión y si hay un campo en blanco significa que el usuario no tiene contraseña.</li>\n<li>ID de usuario - como puedes ver, root tiene el UID de 0</li>\n<li>ID de grupo</li>\n<li>Campo GECOS - se usa generalmente para dejar comentarios sobre el usuario o la cuenta, como su nombre real o número de teléfono, está delimitado por comas.</li>\n<li>Directorio de inicio del usuario</li>\n<li>Shell del usuario - probablemente verás que muchos usuarios tienen bash como su shell por defecto</li>\n</ol>\n\nNormalmente en la página de configuración de un usuario, esperarías ver solo usuarios humanos. Sin embargo, notarás que /etc/passwd contiene otros usuarios. Recuerda que los usuarios realmente solo están en el sistema para ejecutar procesos con diferentes permisos. A veces queremos ejecutar procesos con permisos predefinidos. Por ejemplo, el usuario daemon se utiliza para procesos de demonio.\n\nTambién debes tener en cuenta que puedes editar el archivo /etc/passwd manualmente si deseas agregar usuarios y modificar información con la herramienta <b>vipw</b>, sin embargo, es mejor dejar cosas como estas a las herramientas que discutiremos en una lección posterior, como useradd y userdel.",
          "quizAnswer": "*",
          "quizQuestion": "Si un usuario no tiene acceso de inicio de sesión, ¿cómo se denota eso en /etc/passwd?",
          "slug": "archivoetcpasswd",
          "title": "/etc/passwd"
        },
        {
          "exercise": "Echa un vistazo al archivo /etc/shadow",
          "id": 4,
          "lessonContent": "El archivo /etc/shadow se utiliza para almacenar información sobre la autenticación del usuario. Requiere permisos de lectura de superusuario. \n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\nNotarás que se ve muy similar al contenido de /etc/passwd, sin embargo, en el campo de la contraseña verás una contraseña encriptada. Los campos están separados por dos puntos de la siguiente manera:\n\n<ol>\n<li>Nombre de usuario</li>\n<li>Contraseña encriptada</li>\n<li>Fecha del último cambio de contraseña - expresada como el número de días desde el 1 de enero de 1970. Si es 0, significa que el usuario debe cambiar su contraseña la próxima vez que inicie sesión</li>\n<li>Edad mínima de la contraseña - Días que un usuario tendrá que esperar antes de poder cambiar su contraseña nuevamente</li>\n<li>Edad máxima de la contraseña - Número máximo de días antes de que un usuario tenga que cambiar su contraseña</li>\n<li>Período de advertencia de contraseña - Número de días antes de que una contraseña vaya a caducar</li>\n<li>Período de inactividad de la contraseña - Número de días después de que una contraseña haya caducado para permitir el inicio de sesión con la contraseña</li>\n<li>Fecha de vencimiento de la cuenta - fecha en la que el usuario no podrá iniciar sesión</li>\n<li>Campo reservado para uso futuro</li>\n</ol>\n\nEn la mayoría de las distribuciones actuales, la autenticación de usuario no se basa únicamente en el archivo /etc/shadow, hay otros mecanismos en su lugar, como PAM (Módulos de Autenticación Enchufables) que reemplazan la autenticación.",
          "quizAnswer": "",
          "quizQuestion": "¡No hay preguntas, sigue adelante!",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "Ejecuta el comando <b>groups</b>. ¿Qué ves?",
          "id": 5,
          "lessonContent": "Otro archivo que se utiliza en la gestión de usuarios es el archivo /etc/group. Este archivo permite diferentes grupos con diferentes permisos. \n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\nMuy similar al campo /etc/password, los campos de /etc/group son los siguientes:\n\n<ol>\n<li>Nombre del grupo</li>\n<li>Contraseña del grupo - no es necesario establecer una contraseña de grupo, usar un privilegio elevado como sudo es estándar. Se colocará un \"*\" como valor predeterminado.</li>\n<li>ID de grupo (GID)</li>\n<li>Lista de usuarios - puedes especificar manualmente los usuarios que quieres en un grupo específico</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "¿Cuál es el GID de root?",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "Crea un nuevo usuario, luego cambia su contraseña e inicia sesión como el nuevo usuario.",
          "id": 6,
          "lessonContent": "La mayoría de los entornos empresariales utilizan sistemas de gestión para administrar usuarios, cuentas y contraseñas. Sin embargo, en una sola máquina, existen comandos útiles para administrar usuarios.\n\n<b>Agregar Usuarios</b>\n\nPuedes usar el comando adduser o useradd. El comando adduser contiene más funciones útiles, como crear un directorio de inicio y más. Hay archivos de configuración para agregar nuevos usuarios que se pueden personalizar según lo que quieras asignar a un usuario por defecto. \n\n<pre>$ sudo useradd bob</pre>\n\nVerás que el comando anterior crea una entrada en /etc/passwd para bob, configura grupos por defecto y agrega una entrada al archivo /etc/shadow.\n\n<b>Eliminar Usuarios</b>\n\nPara eliminar un usuario, puedes usar el comando userdel.\n\n<pre>$ sudo userdel bob</pre>\n\nBásicamente, esto hace todo lo posible para deshacer los cambios de archivos realizados por useradd.\n\n<b>Cambiar Contraseñas</b>\n\n<pre>$ passwd bob</pre>\n\nEsto te permitirá cambiar la contraseña tuya o de otro usuario (si eres root).",
          "quizAnswer": "passwd",
          "quizQuestion": "¿Qué comando se utiliza para cambiar una contraseña?",
          "slug": "herramientasdegestiondeusuarios",
          "title": "Herramientas de Gestión de Usuarios"
        }
      ],
      "slug": "usermanagement",
      "title": "Gestión de usuarios"
    },
    {
      "description": "Aprenda sobre los niveles de permisos y cómo modificar los permisos.",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "Utiliza el comando ls -l en varios archivos y recita sus permisos, usuario y grupo.",
          "id": 1,
          "lessonContent": "Como aprendimos anteriormente, los archivos tienen diferentes permisos o modos de archivo. Veamos un ejemplo:\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nHay cuatro partes en los permisos de un archivo. La primera parte es el tipo de archivo, que está indicado por el primer carácter en los permisos, en nuestro caso, al ser un directorio, muestra <b>d</b> para el tipo de archivo. Comúnmente se verá un <b>-</b> para un archivo regular. \n\nLas siguientes tres partes del modo de archivo son los permisos reales. Los permisos se agrupan en conjuntos de 3 bits cada uno. Los primeros 3 bits son los permisos de usuario, luego los permisos de grupo y luego los permisos de otros. He añadido la barra vertical para hacer más fácil la diferenciación.\n\n<pre>d | rwx | r-x | r-x </pre>\n\nCada carácter representa un permiso diferente: \n<ul>\n<li>r: legible</li>\n<li>w: escribible</li>\n<li>x: ejecutable (básicamente un programa ejecutable)</li>\n<li>-: vacío</li>\n</ul>\n\nEntonces, en el ejemplo anterior, vemos que el usuario pete tiene permisos de lectura, escritura y ejecución en el archivo. El grupo penguins tiene permisos de lectura y ejecución. Y finalmente, los otros usuarios (todos los demás) tienen permisos de lectura y ejecución.",
          "quizAnswer": "x",
          "quizQuestion": "¿Qué bit de permiso se utiliza para ejecutable?",
          "slug": "filepermissions",
          "title": "Permisos de Archivos"
        },
        {
          "exercise": "Cambia algunos permisos básicos de archivos de texto y observa cómo cambian los bits al hacer un ls -l.",
          "id": 2,
          "lessonContent": "Cambiar permisos se puede hacer fácilmente con el comando <b>chmod</b>. \n\nPrimero, elige qué conjunto de permisos deseas cambiar, usuario, grupo u otro. Puedes agregar o quitar permisos con un <b>+</b> o un <b>-</b>, veamos algunos ejemplos.\n\n<b>Agregar un bit de permiso en un archivo</b>\n<pre>$ chmod u+x myfile</pre>\n\nEl comando anterior se lee así: cambia el permiso en myfile agregando un bit de permiso ejecutable en el conjunto de usuario. ¡Así que ahora el usuario tiene permiso ejecutable en este archivo!\n\n<b>Quitar un bit de permiso en un archivo</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>Agregar múltiples bits de permiso en un archivo</b>\n<pre>$ chmod ug+w</pre>\n\nHay otra forma de cambiar permisos usando formato numérico. Este método te permite cambiar todos los permisos de una vez. En lugar de usar r, w o x para representar permisos, usarás una representación numérica para un solo conjunto de permisos. Así que no es necesario especificar el grupo con g o el usuario con u.\n\nLas representaciones numéricas se muestran a continuación:\n\n<ul>\n<li>4: permiso de lectura</li>\n<li>2: permiso de escritura</li>\n<li>1: permiso de ejecución</li>\n</ul>\n\nVeamos un ejemplo: \n\n<pre>$ chmod 755 myfile</pre>\n\n¿Puedes adivinar qué permisos estamos dando a este archivo? Vamos a desglosarlo, entonces ahora 755 cubre los permisos para todos los conjuntos. El primer número (7) representa los permisos de usuario, el segundo número (5) representa los permisos de grupo y el último 5 representa los permisos de otros. \n\nEspera un minuto, 7 y 5 no se mencionaron anteriormente, ¿de dónde sacamos estos números? Recuerda que estamos combinando todos los permisos en un solo número ahora, así que tendrás que hacer un poco de matemáticas.\n\n7 = 4 + 2 + 1, entonces 7 son los permisos de usuario y tiene permisos de lectura, escritura y ejecución\n\n5 = 4 + 1, el grupo tiene permisos de lectura y ejecución\n\n5 = 4 + 1, y todos los demás usuarios tienen permisos de lectura y ejecución\n\nUna cosa a tener en cuenta: no es una gran idea cambiar permisos sin ton ni son, podrías potencialmente exponer un archivo sensible para que todos lo modifiquen, sin embargo muchas veces quieres cambiar permisos legítimamente, solo toma precauciones al usar el comando chmod.",
          "quizAnswer": "4",
          "quizQuestion": "¿Qué número representa el permiso de lectura al usar formato numérico?",
          "slug": "modificandopermisos",
          "title": "Modificando Permisos"
        },
        {
          "exercise": "Modifica el grupo y el usuario de algunos archivos de prueba. Después echa un vistazo a los permisos con ls -l.",
          "id": 3,
          "lessonContent": "Además de modificar los permisos en los archivos, también puedes modificar el grupo y la propiedad de usuario del archivo. \n\n<b>Modificar la propiedad de usuario</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nEste comando establecerá al propietario de myfile como patty.\n\n<b>Modificar la propiedad de grupo</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nEste comando establecerá al grupo de myfile como whales.\n\n<b>Modificar tanto la propiedad de usuario como la de grupo al mismo tiempo</b>\nSi agregas dos puntos y el nombre del grupo después del usuario, puedes establecer tanto el usuario como el grupo al mismo tiempo.\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "¿Qué comando utilizas para cambiar la propiedad de usuario?",
          "slug": "permisosdepropietario",
          "title": "Permisos de Propietario"
        },
        {
          "exercise": "<ol>\n<li>Crea un archivo nuevo y luego toma nota de sus permisos.</li>\n<li>Modifica el umask y luego crea otro archivo nuevo.</li>\n<li>Verifica los permisos una vez más en el nuevo archivo, ¿qué esperas ver?</li>\n<ol>",
          "id": 4,
          "lessonContent": "Cada archivo que se crea viene con un conjunto predeterminado de permisos. Si alguna vez deseas cambiar ese conjunto predeterminado de permisos, puedes hacerlo con el comando umask. Este comando toma el conjunto de permisos de 3 bits que vemos en los permisos numéricos. \n\nEn lugar de agregar estos permisos, umask elimina estos permisos. \n\n<pre>$ umask 021</pre>\n\nEn el ejemplo anterior, estamos indicando que queremos que los permisos predeterminados de los nuevos archivos permitan a los usuarios acceder a todo, pero para los grupos queremos quitar su permiso de escritura y para otros queremos quitar su permiso de ejecución. El umask predeterminado en la mayoría de las distribuciones es 022, lo que significa que todos los usuarios tienen acceso, pero no hay acceso de escritura para el grupo y otros usuarios.\n\nCuando ejecutas el comando umask, dará ese conjunto predeterminado de permisos en cualquier nuevo archivo que crees. Sin embargo, si deseas que persista, tendrás que modificar tu archivo de inicio (.profile), pero discutiremos eso en una lección posterior.",
          "quizAnswer": "umask",
          "quizQuestion": "¿Qué comando se utiliza para cambiar los permisos de archivo predeterminados?",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "Observa detenidamente los permisos de /etc/passwd, ¿notas algo más? Los archivos con SUID habilitado también son fácilmente distinguibles.",
          "id": 5,
          "lessonContent": "Hay muchos casos en los que los usuarios normales necesitan acceso elevado para hacer cosas. El administrador del sistema no siempre puede estar presente para ingresar una contraseña de root cada vez que un usuario necesita acceso a un archivo protegido, por lo que existen bits especiales de permisos de archivo para permitir este comportamiento. El ID de usuario establecido (SUID) permite a un usuario ejecutar un programa como el propietario del archivo del programa en lugar de como ellos mismos.\n\nVeamos un ejemplo: \n\nDigamos que quiero cambiar mi contraseña, ¿simple verdad? Solo uso el comando passwd:\n\n<pre>$ passwd</pre>\n\n¿Qué hace el comando de contraseña? Está modificando un par de archivos, pero lo más importante es que está modificando el archivo /etc/shadow. Echemos un vistazo a ese archivo por un segundo: \n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 1 dic 11:45 /etc/shadow\n</pre>\n\n¡Espera un minuto aquí, ¿este archivo es propiedad de root? ¿Cómo es posible que podamos modificar un archivo propiedad de root? \n\nVeamos otro conjunto de permisos, esta vez del comando que ejecutamos: \n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 1 dic 11:45 /usr/bin/passwd\n</pre>\n\nNotarás un nuevo bit de permiso aquí <b>s</b>. Este bit de permiso es el SUID, cuando un archivo tiene este permiso establecido, permite a los usuarios que lanzaron el programa obtener el permiso del propietario del archivo, así como el permiso de ejecución, en este caso root. Por lo tanto, mientras un usuario está ejecutando el comando de contraseña, está ejecutándose como root.\n\nPor eso podemos acceder a un archivo protegido como /etc/shadow cuando ejecutamos el comando passwd. Ahora, si quitas ese bit, verás que no podrás modificar /etc/shadow y, por lo tanto, cambiar tu contraseña. \n\n<b>Modificando SUID</b>\n\nAl igual que los permisos regulares, hay dos formas de modificar los permisos SUID. \n\n<i>Forma simbólica:</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>Forma numérica:</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nComo puedes ver, el SUID se denota con un 4 y se antepone al conjunto de permisos. Puedes ver el SUID denotado como una <b>S</b> mayúscula, esto significa que sigue haciendo lo mismo, pero no tiene permisos de ejecución.",
          "quizAnswer": "4",
          "quizQuestion": "¿Qué número representa el SUID?",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 6,
          "lessonContent": "Similar to the set user ID permission bit, there is a set group ID (SGID) permission bit. This bit allows a program to run as if it was a member of that group. \n\nLet's look at one example: \n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\nAhora podemos ver que el bit de permiso está en el conjunto de permisos de grupo. \n\n<b>Modificando SGID</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nLa representación numérica para SGID es 2.",
          "quizAnswer": "2",
          "quizQuestion": "¿Qué número representa el SGID?",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "Todavía no hemos discutido procesos, aún así podemos ver este cambio en tiempo real: \n\n<ol>\n<li>Abre una ventana de terminal y ejecuta el comando: <b>watch -n 1 \"ps aux | grep passwd\"</b>. Esto observará el proceso de passwd.</li>\n<li>Abre una segunda ventana de terminal y ejecuta: <b>passwd</b></li>\n<li>Mira la primera ventana de terminal, verás un proceso para passwd. ¡La primera columna en la tabla de procesos es el UID de usuario efectivo, y es el usuario root!</li>\n</ol>",
          "id": 7,
          "lessonContent": "Vamos a adentrarnos un poco en los permisos de procesos, ¿recuerdas cuando te dije que al ejecutar el comando passwd con el bit de permiso SUID habilitado ejecutarás el programa como root? Eso es cierto, sin embargo, ¿significa eso que al ser temporalmente root puedes modificar las contraseñas de otros usuarios? ¡No, afortunadamente no!\n\nEsto se debe a los muchos UIDs que implementa Linux. Hay tres UIDs asociados con cada proceso:\n\nCuando lanzas un proceso, se ejecuta con los mismos permisos que el usuario o grupo que lo inició, esto se conoce como un <b>UID de usuario efectivo</b>. Este UID se utiliza para otorgar derechos de acceso a un proceso. Por lo tanto, naturalmente, si Bob ejecutara el comando touch, el proceso se ejecutaría como él y cualquier archivo que creara estaría bajo su propiedad.\n\nHay otro UID, llamado <b>UID de usuario real</b>, que es el ID del usuario que inició el proceso. Estos se utilizan para rastrear quién es el usuario que inició el proceso.\n\nUn último UID es el <b>UID de usuario guardado</b>, que permite a un proceso cambiar entre el UID efectivo y el UID real, viceversa. Esto es útil porque no queremos que nuestro proceso se ejecute con privilegios elevados todo el tiempo, es una buena práctica utilizar privilegios especiales en momentos específicos. \n\nAhora vamos a unir todo esto mirando el comando passwd una vez más. \n\nAl ejecutar el comando passwd, tu UID efectivo es tu ID de usuario, digamos que es 500 por ahora. Oh, pero espera, recuerda que el comando passwd tiene el permiso SUID habilitado. Entonces, cuando lo ejecutas, tu UID efectivo es ahora 0 (0 es el UID de root). Ahora este programa puede acceder a archivos como root.\n\nDigamos que pruebas un poco de poder y quieres modificar la contraseña de Sally, Sally tiene un UID de 600. Bueno, estarás de mala suerte, afortunadamente el proceso también tiene tu UID real en este caso 500. Sabe que tu UID es 500 y por lo tanto no puedes modificar la contraseña del UID 600. (Esto, por supuesto, siempre se pasa por alto si eres un superusuario en una máquina y puedes controlar y cambiar todo).\n\nComo ejecutaste passwd, iniciará el proceso usando tu UID real, y guardará el UID del propietario del archivo (UID efectivo), para que puedas cambiar entre los dos. No es necesario modificar todos los archivos con acceso de root si no es necesario. \n\nLa mayoría de las veces, el UID real y el UID efectivo son iguales, pero en casos como el comando passwd cambiarán.",
          "quizAnswer": "efectivo",
          "quizQuestion": "¿Qué UID decide qué acceso otorgar?",
          "slug": "permisosdeprocesos",
          "title": "Permisos de Procesos"
        },
        {
          "exercise": "¿Qué otros archivos y directorios crees que tienen habilitado un bit pegajoso?",
          "id": 8,
          "lessonContent": "Un último bit de permiso especial del que quiero hablar es el bit pegajoso. \n\nEste bit de permiso \"pega un archivo/directorio\", lo que significa que solo el propietario o el usuario root pueden eliminar o modificar el archivo. Esto es muy útil para directorios compartidos. Echa un vistazo al ejemplo a continuación:\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nVerás un bit de permiso especial al final aquí <b>t</b>, esto significa que cualquiera puede agregar archivos, escribir archivos, modificar archivos en el directorio /tmp, pero solo root puede eliminar el directorio /tmp. \n\n<b>Modificar el bit pegajoso</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nLa representación numérica para el bit pegajoso es <b>1</b>",
          "quizAnswer": "t",
          "quizQuestion": "¿Qué símbolo representa el bit pegajoso?",
          "slug": "stickybit",
          "title": "El bit pegajoso"
        }
      ],
      "slug": "permisos",
      "title": "Permisos"
    },
    {
      "description": "Aprenda sobre los procesos en ejecución en el sistema.",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "Utilice el comando ps con diferentes banderas y vea cómo cambia la salida.",
          "id": 1,
          "lessonContent": "Los procesos son los programas que se están ejecutando en su máquina. Son gestionados por el kernel y cada proceso tiene asociado un ID llamado <b>Identificador de Proceso (PID).</b> Este PID se asigna en el orden en que se crean los procesos. \n\nAdelante y ejecute el comando ps para ver una lista de procesos en ejecución:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nEsto le muestra una vista rápida de los procesos actuales:\n\n<ul>\n<li>PID: Identificador de Proceso</li>\n<li>TTY: Terminal de control asociado con el proceso (hablaremos en detalle sobre esto más adelante)</li>\n<li>STAT: Código de estado del proceso</li>\n<li>TIME: Tiempo total de uso de la CPU</li>\n<li>CMD: Nombre del ejecutable/comando</li>\n</ul>\n\nSi mira la página del manual para ps, verá que hay muchas opciones de comando que puede pasar, que variarán dependiendo de las opciones que desee utilizar: BSD, GNU o Unix. En mi opinión, el estilo BSD es más popular de usar, así que vamos a ir con eso. Si tiene curiosidad por la diferencia entre los estilos, es la cantidad de guiones que usa y las banderas.\n\n<pre>$ ps aux</pre>\n\nLa <b>a</b> muestra todos los procesos en ejecución, incluidos los que se están ejecutando por otros usuarios. La <b>u</b> muestra más detalles sobre los procesos. Y finalmente la <b>x</b> lista todos los procesos que no tienen un TTY asociado, estos programas mostrarán un ? en el campo TTY, son más comunes en procesos daemon que se inician como parte del inicio del sistema.\n\nNotará que ahora está viendo muchos más campos, no es necesario memorizarlos todos, en un curso posterior sobre procesos avanzados, repasaremos algunos de ellos de nuevo:\n\n<ul>\n<li>USUARIO: El usuario efectivo (el que cuyo acceso estamos utilizando)</li>\n<li>PID: Identificador de Proceso</li>\n<li>%CPU: Tiempo de CPU utilizado dividido por el tiempo que el proceso ha estado en ejecución</li>\n<li>%MEM: Relación del tamaño del conjunto residente del proceso con la memoria física de la máquina</li>\n<li>VSZ: Uso de memoria virtual de todo el proceso</li>\n<li>RSS: Tamaño del conjunto residente, la memoria física no intercambiada que una tarea ha utilizado</li>\n<li>TTY: Terminal de control asociado con el proceso</li>\n<li>STAT: Código de estado del proceso</li>\n<li>START: Hora de inicio del proceso</li>\n<li>TIME: Tiempo total de uso de la CPU</li>\n<li>COMANDO: Nombre del ejecutable/comando</li>\n</ul>\n\nEl comando ps puede ser un poco confuso de ver, por ahora los campos en los que nos centraremos más son PID, STAT y COMANDO. \n\nOtro comando muy útil es el comando <b>top</b>, top le proporciona información en tiempo real sobre los procesos en ejecución en su sistema en lugar de una instantánea. De forma predeterminada, obtendrá una actualización cada 10 segundos. Top es una herramienta extremadamente útil para ver qué procesos están consumiendo muchos de sus recursos. \n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "¿Qué bandera de ps se utiliza para ver información detallada sobre los procesos?",
          "slug": "monitorarprocesoscomandops",
          "title": "ps (Procesos)"
        },
        {
          "exercise": "Mira tu salida de ps y lista todos los valores TTY únicos.",
          "id": 2,
          "lessonContent": "Discutimos cómo hay un campo TTY en la salida de ps. El TTY es la terminal que ejecutó el comando.\n\nHay dos tipos de terminales, dispositivos de terminal regulares y dispositivos de pseudoterminal. Un dispositivo de terminal regular es un dispositivo de terminal nativo en el que puedes escribir y enviar salida a tu sistema, esto suena como la aplicación de terminal que has estado lanzando para llegar a tu shell, pero no lo es. \n\nVamos a hacer una transición para que puedas ver esta acción, adelante y escribe Ctrl-Alt-F1 para entrar en TTY1 (la primera consola virtual), notarás cómo no tienes nada excepto la terminal, sin gráficos, etc. Esto se considera un dispositivo de terminal regular, puedes salir de esto con Ctrl-Alt-F7. \n\nUn pseudoterminal es en lo que has estado acostumbrado a trabajar, emulan terminales con la ventana de terminal de shell y se denotan con PTS. Si vuelves a mirar ps, verás tu proceso de shell bajo pts/*. \n\nOk, ahora volviendo al control de la terminal, los procesos suelen estar vinculados a una terminal de control. Por ejemplo, si estuvieras ejecutando un programa en tu ventana de shell como find y cerraras la ventana, tu proceso también se cerraría. \n\nHay procesos como procesos daemon, que son procesos especiales que básicamente mantienen el sistema en funcionamiento. A menudo se inician en el arranque del sistema y generalmente se terminan cuando se apaga el sistema. Se ejecutan en segundo plano y como no queremos que estos procesos especiales se terminen, no están vinculados a una terminal de control. En la salida de ps, el TTY se enumera como un ? lo que significa que no tiene una terminal de control.",
          "quizAnswer": "?",
          "quizQuestion": "¿Qué valor se da para un proceso que no tiene una terminal de control?",
          "slug": "controlandolaterminal",
          "title": "Controlando la Terminal"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "Antes de adentrarnos en aplicaciones más prácticas de procesos, primero debemos entender qué son y cómo funcionan. Esta parte puede resultar confusa ya que nos sumergimos en los detalles más minuciosos, así que si no quieres aprender sobre esto ahora, siéntete libre de regresar a esta lección más tarde. \n\nUn proceso, como mencionamos antes, es un programa en ejecución en el sistema, más precisamente es el sistema asignando memoria, CPU, E/S para hacer que el programa se ejecute. Un proceso es una instancia de un programa en ejecución, adelante y abre 3 ventanas de terminal, en dos ventanas, ejecuta el comando <b>cat</b> sin pasar ninguna opción (el proceso cat permanecerá abierto como un proceso porque espera stdin). Ahora en la tercera ventana ejecuta: <b>ps aux | grep cat</b>. Verás que hay dos procesos para cat, aunque estén llamando al mismo programa.\n\nEl kernel se encarga de los procesos, cuando ejecutamos un programa, el kernel carga el código del programa en memoria, determina y asigna recursos y luego lleva un registro de cada proceso, sabe: \n\n<ul>\n<li>El estado del proceso</li>\n<li>Los recursos que el proceso está utilizando y recibe</li>\n<li>El propietario del proceso</li>\n<li>Manejo de señales (más sobre eso luego)</li>\n<li>Y básicamente todo lo demás</li>\n</ul>\n\nTodos los procesos intentan obtener una parte de ese dulce pastel de recursos, es trabajo del kernel asegurarse de que los procesos reciban la cantidad adecuada de recursos según las demandas del proceso. Cuando un proceso termina, los recursos que utilizó ahora se liberan para otros procesos.",
          "quizAnswer": "kernel",
          "quizQuestion": "¿Qué gestiona y controla los procesos?",
          "slug": "detallesdelproceso",
          "title": "Detalles del Proceso"
        },
        {
          "exercise": "Observa tus procesos en ejecución, ¿puedes ver qué otros procesos tienen padres?",
          "id": 4,
          "lessonContent": "Nuevamente, esta lección y la siguiente son puramente informativas para que puedas ver lo que hay bajo el capó, siéntete libre de volver a esto una vez que hayas trabajado un poco más con los procesos.\n\nCuando se crea un nuevo proceso, un proceso existente básicamente se clona a sí mismo utilizando algo llamado la llamada al sistema fork (las llamadas al sistema se discutirán en un futuro muy lejano). La llamada al sistema fork crea un proceso hijo casi idéntico, este proceso hijo toma un nuevo ID de proceso (PID) y el proceso original se convierte en su proceso padre y tiene algo llamado un ID de proceso padre <b>PPID</b>. Después, el proceso hijo puede continuar usando el mismo programa que estaba usando su padre antes o más a menudo usar la llamada al sistema execve para lanzar un nuevo programa. Esta llamada al sistema destruye la gestión de memoria que el kernel había establecido para ese proceso y configura nuevas para el nuevo programa. \n\nPodemos ver esto en acción:\n\n<pre>$ ps l</pre>\n\nLa opción l nos da un formato \"largo\" o una vista aún más detallada de nuestros procesos en ejecución. Verás una columna etiquetada <b>PPID</b>, este es el ID del padre. Ahora mira tu terminal, verás un proceso en ejecución que es tu shell, así que en mi sistema tengo un proceso ejecutando bash. Ahora recuerda cuando ejecutaste el comando ps l, lo estabas ejecutando desde el proceso que estaba ejecutando bash. Ahora verás que el <b>PID</b> del shell bash es el <b>PPID</b> del comando <b>ps l</b>.\n\nEntonces, si cada proceso debe tener un padre y son solo bifurcaciones entre sí, ¿debe haber una madre de todos los procesos, verdad? Tienes razón, cuando el sistema se inicia, el kernel crea un proceso llamado <b>init</b>, tiene un PID de 1. El proceso init no puede ser terminado a menos que el sistema se apague. Se ejecuta con privilegios de root y ejecuta muchos procesos que mantienen el sistema en funcionamiento. Analizaremos más de cerca init en el curso de arranque del sistema, por ahora solo debes saber que es el proceso que genera todos los demás procesos.",
          "quizAnswer": "fork",
          "quizQuestion": "¿Qué llamada al sistema crea un nuevo proceso?",
          "slug": "creaciondeprocesos",
          "title": "Creación de procesos"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Ahora que sabemos qué sucede cuando se crea un proceso, ¿qué ocurre cuando ya no lo necesitamos? Advertencia, a veces Linux puede volverse un poco oscuro...\n\nUn proceso puede finalizar utilizando la llamada al sistema _exit, esto liberará los recursos que el proceso estaba utilizando para su reasignación. Así que cuando un proceso está listo para terminar, le informa al kernel por qué está terminando con algo llamado un estado de terminación. Comúnmente, un estado de 0 significa que el proceso ha tenido éxito. Sin embargo, eso no es suficiente para terminar completamente un proceso. El proceso padre tiene que reconocer la terminación del proceso hijo utilizando la llamada al sistema wait y lo que hace es comprobar el estado de terminación del proceso hijo. Sé que es macabro pensar en ello, pero la llamada wait es una necesidad, después de todo, ¿qué padre no querría saber cómo murió su hijo?\n\nHay otra forma de terminar un proceso que implica el uso de señales, de las cuales hablaremos pronto.\n\n<b>Procesos Huérfanos</b>\n\nCuando un proceso padre muere antes que un proceso hijo, el kernel sabe que no va a recibir una llamada wait, por lo que convierte a estos procesos en \"huérfanos\" y los pone bajo el cuidado de init (recuerda, la madre de todos los procesos). Init eventualmente realizará la llamada al sistema wait para estos huérfanos para que puedan morir.\n\n<b>Procesos Zombis</b>\n\n¿Qué sucede cuando un proceso hijo termina y el proceso padre aún no ha llamado a wait? Aún queremos poder ver cómo terminó un proceso hijo, por lo que aunque el proceso hijo haya finalizado, el kernel convierte al proceso hijo en un proceso zombi. Los recursos que el proceso hijo utilizó aún se liberan para otros procesos, sin embargo, todavía hay una entrada en la tabla de procesos para este zombi. Los procesos zombis tampoco pueden ser eliminados, ya que técnicamente están \"muertos\", por lo que no se pueden utilizar señales para matarlos. Eventualmente, si el proceso padre llama a la llamada al sistema wait, el zombi desaparecerá, esto se conoce como \"recolección\". Si el padre no realiza una llamada wait, init adoptará al zombi y automáticamente realizará wait y eliminará al zombi. Puede ser malo tener demasiados procesos zombis, ya que ocupan espacio en la tabla de procesos, si se llena, impedirá que otros procesos se ejecuten.",
          "quizAnswer": "0",
          "quizQuestion": "¿Cuál es el estado de terminación más común para un proceso que tiene éxito?",
          "slug": "terminacionprocesos",
          "title": "Terminación de Procesos"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 6,
          "lessonContent": "Una señal es una notificación a un proceso de que algo ha sucedido.\n\n<b>Por qué tenemos señales</b>\n\nSon interrupciones de software y tienen muchos usos:\n\n<ul>\n<li>Un usuario puede escribir uno de los caracteres especiales del terminal (Ctrl-C) o (Ctrl-Z) para matar, interrumpir o suspender procesos</li>\n<li>Pueden ocurrir problemas de hardware y el kernel quiere notificar al proceso</li>\n<li>Pueden ocurrir problemas de software y el kernel quiere notificar al proceso</li>\n<li>Básicamente son formas en que los procesos pueden comunicarse</li>\n</ul>\n\n<b>Proceso de señal</b>\n\nCuando una señal es generada por algún evento, luego se entrega a un proceso, se considera en un estado pendiente hasta que se entrega. Cuando se ejecuta el proceso, la señal será entregada. Sin embargo, los procesos tienen máscaras de señal y pueden bloquear la entrega de señales si se especifica. Cuando se entrega una señal, un proceso puede hacer una multitud de cosas: \n\n<ul>\n<li>Ignorar la señal</li>\n<li>\"Capturar\" la señal y realizar una rutina de manejo específica</li>\n<li>El proceso puede ser terminado, a diferencia de la llamada al sistema de salida normal</li>\n<li>Bloquear la señal, dependiendo de la máscara de señal</li>\n</ul>\n\n<b>Señales comunes</b>\n\nCada señal está definida por enteros con nombres simbólicos que están en forma de SIGxxx. Algunas de las señales más comunes son: \n\n<ul>\n<li>SIGHUP o HUP o 1: Desconexión</li>\n<li>SIGINT o INT o 2: Interrupción</li>\n<li>SIGKILL o KILL o 9: Matar</li>\n<li>SIGSEGV o SEGV o 11: Violación de segmento</li>\n<li>SIGTERM o TERM o 15: Terminación de software</li>\n<li>SIGSTOP o STOP: Detener</li>\n</ul>\n\nLos números pueden variar con las señales, por lo que generalmente se les hace referencia por sus nombres.\n\nAlgunas señales son inbloqueables, un ejemplo es la señal SIGKILL. La señal KILL destruye el proceso.",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "¿Qué señal es inbloqueable?",
          "slug": "señalesproceso",
          "title": "Señales"
        },
        {
          "exercise": "Mata algunos procesos usando diferentes señales.",
          "id": 7,
          "lessonContent": "Puedes enviar señales que terminen procesos, un comando para esto se llama adecuadamente el comando kill. \n\n<pre>$ kill 12445</pre>\n\nEl 12445 es el PID del proceso que deseas matar. Por defecto envía una señal TERM. La señal SIGTERM se envía a un proceso para solicitar su terminación permitiéndole liberar limpiamente sus recursos y guardar su estado. \n\nTambién puedes especificar una señal con el comando kill: \n\n<pre>$ kill -9 12445</pre>\n\nEsto ejecutará la señal SIGKILL y matará el proceso. \n\n<b>¿Diferencias entre SIGHUP, SIGINT, SIGTERM, SIGKILL, SIGSTOP?</b>\n\nEstas señales suenan bastante similares, pero tienen sus diferencias. \n\n<ul>\n<li>SIGHUP - Desconexión, enviada a un proceso cuando se cierra el terminal de control. Por ejemplo, si cerraste una ventana de terminal que tenía un proceso en ejecución, recibirías una señal SIGHUP. Básicamente, te han colgado</li>\n<li>SIGINT - Es una señal de interrupción, por lo que puedes usar Ctrl-C y el sistema intentará matar el proceso con gracia</li>\n<li>SIGTERM - Mata el proceso, pero permite que haga algo de limpieza primero</li>\n<li>SIGKILL - Mata el proceso, mátalo con fuego, no hace ninguna limpieza</li>\n<li>SIGSTOP - Detiene/suspende un proceso</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "¿Cuál es el nombre de la señal para el comando kill por defecto?",
          "slug": "matandoprocesos",
          "title": "matar (Terminar)"
        },
        {
          "exercise": "¿Qué procesos no son muy amables y por qué?",
          "id": 8,
          "lessonContent": "Cuando ejecutas múltiples cosas en tu computadora, como quizás Chrome, Microsoft Word o Photoshop al mismo tiempo, puede parecer que estos procesos se están ejecutando al mismo tiempo, pero eso no es del todo cierto. \n\nLos procesos utilizan la CPU durante un pequeño período de tiempo llamado rebanada de tiempo. Luego se detienen durante milisegundos y otro proceso obtiene una pequeña rebanada de tiempo. Por defecto, la programación de procesos ocurre de esta manera en forma de round-robin. Cada proceso recibe suficientes rebanadas de tiempo hasta que haya terminado de procesar. El kernel maneja todos estos cambios de procesos y lo hace bastante bien la mayor parte del tiempo.\n\nLos procesos no pueden decidir cuándo y cuánto tiempo obtienen tiempo de CPU, si todos los procesos se comportaran normalmente, cada uno (aproximadamente) obtendría una cantidad igual de tiempo de CPU. Sin embargo, hay una forma de influir en el algoritmo de programación de procesos del kernel con un valor de amabilidad. Amabilidad es un nombre bastante extraño, pero lo que significa es que los procesos tienen un número para determinar su prioridad para la CPU. Un número alto significa que el proceso es amable y tiene una prioridad más baja para la CPU y un número bajo o negativo significa que el proceso no es muy amable y quiere obtener la mayor cantidad de la CPU posible. \n\n<pre>$ top</pre>\n\nPuedes ver una columna para NI en este momento, que es el nivel de amabilidad de un proceso.\n\nPara cambiar el nivel de amabilidad, puedes usar los comandos nice y renice:\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nEl comando nice se utiliza para establecer la prioridad para un nuevo proceso. El comando renice se utiliza para establecer la prioridad en un proceso existente. \n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "más bajo",
          "quizQuestion": "Si quiero que un proceso obtenga más prioridad de CPU, ¿debo usar un número nice más bajo o más alto?",
          "slug": "amabilidadproceso",
          "title": "amabilidad"
        },
        {
          "exercise": "Echa un vistazo a los procesos en ejecución en tu sistema y revisa sus estados de proceso.",
          "id": 9,
          "lessonContent": "Echemos un vistazo nuevamente al comando ps aux:\n\n<pre>$ ps aux</pre>\n\nEn la columna STAT, verás muchos valores. Un proceso de Linux puede estar en varios estados diferentes. Los códigos de estado más comunes que verás se describen a continuación:\n\n<ul>\n<li>R: en ejecución o listo, está esperando a que la CPU lo procese</li>\n<li>S: Sueño interrumpible, esperando a que se complete un evento, como la entrada desde la terminal</li>\n<li>D: Sueño ininterrumpible, procesos que no pueden ser eliminados o interrumpidos con una señal, generalmente para hacer que desaparezcan debes reiniciar o solucionar el problema</li>\n<li>Z: Zombi, discutimos en una lección anterior que los zombis son procesos terminados que están esperando a que se recojan sus estados</li>\n<li>T: Detenido, un proceso que ha sido suspendido/detenido</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "¿Qué código STAT se utiliza para representar un sueño ininterrumpible?",
          "slug": "estadosdeproceso",
          "title": "Estados de Proceso"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 10,
          "lessonContent": "Recuerda que todo en Linux es un archivo, incluso los procesos. La información del proceso se almacena en un sistema de archivos especial conocido como el sistema de archivos /proc.\n\n<pre>$ ls /proc</pre>\n\nDeberías ver múltiples valores aquí, hay subdirectorios para cada PID. Si miraras un PID en la salida de ps, podrías encontrarlo en el directorio /proc.\n\nAdelante, ingresa a uno de los procesos y mira ese archivo:\n\n<pre>$ cat /proc/12345/status</pre>\n\nDeberías ver información del estado del proceso y también información más detallada. El directorio /proc es cómo el kernel ve el sistema, por lo que hay mucha más información aquí de la que verías en ps.",
          "quizAnswer": "/proc",
          "quizQuestion": "¿Qué sistema de archivos almacena información del proceso?",
          "slug": "sistema-archivos-proc",
          "title": "/Sistema de archivos proc"
        },
        {
          "exercise": "Mover algunos trabajos entre el segundo plano y el primer plano",
          "id": 11,
          "lessonContent": "Imaginemos que estás trabajando en una sola ventana de terminal y estás ejecutando un comando que está tardando una eternidad. No puedes interactuar con la terminal hasta que se complete, sin embargo, queremos seguir trabajando en nuestras máquinas, por lo que necesitamos mantener esa terminal abierta. Afortunadamente, podemos controlar cómo se ejecutan nuestros procesos con trabajos: \n\n<b>Enviando un trabajo al segundo plano</b>\n\nAñadir un ampersand (&) al comando lo ejecutará en segundo plano para que puedas seguir utilizando tu terminal. Veamos un ejemplo:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>Ver todos los trabajos en segundo plano</b>\n\nAhora puedes ver los trabajos que acabas de enviar al segundo plano.\n\n<pre>$ jobs\n\n[1]    Ejecutando     sleep 1000 &\n[2]-   Ejecutando     sleep 1001 &\n[3]+   Ejecutando     sleep 1002 &\n\n</pre>\n\nEsto te mostrará el ID del trabajo en la primera columna, luego el estado y el comando que se ejecutó. El <b>+</b> junto al ID del trabajo significa que es el trabajo en segundo plano más reciente que se inició. El trabajo con el <b>-</b> es el segundo comando más reciente.\n\n<b>Enviando un trabajo al segundo plano en un trabajo existente</b>\n\nSi ya ejecutaste un trabajo y quieres enviarlo al segundo plano, no es necesario terminarlo y empezar de nuevo. Primero suspende el trabajo con Ctrl-Z, luego ejecuta el comando <b>bg</b> para enviarlo al segundo plano.\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Detenido     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Ejecutando     sleep 1000 &\n[2]    Ejecutando     sleep 1001 &\n[3]-   Ejecutando     sleep 1002 &\n[4]+   Ejecutando     sleep 1003 &\n</pre>\n\n<b>Moviendo un trabajo del segundo plano al primer plano</b>\n\nPara sacar un trabajo del segundo plano, simplemente especifica el ID del trabajo que deseas. Si ejecutas fg sin opciones, traerá de vuelta el trabajo en segundo plano más reciente (el trabajo con el signo + junto a él)\n\n<pre>$ fg %1</pre>\n\n<b>Matar trabajos en segundo plano</b>\n\nSimilar a mover trabajos del segundo plano, puedes usar la misma forma para matar los procesos utilizando su ID de trabajo.\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "¿Qué comando se utiliza para listar los trabajos en segundo plano?",
          "slug": "controltrabajos",
          "title": "Control de trabajos"
        }
      ],
      "slug": "procesos",
      "title": "Procesos"
    },
    {
      "description": "Aprenda todo sobre las herramientas de gestión de paquetes dpkg, apt-get, rpm y yum.",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "Tu sistema está compuesto por muchos paquetes como navegadores de internet, editores de texto, reproductores multimedia, etc. Estos paquetes son gestionados a través de gestores de paquetes, que instalan y mantienen el software en tu sistema. Sin embargo, no todos los paquetes se instalan a través de gestores de paquetes, comúnmente puedes instalar paquetes directamente desde su código fuente (pronto veremos eso). La mayoría de las veces usarás un gestor de paquetes para instalar software, las variedades más comunes de paquetes son Debian (.deb) y Red Hat (.rpm). Los paquetes de estilo Debian se utilizan en distribuciones como Debian, Ubuntu, LinuxMint, etc. Los paquetes de estilo Red Hat se ven en Red Hat Enterprise Linux, Fedora, CentOS, etc.\n\n¿Qué son los paquetes? Puedes conocerlos como Chrome, Photoshop, etc., pero en realidad son simplemente muchos archivos que han sido compilados en uno solo. Las personas (o a veces una sola persona) que escriben este software son conocidas como <b>proveedores de origen</b>, compilan su código y escriben cómo instalarlo. Estos proveedores de origen trabajan en sacar nuevo software y actualizar el software existente. Cuando están listos para lanzarlo al mundo, envían su paquete a los <b>mantenedores de paquetes</b>, quienes se encargan de poner este software en manos de los usuarios. Estos mantenedores de paquetes revisan, gestionan y distribuyen este software en forma de paquetes.",
          "quizAnswer": "",
          "quizQuestion": "¡Sin preguntas, sigue adelante!",
          "slug": "softwaredistribution",
          "title": "Distribución de Software"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 2,
          "lessonContent": "¿Cómo es que los paquetes que se suben a internet terminan en nuestros ordenadores? ¿Vas a la página de descarga de cada paquete que deseas y haces clic en descargar e instalar? Bueno, en realidad puedes hacer eso, pero hay algo mejor llamado repositorios de paquetes. Los repositorios son simplemente ubicaciones de almacenamiento central para paquetes. Hay un montón de repositorios que contienen muchos paquetes y lo mejor de todo es que todos se encuentran en internet, sin discos de instalación tontos. Tu máquina no sabe dónde buscar estos repositorios a menos que le digas explícitamente dónde buscar.\n\nPor ejemplo, digamos que quiero el software WackyWidgets en mi máquina. Bueno, WackyWidgets gestiona sus propios repositorios para sus paquetes de widgets, dentro de este repositorio hay 10 paquetes, el paquete CoolWidget, el paquete SuperWidget, etc. WackyWidgets aloja este repositorio en un enlace de origen llamado: http://download.widgets/linux/deb/\n\nAhora, en lugar de ir a su sitio web para descargar el paquete directamente, puedes decirle a tu máquina que busque el software de WackyWidgets desde el enlace de origen.\n\nTu distribución ya viene con fuentes preaprobadas para obtener paquetes y así es como instala todos los paquetes base que ves en tu sistema. En un sistema Debian, este archivo de fuentes es el archivo <b>/etc/apt/sources.list</b>. Tu máquina sabrá buscar allí y comprobará si has añadido algún repositorio de origen.",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "¿Dónde se encuentra el archivo de fuentes en un sistema Debian?",
          "slug": "repositoriosdepaquetes",
          "title": "Repositorios de paquetes"
        },
        {
          "exercise": "Familiarízate con la documentación de tar y mira las otras opciones disponibles en la página del manual.",
          "id": 3,
          "lessonContent": "Antes de meternos en la instalación de paquetes y los diferentes gestores, necesitamos hablar sobre archivar y comprimir archivos, porque probablemente te encuentres con esto cuando busques software en internet. \n\nProbablemente ya sepas qué es un archivo comprimido, es probable que hayas encontrado tipos de archivo como .rar y .zip. Estos son archivos que contienen muchos archivos en su interior, pero vienen en un único archivo conocido como archivo comprimido.\n\n<b>Comprimiendo archivos con gzip</b>\n\ngzip es un programa utilizado para comprimir archivos en Linux, tienen la extensión .gz. \n\nPara comprimir un archivo:\n<pre>$ gzip micoolarchivo</pre>\n\nPara descomprimir el archivo:\n<pre>$ gunzip micoolarchivo.gz</pre>\n\n<b>Creando archivos con tar</b>\nDesafortunadamente, gzip no puede añadir múltiples archivos en un solo archivo para nosotros. Afortunadamente tenemos el programa tar que sí puede. Cuando creas un archivo usando tar, tendrá la extensión .tar. \n\n<pre>$ tar cvf mifichero.tar micoolarchivo1 micoolarchivo2</pre>\n\n<ul>\n<li>c - crear</li>\n<li>v - indica al programa que sea detallado y nos muestre lo que está haciendo</li>\n<li>f - el nombre del archivo tar tiene que venir después de esta opción, si estás creando un archivo tar tendrás que inventar un nombre</li>\n</ul>\n\n<b>Desempaquetando archivos con tar</b>\n\nPara extraer el contenido de un archivo tar, usa: \n\n<pre>$ tar xvf mifichero.tar</pre>\n\n<ul>\n<li>x - extraer</li>\n<li>v - indica al programa que sea detallado y nos muestre lo que está haciendo</li>\n<li>f - el archivo que quieres extraer</li>\n</ul>\n\n<b>Comprimiendo/descomprimiendo archivos con tar y gzip</b>\n\nMuchas veces verás un archivo tar que ha sido comprimido, como por ejemplo: micompresion.tar.gz, todo lo que necesitas hacer es trabajar de afuera hacia adentro, primero elimina la compresión con gunzip y luego puedes desempaquetar el archivo tar. O también puedes usar la opción <b>z</b> con tar, que simplemente le indica que use la utilidad gzip o gunzip.\n\nCrear un archivo tar comprimido:\n<pre>$ tar czf mifichero.tar.gz</pre>\n\nDescomprimir y desempaquetar: \n<pre>$ tar xzf archivo.tar</pre>\n\nSi necesitas ayuda, recuerda esto: e<b>X</b>traer todos los <b>Z</b>etas <b>F</b>icheros!\n\ntar es uno de esos comandos que es tan importante y sin embargo nunca lo recuerdas realmente, relevante xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>Otras Utilidades</b>\n\nA lo largo de tu viaje por Linux, te encontrarás con otros tipos de archivos y compresión como: bzip2, compress, zip, unzip, etc. Son un poco menos comunes, pero ten en cuenta que diferentes utilidades requerirán diferentes comandos.",
          "quizAnswer": "c",
          "quizQuestion": "¿Qué bandera de tar se utiliza para crear archivos?",
          "slug": "archivocomprimidostar",
          "title": "tar and gzip"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "Los paquetes rara vez funcionan por sí solos, la mayoría de las veces están acompañados de dependencias para ayudarlos a ejecutarse. Por ejemplo, digamos que tenemos un grupo de restaurantes, estos restaurantes ofrecen diferentes tipos de cocina, sin embargo, todos obtienen sus ingredientes de la misma granja. Su comida depende de los suministros de la granja, si la granja dejara de suministrar alimentos de repente, los restaurantes estarían en un estado bastante malo. \n\nEn Linux, estas dependencias suelen ser otros paquetes o bibliotecas compartidas. Las bibliotecas compartidas son conjuntos de código que otros programas desean utilizar y no quieren tener que volver a escribir por sí mismos. Piensa de nuevo en el restaurante, ¿cuánto trabajo sería si cada restaurante también cultivara su propia comida? Demasiado.\n\nProfundizaremos más en las bibliotecas compartidas en el curso de sistemas de archivos, así que por ahora solo recuerda que los paquetes tienen dependencias para ayudarlos a ejecutarse, ya sea que esas dependencias sean otros paquetes o bibliotecas, si las dependencias no están presentes, el paquete terminará en un estado roto y la mayoría de las veces ni siquiera se instalará.",
          "quizAnswer": "",
          "quizQuestion": "¡Sin preguntas, sigue adelante!",
          "slug": "dependenciasdepaquetes",
          "title": "Dependencias de Paquetes"
        },
        {
          "exercise": "Encuentra un programa que desees instalar en tu sistema como Google Chrome e instálalo usando uno de estos comandos.",
          "id": 5,
          "lessonContent": "Aunque la mayor parte de este curso trata sobre sistemas de gestión de paquetes (los Batmans de la gestión de paquetes), no debemos olvidar a los Robins. Aunque son muy útiles y confiables, no vienen con ese dulce batimóvil y cinturón de utilidades.\n\nAl igual que .exe es un archivo ejecutable único, lo son .deb y .rpm. Normalmente no los verías si usas repositorios de paquetes, pero si descargas paquetes directamente, lo más probable es que los obtengas en estos formatos populares. Obviamente, son exclusivos de sus distribuciones, .deb para las basadas en Debian y .rpm para las basadas en Red Hat.\n\nPara instalar estos paquetes directos, puedes usar los comandos de gestión de paquetes: rpm y dpkg. Estas herramientas se utilizan para instalar archivos de paquetes, sin embargo, no instalarán las dependencias del paquete, por lo que si tu paquete tenía 10 dependencias, tendrías que instalar esos paquetes por separado y luego sus dependencias y así sucesivamente. Como puedes ver, esa fue una de las razones que dio lugar a los sistemas de gestión completos que discutiremos más adelante.\n\nTen en cuenta que habrá innumerables ocasiones en las que necesitarás instalar, consultar o verificar un paquete con una de estas herramientas, así que recuerda estos comandos.\n\n<b>Instalar un paquete</b>\n\n<pre>\nDebian: $ dpkg -i some_deb_package.deb\nRPM: $ rpm -i some_rpm_package.rpm\n</pre>\n\nLa <b>i</b> significa instalar. También puedes usar el formato más largo de --install.\n\n<b>Eliminar un paquete</b>\n\n<pre>\nDebian: $ dpkg -r some_deb_package.deb\nRPM: $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian: <b>r</b> para eliminar\nRPM: <b>e</b> para borrar\n\n<b>Lista de paquetes instalados</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> para listar\nRPM: <b>q</b> para consultar y <b>a</b> para todos",
          "quizAnswer": "dpkg",
          "quizQuestion": "¿Cuál es la herramienta de gestión de paquetes para archivos .deb?",
          "slug": "herramientasinstalacionpaquetes",
          "title": "rpm and dpkg"
        },
        {
          "exercise": "Ejecuta cada uno de estos comandos de paquete y observa la salida que recibes.",
          "id": 6,
          "lessonContent": "Ah, los Batmans de la gestión de paquetes, estos sistemas vienen con todo lo necesario para facilitar la instalación, eliminación y cambios de paquetes, incluida la instalación de dependencias de paquetes. Dos de los sistemas de gestión más populares son <b>yum</b> y <b>apt</b>. Yum es exclusivo de la familia Red Hat y apt es exclusivo de la familia Debian.\n\n<b>Instalar un paquete desde un repositorio</b>\n\n<pre>\nDebian: $ apt install nombre_paquete\nRPM: $ yum install nombre_paquete\n</pre>\n\n<b>Eliminar un paquete</b>\n\n<pre>\nDebian: $ apt remove nombre_paquete\nRPM: $ yum erase nombre_paquete\n</pre>\n\n<b>Actualizar paquetes de un repositorio</b>\n\nSiempre es mejor práctica actualizar los repositorios de paquetes para que estén actualizados antes de instalar y actualizar un paquete.\n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>Obtener información sobre un paquete instalado</b>\n\n<pre>\nDebian: apt show nombre_paquete\nRPM: yum info nombre_paquete\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "¿Qué comando se utiliza para mostrar información del paquete en un sistema Debian?",
          "slug": "sistemasdegestiondepaquetes",
          "title": "yum y apt"
        },
        {
          "exercise": "Encuentra un programa de código fuente (de un sitio confiable) e instálalo desde el código fuente.",
          "id": 7,
          "lessonContent": "A menudo te encontrarás con un paquete oscuro que solo viene en forma de código fuente puro. Necesitarás usar algunos comandos para compilar e instalar ese paquete de código fuente en tu sistema. \n\nLo primero es lo primero, necesitarás tener software para instalar las herramientas que te permitirán compilar código fuente. \n\n<pre>$ sudo apt install build-essential</pre>\n\nUna vez que hagas eso, extrae el contenido del archivo del paquete, probablemente un archivo .tar.gz. \n\n<pre>$ tar -xzvf paquete.tar.gz</pre>\n\nAntes de hacer cualquier cosa, echa un vistazo al archivo README o INSTALL dentro del paquete. A veces habrá instrucciones de instalación específicas. \n\nDependiendo del método de compilación que haya utilizado el desarrollador, tendrás que usar diferentes comandos, como cmake u otro.\n\nSin embargo, lo más común es que veas una compilación básica con make, así que discutiremos eso:\n\nDentro del contenido del paquete habrá un script de configuración, este script verifica las dependencias en tu sistema y si te falta algo, verás un error y tendrás que solucionar esas dependencias. \n\n<pre>$ ./configure</pre>\n\nEl <b>./</b> te permite ejecutar un script en el directorio actual. \n\n<pre>$ make</pre>\n\nDentro del contenido del paquete, hay un archivo llamado Makefile que contiene reglas para construir el software. Cuando ejecutas el comando make, mira este archivo para construir el software.\n\n<pre>$ sudo make install</pre>\n\nEste comando realmente instala el paquete, copiará los archivos correctos en las ubicaciones correctas de tu computadora.\n\nSi deseas desinstalar el paquete, usa:\n\n<pre>$ sudo make uninstall</pre>\n\nTen cuidado al usar make install, es posible que no te des cuenta de todo lo que está sucediendo en segundo plano. Si decides eliminar este paquete, es posible que en realidad no elimines todo porque no te diste cuenta de lo que se agregó a tu sistema. En su lugar, olvida todo sobre make install que te acabo de explicar y usa el comando <b>checkinstall</b>. Este comando creará un archivo .deb para que puedas instalar y desinstalar fácilmente. \n\n<pre>$ sudo checkinstall</pre> \n\nEste comando esencialmente \"make install\" y construirá un paquete .deb e instalará. Esto facilita la eliminación del paquete más adelante.",
          "quizAnswer": "checkinstall",
          "quizQuestion": "¿Qué deberías usar siempre en lugar de make install?",
          "slug": "compilarcodigofuente",
          "title": "Compilar Código Fuente"
        }
      ],
      "slug": "paquetes",
      "title": "Paquetes"
    },
    {
      "description": "Aprenda sobre los dispositivos Linux y cómo interactúan con el kernel y el espacio de usuario.",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "Echa un vistazo al contenido del directorio /dev, ¿reconoces algún dispositivo familiar?",
          "id": 1,
          "lessonContent": "Cuando conectas un dispositivo a tu máquina, generalmente necesita un controlador de dispositivo para funcionar correctamente. Puedes interactuar con los controladores de dispositivo a través de archivos de dispositivo o nodos de dispositivo, que son archivos especiales que se ven como archivos regulares. Dado que estos archivos de dispositivo son como archivos regulares, puedes usar programas como ls, cat, etc. para interactuar con ellos. Estos archivos de dispositivo generalmente se almacenan en el directorio /dev. Adelante y haz ls en el directorio /dev de tu sistema, verás una gran cantidad de archivos de dispositivos en tu sistema. \n\n<pre>$ ls /dev </pre>\n\nAlgunos de estos dispositivos ya los has utilizado e interactuado con ellos, como /dev/null. Recuerda que cuando enviamos la salida a /dev/null, el kernel sabe que este dispositivo toma toda nuestra entrada y simplemente la descarta, por lo que no se devuelve nada.\n\nEn los viejos tiempos, si querías agregar un dispositivo a tu sistema, agregabas el archivo de dispositivo en /dev y probablemente lo olvidabas. Bueno, repite eso un par de veces y verás dónde estaba el problema. El directorio /dev se llenaría de archivos de dispositivos estáticos de dispositivos que ya has actualizado, dejado de usar, etc. Los dispositivos también se les asignan archivos de dispositivo en el orden en que el kernel los encuentra. Por lo tanto, si cada vez que reiniciabas tu sistema, los dispositivos podían tener diferentes archivos de dispositivo dependiendo de cuándo se descubrieron.\n\nAfortunadamente, ya no usamos ese método, ahora tenemos algo que usamos para agregar y quitar dinámicamente dispositivos que se están utilizando actualmente en el sistema y lo discutiremos en las próximas lecciones.",
          "quizAnswer": "/dev",
          "quizQuestion": "¿Dónde se almacenan los archivos de dispositivo en el sistema?",
          "slug": "devdirectory",
          "title": "/dev directorio"
        },
        {
          "exercise": "Mira tu directorio /dev y descubre qué tipos de dispositivos puedes ver.",
          "id": 2,
          "lessonContent": "Antes de hablar sobre cómo se gestionan los dispositivos, veamos algunos dispositivos en realidad.\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\nLas columnas son las siguientes de izquierda a derecha:\n\n<ul>\n<li>Permisos</li>\n<li>Propietario</li>\n<li>Grupo</li>\n<li>Número de dispositivo principal</li>\n<li>Número de dispositivo secundario</li>\n<li>Marca de tiempo</li>\n<li>Nombre del dispositivo</li>\n</ul>\n\nRecuerda que en el comando ls puedes ver el tipo de archivo con el primer bit de cada línea. Los archivos de dispositivo se indican de la siguiente manera: \n\n<ul>\n<li>c - carácter</li>\n<li>b - bloque</li>\n<li>p - tubería</li>\n<li>s - socket</li>\n</ul>\n\n<b>Dispositivo de Carácter</b>\n\nEstos dispositivos transfieren datos, pero uno a la vez. Verás muchos dispositivos pseudo (/dev/null) como dispositivos de carácter, estos dispositivos no están realmente conectados físicamente a la máquina, pero permiten una mayor funcionalidad al sistema operativo. \n\n<b>Dispositivo de Bloque</b>\n\nEstos dispositivos transfieren datos, pero en bloques grandes de tamaño fijo. Comúnmente verás dispositivos que utilizan bloques de datos como dispositivos de bloque, como discos duros, sistemas de archivos, etc. \n\n<b>Dispositivo de Tubería</b>\n\nLas tuberías nombradas permiten que dos o más procesos se comuniquen entre sí, son similares a los dispositivos de carácter, pero en lugar de enviar la salida a un dispositivo, se envía a otro proceso. \n\n<b>Dispositivo de Socket</b>\n\nLos dispositivos de socket facilitan la comunicación entre procesos, similar a los dispositivos de tubería pero pueden comunicarse con muchos procesos a la vez. \n\n<b>Caracterización de Dispositivos</b>\n\nLos dispositivos se caracterizan utilizando dos números, <b>número de dispositivo principal</b> y <b>número de dispositivo secundario</b>. Puedes ver estos números en el ejemplo de ls anterior, están separados por una coma. Por ejemplo, supongamos que un dispositivo tuviera los números de dispositivo: <b>8, 0</b>:\n\nEl número de dispositivo principal representa el controlador de dispositivo que se utiliza, en este caso 8, que a menudo es el número principal para los dispositivos de bloque sd. El número secundario le indica al kernel qué dispositivo único es en esta clase de controlador, en este caso se usa 0 para representar el primer dispositivo (a).",
          "quizAnswer": "c",
          "quizQuestion": "¿Cuál es el símbolo para los dispositivos de carácter en el comando ls -l?",
          "slug": "tiposdedispositivos",
          "title": "tipos de dispositivos"
        },
        {
          "exercise": "Escribe en los dispositivos pseudo y observa qué sucede, ¡ten cuidado de no escribir en tus discos en esos dispositivos!",
          "id": 3,
          "lessonContent": "Aquí están los nombres de dispositivos más comunes que encontrarás: \n\n<b>Dispositivos SCSI</b>\n\nSi tienes algún tipo de almacenamiento masivo en tu máquina, lo más probable es que esté utilizando el protocolo SCSI (pronunciado \"scuzzy\"). SCSI significa Interfaz de Sistema Pequeño de Computadora, es un protocolo utilizado para permitir la comunicación entre discos, impresoras, escáneres y otros periféricos a tu sistema. Es posible que hayas oído hablar de dispositivos SCSI que en realidad no se utilizan en sistemas modernos, sin embargo, nuestros sistemas Linux corresponden los discos SCSI con unidades de disco duro en /dev. Se representan con un prefijo de sd (disco SCSI):\n\nArchivos de dispositivos SCSI comunes:\n\n<ul>\n<li>/dev/sda - Primer disco duro</li>\n<li>/dev/sdb - Segundo disco duro</li>\n<li>/dev/sda3 - Tercera partición en el primer disco duro</li>\n</ul>\n\n<b>Dispositivos Pseudo</b>\n\nComo discutimos anteriormente, los dispositivos pseudo no están realmente conectados físicamente a tu sistema, los dispositivos pseudo más comunes son dispositivos de caracteres: \n\n<ul>\n<li>/dev/zero - acepta y descarta toda la entrada, produce un flujo continuo de bytes NULL (valor cero)</li>\n<li>/dev/null - acepta y descarta toda la entrada, no produce ninguna salida</li>\n<li>/dev/random - produce números aleatorios</li>\n</ul>\n\n<b>Dispositivos PATA</b>\n\nA veces, en sistemas más antiguos, es posible que veas que los discos duros se refieren con un prefijo hd: \n\n<ul>\n<li>/dev/hda - Primer disco duro</li>\n<li>/dev/hdd2 - Segunda partición en el cuarto disco duro</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "¿Cuál sería comúnmente el nombre de dispositivo para la primera partición en el segundo disco SCSI?",
          "slug": "nombresdedispositivos",
          "title": "Nombres de Dispositivos"
        },
        {
          "exercise": "Eche un vistazo al contenido del directorio /sys y vea qué archivos se encuentran allí.",
          "id": 4,
          "lessonContent": "Sysfs se creó hace mucho tiempo para gestionar mejor los dispositivos en nuestro sistema que el directorio /dev no podía manejar. Sysfs es un sistema de archivos virtual, montado más a menudo en el directorio /sys. Nos proporciona información más detallada de la que podríamos ver en el directorio /dev. Ambos directorios /sys y /dev parecen ser muy similares y lo son en algunos aspectos, pero tienen diferencias importantes. Básicamente, el directorio /dev es simple, permite que otros programas accedan a los dispositivos mismos, mientras que el sistema de archivos /sys se utiliza para ver información y gestionar el dispositivo. \n\nEl sistema de archivos /sys contiene básicamente toda la información de todos los dispositivos en su sistema, como el fabricante y modelo, dónde está conectado el dispositivo, el estado del dispositivo, la jerarquía de dispositivos y más. Los archivos que ve aquí no son nodos de dispositivo, por lo que realmente no interactúa con los dispositivos desde el directorio /sys, más bien está gestionando dispositivos. \n\nEche un vistazo al contenido del directorio /sys:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "¿Qué directorio se utiliza para ver información detallada sobre dispositivos?",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "Ejecuta el comando udevadm dado y revisa la entrada.",
          "id": 5,
          "lessonContent": "En los viejos tiempos y en realidad hoy en día, si realmente quisieras, crearías nodos de dispositivo usando un comando como: \n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nEste comando creará un nodo de dispositivo /dev/sdb1 y lo convertirá en un dispositivo de bloques (b) con un número mayor de 8 y un número menor de 3.\n\nPara eliminar un dispositivo, simplemente <b>rm</b> el archivo del dispositivo en el directorio /dev. \n\nAfortunadamente, realmente ya no necesitamos hacer esto gracias a udev. El sistema udev crea y elimina dinámicamente archivos de dispositivo para nosotros dependiendo de si están conectados o no. Hay un demonio udevd que se ejecuta en el sistema y escucha mensajes del kernel sobre dispositivos conectados al sistema. Udevd analizará esa información y la emparejará con las reglas especificadas en /etc/udev/rules.d, dependiendo de esas reglas es muy probable que cree nodos de dispositivo y enlaces simbólicos para los dispositivos. Puedes escribir tus propias reglas de udev, pero eso está un poco fuera del alcance de esta lección. Afortunadamente, tu sistema ya viene con muchas reglas de udev, por lo que es posible que nunca necesites escribir las tuyas.\n\nTambién puedes ver la base de datos de udev y sysfs usando el comando <b>udevadm</b>. Esta herramienta es muy útil, pero a veces puede volverse muy confusa, un comando simple para ver información de un dispositivo sería:\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "¿Qué agrega y elimina dispositivos dinámicamente?",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "Prueba cada uno de estos comandos y observa la salida que recibes.",
          "id": 6,
          "lessonContent": "Al igual que usaríamos el comando ls para listar archivos y directorios, podemos usar herramientas similares que listan información sobre dispositivos.\n\n<b>Listado de Dispositivos USB</b>\n\n<pre>$ lsusb </pre>\n\n<b>Listado de Dispositivos PCI</b>\n\n<pre>$ lspci </pre>\n\n<b>Listado de Dispositivos SCSI</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "¿Qué comando se puede utilizar para ver dispositivos usb?",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "Utiliza el comando dd para hacer una copia de seguridad de tu unidad y establece la salida en un archivo .img.",
          "id": 7,
          "lessonContent": "La herramienta dd es súper útil para convertir y copiar datos. Lee la entrada desde un archivo o flujo de datos y la escribe en un archivo o flujo de datos. \n\nConsidera el siguiente comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nEste comando está copiando el contenido de backup.img a /dev/sdb. Copiará los datos en bloques de 1024 bytes hasta que no haya más datos por copiar. \n\n<ul>\n<li>if=archivo - Archivo de entrada, lee desde un archivo en lugar de la entrada estándar</li>\n<li>of=archivo - Archivo de salida, escribe en un archivo en lugar de la salida estándar</li>\n<li>bs=bytes - Tamaño de bloque, lee y escribe esta cantidad de bytes de datos a la vez. Puedes usar diferentes métricas de tamaño indicando el tamaño con una k para kilobyte, m para megabyte, etc., por lo que 1024 bytes son 1k</li>\n<li>count=número - Número de bloques a copiar.</li>\n</ul>\n\nVerás algunos comandos dd que usan la opción count, generalmente con dd if deseas copiar un archivo que es de 1 megabyte, generalmente querrás ver ese archivo como 1 megabyte cuando haya terminado de copiarse. Digamos que ejecutas el siguiente comando: \n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\nNuestro archivo backup.img es de 10M, sin embargo, en este comando estamos diciendo que copie 1M 2 veces, por lo que solo se copian 2M, dejando nuestros datos copiados incompletos. La opción count puede ser útil en muchas situaciones, pero si solo estás copiando datos, puedes omitir count y también bs. Si realmente quieres optimizar tus transferencias de datos, entonces querrás empezar a usar esas opciones.\n\ndd es extremadamente poderoso, puedes usarlo para hacer copias de seguridad de cualquier cosa, incluidas unidades de disco completas, restaurar imágenes de disco y más. Ten cuidado, esa herramienta poderosa puede tener un precio si no estás seguro de lo que estás haciendo.",
          "quizAnswer": "bs",
          "quizQuestion": "¿Cuál es la opción de dd para el tamaño de bloque?",
          "slug": "comandodd",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Dispositivos"
    },
    {
      "description": "Aprende sobre el sistema de archivos de Linux, los diferentes tipos de sistemas de archivos, particionamiento y más.",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "Mira dentro de tu directorio /usr, ¿qué tipo de información se encuentra allí?",
          "id": 1,
          "lessonContent": "En este punto, probablemente estés bastante familiarizado con la estructura de directorios de tu sistema, si no, pronto lo estarás. Los sistemas de archivos pueden variar en cómo están estructurados, pero en su mayor parte deberían cumplir con el Estándar de Jerarquía del Sistema de Archivos. \n\nAdelante y haz un <b>ls -l /</b> para ver los directorios listados bajo el directorio raíz, el tuyo puede verse diferente al mío, pero los directorios deberían parecerse en su mayor parte a lo siguiente:\n\n<ul>\n<li>/ - El directorio raíz de toda la jerarquía del sistema de archivos, todo está anidado bajo este directorio.</li>\n<li>/bin - Programas esenciales listos para ejecutarse (binarios), incluye los comandos más básicos como ls y cp.</li>\n<li>/boot - Contiene archivos del cargador de arranque del kernel.</li>\n<li>/dev - Archivos de dispositivos.</li>\n<li>/etc - Directorio de configuración del sistema central, solo debería contener archivos de configuración y no binarios.</li>\n<li>/home - Directorios personales para usuarios, contiene tus documentos, archivos, configuraciones, etc.</li>\n<li>/lib - Contiene archivos de biblioteca que los binarios pueden usar.</li>\n<li>/media - Utilizado como punto de conexión para medios extraíbles como unidades USB.</li>\n<li>/mnt - Sistemas de archivos montados temporalmente.</li>\n<li>/opt - Paquetes de software de aplicación opcionales.</li>\n<li>/proc - Información sobre los procesos en ejecución actualmente.</li>\n<li>/root - Directorio de inicio del usuario root.</li>\n<li>/run - Información sobre el sistema en ejecución desde el último arranque.</li>\n<li>/sbin - Contiene binarios esenciales del sistema, generalmente solo pueden ser ejecutados por root.</li>\n<li>/srv - Datos específicos del sitio que son servidos por el sistema.</li>\n<li>/tmp - Almacenamiento para archivos temporales.</li>\n<li>/usr - Lamentablemente nombrado, la mayoría de las veces no contiene archivos de usuario en el sentido de una carpeta de inicio. Esto está destinado para software y utilidades instalados por el usuario, sin embargo, eso no significa que no puedas agregar directorios personales allí. Dentro de este directorio hay subdirectorios para /usr/bin, /usr/local, etc.</li>\n<li>/var - Directorio variable, se utiliza para el registro del sistema, seguimiento de usuarios, cachés, etc. Básicamente cualquier cosa que esté sujeta a cambios todo el tiempo.</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "¿En qué directorio se almacenan los registros?",
          "slug": "jerarquiadelsistemaarchivos",
          "title": "Jerarquía del sistema de archivos"
        },
        {
          "exercise": "Investiga un poco en línea sobre los otros tipos de sistemas de archivos: ReiserFS, ZFS, JFS y otros que puedas encontrar.",
          "id": 2,
          "lessonContent": "Existen muchas implementaciones de sistemas de archivos disponibles. Algunos son más rápidos que otros, algunos admiten almacenamiento de mayor capacidad y otros solo funcionan en almacenamientos de menor capacidad. Los diferentes sistemas de archivos tienen diferentes formas de organizar sus datos y entraremos en detalle sobre qué tipos de sistemas de archivos existen. Dado que hay tantas implementaciones diferentes disponibles, las aplicaciones necesitan una forma de lidiar con las diferentes operaciones. Por lo tanto, existe algo llamado la capa de abstracción del Sistema de Archivos Virtual (VFS). Es una capa entre las aplicaciones y los diferentes tipos de sistemas de archivos, por lo que no importa qué sistema de archivos tengas, tus aplicaciones podrán trabajar con él. \n\nPuedes tener muchos sistemas de archivos en tus discos, dependiendo de cómo estén particionados y lo veremos en una lección próxima.\n\n<b>Registro</b>\n\nEl registro viene por defecto en la mayoría de los tipos de sistemas de archivos, pero en caso de que no lo tenga, debes saber qué hace. Digamos que estás copiando un archivo grande y de repente se corta la energía. Bueno, si estás en un sistema de archivos sin registro, el archivo terminaría dañado y tu sistema de archivos sería inconsistente y luego, al reiniciar, tu sistema realizaría una comprobación del sistema de archivos para asegurarse de que todo esté bien. Sin embargo, las reparaciones podrían llevar un tiempo dependiendo de cuán grande sea tu sistema de archivos. \n\nAhora, si estuvieras en un sistema con registro, antes de que tu máquina comience a copiar el archivo, escribirá lo que vas a hacer en un archivo de registro (registro). Ahora, cuando realmente copies el archivo, una vez que se complete, el registro marcará esa tarea como completada. El sistema de archivos siempre está en un estado consistente debido a esto, por lo que sabrá exactamente dónde lo dejaste si tu máquina se apaga repentinamente. Esto también reduce el tiempo de arranque porque en lugar de verificar todo el sistema de archivos, solo mira tu registro.\n\n<b>Tipos Comunes de Sistemas de Archivos de Escritorio</b>\n\n<ul>\n<li>ext4 - Esta es la versión más actual de los sistemas de archivos nativos de Linux. Es compatible con las versiones anteriores ext2 y ext3. Admite volúmenes de disco de hasta 1 exabyte y tamaños de archivo de hasta 16 terabytes y mucho más. Es la opción estándar para los sistemas de archivos de Linux.</li>\n<li>Btrfs - \"Mejor o Butter FS\", es un nuevo sistema de archivos para Linux que viene con instantáneas, copias de seguridad incrementales, aumento de rendimiento y mucho más. Está ampliamente disponible, pero aún no es del todo estable y compatible.</li>\n<li>XFS - Sistema de archivos de registro de alto rendimiento, ideal para un sistema con archivos grandes como un servidor multimedia.</li>\n<li>NTFS y FAT - Sistemas de archivos de Windows</li>\n<li>HFS+ - Sistema de archivos de Macintosh</li>\n</ul>\n\nConsulta qué sistemas de archivos hay en tu máquina: \n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\nEl comando <b>df</b> informa sobre el uso del espacio en disco del sistema de archivos y otros detalles sobre tu disco, hablaremos más sobre esta herramienta más adelante.",
          "quizAnswer": "ext4",
          "quizQuestion": "¿Cuál es el tipo de sistema de archivos Linux común?",
          "slug": "tipos-de-sistemas-de-archivos",
          "title": "Tipos de Sistemas de Archivos"
        },
        {
          "exercise": "Ejecuta <b>parted -l</b> en tu máquina y evalúa tus resultados.",
          "id": 3,
          "lessonContent": "Los discos duros se pueden subdividir en particiones, lo que básicamente crea múltiples dispositivos de bloques. Recuerda ejemplos como /dev/sda1 y /dev/sda2, donde /dev/sda es el disco completo, pero /dev/sda1 es la primera partición en ese disco. Las particiones son extremadamente útiles para separar datos y si necesitas un determinado sistema de archivos, puedes crear fácilmente una partición en lugar de hacer que todo el disco sea de un solo tipo de sistema de archivos.\n\n<b>Tabla de Particiones</b>\n\nCada disco tendrá una tabla de particiones, la cual le indica al sistema cómo está particionado el disco. Esta tabla te dice dónde comienzan y terminan las particiones, cuáles son arrancables, qué sectores del disco están asignados a qué partición, etc. Hay dos esquemas principales de tablas de particiones utilizados, Registro de Arranque Principal (MBR) y Tabla de Partición GUID (GPT).\n\n<b>Partición</b>\n\nLos discos están compuestos por particiones que nos ayudan a organizar nuestros datos. Puedes tener múltiples particiones en un disco y no pueden superponerse entre sí. Si hay espacio no asignado a una partición, se conoce como espacio libre. Los tipos de particiones dependen de tu tabla de particiones. Dentro de una partición, puedes tener un sistema de archivos o dedicar una partición a otras cosas como swap (llegaremos a eso pronto).\n\n<i>MBR</i>\n\n<ul>\n<li>Tabla de particiones tradicional, solía ser el estándar</li>\n<li>Puede tener particiones primarias, extendidas y lógicas</li>\n<li>MBR tiene un límite de cuatro particiones primarias</li>\n<li>Se pueden crear particiones adicionales convirtiendo una partición primaria en una partición extendida (solo puede haber una partición extendida en un disco). Luego, dentro de la partición extendida, se agregan particiones lógicas. Las particiones lógicas se utilizan como cualquier otra partición. Un poco tonto, lo sé.</li>\n<li>Admite discos de hasta 2 terabytes</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>La Tabla de Partición GUID (GPT) se está convirtiendo en el nuevo estándar para la partición de discos</li>\n<li>Tiene solo un tipo de partición y puedes crear muchas de ellas</li>\n<li>Cada partición tiene un ID único a nivel global (GUID)</li>\n<li>Se utiliza principalmente en conjunto con el arranque basado en UEFI (entraremos en detalles en otro curso)</li>\n</ul>\n\n<b>Estructura del Sistema de Archivos</b>\n\nSabemos por nuestra lección anterior que un sistema de archivos es una colección organizada de archivos y directorios. En su forma más simple, está compuesto por una base de datos para administrar archivos y los propios archivos, sin embargo, vamos a entrar en un poco más de detalle.\n\n<ul>\n<li>Bloque de arranque - Este se encuentra en los primeros sectores del sistema de archivos y realmente no es utilizado por el sistema de archivos. En cambio, contiene información utilizada para arrancar el sistema operativo. Solo se necesita un bloque de arranque por el sistema operativo. Si tienes múltiples particiones, tendrán bloques de arranque, pero muchos de ellos no se utilizan.</li>\n<li>Super bloque - Este es un solo bloque que viene después del bloque de arranque, y contiene información sobre el sistema de archivos, como el tamaño de la tabla de inodos, el tamaño de los bloques lógicos y el tamaño del sistema de archivos.</li>\n<li>Tabla de inodos - Piensa en esto como la base de datos que administra nuestros archivos (tenemos una lección completa sobre inodos, así que no te preocupes). Cada archivo o directorio tiene una entrada única en la tabla de inodos y contiene información variada sobre el archivo.</li>\n<li>Bloques de datos - Estos son los datos reales de los archivos y directorios.</li>\n</ul>\n\nEchemos un vistazo a las diferentes tablas de particiones. A continuación se muestra un ejemplo de una partición utilizando la tabla de particiones MBR (msdos). Puedes ver las particiones primarias, extendidas y lógicas en la máquina.\n\n<pre>\npete@icebox:~$ sudo parted -l\nModelo: Seagate (scsi)\nDisco /dev/sda: 21.5GB\nTamaño del sector (lógico/físico): 512B/512B\nTabla de particiones: msdos\n\nNúmero  Inicio   Fin     Tamaño    Tipo      Sistema de archivos     Banderas\n 1      1049kB  6860MB  6859MB    primaria   ext4                    arranque\n 2      6861MB  21.5GB  14.6GB    extendida\n 5      6861MB  7380MB  519MB     lógica     linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB    lógica     xfs\n</pre>\n\n\nEste ejemplo es de GPT, utilizando solo un ID único para las particiones.\n\n<pre>\nModelo: Thumb Drive (scsi)\nDisco /dev/sdb: 4041MB\nTamaño del sector (lógico/físico): 512B/512B\nTabla de particiones: gpt\n\nNúmero  Inicio   Fin     Tamaño    Sistema de archivos  Nombre        Banderas\n 1      17.4kB  1000MB  1000MB                    first\n 2      1000MB  4040MB  3040MB                    second\n</pre>",
          "quizAnswer": "extendida",
          "quizQuestion": "¿Qué tipo de partición se utiliza para crear más de 4 particiones en el esquema de particionamiento MBR?",
          "slug": "anatomyofadisk",
          "title": "Anatomía de un Disco"
        },
        {
          "exercise": "Particionar una unidad USB con la mitad del disco como ext4 y la otra mitad como espacio libre.",
          "id": 4,
          "lessonContent": "Vamos a hacer algunas cosas prácticas con sistemas de archivos trabajando a través del proceso en una unidad USB. Si no tienes una, no te preocupes, aún puedes seguir estas próximas lecciones. \n\nPrimero necesitaremos particionar nuestro disco. Hay muchas herramientas disponibles para hacer esto: \n\n<ul>\n<li>fdisk - herramienta básica de particionamiento de línea de comandos, no soporta GPT</li>\n<li>parted - esta es una herramienta de línea de comandos que soporta particionamiento tanto MBR como GPT</li>\n<li>gparted - esta es la versión con interfaz gráfica de parted</li>\n<li>gdisk - fdisk, pero no soporta MBR, solo GPT</li>\n</ul>\n\nVamos a usar parted para hacer nuestra partición. Digamos que conecto el dispositivo USB y vemos que el nombre del dispositivo es /dev/sdb2. \n\n<b>Iniciar parted</b>\n\n<pre>$ sudo parted</pre>\n\nEntrarás en la herramienta parted, aquí puedes ejecutar comandos para particionar tu dispositivo. \n\n<b>Seleccionar el dispositivo</b>\n\n<pre>select /dev/sdb2</pre>\n\nPara seleccionar el dispositivo con el que trabajarás, selecciónalo por su nombre de dispositivo.\n\n<b>Ver la tabla de particiones actual</b>\n\n<pre>\n(parted) print                                                            \nModelo: Seagate (scsi)\nDisco /dev/sda: 21.5GB\nTamaño de sector (lógico/físico): 512B/512B\nTabla de particiones: msdos\n\nNúmero  Inicio   Fin     Tamaño   Tipo      Sistema de archivos     Banderas\n 1      1049kB  6860MB  6859MB  primaria   ext4            arranque\n 2      6861MB  21.5GB  14.6GB  extendida\n 5      6861MB  7380MB  519MB   lógica   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  lógica   xfs\n</pre>\n\nAquí verás las particiones disponibles en el dispositivo. Los puntos de <b>inicio</b> y <b>fin</b> son donde las particiones ocupan espacio en el disco duro, querrás encontrar un buen lugar de inicio y fin para tus particiones. \n\n<b>Particionar el dispositivo</b>\n\n<pre>mkpart primaria 123 4567</pre>\n\nAhora solo elige un punto de inicio y fin y haz la partición, deberás especificar el tipo de partición dependiendo de la tabla que hayas usado. \n\n<b>Redimensionar una partición</b>\n\nTambién puedes redimensionar una partición si no tienes espacio. \n\n<pre>resize 2 1245 3456</pre>\n\nSelecciona el número de partición y luego los puntos de inicio y fin a los que deseas redimensionarla. \n\nParted es una herramienta muy poderosa y debes tener cuidado al particionar tus discos.",
          "quizAnswer": "mkpart",
          "quizQuestion": "¿Cuál es el comando de parted para hacer una partición?",
          "slug": "particionadodedisco",
          "title": "Particionado de disco"
        },
        {
          "exercise": "Crea un sistema de archivos ext4 en la unidad USB.",
          "id": 5,
          "lessonContent": "Ahora que realmente has particionado un disco, ¡vamos a crear un sistema de archivos!\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\n¡Tan simple como eso! La herramienta <b>mkfs</b> (make filesystem) nos permite especificar el tipo de sistema de archivos que queremos y dónde lo queremos. Solo querrás crear un sistema de archivos en un disco recién particionado o si estás reparticionando uno antiguo. Lo más probable es que dejes tu sistema de archivos en un estado corrupto si intentas crear uno encima de uno existente.",
          "quizAnswer": "mkfs",
          "quizQuestion": "¿Qué comando se utiliza para crear un sistema de archivos?",
          "slug": "creando-sistemas-archivos",
          "title": "Creando Sistemas de Archivos"
        },
        {
          "exercise": "Mire la página del manual para montar y desmontar y vea qué otras opciones puede usar.",
          "id": 6,
          "lessonContent": "Antes de poder ver el contenido de su sistema de archivos, tendrá que montarlo. Para hacer eso, necesitaré la ubicación del dispositivo, el tipo de sistema de archivos y un punto de montaje, el punto de montaje es un directorio en el sistema donde se va a adjuntar el sistema de archivos. Básicamente queremos montar nuestro dispositivo en un punto de montaje. \n\nPrimero cree el punto de montaje, en nuestro caso <b>mkdir /mydrive</b>\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\n¡Tan simple como eso! Ahora, cuando vayamos a /mydrive, podremos ver el contenido de nuestro sistema de archivos, el <b>-t</b> especifica el tipo de sistema de archivos, luego tenemos la ubicación del dispositivo y luego el punto de montaje. \n\nPara desmontar un dispositivo de un punto de montaje: \n\n<pre>$ sudo umount /mydrive \no \n$ sudo umount /dev/sdb2</pre>\n\nRecuerde que el kernel nombra los dispositivos en el orden en que los encuentra. ¿Qué pasa si el nombre de nuestro dispositivo cambia por alguna razón después de montarlo? Bueno, afortunadamente, puede usar el Identificador Único Universal (UUID) de un dispositivo en lugar de un nombre.\n\nPara ver los UUID en su sistema para dispositivos de bloques:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nPodemos ver los nombres de nuestros dispositivos, sus tipos de sistemas de archivos correspondientes y sus UUID. Ahora, cuando queramos montar algo, podemos usar:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nLa mayoría de las veces no necesitará montar dispositivos a través de sus UUID, es mucho más fácil usar el nombre del dispositivo y muchas veces el sistema operativo sabrá montar dispositivos comunes como las unidades USB. Sin embargo, si necesita montar automáticamente un sistema de archivos al inicio, como si agregara un disco duro secundario, querrá usar el UUID y lo veremos en la próxima lección.",
          "quizAnswer": "mount",
          "quizQuestion": "¿Qué comando se utiliza para adjuntar un sistema de archivos?",
          "slug": "montarydesmontarsistemasdearchivos",
          "title": "montar y desmontar"
        },
        {
          "exercise": "Agrega la unidad USB en la que hemos estado trabajando como una entrada en /etc/fstab, cuando reinicies deberías seguir viéndola montada.",
          "id": 7,
          "lessonContent": "Cuando queremos montar sistemas de archivos automáticamente al inicio, podemos agregarlos a un archivo llamado /etc/fstab (pronunciado \"eff es tab\" no \"eff stab\"), abreviatura de tabla de sistemas de archivos. Este archivo contiene una lista permanente de sistemas de archivos que están montados.\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\nCada línea representa un sistema de archivos, los campos son: \n\n<ul>\n<li>UUID - Identificador del dispositivo</li>\n<li>Punto de montaje - Directorio al que se monta el sistema de archivos</li>\n<li>Tipo de sistema de archivos</li>\n<li>Opciones - otras opciones de montaje, consulte la página del manual para más detalles</li>\n<li>Dump - utilizado por la utilidad de volcado para decidir cuándo hacer una copia de seguridad, debería ser 0 por defecto</li>\n<li>Pass - Utilizado por fsck para decidir en qué orden se deben verificar los sistemas de archivos, si el valor es 0, no se verificará</li>\n</ul>\n\nPara agregar una entrada, simplemente modifique directamente el archivo /etc/fstab utilizando la sintaxis de entrada anterior. Ten cuidado al modificar este archivo, podrías complicarte un poco la vida si te equivocas.",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "¿Qué archivo se utiliza para definir cómo deben montarse los sistemas de archivos?",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "Particionar el espacio libre en la unidad USB para espacio de intercambio (swap space).",
          "id": 8,
          "lessonContent": "En nuestro ejemplo anterior, te mostré cómo ver tu tabla de particiones, vamos a revisitar ese ejemplo, más específicamente esta línea:\n\n<pre>\nNúmero  Inicio   Fin     Tamaño    Tipo      Sistema de archivos     Banderas\n 5      6861MB  7380MB  519MB   lógico   linux-swap(v1)\n</pre>\n\n¿Qué es esta partición de swap? Bueno, swap es lo que usamos para asignar memoria virtual a nuestro sistema. Si tienes poca memoria, el sistema utiliza esta partición para \"intercambiar\" trozos de memoria de procesos inactivos al disco, para que no te quedes sin memoria.\n\n<b>Usando una partición para espacio de intercambio (swap space)</b>\n\nDigamos que queremos configurar nuestra partición /dev/sdb2 para ser utilizada como espacio de intercambio.\n\n<ol>\n<li>Primero asegúrate de que no haya nada en la partición</li>\n<li>Ejecuta: mkswap /dev/sdb2 para inicializar áreas de intercambio</li>\n<li>Ejecuta: swapon /dev/sdb2 esto habilitará el dispositivo de intercambio</li>\n<li>Si deseas que la partición de intercambio persista al arrancar, necesitas agregar una entrada al archivo /etc/fstab. sw es el tipo de sistema de archivos que usarás.</li>\n<li>Para eliminar el intercambio: swapoff /dev/sdb2</li>\n</ol>\n\nGeneralmente deberías asignar aproximadamente el doble de espacio de intercambio que de memoria. Pero los sistemas modernos de hoy suelen ser bastante potentes y tener suficiente RAM como es.",
          "quizAnswer": "swapon",
          "quizQuestion": "¿Cuál es el comando para habilitar el espacio de intercambio en un dispositivo?",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "Observa tu uso de disco y espacio libre con du y df.",
          "id": 9,
          "lessonContent": "Hay algunas herramientas que puedes usar para ver la utilización de tus discos: \n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-bloques    Usado Disponible Uso% Montado en\n/dev/sda1       6.2G  2.3G  3.6G  40% /\n</pre>\n\nEl comando df te muestra la utilización de tus sistemas de archivos actualmente montados. La bandera -h te da un formato legible para humanos. Puedes ver cuál es el dispositivo, cuánta capacidad se está utilizando y cuánta está disponible. \n\nDigamos que tu disco se está llenando y quieres saber qué archivos o directorios están ocupando ese espacio, para eso puedes usar el comando <b>du</b>. \n\n<pre>$ du -h</pre>\n\nEsto te muestra el uso del disco del directorio actual en el que te encuentras, puedes echar un vistazo al directorio raíz con <b>du -h /</b> pero eso puede ser un poco desordenado.\n\nAmbos comandos son tan similares en sintaxis que puede ser difícil recordar cuál usar, para verificar cuánto de tu <b>disco</b> está <b>libre</b> usa df. Para verificar el <b>uso del disco</b>, usa du.",
          "quizAnswer": "df",
          "quizQuestion": "¿Qué comando se utiliza para mostrar cuánto espacio está libre en tu disco?",
          "slug": "uso-del-disco",
          "title": "Uso del Disco"
        },
        {
          "exercise": "Mira la página del manual de fsck para ver qué más puede hacer.",
          "id": 10,
          "lessonContent": "A veces nuestro sistema de archivos no está siempre en la mejor condición, si tenemos un apagón repentino, nuestros datos pueden corromperse. Depende del sistema intentar devolvernos a un estado de funcionamiento (aunque seguro que podemos intentarlo nosotros mismos). \n\nEl comando <b>fsck</b> (comprobación del sistema de archivos) se utiliza para verificar la consistencia de un sistema de archivos e incluso puede intentar repararlo por nosotros. Por lo general, cuando arrancas un disco, fsck se ejecutará antes de que tu disco se monte para asegurarse de que todo esté bien. A veces, sin embargo, tu disco está tan mal que tendrás que hacerlo manualmente. Sin embargo, asegúrate de hacer esto mientras estás en un disco de rescate o en algún lugar donde puedas acceder a tu sistema de archivos sin que esté montado.\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "¿Qué comando se utiliza para verificar la integridad de un sistema de archivos?",
          "slug": "reparacion-sistema-archivos",
          "title": "Reparación del sistema de archivos"
        },
        {
          "exercise": "Observa algunos números de inodo para diferentes archivos, ¿cuáles suelen crearse primero?",
          "id": 11,
          "lessonContent": "Recuerda cómo nuestro sistema de archivos está compuesto por todos nuestros archivos reales y una base de datos que gestiona estos archivos. La base de datos se conoce como la tabla de inodos. \n\n<b>¿Qué es un inodo?</b>\n\nUn inodo (nodo de índice) es una entrada en esta tabla y hay uno para cada archivo. Describe todo sobre el archivo, como:\n\n<ul>\n<li>Tipo de archivo - archivo regular, directorio, dispositivo de caracteres, etc.</li>\n<li>Propietario</li>\n<li>Grupo</li>\n<li>Permisos de acceso</li>\n<li>Timestamps - mtime (hora de la última modificación del archivo), ctime (hora del último cambio de atributo), atime (hora del último acceso)</li>\n<li>Número de enlaces duros al archivo</li>\n<li>Tamaño del archivo</li>\n<li>Número de bloques asignados al archivo</li>\n<li>Punteros a los bloques de datos del archivo - ¡muy importante!</li>\n</ul>\n\nBásicamente, los inodos almacenan todo sobre el archivo, ¡excepto el nombre de archivo y el archivo en sí!\n\n<b>¿Cuándo se crean los inodos?</b>\n\nCuando se crea un sistema de archivos, también se asigna espacio para los inodos. Hay algoritmos que determinan cuánto espacio de inodo necesitas según el volumen del disco y más. Probablemente en algún momento de tu vida hayas visto errores por problemas de falta de espacio en disco. Bueno, lo mismo puede ocurrir con los inodos (aunque menos común), puedes quedarte sin inodos y por lo tanto ser incapaz de crear más archivos. Recuerda que el almacenamiento de datos depende tanto de los datos como de la base de datos (inodos). \n\nPara ver cuántos inodos quedan en tu sistema, usa el comando <b>df -i</b>\n\n<b>Información de inodo</b>\n\nLos inodos se identifican por números, cuando se crea un archivo se le asigna un número de inodo, el número se asigna en orden secuencial. Sin embargo, a veces puedes notar que al crear un nuevo archivo, recibe un número de inodo más bajo que otros, esto se debe a que una vez que se eliminan los inodos, pueden ser reutilizados por otros archivos. Para ver los números de inodo ejecuta <b>ls -li</b>:\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 ene 20 20:13 Escritorio\n141 drwxr-xr-x 2 pete pete 6 ene 20 20:01 Documentos\n</pre>\n\nEl primer campo en este comando lista el número de inodo.\n\nTambién puedes ver información detallada sobre un archivo con stat, te proporciona información sobre el inodo también.\n\n<pre>\npete@icebox:~$ stat ~/Escritorio/\n  Archivo: ‘/home/pete/Escritorio/’\n  Tamaño: 6               Bloques: 0          Bloque de E/S: 4096   directorio\nDispositivo: 806h/2054d      Inodo: 140         Enlaces: 2\nAcceso: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAcceso: 2016-01-20 20:13:50.647435982 -0800\nModificar: 2016-01-20 20:13:06.191675843 -0800\nCambiar: 2016-01-20 20:13:06.191675843 -0800\n Creación: -\n</pre>\n\n\n<b>¿Cómo localizan los inodos los archivos?</b>\n\nSabemos que nuestros datos están en algún lugar del disco, lamentablemente probablemente no se almacenaron de forma secuencial, por lo que tenemos que usar inodos. Los inodos apuntan a los bloques de datos reales de tus archivos. En un sistema de archivos típico (no todos funcionan igual), cada inodo contiene 15 punteros, los primeros 12 punteros apuntan directamente a los bloques de datos. El puntero 13, apunta a un bloque que contiene punteros a más bloques, el puntero 14 apunta a otro bloque anidado de punteros, ¡y el puntero 15 apunta nuevamente a otro bloque de punteros! ¡Confuso, lo sé! La razón por la que se hace de esta manera es mantener la estructura del inodo igual para cada inodo, pero poder hacer referencia a archivos de diferentes tamaños. Si tienes un archivo pequeño, puedes encontrarlo más rápido con los primeros 12 punteros directos, los archivos más grandes se pueden encontrar con los anidamientos de punteros. De cualquier manera, la estructura del inodo es la misma.",
          "quizAnswer": "df -i",
          "quizQuestion": "¿Cómo puedes ver cuántos inodos quedan en tu sistema?",
          "slug": "inodos",
          "title": "Inodos"
        },
        {
          "exercise": "Juega con la creación de enlaces simbólicos y enlaces duros, elimina un par y observa qué sucede.",
          "id": 12,
          "lessonContent": "Vamos a usar un ejemplo previo de información de inodo: \n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nPuede que hayas notado que hemos estado pasando por alto el tercer campo en el comando ls, ese campo es el recuento de enlaces. El recuento de enlaces es el número total de enlaces duros que tiene un archivo, lo cual no significa nada para ti en este momento. Así que hablemos primero de los enlaces. \n\n<b>Enlaces simbólicos</b>\n\nEn el sistema operativo Windows, existen cosas conocidas como accesos directos, los accesos directos son simplemente alias de otros archivos. Si haces algo al archivo original, podrías potencialmente romper el acceso directo. En Linux, el equivalente de los accesos directos son los enlaces simbólicos (o enlaces suaves o symlinks). Los enlaces simbólicos nos permiten enlazar a otro archivo por su nombre de archivo. Otro tipo de enlaces que se encuentran en Linux son los enlaces duros, que en realidad son otro archivo con un enlace a un inodo. Veamos a qué me refiero en la práctica comenzando con los enlaces simbólicos.\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n</pre>\n\nPuedes ver que he creado un enlace simbólico llamado myfilelink que apunta a myfile. Los enlaces simbólicos se indican con ->. Observa cómo obtuve un nuevo número de inodo, los enlaces simbólicos son solo archivos que apuntan a nombres de archivo. Cuando modificas un enlace simbólico, el archivo también se modifica. Los números de inodo son únicos para los sistemas de archivos, no puedes tener dos del mismo número de inodo en un solo sistema de archivos, lo que significa que no puedes hacer referencia a un archivo en un sistema de archivos diferente por su número de inodo. Sin embargo, si usas enlaces simbólicos, no utilizan números de inodo, utilizan nombres de archivo, por lo que pueden ser referenciados en diferentes sistemas de archivos. \n\n<b>Enlaces duros</b>\n\nVeamos un ejemplo de un enlace duro:\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myhardlink\n</pre>\n\nUn enlace duro simplemente crea otro archivo con un enlace al mismo inodo. Entonces, si modificara el contenido de myfile2 o myhardlink, el cambio se vería en ambos, pero si eliminara myfile2, el archivo seguiría siendo accesible a través de myhardlink. Aquí es donde entra en juego nuestro recuento de enlaces en el comando ls. El recuento de enlaces es el número de enlaces duros que tiene un inodo, cuando eliminas un archivo, ese recuento de enlaces disminuirá. El inodo solo se elimina cuando se han eliminado todos los enlaces duros al inodo. Cuando creas un archivo, su recuento de enlaces es 1 porque es el único archivo que apunta a ese inodo. A diferencia de los enlaces simbólicos, los enlaces duros no abarcan sistemas de archivos porque los inodos son únicos para el sistema de archivos. \n\n<b>Creación de un enlace simbólico</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nPara crear un enlace simbólico, utilizas el comando ln con -s para simbólico y especificas un archivo de destino y luego un nombre de enlace. \n\n<b>Creación de un enlace duro</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nSimilar a la creación de un enlace simbólico, excepto que esta vez omites el -s.",
          "quizAnswer": "ln -s",
          "quizQuestion": "¿Cuál es el comando utilizado para hacer un enlace simbólico?",
          "slug": "symlinks",
          "title": "symlinks"
        }
      ],
      "slug": "el-sistema-de-archivos",
      "title": "El sistema de archivos"
    },
    {
      "description": "Aprende sobre las etapas del proceso de arranque de Linux.",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "Reinicia tu sistema y observa si puedes identificar cada paso mientras tu máquina se inicia.",
          "id": 1,
          "lessonContent": "Ahora que tenemos un buen entendimiento de algunos de los componentes importantes de Linux, vamos a unirlos todos aprendiendo cómo arranca el sistema. Cuando enciendes tu máquina, hace algunas cosas interesantes como mostrarte la pantalla del logo, ejecutar diferentes mensajes y luego al final te aparece una ventana de inicio de sesión. Bueno, en realidad hay un montón de cosas sucediendo entre cuando presionas el botón de encendido y cuando inicias sesión y discutiremos eso en este curso. \n\nEl proceso de arranque de Linux se puede dividir en 4 etapas simples: \n\n<b>1. BIOS</b>\n\nLa BIOS (que significa \"Sistema Básico de Entrada/Salida\") inicializa el hardware y se asegura con una Prueba de Autoinicio (POST) de que todo el hardware está listo para funcionar. El trabajo principal de la BIOS es cargar el cargador de arranque.\n\n<b>2. Cargador de Arranque</b>\n\nEl cargador de arranque carga el kernel en memoria y luego inicia el kernel con un conjunto de parámetros del kernel. Uno de los cargadores de arranque más comunes es GRUB, que es un estándar universal de Linux. \n\n<b>3. Kernel</b>\n\nCuando se carga el kernel, inicializa inmediatamente dispositivos y memoria. El trabajo principal del kernel es cargar el proceso init. \n\n<b>4. Init</b>\n\nRecuerda que el proceso init es el primer proceso que se inicia, init inicia y detiene procesos de servicios esenciales en el sistema. Hay tres implementaciones principales de init en distribuciones de Linux. Repasaremos brevemente y luego profundizaremos en ellos en otro curso.\n\nAhí está, la explicación (muy) simple del proceso de arranque de Linux. Profundizaremos más en estas etapas en las próximas lecciones.",
          "quizAnswer": "init",
          "quizQuestion": "¿Cuál es la última etapa en el proceso de arranque de Linux?",
          "slug": "resumenprocesoarranque",
          "title": "Resumen del Proceso de Arranque"
        },
        {
          "exercise": "Ingresa a tu menú de BIOS y verifica si tienes habilitado el arranque UEFI.",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nEl primer paso en el proceso de arranque de Linux es el BIOS, que realiza comprobaciones de integridad del sistema. El BIOS es un firmware que se encuentra comúnmente en computadoras compatibles con IBM PC, el tipo dominante de computadoras que existen hoy en día. Probablemente has utilizado el firmware BIOS para cambiar el orden de arranque de tus discos duros, verificar la hora del sistema, la dirección MAC de tu máquina, etc. El objetivo principal del BIOS es encontrar el cargador del sistema.\n\nAsí que una vez que el BIOS inicia el disco duro, busca el bloque de arranque para averiguar cómo arrancar el sistema. Dependiendo de cómo hayas particionado tu disco, buscará el registro de arranque principal (MBR) o GPT. El MBR se encuentra en el primer sector del disco duro, los primeros 512 bytes. El MBR contiene el código para cargar otro programa en algún lugar del disco, este programa a su vez carga nuestro cargador de arranque.\n\nAhora, si has particionado tu disco con GPT, la ubicación del cargador de arranque cambia un poco.\n\n<b>UEFI</b>\n\nHay otra forma de arrancar tu sistema en lugar de usar BIOS y es con UEFI (que significa \"Interfaz de firmware extensible unificada\"). UEFI fue diseñado para ser el sucesor del BIOS, la mayoría del hardware que existe hoy en día viene con firmware UEFI incorporado. Las máquinas Macintosh han estado utilizando el arranque EFI desde hace años y Windows ha trasladado la mayor parte de sus cosas al arranque UEFI. El formato GPT estaba destinado a ser utilizado con EFI. No necesariamente necesitas EFI si estás arrancando un disco GPT. El primer sector de un disco GPT está reservado para un \"MBR protector\" para que sea posible arrancar una máquina basada en BIOS.\n\nUEFI almacena toda la información sobre el inicio en un archivo .efi. Este archivo se almacena en una partición especial llamada partición del sistema EFI en el hardware. Dentro de esta partición contendrá el cargador de arranque. UEFI viene con muchas mejoras respecto al firmware BIOS tradicional. Sin embargo, dado que estamos utilizando Linux, la mayoría de nosotros estamos utilizando BIOS. Por lo tanto, todas estas lecciones seguirán con esa pretensión.",
          "quizAnswer": "cargador de arranque",
          "quizQuestion": "¿Qué carga el BIOS?",
          "slug": "procesodearranquebios",
          "title": "Proceso de arranque: BIOS"
        },
        {
          "exercise": "Si tienes GRUB como tu cargador de arranque, ve al menú GRUB con 'e' y revisa la configuración.",
          "id": 3,
          "lessonContent": "Las principales responsabilidades del cargador de arranque son:\n\n<ul>\n<li>Arrancar en un sistema operativo, también se puede utilizar para arrancar en sistemas operativos que no sean Linux</li>\n<li>Seleccionar un kernel para usar</li>\n<li>Especificar parámetros del kernel</li>\n</ul>\n\nEl cargador de arranque más común para Linux es GRUB, es probable que lo estés utilizando en tu sistema. Hay muchos otros cargadores de arranque que puedes usar, como LILO, efilinux, coreboot, SYSLINUX y más. Sin embargo, solo trabajaremos con GRUB como nuestro cargador de arranque.\n\nEntonces sabemos que el objetivo principal del cargador de arranque es cargar el kernel, pero ¿dónde encuentra el kernel? Para encontrarlo, necesitaremos revisar nuestros parámetros del kernel. Los parámetros se pueden encontrar yendo al menú GRUB al iniciar con la tecla 'e'. Si no tienes GRUB, no te preocupes, repasaremos los parámetros de arranque que verás:\n\n<ul>\n<li>initrd - Especifica la ubicación del disco RAM inicial (hablaremos más sobre esto en la próxima lección).</li>\n<li>BOOT_IMAGE - Aquí es donde se encuentra la imagen del kernel</li>\n<li>root - La ubicación del sistema de archivos raíz, el kernel busca dentro de esta ubicación para encontrar init. A menudo se representa por su UUID o el nombre del dispositivo, como /dev/sda1.</li>\n<li>ro - Este parámetro es bastante estándar, monta el sistema de archivos en modo de solo lectura.</li>\n<li>quiet - Se agrega para que no veas los mensajes de pantalla que se muestran en segundo plano durante el arranque.</li>\n<li>splash - Permite mostrar la pantalla de inicio.</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "¿Qué parámetro del kernel hace que no veas los mensajes de arranque?",
          "slug": "procesodearranquebootloader",
          "title": "Proceso de arranque: Bootloader"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "Ahora que nuestro cargador de arranque ha pasado los parámetros necesarios, veamos cómo se inicia:\n\n<b>Initrd vs Initramfs</b>\n\nHay un problema de 'huevo y gallina' cuando hablamos del arranque del kernel. El kernel gestiona el hardware de nuestros sistemas, sin embargo, no todos los controladores están disponibles para el kernel durante el arranque. Por lo tanto, dependemos de un sistema de archivos raíz temporal que contiene solo los módulos esenciales que el kernel necesita para acceder al resto del hardware. En versiones antiguas de Linux, esta tarea se asignaba al initrd (disco RAM inicial). El kernel montaba el initrd, obtenía los controladores necesarios para el arranque y, cuando terminaba de cargar todo lo que necesitaba, reemplazaba el initrd con el sistema de archivos raíz real. En la actualidad, tenemos algo llamado initramfs, que es un sistema de archivos raíz temporal integrado en el propio kernel para cargar todos los controladores necesarios para el sistema de archivos raíz real, por lo que ya no es necesario localizar el archivo initrd. \n\n<b>Montaje del sistema de archivos raíz</b>\n\nAhora el kernel tiene todos los módulos que necesita para crear un dispositivo raíz y montar la partición raíz. Antes de continuar, la partición raíz se monta en modo de solo lectura para que fsck pueda ejecutarse de forma segura y verificar la integridad del sistema. Después, vuelve a montar el sistema de archivos raíz en modo de escritura. Luego, el kernel localiza el programa init y lo ejecuta.",
          "quizAnswer": "initramfs",
          "quizQuestion": "¿Qué se utiliza en los sistemas modernos para cargar un sistema de archivos raíz temporal?",
          "slug": "procesodearranquekernel",
          "title": "Proceso de arranque: Kernel"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Hemos discutido init en lecciones anteriores y sabemos que es el primer proceso que se inicia y que inicia todos los otros servicios esenciales en nuestro sistema. Pero ¿cómo?\n\nEn realidad, hay tres implementaciones principales de init en Linux: \n\n<b>System V init (sysv)</b>\n\nEste es el sistema init tradicional. Inicia y detiene procesos secuencialmente, basándose en scripts de inicio. El estado de la máquina se denota por niveles de ejecución, cada nivel de ejecución inicia o detiene una máquina de manera diferente. \n\n<b>Upstart</b>\n\nEste es el init que encontrarás en instalaciones antiguas de Ubuntu. Upstart utiliza la idea de trabajos y eventos y funciona iniciando trabajos que realizan ciertas acciones en respuesta a eventos. \n\n<b>Systemd</b>\n\nEste es el nuevo estándar para init, está orientado a objetivos. Básicamente tienes un objetivo que deseas lograr y systemd intenta satisfacer las dependencias del objetivo para completarlo. \n\nTenemos un curso completo sobre sistemas de Init donde profundizaremos en cada uno de estos sistemas con más detalle.",
          "quizAnswer": "systemd",
          "quizQuestion": "¿Cuál es el estándar más reciente para init?",
          "slug": "procesodearranqueinit",
          "title": "Proceso de Arranque: Init"
        }
      ],
      "slug": "iniciarelsistema",
      "title": "Iniciar el sistema"
    },
    {
      "description": "La parte más importante del sistema Linux, aprende cómo funciona y cómo configurarlo.",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "Como has aprendido hasta este punto, el kernel es el núcleo del sistema operativo. Hemos hablado sobre las otras partes del sistema operativo pero aún no hemos mostrado cómo todas trabajan juntas. El sistema operativo Linux se puede organizar en tres niveles diferentes de abstracción.\n\nEl nivel más básico es el hardware, esto incluye nuestra CPU, memoria, discos duros, puertos de red, etc. La capa física que realmente calcula lo que nuestra máquina está haciendo.\n\nEl siguiente nivel es el kernel, que maneja el proceso y la gestión de memoria, la comunicación de dispositivos, las llamadas al sistema, configura nuestro sistema de archivos, etc. El trabajo del kernel es hablar con el hardware para asegurarse de que haga lo que queremos que hagan nuestros procesos.\n\nY el nivel con el que estás familiarizado es el espacio de usuario, el espacio de usuario incluye la terminal, los programas que ejecutas, los gráficos, etc.\n\nEn este curso, nos enfocaremos en el kernel y aprenderemos sus complejidades.",
          "quizAnswer": "kernel",
          "quizQuestion": "¿Qué nivel del sistema operativo gestiona los dispositivos?",
          "slug": "kerneloverview",
          "title": "Visión general del Kernel"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 2,
          "lessonContent": "Las próximas lecciones se vuelven bastante teóricas, así que si estás buscando algo práctico puedes saltar adelante y volver más tarde.\n\n¿Por qué tenemos diferentes capas de abstracción para el espacio de usuario y el kernel? ¿Por qué no se pueden combinar ambas potencias en una sola capa? Bueno, existe una muy buena razón por la cual estas dos capas existen por separado. Ambas operan en diferentes modos, el kernel opera en modo kernel y el espacio de usuario opera en modo usuario. \n\nEn el modo kernel, el kernel tiene acceso completo al hardware, controla todo. En el modo de espacio de usuario, hay una pequeña cantidad de memoria segura y CPU a la que se te permite acceder. Básicamente, cuando queremos hacer algo que involucre hardware, como leer datos de nuestros discos, escribir datos en nuestros discos, controlar nuestra red, etc., todo se hace en modo kernel. ¿Por qué es necesario esto? Imagina si tu máquina estuviera infectada con software espía, no querrías que tuviera acceso directo al hardware de tu sistema. Puede acceder a todos tus datos, a tu cámara web, etc. y eso no es bueno. \n\nEstos diferentes modos se llaman niveles de privilegio (apropiadamente nombrados por los niveles de privilegio que obtienes) y a menudo se describen como anillos de protección. Para facilitar la comprensión, digamos que descubres que Britney Spears está en tu ciudad en tu klerb local, está protegida por sus seguidores, luego por sus guardaespaldas personales, luego por el portero fuera del klerb. Quieres conseguir su autógrafo (¿por qué no?), pero no puedes llegar a ella porque está muy protegida. Los anillos funcionan de la misma manera, el anillo más interno corresponde al nivel de privilegio más alto. Hay dos niveles o modos principales en una arquitectura de computadora x86. El anillo n.º 3 es el privilegio en el que se ejecutan las aplicaciones en modo usuario, el anillo n.º 0 es el privilegio en el que se ejecuta el kernel. El anillo n.º 0 puede ejecutar cualquier instrucción del sistema y se le otorga plena confianza. Entonces, ahora que sabemos cómo funcionan esos niveles de privilegio, ¿cómo podemos escribir algo en nuestro hardware? ¿No estaremos siempre en un modo diferente al del kernel? \n\nLa respuesta está en las llamadas al sistema, las llamadas al sistema nos permiten realizar una instrucción privilegiada en modo kernel y luego volver al modo usuario.",
          "quizAnswer": "0",
          "quizQuestion": "¿Qué número de anillo tiene los privilegios más altos?",
          "slug": "nivelesdeprivilegiodelkernel",
          "title": "Niveles de Privilegio"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "¿Recuerdas a Britney en la lección anterior? Digamos que queremos verla y tomar algo juntos, ¿cómo pasamos de estar afuera entre la multitud de personas a estar dentro de su círculo más íntimo? Usaríamos llamadas al sistema. Las llamadas al sistema son como los pases VIP que te llevan a una puerta lateral secreta que conduce directamente a Britney.\n\nLas llamadas al sistema (syscall) proporcionan a los procesos del espacio de usuario una forma de solicitar al kernel que haga algo por nosotros. El kernel pone a disposición ciertos servicios a través de la API de llamadas al sistema. Estos servicios nos permiten leer o escribir en un archivo, modificar el uso de memoria, modificar nuestra red, etc. La cantidad de servicios es fija, por lo que no puedes estar agregando llamadas al sistema sin ton ni son, tu sistema ya tiene una tabla de qué llamadas al sistema existen y cada llamada al sistema tiene un ID único. \n\nNo entraré en detalles de las llamadas al sistema, ya que eso requeriría que sepas un poco de C, pero lo básico es que cuando llamas a un programa como ls, el código dentro de este programa contiene un envoltorio de llamada al sistema (así que no es la llamada al sistema real todavía). Dentro de este envoltorio, se invoca la llamada al sistema que ejecutará una trampa, esta trampa luego es capturada por el controlador de llamadas al sistema y luego hace referencia a la llamada al sistema en la tabla de llamadas al sistema. Digamos que estamos tratando de llamar a la llamada al sistema stat(), esta se identifica por un ID de llamada al sistema y el propósito de la llamada al sistema stat() es consultar el estado de un archivo. Ahora recuerda, estabas ejecutando el programa ls en modo no privilegiado. Entonces ahora ve que estás intentando hacer una llamada al sistema, luego te cambia a modo kernel, allí hace muchas cosas pero lo más importante es que busca tu número de llamada al sistema, lo encuentra en una tabla basada en el ID de la llamada al sistema y luego ejecuta la función que querías ejecutar. Una vez que haya terminado, volverá al modo de usuario y tu proceso recibirá un estado de retorno si fue exitoso o si tuvo un error. Los entresijos de las llamadas al sistema se vuelven realmente detallados, te recomendaría buscar información en línea si quieres aprender más. \n\nEn realidad, puedes ver las llamadas al sistema que un proceso realiza con el comando strace. El comando strace es útil para depurar cómo se ejecutó un programa. \n\n<pre>$ strace ls</pre>",
          "quizAnswer": "llamada al sistema",
          "quizQuestion": "¿Qué se utiliza para cambiar de modo de usuario a modo kernel?",
          "slug": "llamadas-al-sistema",
          "title": "Llamadas al sistema"
        },
        {
          "exercise": "<ol>\n<li>Descubre qué versión de kernel tienes.</li>\n<li>Investiga las diferentes versiones de kernels disponibles.</li>\n</ol>",
          "id": 4,
          "lessonContent": "Ok, ahora que hemos dejado atrás todas esas cosas aburridas, hablemos sobre la instalación y modificación real de los kernels. Puedes instalar varios kernels en tu sistema, ¿recuerdas nuestra lección sobre el proceso de arranque? En nuestro menú GRUB podemos elegir a qué kernel arrancar. \n\nPara ver qué versión de kernel tienes en tu sistema, usa el siguiente comando:\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nEl comando uname imprime información del sistema, el comando -r imprimirá toda la versión de lanzamiento del kernel.\n\nPuedes instalar el kernel de Linux de diferentes maneras, puedes descargar el paquete fuente y compilarlo desde la fuente o puedes instalarlo usando herramientas de gestión de paquetes.\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\ny luego simplemente reinicia en el kernel que instalaste. ¿Simple verdad? Más o menos, también necesitarás instalar otros paquetes de Linux como los linux-headers, linux-image-generic, etc.). También puedes especificar el número de versión, por lo que el comando anterior puede parecerse a <b>sudo apt install 3.19.0-43-generic</b>\n\nAlternativamente, si solo deseas la versión actualizada del kernel, simplemente usa dist-upgrade, realiza actualizaciones a todos los paquetes en tu sistema:\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nHay muchas versiones de kernel diferentes, algunas se utilizan como LTS (soporte a largo plazo), otras son las más recientes y mejores, la compatibilidad puede ser muy diferente entre las versiones del kernel, por lo que es posible que desees probar diferentes kernels.",
          "quizAnswer": "uname -r",
          "quizQuestion": "¿Cómo puedes ver la versión del kernel de tu sistema?",
          "slug": "instalacionkernel",
          "title": "Instalación del Kernel"
        },
        {
          "exercise": "Ve a tu directorio /boot y mira qué archivos hay allí.",
          "id": 5,
          "lessonContent": "¿Qué sucede cuando instalas un nuevo kernel? Bueno, en realidad agrega un par de archivos a tu sistema, estos archivos suelen agregarse al directorio /boot. \n\nVerás múltiples archivos para diferentes versiones de kernel:\n\n<ul>\n<li>vmlinuz - este es el kernel de Linux real</li>\n<li>initrd - como discutimos antes, el initrd se utiliza como un sistema de archivos temporal, utilizado antes de cargar el kernel</li>\n<li>System.map - tabla de búsqueda simbólica</li>\n<li>config - configuración del kernel, si estás compilando tu propio kernel, puedes establecer qué módulos se pueden cargar</li>\n</ul>\n\nSi tu directorio /boot se queda sin espacio, siempre puedes eliminar versiones antiguas de estos archivos o simplemente usar un gestor de paquetes, pero ten cuidado al realizar mantenimiento en este directorio y no elimines accidentalmente el kernel que estás utilizando.",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "¿Cómo se llama la imagen del kernel en /boot?",
          "slug": "ubicacionkernel",
          "title": "Ubicación del Kernel"
        },
        {
          "exercise": "Descarga tu módulo de bluetooth con modprobe y observa qué sucede. ¿Cómo lo arreglarás?",
          "id": 6,
          "lessonContent": "Imaginemos que tengo un coche genial, invierto mucho tiempo y dinero en él. Añado un alerón, un enganche, un portabicicletas y otras cosas aleatorias. Estos componentes en realidad no cambian la funcionalidad principal del coche y puedo quitarlos y añadirlos muy fácilmente. El kernel utiliza el mismo concepto con los módulos del kernel.\n\nEl kernel en sí mismo es una pieza de software monolítica, cuando queremos añadir soporte para un nuevo tipo de teclado, no escribimos este código directamente en el código del kernel. Así como no fusionaríamos un portabicicletas a nuestro coche (bueno, tal vez algunas personas lo harían). Los módulos del kernel son piezas de código que pueden cargarse y descargarse en el kernel según la demanda. Nos permiten extender la funcionalidad del kernel sin añadir realmente al código principal del kernel. También podemos añadir módulos y no tener que reiniciar el sistema (en la mayoría de los casos).\n\n<b>Ver una lista de módulos cargados actualmente</b>\n\n<pre>$ lsmod</pre>\n\n<b>Cargar un módulo</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobe intenta cargar el módulo desde <b>/lib/modules/(versión del kernel)/kernel/drivers</b>. Los módulos del kernel también pueden tener dependencias, modprobe carga nuestras dependencias de módulos si estas aún no están cargadas. \n\n<b>Eliminar un módulo</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>Cargar en el arranque</b>\n\nTambién puedes cargar módulos durante el arranque del sistema, en lugar de cargarlos temporalmente con modprobe (que se descargará cuando reinicies). Simplemente modifica el directorio <b>/etc/modprobe.d</b> y añade un archivo de configuración en él de la siguiente manera:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\nUn ejemplo un poco extravagante, pero si tuvieras un módulo llamado peanut_butter y quisieras añadir un parámetro del kernel para type=almond, puedes hacer que se cargue al iniciar usando este archivo de configuración. También ten en cuenta que los módulos del kernel tienen sus propios parámetros del kernel, así que querrás leer sobre el módulo específicamente para obtener más información.\n\n<b>No cargar en el arranque</b>\n\nTambién puedes asegurarte de que un módulo no se cargue en el arranque añadiendo un archivo de configuración de la siguiente manera:\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "¿Qué comando se utiliza para descargar un módulo?",
          "slug": "kernelmodules",
          "title": "Módulos del Kernel"
        }
      ],
      "slug": "kernel",
      "title": "Kernel"
    },
    {
      "description": "Aprende sobre los diferentes sistemas de inicio, SysV, Upstart y systemd.",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Si estás ejecutando System V, cambia el nivel de ejecución predeterminado de tu máquina a otro y observa qué sucede.",
          "id": 1,
          "lessonContent": "El propósito principal de init es iniciar y detener procesos esenciales en el sistema. Hay tres implementaciones principales de init en Linux, System V, Upstart y systemd. En esta lección, vamos a repasar la versión más tradicional de init, System V init o Sys V (pronunciado como 'System Five'). \n\nPara saber si estás utilizando la implementación Sys V init, si tienes un archivo /etc/inittab es muy probable que estés ejecutando Sys V. \n\nSys V inicia y detiene procesos secuencialmente, por lo que si quisieras iniciar un servicio llamado foo-a, antes de que foo-b pueda funcionar, debes asegurarte de que foo-a ya esté en ejecución. Sys V hace esto con scripts, estos scripts inician y detienen servicios para nosotros, podemos escribir nuestros propios scripts o la mayoría de las veces usar los que ya están integrados en el sistema operativo y se utilizan para cargar servicios esenciales. \n\nLas ventajas de usar esta implementación de init es que es relativamente fácil resolver dependencias, ya que sabes que foo-a viene antes que foo-b, sin embargo, el rendimiento no es óptimo porque generalmente una cosa se está iniciando o deteniendo a la vez. \n\nCuando se utiliza Sys V, el estado de la máquina está definido por los niveles de ejecución que van del 0 al 6. Estos modos diferentes variarán dependiendo de la distribución, pero la mayoría de las veces se verán así: \n\n<ul>\n<li>0: Apagado</li>\n<li>1: Modo de usuario único</li>\n<li>2: Modo multiusuario sin red</li>\n<li>3: Modo multiusuario con red</li>\n<li>4: No utilizado</li>\n<li>5: Modo multiusuario con red y GUI</li>\n<li>6: Reinicio</li>\n</ul>\n\nCuando tu sistema se inicia, busca en qué nivel de ejecución te encuentras y ejecuta los scripts ubicados dentro de esa configuración de nivel de ejecución. Los scripts se encuentran en <b>/etc/rc.d/rc[número de nivel de ejecución].d/</b> o <b>/etc/init.d</b>. Los scripts que comienzan con S (inicio) o K (finalización) se ejecutarán al inicio y al apagado, respectivamente. Los números junto a estos caracteres indican el orden en que se ejecutan. \n\nPor ejemplo:\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nVemos que al cambiar al nivel de ejecución 0 o modo de apagado, nuestra máquina intentará ejecutar un script para finalizar los servicios de actualización y luego openvpn. Para saber en qué nivel de ejecución se está iniciando tu máquina, puedes ver el nivel de ejecución predeterminado en el archivo /etc/inittab. También puedes cambiar tu nivel de ejecución predeterminado en este archivo. \n\nCabe destacar que System V se está reemplazando lentamente, tal vez no hoy, ni siquiera en años. Sin embargo, es posible que veas niveles de ejecución en otras implementaciones de init, principalmente para admitir aquellos servicios que solo se inician o detienen mediante scripts de init de System V.",
          "quizAnswer": "0",
          "quizQuestion": "¿Qué nivel de ejecución se utiliza generalmente para el apagado?",
          "slug": "visión-general-sysv",
          "title": "Visión general de System V"
        },
        {
          "exercise": "Administra un par de servicios y cambia sus estados, ¿qué observas?",
          "id": 2,
          "lessonContent": "Hay muchas herramientas de línea de comandos que puedes usar para gestionar los servicios de Sys V. \n\n<b>Listar servicios</b>\n\n<pre>$ service --status-all</pre>\n\n<b>Iniciar un servicio</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>Detener un servicio</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>Reiniciar un servicio</b>\n\n<pre>$ sudo service networking restart</pre>\n\nEstos comandos no son específicos de los sistemas de inicio Sys V, también puedes usar estos comandos para gestionar servicios de Upstart. Dado que Linux está tratando de alejarse de los scripts de inicio más tradicionales de Sys V, todavía hay cosas en su lugar para ayudar en esa transición.",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "¿Cuál es el comando para detener un servicio llamado peanut con Sys V?",
          "slug": "sysvservices",
          "title": "Servicio de System V"
        },
        {
          "exercise": "Si estás ejecutando Upstart, intenta entender las configuraciones de trabajo en /etc/init.",
          "id": 3,
          "lessonContent": "Upstart fue desarrollado por Canonical, por lo que fue la implementación de inicio en Ubuntu durante un tiempo, sin embargo, en las instalaciones modernas de Ubuntu ahora se utiliza systemd. Upstart fue creado para mejorar los problemas con Sys V, como los estrictos procesos de inicio, bloqueo de tareas, etc. El modelo basado en eventos y trabajos de Upstart le permite responder a los eventos a medida que ocurren. \n\nPara saber si estás usando Upstart, si tienes un directorio /usr/share/upstart, eso es un indicador bastante bueno. \n\nLos trabajos son las acciones que realiza Upstart y los eventos son mensajes que se reciben de otros procesos para activar trabajos. Para ver una lista de trabajos y su configuración:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nDentro de estas configuraciones de trabajo, se incluirá información sobre cómo iniciar trabajos y cuándo iniciar trabajos.\n\nPor ejemplo, en el archivo networking.conf, podría decir algo tan simple como:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nEsto significa que iniciará la configuración de la red en el runlevel 2, 3 o 5 y detendrá la red en el runlevel 0. Hay muchas formas de escribir el archivo de configuración y descubrirás eso cuando veas las diferentes configuraciones de trabajo disponibles. \n\nLa forma en que funciona Upstart es la siguiente: \n\n<ol>\n<li>Primero, carga las configuraciones de trabajo desde /etc/init</li>\n<li>Una vez que ocurre un evento de inicio, ejecutará trabajos desencadenados por ese evento.</li>\n<li>Estos trabajos generarán nuevos eventos y luego esos eventos activarán más trabajos</li>\n<li>Upstart continúa haciendo esto hasta que complete todos los trabajos necesarios</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "¿Cuál es la implementación de inicio que se utiliza en Ubuntu?",
          "slug": "upstartoverview",
          "title": "Visión general de Upstart"
        },
        {
          "exercise": "Observa tu lista de trabajos de Upstart, ahora cambia el estado del trabajo con uno de los comandos que aprendimos hoy. ¿Qué notas después?",
          "id": 4,
          "lessonContent": "Upstart puede desencadenar muchos eventos y trabajos para ejecutarse, desafortunadamente no hay una manera fácil de ver de dónde proviene un evento o trabajo, por lo que tendrás que investigar las configuraciones de trabajo en /etc/init. La mayoría del tiempo, nunca necesitarás mirar los archivos de configuración de trabajos de Upstart, pero querrás controlar algunos trabajos específicos de manera más fácil. Hay muchos comandos útiles que puedes usar en un sistema Upstart. \n\n<b>Ver trabajos</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\nVerás una lista de trabajos de Upstart con diferentes estados aplicados a ellos. En cada línea, el nombre del trabajo es el primer valor y el segundo campo (antes de la /) es en realidad el objetivo del trabajo, el tercer valor (después de la /) es el estado actual. Así que vemos que nuestro trabajo de apagado eventualmente quiere detenerse, pero actualmente está en un estado de espera. El estado y los objetivos del trabajo cambiarán a medida que inicies o detengas trabajos. \n\n<b>Ver trabajo específico</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nNo entraremos en los detalles de cómo escribir una configuración de trabajo de Upstart, sin embargo, ya sabemos que los trabajos se detienen, inician y reinician en estas configuraciones. Estos trabajos también emiten eventos, por lo que pueden iniciar otros trabajos. Repasaremos los comandos manuales de la operación de Upstart, pero si tienes curiosidad, deberías profundizar en los archivos .conf.\n\n<b>Iniciar manualmente un trabajo</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>Detener manualmente un trabajo</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>Reiniciar manualmente un trabajo</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>Emitir manualmente un evento</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "¿Cómo reiniciaría manualmente un trabajo de Upstart llamado peanuts?",
          "slug": "trabajosdeupstart",
          "title": "Trabajos de Upstart"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Systemd se está convirtiendo lentamente en el estándar emergente para init. Si tienes un directorio /usr/lib/systemd, es muy probable que estés utilizando systemd.\n\nSystemd utiliza objetivos para poner en marcha tu sistema. Básicamente tienes un objetivo que deseas lograr y este objetivo también tiene dependencias que necesitamos alcanzar. Systemd es extremadamente flexible y robusto, no sigue una secuencia estricta para iniciar procesos. Esto es lo que sucede durante el arranque típico de systemd:\n\n<ol>\n<li>Primero, systemd carga sus archivos de configuración, que generalmente se encuentran en /etc/systemd/system o /usr/lib/systemd/system</li>\n<li>Luego determina su objetivo de arranque, que suele ser default.target</li>\n<li>Systemd averigua las dependencias del objetivo de arranque y las activa</li>\n</ol>\n\nSimilar a los niveles de ejecución de Sys V, systemd arranca en diferentes objetivos:\n\n<ul>\n<li>poweroff.target - apagar el sistema</li>\n<li>rescue.target - modo de usuario único</li>\n<li>multi-user.target - usuario múltiple con red</li>\n<li>graphical.target - usuario múltiple con red y GUI</li>\n<li>reboot.target - reiniciar</li>\n</ul>\n\nEl objetivo de arranque predeterminado default.target generalmente apunta a graphical.target.\n\nEl principal objeto con el que trabaja systemd se conoce como unidades. Systemd no solo detiene y arranca servicios, puede montar sistemas de archivos, monitorear tus sockets de red, etc. y debido a esa robustez tiene diferentes tipos de unidades con las que opera. Las unidades más comunes son:\n\n<ul>\n<li>Unidades de servicio - estos son los servicios que hemos estado iniciando y deteniendo, estos archivos de unidad terminan en .service</li>\n<li>Unidades de montaje - Estas montan sistemas de archivos, estos archivos de unidad terminan en .mount</li>\n<li>Unidades de objetivo - Estas agrupan otras unidades, los archivos terminan en .target</li>\n</ul>\n\nPor ejemplo, digamos que arrancamos en nuestro default.target, bueno, este objetivo agrupa la unidad networking.service, la unidad crond.service, etc., por lo que una vez que activamos una sola unidad, todo lo que está por debajo de esa unidad también se activa.",
          "quizAnswer": "target",
          "quizQuestion": "¿Qué unidad se utiliza para agrupar otras unidades?",
          "slug": "systemdoverview",
          "title": "Visión general de Systemd"
        },
        {
          "exercise": "Observa los estados de las unidades y inicia y detén algunos servicios. ¿Qué observas?",
          "id": 6,
          "lessonContent": "No entraremos en los detalles de cómo escribir archivos de unidad de systemd. Sin embargo, repasaremos brevemente un resumen de un archivo de unidad y cómo controlar manualmente las unidades. \n\nAquí tienes un archivo de unidad de servicio básico: foobar.service\n\n<pre>\n[Unit]\nDescription=Mi Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nEste es un simple archivo de destino de servicio, al principio del archivo vemos una sección para [Unit], esto nos permite darle a nuestro archivo de unidad una descripción y controlar el orden de activación de la unidad. La siguiente parte es la sección [Service], aquí podemos iniciar, detener o recargar un servicio. Y la sección [Install] se utiliza para dependencias. Esto es solo la punta del iceberg para escribir archivos de systemd, así que te insto a que leas más sobre el tema si quieres saber más. \n\nAhora, veamos algunos comandos que puedes usar con las unidades de systemd: \n\n<b>Listar unidades</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>Ver estado de la unidad</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>Iniciar un servicio</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>Detener un servicio</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>Reiniciar un servicio</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>Habilitar una unidad</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>Deshabilitar una unidad</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nNuevamente, aún no has visto cuánta profundidad alcanza systemd, así que infórmate más si quieres aprender más.",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "¿Cuál es el comando para iniciar un servicio llamado peanut.service?",
          "slug": "systemdgoals",
          "title": "Objetivos de Systemd"
        },
        {
          "exercise": "¿Qué crees que está sucediendo con init cuando apagas tu máquina?",
          "id": 7,
          "lessonContent": "Es difícil de creer que en realidad no hemos discutido formas de controlar el estado de tu sistema a través de la línea de comandos, pero al hablar de init, no solo hablamos de los modos que nos permiten iniciar nuestro sistema, sino también de los que detienen nuestro sistema.\n\nPara apagar tu sistema:\n\n<pre>$ sudo shutdown -h now</pre>\n\nEsto detendrá el sistema (lo apagará), también debes especificar un tiempo en el que deseas que esto ocurra. Puedes agregar un tiempo en minutos que apagará el sistema en esa cantidad de tiempo.\n\n<pre>$ sudo shutdown -h +2</pre>\n\nEsto apagará tu sistema en dos minutos. También puedes reiniciar con el comando shutdown: \n\n<pre>$ sudo shutdown -r now</pre>\n\nO simplemente usa el comando reboot:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "¿Cuál es el comando para apagar tu sistema en 4 minutos?",
          "slug": "powerstates",
          "title": "Estados de energía"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "Aprende a monitorear recursos con top, promedios de carga, iostat ¡y más!",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "Juegue con el comando top y vea qué procesos están utilizando más recursos.",
          "id": 1,
          "lessonContent": "En este curso, repasaremos cómo leer y analizar la utilización de recursos en su sistema, esta lección muestra algunas herramientas excelentes para usar cuando necesita rastrear lo que está haciendo un proceso. \n\n<b>top</b>\n\nYa hemos hablado de top antes, pero vamos a profundizar en los detalles de lo que realmente está mostrando. Recuerde que top es la herramienta que utilizamos para obtener una vista en tiempo real de la utilización del sistema por nuestros procesos:\n\n<pre>\ntop - 18:06:26 up 6 days,  4:07,  2 users,  load average: 0.92, 0.62, 0.59\nTasks: 389 total,   1 running, 387 sleeping,   0 stopped,   1 zombie\n%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  32870888 total, 27467976 used,  5402912 free,   518808 buffers\nKiB Swap: 33480700 total,    39892 used, 33440808 free. 19454152 cached Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nVeamos qué significa esta salida, no es necesario memorizar esto, pero vuelva a esto cuando necesite una referencia.\n\n<b>1ra línea: Esta es la misma información que vería si ejecutara el comando uptime (más por venir)</b>\n\nLos campos son de izquierda a derecha:\n<ol>\n<li>Hora actual</li>\n<li>Cuánto tiempo ha estado funcionando el sistema</li>\n<li>Cuántos usuarios están actualmente conectados</li>\n<li>Promedio de carga del sistema (más por venir)</li>\n</ol>\n\n<b>2da línea: Tareas que se están ejecutando, durmiendo, detenidas y zombis</b>\n\n<b>3ra línea: Información de la CPU</b>\n\n<ol>\n<li>us: tiempo de CPU de usuario - Porcentaje de tiempo de CPU dedicado a ejecutar procesos de usuarios que no están agradables.</li>\n<li>sy: tiempo de CPU del sistema - Porcentaje de tiempo de CPU dedicado a ejecutar el kernel y procesos del kernel</li>\n<li>ni: tiempo de CPU agradable - Porcentaje de tiempo de CPU dedicado a ejecutar procesos agradables</li>\n<li>id: tiempo de CPU inactivo - Porcentaje de tiempo de CPU que se pasa inactivo</li>\n<li>wa: espera de E/S - Porcentaje de tiempo de CPU que se pasa esperando E/S. Si este valor es bajo, el problema probablemente no sea de E/S de disco o red</li> \n<li>hi: interrupciones de hardware - Porcentaje de tiempo de CPU dedicado a servir interrupciones de hardware</li>\n<li>si: interrupciones de software - Porcentaje de tiempo de CPU dedicado a servir interrupciones de software</li>\n<li>st: tiempo de robo - Si está ejecutando máquinas virtuales, este es el porcentaje de tiempo de CPU que le fue robado para otras tareas</li>\n</ol>\n\n<b>4ta y 5ta línea: Uso de memoria y uso de intercambio</b>\n\n<b>Lista de procesos que se están utilizando actualmente</b>\n\n<ol>\n<li>PID: Id del proceso</li>\n<li>USER: usuario que es el propietario del proceso</li>\n<li>PR: Prioridad del proceso</li>\n<li>NI: El valor agradable</li>\n<li>VIRT: Memoria virtual utilizada por el proceso</li>\n<li>RES: Memoria física utilizada por el proceso</li>\n<li>SHR: Memoria compartida del proceso</li>\n<li>S: Indica el estado del proceso: S=durmiendo, R=en ejecución, Z=zombi, D=no interrumpible, T=detenida</li>\n<li>%CPU - este es el porcentaje de CPU utilizado por este proceso</li>\n<li>%MEM - porcentaje de RAM utilizado por este proceso</li>\n<li>TIME+ - tiempo total de actividad de este proceso</li>\n<li>COMMAND - nombre del proceso</li>\n</ol>\n\nTambién puede especificar un ID de proceso si solo desea rastrear ciertos procesos:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "¿Qué comando muestra la misma salida que la primera línea en top?",
          "slug": "seguimientoprocesostop",
          "title": "Procesos de seguimiento: top"
        },
        {
          "exercise": "Lee las páginas de manual de lsof y fuser, hay mucha información que no cubrimos que te permite tener una mayor flexibilidad con estas herramientas.",
          "id": 2,
          "lessonContent": "Imaginemos que has conectado una unidad USB y has empezado a trabajar en algunos archivos. Una vez que hayas terminado, desmontas el dispositivo USB y recibes un error \"Dispositivo o recurso ocupado\". ¿Cómo averiguarías qué archivos en la unidad USB siguen en uso? En realidad, hay dos herramientas que puedes utilizar para esto: \n\n<b>lsof</b>\n\nRecuerda que los archivos no son solo archivos de texto, imágenes, etc., son todo en el sistema, discos, tuberías, sockets de red, dispositivos, etc. Para ver qué está en uso por un proceso, puedes usar el comando lsof (abreviatura de \"listar archivos abiertos\"), esto te mostrará una lista de todos los archivos abiertos y su proceso asociado. \n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nAhora puedo ver qué procesos están manteniendo abierto el dispositivo/archivo. En nuestro ejemplo de USB, también puedes finalizar estos procesos para poder desmontar esta molesta unidad.\n\n<b>fuser</b>\n\nOtra forma de rastrear un proceso es el comando fuser (abreviatura de \"usuario de archivo\"), esto te mostrará información sobre el proceso que está utilizando el archivo o el usuario de archivo. \n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\nPodemos ver qué procesos están utilizando actualmente nuestro directorio /home/pete. Las herramientas lsof y fuser son muy similares, familiarízate con estas herramientas e intenta usarlas la próxima vez que necesites rastrear un archivo o proceso.",
          "quizAnswer": "lsof",
          "quizQuestion": "¿Qué comando se utiliza para listar archivos abiertos y su información de proceso?",
          "slug": "rastreandoprocesoslsoffuser",
          "title": "lsof y fuser"
        },
        {
          "exercise": "Ejecuta el comando <b>ps m</b> y mira qué procesos en ejecución son multihilo.",
          "id": 3,
          "lessonContent": "Es posible que hayas escuchado los términos procesos de un solo hilo y procesos multihilo. Los hilos son muy similares a los procesos, en el sentido de que se utilizan para ejecutar el mismo programa, a menudo se les llama procesos livianos. Si un proceso tiene un hilo, es de un solo hilo y si un proceso tiene más de un hilo, es multihilo. Sin embargo, todos los procesos tienen al menos un hilo. \n\nLos procesos operan con sus propios recursos del sistema aislados, sin embargo, los hilos pueden compartir estos recursos entre sí fácilmente, lo que facilita la comunicación entre ellos y a veces es más eficiente tener una aplicación multihilo que una aplicación multiproceso.\n\nBásicamente, digamos que abres LibreOffice Writer y Chrome, cada uno es su propio proceso separado. Ahora entras en Writer y comienzas a editar texto, cuando editas el texto se guarda automáticamente. Estos dos procesos paralelos \"livianos\" de guardar y editar son hilos. \n\nPara ver los hilos de proceso, puedes usar: \n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nLos procesos se indican con cada PID y debajo de los procesos están sus hilos (indicados por --). Por lo tanto, puedes ver que los procesos anteriores son de un solo hilo.",
          "quizAnswer": "Verdadero",
          "quizQuestion": "Verdadero o falso, todos los procesos comienzan como de un solo hilo.",
          "slug": "processthreads",
          "title": "Hilos de Proceso"
        },
        {
          "exercise": "Verifica la carga promedio de tu sistema y observa qué está haciendo.",
          "id": 4,
          "lessonContent": "Vamos a repasar un comando útil, <b>uptime</b>.\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 encendido 1 día,  5:59,  2 usuarios,  carga promedio: 0.00, 0.02, 0.05\n</pre>\n\nHablamos sobre uptime en la primera lección de este curso, pero no hemos revisado el campo de carga promedio. Las cargas promedio son una buena manera de ver la carga de CPU en tu sistema. Estos números representan la carga promedio de la CPU en intervalos de 1, 5 y 15 minutos. ¿Qué quiero decir con carga de CPU? La carga de CPU es el número promedio de procesos que están esperando ser ejecutados por la CPU.\n\nDigamos que tienes una CPU de un solo núcleo, piensa en este núcleo como un carril único en el tráfico. Si es hora punta en la autopista, este carril va a estar muy ocupado y el tráfico va a estar al 100% o una carga de 1. Ahora el tráfico se ha vuelto tan malo que está congestionando la autopista y está poniendo las carreteras normales ocupadas con el doble de autos, podemos decir que tu carga es del 200% o una carga de 2. Ahora digamos que se despeja un poco y solo hay la mitad de autos en el carril de la autopista, podemos decir que la carga del carril es de 0.5. Cuando el tráfico es inexistente y podemos llegar a casa más rápido, la carga debería ser idealmente muy baja, como el tráfico de las 2 am. Los autos en este caso son procesos y estos procesos solo están esperando para salir de la autopista y llegar a casa.\n\nAhora, solo porque tienes una carga promedio de 1 no significa que tu computadora esté funcionando lentamente. La mayoría de las máquinas modernas hoy en día tienen múltiples núcleos. Si tuvieras un procesador de cuatro núcleos (4 núcleos) y tu carga promedio es de 1, realmente solo está afectando al 25% de tu CPU. Piensa en cada núcleo como un carril en el tráfico. Puedes ver la cantidad de núcleos que tienes en tu sistema con <b>cat /proc/cpuinfo</b>.\n\nAl observar la carga promedio, debes tener en cuenta el número de núcleos, si descubres que tu máquina siempre está utilizando una carga por encima del promedio, podría haber algo mal sucediendo.",
          "quizAnswer": "uptime",
          "quizQuestion": "¿Qué comando puedes usar para ver la carga promedio?",
          "slug": "monitoreo-de-cpu",
          "title": "Monitoreo de CPU"
        },
        {
          "exercise": "Utiliza iostat para ver el uso de tu disco.",
          "id": 5,
          "lessonContent": "También podemos monitorear el uso de la CPU, así como el uso del disco con una herramienta útil conocida como <b>iostat</b>\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\nLa primera parte es la información de la CPU:\n\n<ul>\n<li>%user - Muestra el porcentaje de utilización de la CPU que ocurrió mientras se ejecutaba a nivel de usuario (aplicación)</li>\n<li>%nice - Muestra el porcentaje de utilización de la CPU que ocurrió mientras se ejecutaba a nivel de usuario con prioridad nice.</li>\n<li>%system - Muestra el porcentaje de utilización de la CPU que ocurrió mientras se ejecutaba a nivel del sistema (kernel).</li>\n<li>%iowait - Muestra el porcentaje de tiempo que la CPU o CPUs estuvieron inactivas mientras el sistema tenía una solicitud de E/S de disco pendiente.</li>\n<li>%steal - Muestra el porcentaje de tiempo pasado en espera involuntaria por la CPU o CPUs virtuales mientras el hipervisor estaba atendiendo a otro procesador virtual.</li>\n<li>%idle - Muestra el porcentaje de tiempo que la CPU o CPUs estuvieron inactivas y el sistema no tenía una solicitud de E/S de disco pendiente.</li>\n</ul>\n\nLa segunda parte es la utilización del disco:\n\n<ul>\n<li>tps - Indica el número de transferencias por segundo que se emitieron al dispositivo. Una transferencia es una solicitud de E/S al dispositivo. Múltiples solicitudes lógicas pueden combinarse en una sola solicitud de E/S al dispositivo. Una transferencia tiene un tamaño indeterminado.</li>\n<li>kB_read/s - Indica la cantidad de datos leídos del dispositivo expresada en kilobytes por segundo.</li>\n<li>kB_wrtn/s - Indica la cantidad de datos escritos en el dispositivo expresada en kilobytes por segundo.</li>\n<li>kB_read - El número total de kilobytes leídos.</li>\n<li>kB_wrtn - El número total de kilobytes escritos.</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "¿Qué comando se puede utilizar para ver el uso de E/S y de la CPU?",
          "slug": "monitoreo-de-e-s",
          "title": "Monitoreo de E/S"
        },
        {
          "exercise": "Observa tu uso de memoria con vmstat.",
          "id": 6,
          "lessonContent": "Además del monitoreo de la CPU y el monitoreo de E/S, puedes monitorear el uso de tu memoria con <b>vmstat</b>\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\nLos campos son los siguientes:\n\n<b>procs</b>\n<ul>\n<li>r - Número de procesos en ejecución</li>\n<li>b - Número de procesos en espera ininterrumpible</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - Cantidad de memoria virtual utilizada</li>\n<li>free - Cantidad de memoria libre</li>\n<li>buff - Cantidad de memoria utilizada como búferes</li>\n<li>cache - Cantidad de memoria utilizada como caché</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - Cantidad de memoria intercambiada desde el disco</li>\n<li>so - Cantidad de memoria intercambiada hacia el disco</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - Cantidad de bloques recibidos desde un dispositivo de bloques</li>\n<li>bo - Cantidad de bloques enviados a un dispositivo de bloques</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - Número de interrupciones por segundo</li>\n<li>cs - Número de cambios de contexto por segundo</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - Tiempo dedicado a tiempo de usuario</li>\n<li>sy - Tiempo dedicado a tiempo de kernel</li>\n<li>id - Tiempo dedicado a inactividad</li>\n<li>wa - Tiempo dedicado a esperar por E/S</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "¿Qué herramienta se utiliza para ver la utilización de memoria?",
          "slug": "monitoreomemoria",
          "title": "Monitoreo de memoria"
        },
        {
          "exercise": "Instala sar en tu sistema y comienza a recolectar y analizar la utilización de recursos de tu sistema.",
          "id": 7,
          "lessonContent": "Estas herramientas de monitoreo son buenas para revisar cuando tu máquina tiene problemas, pero ¿qué pasa con las máquinas que tienen problemas cuando no estás mirando? Para esas situaciones, necesitarás usar una herramienta de monitoreo continuo, algo que recopilará, informará y guardará la información de actividad de tu sistema. En esta lección veremos una gran herramienta para usar <b>sar</b>.\n\n<b>Instalando sar</b>\nSar es una herramienta que se utiliza para realizar análisis históricos en tu sistema, primero asegúrate de tenerlo instalado mediante la instalación del paquete sysstat <b>sudo apt install sysstat</b>.\n\n<b>Configuración de la recolección de datos</b>\nNormalmente, una vez que instalas sysstat, tu sistema comenzará automáticamente a recolectar datos, si no lo hace, puedes habilitarlo modificando el campo ENABLED en /etc/default/sysstat.\n\n<b>Usando sar</b>\n\n<pre>$ sudo sar -q</pre>\n\nEste comando mostrará los detalles desde el inicio del día.\n\n<pre>$ sudo sar -r</pre>\n\nEsto mostrará los detalles del uso de memoria desde el inicio del día.\n\n<pre>$ sudo sar -P</pre>\n\nEsto mostrará los detalles del uso de la CPU.\n\nPara ver una vista de un día diferente, puedes ir a /var/log/sysstat/saXX donde XX es el día que deseas ver.\n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "¿Qué herramienta es buena para monitorear los recursos del sistema?",
          "slug": "monitoreocontinuo",
          "title": "Monitoreo Continuo"
        },
        {
          "exercise": "Crea un trabajo de cron que deseas ejecutar en un momento programado.",
          "id": 8,
          "lessonContent": "Aunque hemos estado hablando sobre la utilización de recursos, creo que este sería un buen momento para mencionar una herramienta útil en Linux que se utiliza para programar tareas usando cron. Hay un servicio que ejecuta programas por ti en el momento que programes. Esto es realmente útil si tienes un script que deseas ejecutar una vez al día y que necesita hacer algo por ti. \n\nPor ejemplo, digamos que tengo un script ubicado en /home/pete/scripts/change_wallpaper. Utilizo este script todas las mañanas para cambiar la imagen que uso como fondo de pantalla, pero cada mañana tengo que ejecutar este script manualmente. En lugar de eso, puedo crear un trabajo de cron que ejecute mi script a través de cron. Puedo especificar la hora a la que quiero que se ejecute este trabajo de cron y ejecutar mi script. \n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\nLos campos son los siguientes de izquierda a derecha:\n<ul>\n<li>Minuto - (0-59)</li>\n<li>Hora - (0-23)</li>\n<li>Día del mes - (1-31)</li>\n<li>Mes - (1-12)</li>\n<li>Día de la semana - (0-7). 0 y 7 se indican como domingo</li>\n</ul>\n\nEl asterisco en el campo significa que coincide con todos los valores. Así que en mi ejemplo anterior, quiero que esto se ejecute todos los días de todos los meses a las 8:30 am.\n\nPara crear un trabajo de cron, simplemente edita el archivo crontab:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "¿Cuál es el comando para editar tus trabajos de cron?",
          "slug": "cronjobs",
          "title": "Trabajos de Cron"
        }
      ],
      "slug": "processutilization",
      "title": "Utilización del Proceso"
    },
    {
      "description": "Aprende sobre los registros del sistema y el directorio /var/log.",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "Mira tu archivo /var/log/syslog y ve qué más está ocurriendo en tu máquina.",
          "id": 1,
          "lessonContent": "Los servicios, kernel, demonios, etc en tu sistema están constantemente haciendo algo, estos datos se envían para ser guardados en tu sistema en forma de registros. Esto nos permite tener un diario legible por humanos de los eventos que están ocurriendo en nuestro sistema. Estos datos generalmente se mantienen en el directorio /var, el directorio /var es donde guardamos nuestros datos variables, ¡como los registros!\n\n¿Cómo se reciben incluso estos mensajes en tu sistema? Existe un servicio llamado syslog que envía esta información al registrador del sistema. \n\nSyslog en realidad contiene muchos componentes, uno de los importantes es un demonio en ejecución llamado syslogd (las distribuciones de Linux más nuevas utilizan rsyslogd), que espera a que ocurran mensajes de eventos y filtra aquellos sobre los que desea saber, y dependiendo de lo que se supone que debe hacer con ese mensaje, lo enviará a un archivo, a tu consola o no hará nada con él.\n\nPensarías que este registrador del sistema es el lugar centralizado para gestionar registros, pero desafortunadamente no lo es. Verás muchas aplicaciones que escriben sus propias reglas de registro y generan diferentes archivos de registro, sin embargo, en general, el formato de los registros debería incluir una marca de tiempo y los detalles del evento. \n\nAquí tienes un ejemplo de una línea de syslog:\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nAquí podemos ver que el 27 de enero a las 07:41:32 nuestro servicio cron ejecutó el trabajo cron.weekly. Puedes ver todos los mensajes de eventos que recopila syslog en el archivo /var/log/syslog.",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "¿Cuál es el demonio que gestiona los registros en los sistemas Linux más nuevos?",
          "slug": "registrodelSistema",
          "title": "Registro del sistema"
        },
        {
          "exercise": "Mira tu archivo de configuración /etc/rsyslog.d y ve qué más se está registrando a través del registrador del sistema.",
          "id": 2,
          "lessonContent": "El servicio syslog gestiona y envía registros al registrador del sistema. Rsyslog es una versión avanzada de syslog, la mayoría de las distribuciones de Linux deberían estar utilizando esta nueva versión. La salida de todos los registros que recopila el servicio syslog se puede encontrar en /var/log/syslog (cada mensaje excepto los mensajes de autenticación).\n\nPara saber qué archivos mantiene nuestro registrador del sistema, mira los archivos de configuración en /etc/rsyslog.d:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nEstas reglas para archivos de registro están indicadas por el selector en la columna de la izquierda y la acción en la columna de la derecha. La acción nos dice dónde enviar la información de registro, a un archivo, consola, etc. Recuerda que no todas las aplicaciones y servicios utilizan rsyslog para gestionar sus registros, por lo que si quieres saber específicamente qué se registra, tendrás que mirar dentro de este directorio.\n\nVeamos la acción de registro en realidad, puedes enviar manualmente un registro con el comando logger:\n\n<pre>\nlogger -s Hola\n</pre>\n\nAhora mira dentro de tu /var/log/syslog y deberías ver esta entrada en tus registros!",
          "quizAnswer": "logger",
          "quizQuestion": "¿Qué comando puedes usar para registrar manualmente un mensaje?",
          "slug": "syslog",
          "title": "Primeros algunos archivos de registro estándar. Registro por facilidad."
        },
        {
          "exercise": "Mira tus archivos /var/log/messages y /var/log/syslog y observa cuáles son las diferencias.",
          "id": 3,
          "lessonContent": "Hay muchos archivos de registro que puedes ver en tu sistema, muchos importantes se pueden encontrar en /var/log. No los revisaremos todos, pero discutiremos un par de los principales. \n\nHay dos archivos de registro generales que puedes ver para tener una idea de lo que está haciendo tu sistema:\n\n<b>/var/log/messages</b>\n\nEste registro contiene todos los mensajes no críticos y no de depuración, incluye mensajes registrados durante el arranque (dmesg), autenticación, cron, daemon, etc. Muy útil para tener una idea de cómo se comporta tu máquina. \n\n<b>/var/log/syslog</b>\n\nEsto registra todo excepto mensajes de autenticación, es extremadamente útil para depurar errores en tu máquina. \n\nEstos dos registros deberían ser más que suficientes al solucionar problemas con tu sistema. Sin embargo, si solo quieres ver un componente de registro específico, también hay registros separados para esos casos.",
          "quizAnswer": "syslog",
          "quizQuestion": "¿Qué archivo de registro registra todo excepto mensajes de autenticación?",
          "slug": "registrogeneral",
          "title": "Registro General"
        },
        {
          "exercise": "Mire sus registros de dmesg y kern, ¿qué diferencias nota?",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nAl arrancar, su sistema registra información sobre el búfer de anillo del kernel. Esto nos muestra información sobre controladores de hardware, información del kernel y estado durante el arranque y más. Este archivo de registro se puede encontrar en /var/log/dmesg y se restablece en cada arranque, es posible que no vea ningún uso en él ahora, pero si alguna vez tiene problemas con algo durante el arranque o un problema de hardware, dmesg es el mejor lugar para buscar. También puede ver este registro usando el comando dmesg. \n\n<b>/var/log/kern.log</b>\nOtro registro que puede usar para ver información del kernel es el archivo /var/log/kern.log, este registra la información y eventos del kernel en su sistema, también registra la salida de dmesg.",
          "quizAnswer": "dmesg",
          "quizQuestion": "¿Qué comando se puede usar para ver mensajes de arranque del kernel?",
          "slug": "kernellogging",
          "title": "Registro del kernel"
        },
        {
          "exercise": "Realiza algunos intentos fallidos de inicio de sesión y luego uno exitoso, revisa tu /var/log/auth.log y observa qué sucedió.",
          "id": 5,
          "lessonContent": "El registro de autenticación puede ser muy útil para revisar si tienes problemas al iniciar sesión. \n\n<b>/var/log/auth.log</b>\n\nEsto contiene registros de autorización del sistema, como el inicio de sesión del usuario y el método de autenticación utilizado. \n\nFragmento de ejemplo:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "¿Qué registro se utiliza para la autenticación de usuario?",
          "slug": "registroautenticacion",
          "title": "Registro de autenticación"
        },
        {
          "exercise": "Mira tu archivo de configuración de logrotate y observa cómo gestiona algunos de tus registros.",
          "id": 6,
          "lessonContent": "Los archivos de registro generan mucha información y almacenan estos datos en sus discos duros, sin embargo, hay muchos problemas con esto, en su mayor parte solo queremos poder ver los registros más nuevos, también queremos administrar eficientemente nuestro espacio en disco, ¿cómo hacemos todo esto? La respuesta es con logrotate. \n\nLa utilidad logrotate gestiona los registros por nosotros. Tiene un archivo de configuración que nos permite especificar cuántos y qué registros mantener, cómo comprimir nuestros registros para ahorrar espacio y más. La herramienta logrotate generalmente se ejecuta a través de cron una vez al día y los archivos de configuración se pueden encontrar en /etc/logrotate.d. \n\nHay otras herramientas de rotación de registros que puede usar para administrar sus registros, pero logrotate es la más común.",
          "quizAnswer": "logrotate",
          "quizQuestion": "¿Qué utilidad se utiliza para gestionar registros?",
          "slug": "gestiondearchivosderegistro",
          "title": "Gestión de archivos de registro"
        }
      ],
      "slug": "logging",
      "title": "Registro"
    },
    {
      "description": "Aprende sobre el intercambio de red con rsync, scp, nfs y más.",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "Intenta copiar un archivo con scp de una máquina a otra.",
          "id": 1,
          "lessonContent": "Por lo general, no eres la única computadora en tu red, especialmente si estás trabajando en un entorno comercial. Cuando queremos transferir datos de una máquina a otra, a veces puede ser más fácil conectar una unidad USB y copiarlos manualmente. Pero en su mayor parte, si estás trabajando con máquinas en la misma red, la forma de transferir datos es a través del uso compartido de archivos en red. \n\nEn este curso repasaremos un par de métodos diferentes para copiar datos hacia y desde diferentes máquinas en tu red. Hablaremos sobre algunas copias de archivos simples, luego hablaremos sobre montar directorios enteros en tu máquina que actúan como una unidad separada. \n\nUna herramienta simple de uso compartido de archivos es el comando <b>scp</b>. El comando scp significa copia segura, funciona exactamente de la misma manera que lo hace el comando cp, pero te permite copiar de un host a otro host en la misma red. Funciona a través de ssh, por lo que todas tus acciones utilizan la misma autenticación y seguridad que ssh. \n\n<b>Para copiar un archivo desde el host local a un host remoto</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>Para copiar un archivo desde un host remoto a tu host local</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>Para copiar un directorio desde tu host local a un host remoto</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "¿Qué comando puedes usar para copiar archivos de forma segura de un host a otro?",
          "slug": "compartirarchivosenred",
          "title": "Descripción general de uso compartido de archivos"
        },
        {
          "exercise": "Utiliza rsync para sincronizar un directorio con otro directorio, ¡asegúrate de no sobrescribir un directorio importante!",
          "id": 2,
          "lessonContent": "Otra herramienta utilizada para copiar datos entre diferentes hosts es rsync (abreviatura de sincronización remota). Rsync es muy similar a scp, pero tiene una diferencia importante. Rsync utiliza un algoritmo especial que verifica de antemano si ya existen datos que estás copiando y solo copiará las diferencias. Por ejemplo, supongamos que estabas copiando un archivo y tu red se interrumpió, por lo tanto, tu copia se detuvo a la mitad. En lugar de volver a copiar todo desde el principio, rsync solo copiará las partes que no se copiaron. \n\nTambién verifica la integridad de un archivo que estás copiando con sumas de verificación. Estas pequeñas optimizaciones permiten una mayor flexibilidad en la transferencia de archivos y hacen que rsync sea ideal para la sincronización de directorios de forma remota y local, copias de seguridad de datos, transferencias de datos grandes y más.\n\nAlgunas opciones comúnmente utilizadas de rsync:\n\n<ul>\n<li>v - salida detallada</li>\n<li>r - recursivo en directorios</li>\n<li>h - salida legible para humanos</li>\n<li>z - comprimido para una transferencia más fácil, ideal para conexiones lentas</li>\n</ul>\n\n<b>Copiar/sincronizar archivos en el mismo host</b>\n\n<pre>$ rsync -zvr /mi/directorio/local/uno /mi/directorio/local/dos</pre>\n\n<b>Copiar/sincronizar archivos en el host local desde un host remoto</b>\n\n<pre>$ rsync /directorio/local usuario@hostremoto.com:/directorio/remoto</pre>\n\n<b>Copiar/sincronizar archivos en un host remoto desde un host local</b>\n\n<pre>$ rsync usuario@hostremoto.com:/directorio/remoto /directorio/local</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "¿Qué comando sería útil para copias de seguridad de datos?",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "¡Intenta configurar un SimpleHTTPServer!",
          "id": 3,
          "lessonContent": "Python tiene una herramienta súper útil para servir archivos a través de HTTP. Esto es genial si solo quieres crear un recurso compartido de red rápido al que otras máquinas en tu red puedan acceder. Para hacerlo, simplemente ve al directorio que deseas compartir y ejecuta:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nEsto configura un servidor web básico al que puedes acceder a través de la dirección localhost. Así que toma la dirección IP de la máquina en la que ejecutaste esto y luego en otra máquina accede a ella en el navegador con: http://DIRECCION_IP:8000. En tu propia máquina, puedes ver los archivos disponibles escribiendo: http://localhost:8000 en tu navegador web.\n\nTambién puedes hacer esto con node o si estás ejecutando Python 3, la sintaxis será un poco diferente.",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "¿Qué herramienta puedes usar para crear un servidor http simple con python?",
          "slug": "simplehttpserver",
          "title": "Servidor HTTP Simple"
        },
        {
          "exercise": "Lee la página de manual de NFS para aprender más.",
          "id": 4,
          "lessonContent": "El intercambio de archivos en red más estándar para Linux es NFS (Sistema de Archivos de Red), NFS permite a un servidor compartir directorios y archivos con uno o más clientes a través de la red. \n\nNo entraremos en los detalles de cómo crear un servidor NFS ya que puede volverse complejo, sin embargo discutiremos cómo configurar clientes NFS.\n\n<b>Configuración de cliente NFS</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>Montaje automático</b>\n\nDigamos que usas el servidor NFS con frecuencia y deseas mantenerlo montado permanentemente, normalmente pensarías en editar el archivo /etc/fstab, pero es posible que no siempre obtengas una conexión al servidor y eso puede causar problemas al arrancar. En su lugar, lo que deseas hacer es configurar el montaje automático para que puedas conectarte al servidor NFS cuando sea necesario. Esto se hace con la herramienta <b>automount</b> o en versiones recientes de Linux con <b>amd</b>. Cuando se accede a un archivo en un directorio especificado, automount buscará el servidor remoto y lo montará automáticamente.",
          "quizAnswer": "automount",
          "quizQuestion": "¿Qué herramienta se utiliza para gestionar puntos de montaje automáticamente?",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Configura un recurso compartido de Samba, si no tienes uno, abre smb.conf y familiarízate con las opciones en el archivo de configuración.",
          "id": 5,
          "lessonContent": "En los primeros días de la informática, se hizo necesario que las máquinas con Windows compartieran archivos con máquinas Linux, de ahí nació el protocolo Server Message Block (SMB). SMB se utilizaba para compartir archivos entre sistemas operativos Windows (Mac también tiene uso compartido de archivos con SMB) y luego se limpió y optimizó en forma del protocolo Common Internet File System (CIFS).\n\nSamba es como llamamos a las utilidades de Linux para trabajar con CIFS en Linux. Además de compartir archivos, también puedes compartir recursos como impresoras.\n\n<b>Crear un recurso compartido de red con Samba</b>\n\nVamos a través de los pasos básicos para crear un recurso compartido de red al que una máquina con Windows puede acceder:\n\n<b>Instalar Samba</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>Configurar smb.conf</b>\n\nEl archivo de configuración para Samba se encuentra en /etc/samba/smb.conf, este archivo debe indicar al sistema qué directorios deben compartirse, sus permisos de acceso y más opciones. El smb.conf predeterminado ya viene con mucho código comentado y puedes usarlo como ejemplo para escribir tus propias configuraciones.\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Configurar una contraseña para Samba</b>\n\n<pre>$ sudo smbpasswd -a [nombre de usuario]</pre>\n\n<b>Crear un directorio compartido</b>\n\n<pre>$ mkdir /mi/directorio/para/compartir</pre>\n\n<b>Reiniciar el servicio de Samba</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Acceder a un recurso compartido de Samba a través de Windows</b>\n\nEn Windows, simplemente escribe la conexión de red en el símbolo del sistema: \\\\HOST\\nombre_compartido.\n\n<b>Acceder a un recurso compartido de Samba/Windows a través de Linux</b>\n\n<pre>$ smbclient //HOST/directorio -U usuario</pre>\n\nEl paquete Samba incluye una herramienta de línea de comandos llamada <b>smbclient</b> que puedes usar para acceder a cualquier servidor Windows o Samba. Una vez que estés conectado al recurso compartido, puedes navegar y transferir archivos.\n\n<b>Adjuntar un recurso compartido de Samba a tu sistema</b>\n\nEn lugar de transferir archivos uno por uno, simplemente puedes montar el recurso compartido de red en tu sistema.\n\n<pre>$ sudo mount -t cifs nombre_servidor:directorio punto_montaje -o usuario=nombre_usuario,contraseña=contraseña</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "¿Cuál es el último protocolo utilizado para la transferencia de archivos entre Windows y Linux?",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "Compartir Red"
    },
    {
      "description": "Aprende sobre los conceptos básicos de redes y el modelo TCP/IP.",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "Veamos una red doméstica típica, tienes algunos componentes diferentes. \n\n<ul>\n<li>ISP - Tu proveedor de servicios de Internet, la empresa a la que pagas para tener Internet en tu casa.</li>\n<li>Router - El router permite que cada máquina de tu red se conecte a Internet. En la mayoría de los routers modernos, puedes conectarte de forma inalámbrica o a través de un cable Ethernet.</li>\n<li>WAN - Red de Área Amplia, así es como llamamos a la red que abarca todo entre tu router y una red más amplia como Internet.</li>\n<li>WLAN - Red de Área Local Inalámbrica, esta es la red entre tu router y cualquier dispositivo inalámbrico que puedas tener, como laptops.</li>\n<li>LAN - Red de Área Local, esta es la red entre tu router y cualquier dispositivo cableado como PCs de escritorio.</li>\n<li>Hosts - Cada máquina en una red se conoce como un host.</li>\n</ul>\n\nLos datos e información que se transmiten a través de las redes se conocen como paquetes y al final de la sección de Networking Nomad, entenderás en detalle cómo viaja un paquete hacia y desde los hosts.",
          "quizAnswer": "LAN",
          "quizQuestion": "¿Cómo se conoce a la red de área local?",
          "slug": "conceptosred",
          "title": "Conceptos básicos de redes"
        },
        {
          "exercise": "Lee más sobre el modelo OSI: <a href=\"https://es.wikipedia.org/wiki/Modelo_OSI\">https://es.wikipedia.org/wiki/Modelo_OSI</a>",
          "id": 2,
          "lessonContent": "Antes de que podamos ver algunas cosas prácticas de redes, tenemos que repasar algunos términos aburridos que probablemente hayas escuchado antes. El modelo OSI (Interconexión de Sistemas Abiertos) es un modelo teórico de redes. Este modelo nos muestra cómo un paquete atraviesa una red en siete capas diferentes. No entraré en detalles de este modelo, ya que la mayoría de estos cursos de redes se centrarán en el modelo TCP/IP, pero se debe mencionar que existe un modelo teórico de redes que ha jugado un papel importante en el modelo de redes TCP/IP que usamos hoy en día.",
          "quizAnswer": "OSI",
          "quizQuestion": "¿Qué se utiliza como modelo teórico de redes?",
          "slug": "modelosi",
          "title": "Modelo OSI"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "El modelo OSI dio origen a lo que eventualmente se convirtió en el modelo TCP/IP y este modelo es en realidad en lo que se basa Internet. Es la implementación real de la red. El modelo TCP/IP utiliza el conjunto de protocolos TCP/IP, al que comúnmente nos referimos simplemente como TCP/IP. Estos protocolos trabajan juntos para especificar cómo se deben recopilar, dirigir, transmitir y enrutar los datos a través de una red. Utilizando el modelo TCP/IP, podemos ver cómo estos protocolos se utilizan para mostrar el desglose de cómo un paquete viaja a través de la red.\n\n<b>Capa de Aplicación</b>\n\nLa capa superior del modelo TCP/IP. Determina cómo los programas de tu computadora (como tu navegador web) interactúan con los servicios de la capa de transporte para ver los datos que se envían o se reciben.\n\nEsta capa utiliza:\n<ul>\n<li>HTTP (Protocolo de Transferencia de Hipertexto) - utilizado para las páginas web en Internet.</li>\n<li>SMTP (Protocolo Simple de Transferencia de Correo) - transmisión de correo electrónico</li>\n</ul>\n\n<b>Capa de Transporte</b>\n\nCómo se transmitirán los datos, incluye la verificación de los puertos correctos, la integridad de los datos y básicamente la entrega de nuestros paquetes.\n\nEsta capa utiliza:\n<ul>\n<li>TCP (Protocolo de Control de Transmisión) - entrega fiable de datos</li>\n<li>UDP (Protocolo de Datagramas de Usuario) - entrega no fiable de datos</li>\n</ul>\n\n<b>Capa de Red</b>\n\nEsta capa especifica cómo mover paquetes entre hosts y a través de redes.\n\nEsta capa utiliza:\n<ul>\n<li>IP (Protocolo de Internet) - Ayuda a enrutar paquetes de una máquina a otra.</li>\n<li>ICMP (Protocolo de Mensajes de Control de Internet) - Ayuda a informarnos sobre lo que está sucediendo, como mensajes de error e información de depuración.</li>\n</ul>\n\n<b>Capa de Enlace</b>\n\nEsta capa especifica cómo enviar datos a través de un componente físico. Como datos que viajan a través de Ethernet, fibra, etc.\n\nLas listas anteriores de protocolos que cada capa utiliza no son exhaustivas y encontrarás muchos otros protocolos que entran en juego.\n\nEn las siguientes lecciones, profundizaremos en cada una de estas capas y discutiremos cómo nuestro paquete atraviesa la red a través del modelo TCP/IP (hay muchas perspectivas sobre cómo un paquete viaja a través de las redes, no las veremos todas, pero ten en cuenta que existen).",
          "quizAnswer": "Aplicación",
          "quizQuestion": "¿Cuál es la capa superior del modelo TCP/IP?",
          "slug": "modelo-tcpip",
          "title": "Modelo TCP/IP"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "Antes de ver cómo se mueve un paquete a través de una red, debemos familiarizarnos con algunos términos. Cuando envías una carta, debes saber a quién se envía y de dónde proviene. Los paquetes necesitan la misma información, nuestros hosts y otros hosts se identifican utilizando direcciones MAC (control de acceso a medios) y direcciones IP, para facilitarnos la identificación usamos nombres de host.\n\n<b>Direcciones MAC</b>\n\nUna dirección MAC es un identificador único utilizado como dirección de hardware. Esta dirección nunca cambiará. Cuando deseas acceder a Internet, tu máquina necesita tener un dispositivo llamado tarjeta de interfaz de red. Este adaptador de red tiene su propia dirección de hardware que se utiliza para identificar tu máquina. Una dirección MAC para un dispositivo Ethernet se ve algo así: 00:C4:B5:45:B2:43. Las direcciones MAC se asignan a los adaptadores de red cuando se fabrican. Cada fabricante tiene un identificador único organizacional (OUI) para identificarlos como el fabricante. Este OUI se indica en los primeros 3 bytes de la dirección MAC. Por ejemplo, Dell tiene 00-14-22, por lo que un adaptador de red de Dell podría tener una dirección MAC como: 00-14-22-34-B2-C2. \n\n<b>Direcciones IP</b>\n\nUna dirección IP se utiliza para identificar un dispositivo en una red, son independientes del hardware y pueden variar en sintaxis dependiendo de si estás utilizando IPv4 o IPv6 (más sobre esto más adelante). Por ahora asumiremos que estás utilizando IPv4, por lo que una dirección IP típica se vería así: 10.24.12.4. Las direcciones IP se utilizan en el lado del software de las redes. Cada vez que un sistema está conectado a Internet, debe tener una dirección IP. También pueden cambiar si tu red cambia y son únicas en todo Internet (esto no siempre es el caso una vez que aprendemos sobre NAT). \n\nRecuerda que se necesitan tanto software como hardware para mover paquetes a través de las redes, por lo que tenemos dos identificadores para cada uno, MAC (hardware) e IP (software).\n\n<b>Nombres de host</b>\n\nUna última forma de identificar tus máquinas es a través del nombre de host. Los nombres de host toman tu dirección IP y te permiten vincular esa dirección a un nombre legible para los humanos. En lugar de recordar 192.12.41.4, puedes recordar simplemente myhost.com.",
          "quizAnswer": "4",
          "quizQuestion": "¿Cuántos bytes hay en una dirección IPv4?",
          "slug": "direccionred",
          "title": "Dirección de red"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Imaginemos que queremos enviar un correo electrónico a Patty. Vamos a repasar cada una de las capas TCP/IP para ver esto en acción. \n\nRecuerda que los paquetes se utilizan para transmitir datos a través de redes, un paquete consta de una cabecera y una carga útil. La cabecera contiene información sobre a dónde va el paquete y de dónde proviene. La carga útil es la información real que se está transfiriendo. A medida que nuestro paquete atraviesa la red, cada capa agrega un poco de información a la cabecera del paquete. También ten en cuenta que diferentes capas utilizan un término diferente para nuestro \"paquete\". En la capa de transporte esencialmente encapsulamos nuestros datos en un segmento y en la capa de enlace nos referimos a esto como un trama, pero debes saber que el término paquete se puede utilizar en relación con lo mismo.\n\nComenzamos en la capa de aplicación. Cuando enviamos nuestro correo electrónico a través de nuestro cliente de correo electrónico, la capa de aplicación encapsulará estos datos. La capa de aplicación se comunica con la capa de transporte a través de un puerto especificado y a través de este puerto envía sus datos. Queremos enviar un correo electrónico a través del protocolo de capa de aplicación SMTP (protocolo simple de transferencia de correo). Los datos se envían a través de nuestro protocolo de transporte que abre una conexión a este puerto (el puerto 25 se utiliza para SMTP), por lo que estos datos se envían a través de este puerto y esos datos se envían a la capa de transporte para ser encapsulados en segmentos.",
          "quizAnswer": "Aplicación",
          "quizQuestion": "¿Qué capa se utiliza para presentar los datos del paquete en un formato amigable para el usuario?",
          "slug": "capadeaplicacion",
          "title": "Capa de Aplicación"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 6,
          "lessonContent": "La capa de transporte nos ayuda a transferir nuestros datos de una manera que las redes puedan leer. Divide nuestros datos en fragmentos que se transportarán y se volverán a unir en el orden correcto. Estos fragmentos se conocen como segmentos. Los segmentos facilitan el transporte de datos a través de las redes. \n\n<b>Puertos</b>\n\nAunque sepamos a dónde enviamos nuestros datos a través de direcciones IP, estas no son lo suficientemente específicas para enviar nuestros datos a ciertos procesos o servicios. Servicios como HTTP utilizan un canal de comunicación a través de puertos. Si queremos enviar datos de una página web, necesitamos enviarlos a través del puerto HTTP (puerto 80). Además de formar segmentos, la capa de transporte también adjuntará los puertos de origen y destino al segmento, para que cuando el receptor reciba el paquete final sepa qué puerto utilizar. \n\n<b>UDP</b>\n\nHay dos protocolos de transporte populares: UDP y TCP. Discutiremos brevemente UDP y pasaremos la mayor parte de nuestro tiempo en TCP, ya que es el más comúnmente utilizado.\n\nUDP no es un método confiable para transportar datos, de hecho no le importa realmente si obtienes todos tus datos originales. Esto puede sonar terrible, pero tiene sus usos, como en la transmisión de medios, está bien si pierdes algunos fotogramas a cambio de obtener tus datos un poco más rápido. \n\n<b>TCP</b>\n\nTCP proporciona una conexión confiable y orientada a la transmisión de datos. TCP utiliza puertos para enviar datos hacia y desde los hosts. Una aplicación abre una conexión desde un puerto en su host hacia otro puerto en un host remoto. Para establecer la conexión, utilizamos el saludo de TCP. \n\n<ul>\n<li>El cliente (proceso de conexión) envía un segmento SYN al servidor para solicitar una conexión</li>\n<li>El servidor envía al cliente un segmento SYN-ACK para confirmar la solicitud de conexión del cliente</li>\n<li>El cliente envía un ACK al servidor para confirmar la solicitud de conexión del servidor</li>\n</ul>\n\nUna vez establecida esta conexión, los datos pueden intercambiarse a través de una conexión TCP. Los datos se envían en diferentes segmentos y se rastrean con números de secuencia TCP para que puedan ser ordenados en el orden correcto cuando se entregan. En nuestro ejemplo de correo electrónico, la capa de transporte adjunta el puerto de destino (25) al puerto de origen del host de origen.",
          "quizAnswer": "TCP",
          "quizQuestion": "¿Cuál es un protocolo de transporte confiable?",
          "slug": "capadetransporte",
          "title": "Capa de transporte"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 7,
          "lessonContent": "La capa de red determina la ruta de nuestros paquetes desde nuestro host de origen hasta un host de destino. Afortunadamente, en nuestro ejemplo, nuestro paquete solo viaja dentro de la misma red, pero Internet está compuesto por muchas redes. Estas redes más pequeñas que conforman Internet se conocen como subredes. Todas las subredes se conectan de alguna manera, por eso podemos acceder a www.google.com aunque esté en su propia red. No entraré en detalles ya que tenemos un curso completo dedicado a las subredes, pero por ahora, en relación con nuestra capa de red, sepa que las direcciones IP definen las reglas para viajar a diferentes subredes. \n\nEn la capa de red, recibe el segmento proveniente de la capa de transporte y encapsula este segmento en un paquete IP, luego adjunta la dirección IP del host de origen y la dirección IP del host de destino al encabezado del paquete. En este punto, nuestro paquete tiene información sobre a dónde va y de dónde viene. Ahora envía nuestro paquete a la capa de hardware físico.",
          "quizAnswer": "subredes",
          "quizQuestion": "¿Cómo se llaman las redes más pequeñas que conforman Internet?",
          "slug": "capadered",
          "title": "Capa de Red"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 8,
          "lessonContent": "En la parte inferior del modelo TCP/IP se encuentra la Capa de enlace. Esta capa es la capa específica de hardware.\n\nEn la capa de enlace, nuestro paquete se encapsula una vez más en algo llamado trama. El encabezado de la trama adjunta las direcciones MAC de origen y destino de nuestros hosts, sumas de verificación y separadores de paquetes para que el receptor pueda saber cuándo termina un paquete. \n\nAfortunadamente estamos en la misma red, por lo que nuestro paquete no tendrá que viajar demasiado lejos. Primero, la capa de enlace adjunta mi dirección MAC de origen al encabezado de la trama, pero también necesita conocer la dirección MAC de Patty. ¿Cómo lo sabe y cómo la encuentro si no está en Internet? ¡Usamos ARP!\n\n<b>ARP (Protocolo de resolución de direcciones)</b>\n\nARP encuentra la dirección MAC asociada con una dirección IP. ARP se utiliza dentro de la misma red. Si Patty no estuviera en la misma red, usaríamos un sistema de enrutamiento para determinar el siguiente enrutador que recibiría el paquete y una vez que estuviéramos en la misma red, podríamos usar ARP. \n\nUna vez que estamos en la misma red, los sistemas primero utilizan la tabla de búsqueda ARP que almacena información sobre qué direcciones IP están asociadas con qué direcciones MAC. Si el valor no está allí, entonces se utiliza ARP. Luego, el sistema enviará un mensaje de difusión a la red utilizando el protocolo ARP para averiguar qué host tiene la IP 10.10.1.4. Un mensaje de difusión es un mensaje especial que se envía a todos los hosts en una red (apropiadamente nombrado para enviar una difusión). Cualquier máquina con la dirección IP solicitada responderá con un paquete ARP que contiene la dirección IP y la dirección MAC.\n\nAhora que tenemos todos los datos necesarios que necesitamos, dirección IP y direcciones MAC, nuestra capa de enlace reenvía esta trama a través de nuestra tarjeta de interfaz de red, hacia el siguiente dispositivo y encuentra la red de Patty. Este paso es un poco más complejo de lo que acabo de explicar, pero discutiremos más detalles en el curso de Enrutamiento.\n\nY ahí tienes un recorrido de paquetes simple (o no tan simple) por la capa TCP/IP. Ten en cuenta que los paquetes no viajan de esta manera de forma unidireccional. ¡Ni siquiera hemos llegado a la red de Patty todavía! Al viajar a través de las redes, se requiere pasar por el modelo TCP/IP al menos dos veces antes de que se envíe o reciba cualquier dato. En realidad, la forma en que se ve este paquete sería algo así: \n\n<b>Recorrido del paquete</b>\n\n<ol>\n<li>Pete envía un correo electrónico a Patty: estos datos se envían a la capa de transporte.</li>\n<li>La capa de transporte encapsula los datos en un encabezado TCP o UDP para formar un segmento, el segmento adjunta el puerto TCP o UDP de destino y origen, luego el segmento se envía a la capa de red.</li>\n<li>La capa de red encapsula el segmento TCP dentro de un paquete IP, adjunta las direcciones IP de origen y destino. Luego enruta el paquete a la capa de enlace.</li>\n<li>El paquete llega entonces al hardware físico de Pete y se encapsula en una trama. Las direcciones MAC de origen y destino se agregan a la trama.</li>\n<li>Patty recibe esta trama de datos a través de su capa física y verifica cada trama para la integridad de los datos, luego desencapsula el contenido de la trama y envía el paquete IP a la capa de red.</li>\n<li>La capa de red lee el paquete para encontrar las direcciones IP de origen y destino que se adjuntaron previamente. Comprueba si su IP es la misma que la IP de destino, ¡lo es! Desencapsula el paquete y envía el segmento a la capa de transporte.</li>\n<li>La capa de transporte desencapsula los segmentos, verifica los números de puerto TCP o UDP y establece una conexión con la capa de aplicación en función de esos números de puerto.</li>\n<li>La capa de aplicación recibe los datos de la capa de transporte en el puerto que se especificó y los presenta a Patty en forma de mensaje de correo electrónico final</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "¿Qué se utiliza para encontrar la dirección MAC en la misma red?",
          "slug": "capaenlace",
          "title": "Capa de enlace"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 9,
          "lessonContent": "Un concepto importante de redes que aún no hemos cubierto es DHCP (Protocolo de Configuración Dinámica de Host)\n\nDHCP asigna direcciones IP, máscaras de subred y pasarelas a nuestras máquinas. Por ejemplo, digamos que tienes un teléfono celular y quieres obtener un número de teléfono para empezar a hablar con la gente. Tienes que llamar a tu operador telefónico y te darán un número. Mientras pagues tus facturas, puedes seguir usando tu teléfono. DHCP es el operador telefónico en este caso, te da una dirección IP para que puedas hablar con otras direcciones IP. También se te arrienda una dirección IP, estas duran un cierto período de tiempo, luego se renovarán dependiendo de cómo tengas configurada tu arrendamiento. \n\nDHCP es genial por muchas razones, permite a un administrador de red no preocuparse por asignar direcciones IP y también evita que se configuren direcciones IP duplicadas. Cada red física debería tener su propio servidor DHCP para que un host pueda solicitar una dirección IP. En un entorno doméstico normal, el enrutador suele actuar como servidor DHCP.\n\nLa forma en que DHCP obtiene toda tu información de host dinámica es:\n\n<ol>\n<li>DHCP DISCOVER - Este mensaje se difunde para buscar un servidor DHCP.</li>\n<li>DHCP OFFER - El servidor DHCP en la red responde con un mensaje de oferta. La oferta contiene un paquete con el tiempo de arrendamiento DHCP, máscara de subred, dirección IP, etc.</li>\n<li>DHCP REQUEST - El cliente envía otra difusión para que todos los servidores DHCP sepan qué oferta aceptó.</li>\n<li>DHCP ACK - El servidor envía un acuse de recibo.</li>\n</ol>\n\nDHCP se vuelve más complejo que esto, pero esta es la esencia de ello.",
          "quizAnswer": "DISCOVER, OFFER, REQUEST, ACK",
          "quizQuestion": "¿Cuáles son los pasos en una solicitud de DHCP?",
          "slug": "dhcpoverview",
          "title": "Visión general de DHCP"
        }
      ],
      "slug": "networkbasics",
      "title": "Conceptos básicos de redes"
    },
    {
      "description": "Aprende sobre subredes y cómo hacer aritmética de subredes!",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "Encuentra tu dirección IP con ifconfig.",
          "id": 1,
          "lessonContent": "Cada host de red tiene una dirección única, y cada dirección única se puede utilizar para localizar el host dentro de la red. Estas direcciones únicas se conocen como 'direcciones IP'. Una dirección IPv4 se ve algo así:\n\n<pre>204.23.124.23</pre>\n\nEsta dirección en realidad contiene dos partes: la parte de red (que identifica en qué red se encuentra) y la parte de host (que identifica el host). Para este curso, principalmente estaremos discutiendo direcciones IPv4, que es lo que comúnmente verás al referirte a 'direcciones IP'. \n\nUna dirección IP se separa en octetos por los puntos. Hay 4 octetos en una dirección IPv4. Si conoces un poco de informática, sabrás que un octeto son 8 bits, y sabrás que 8 bits en realidad equivalen a 1 byte. Esto significa que una dirección IPv4 tiene 4 bytes. Usamos bits con frecuencia al tratar con subredes y direcciones IP.\n\nPuedes ver tu dirección IP con el comando 'ifconfig -a':\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\nComo puedes ver, mi dirección IPv4 es: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "¿Cuántos bytes hay en una dirección IPv4?",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "Utiliza ifconfig para ver tu máscara de subred.",
          "id": 2,
          "lessonContent": "¿Cómo puedo saber si estoy en la misma red que Patty? Bueno, simplemente podemos mirar la subred. Una subred es un grupo de hosts con direcciones IP que son similares de cierta manera. Estos hosts suelen estar en una ubicación cercana entre sí y puedes enviar datos fácilmente hacia y desde los hosts en la misma subred. Piénsalo como enviar correo en el mismo código postal, es mucho más fácil que enviar correo a un estado diferente. \n\nPor ejemplo, todos los hosts con una dirección IP que comienza con 123.45.67 estarían en la misma subred. Mi host tiene una IP de 123.45.67.8 y la de Patty es 123.45.67.9. Los números comunes son mi prefijo de red y el 8 y el 9 son nuestros hosts, por lo tanto mi red es la misma que la de Patty. Una subred se divide en un prefijo de red, como 123.45.67.0 y una máscara de subred.\n\n<b>Máscaras de Subred</b>\n\nLas máscaras de subred determinan qué parte de tu dirección IP es la porción de red y qué parte es la porción de host. \n\nUna máscara de subred típica puede verse algo así:\n\n<pre>255.255.255.0</pre>\n\nLa parte 255 es en realidad nuestra máscara. Para hacer esto un poco más fácil de entender, recuerda cómo nos referimos a cada octeto como 8 bits. En informática, un bit se denota con un 0 o un 1 en forma binaria. Cuando se usan números binarios, 1 significa encendido y 0 apagado. Entonces, ¿qué equivale a 8 0's o 1's?\n\nIntroduce en Google \"calculadora de binario a decimal\" y convierte 11111111 a forma decimal. ¿Qué obtienes? ¡255! Entonces un octeto va de 0 a 255. Entonces, si tuviéramos una máscara de subred de 255.255.255.0 y una dirección IP de 192.168.1.0, ¿cuántos hosts hay en esa subred? Descubriremos la respuesta en nuestra lección de matemáticas de subred.\n\nTambién cuando hablamos de nuestra subred, comúnmente la denotamos por el prefijo de red seguido de la máscara de subred:\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>¿Por qué?</b>\n\n¿Por qué diablos creamos subredes? La segmentación de redes se utiliza para segmentar redes y controlar el flujo de tráfico dentro de esa red. Por lo tanto, un host en una subred no puede interactuar con otro host en una subred diferente. \n\nPero espera un minuto, ¿qué pasa si quiero conectarme con otros hosts como yahoo.com? Entonces necesitas conectar subredes juntas. Para conectar subredes solo necesitas encontrar los hosts que están conectados a más de una subred. Por ejemplo, si mi host en 192.168.1.129 está conectado a una red local de 192.168.1.129/24 puede alcanzar cualquier host en esa red. Para alcanzar hosts en el resto de Internet, necesita comunicarse a través del enrutador. Tradicionalmente, en la mayoría de las redes con una máscara de subred de 255.255.255.0, el enrutador suele estar en la dirección 1 de la subred, por lo tanto 192.168.1.1. Ahora ese enrutador tendrá un puerto que lo conecta a otra subred (más en el curso de enrutamiento). Ciertas direcciones IP (redes privadas) no son visibles para Internet, y tenemos cosas como NAT en su lugar (más sobre esto más adelante).",
          "quizAnswer": "Verdadero",
          "quizQuestion": "Verdadero o falso, una subred consiste en una máscara de subred y un prefijo de red.",
          "slug": "subredes",
          "title": "Subredes"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "Ok, sabemos que las máscaras de subred son importantes para averiguar cuántos hosts podemos tener en nuestra subred. Entonces, ¿cuántos hosts serían esos? \n\nDigamos que tengo una dirección IP de <b>192.168.1.0</b> y una máscara de subred de <b>255.255.255.0</b>, ahora alineemos estos números en forma binaria. Por ahora, usa una calculadora en línea para convertir estos valores de decimal a binario.\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nLa dirección IP está enmascarada por nuestra máscara de subred, cuando ves un 1, está enmascarado y fingimos que no lo vemos. Entonces, los únicos hosts posibles que podemos tener son de la región 00000000. Recuerda que 11111111 en forma binaria equivale a 255, también consideramos 0 como un número de host, por lo que hay 256 opciones posibles. Sin embargo, puede parecer que tenemos 256 opciones posibles, pero en realidad restamos 2 hosts porque tenemos que tener en cuenta la dirección de difusión y la dirección de subred, lo que nos deja con 254 hosts posibles en nuestra subred. Así que sabemos que podemos tener hosts con direcciones IP que van desde 192.168.1.1 - 192.168.1.254.",
          "quizAnswer": "11111111",
          "quizQuestion": "¿Cuál es el equivalente binario de 255?",
          "slug": "subnetmath",
          "title": "Matemáticas de subredes"
        },
        {
          "exercise": "Mira tu dirección IP y máscara de subred y ve cuántos hosts puedes tener en tu subred.",
          "id": 4,
          "lessonContent": "Odio tener que agregar esta sección, en el mundo real es muy probable que nunca tengas que hacer cálculos de subred a mano, sin embargo, si te están entrevistando sobre esto, tendrás que saber cómo convertir a y desde forma binaria para subnetting. Afortunadamente, hay algunos trucos aritméticos que puedes memorizar. \n\nPrimero memoriza tus cálculos en base-2, simplemente hazlo:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>Tabla Decimal a Binario</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\nHay muchas razones por las que la siguiente tabla se ve de la forma en que lo hace, si te interesa cómo funciona, hay muchos recursos en línea.\n\n¿Listo, memorizaste estos? Hagamos una rápida conversión de decimal a binario:\n\n<b>Convertir 192.168.23.43 a Binario</b>\n\nRecuerda: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\nVamos a convertir el primer octeto a binario y entenderás cómo funciona el resto.\n\n<ol>\n<li>¿Puedes restar 192 - 128? Sí, entonces el primer bit es 1</li>\n<li>192 - 128 = 64, el siguiente número en la tabla es 64, ¿puedes restar 64 - 64? Sí, entonces el segundo bit es 1</li>\n<li>Nos hemos quedado sin números para restar, así que nuestra forma binaria de 192 es 11000000</li>\n</ol>\n\n<b>Convertir Binario 11000000 a Decimal</b>\n\nPara la conversión de binario a decimal, sumas los números que tienen un 1, entonces:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "¿Cuál es la conversión binaria de 123?",
          "slug": "subnettingcheats",
          "title": "Trucos de Subnetting"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "CIDR (enrutamiento interdominio sin clases) se utiliza para representar una máscara de subred de una manera más compacta. Puede ver subredes anotadas en notación CIDR, donde una subred como 10.42.3.0/255.255.255.0 se escribe como 10.42.3.0/24, lo que simplemente significa que incluye tanto el prefijo de subred como la máscara de subred.\n\nRecuerde que una dirección IP consta de 4 bytes o 32 bits, CIDR indica la cantidad de bits utilizados como prefijo de red. Entonces, 123.12.24.0/23 significa que se utilizan los primeros 23 bits. ¿Qué significa eso? ¿Cuántos hosts son esos? \n\nUn truco simple es restar el total de bits que puede tener una dirección IP (32) de la dirección CIDR (23), por lo que quedan 9 bits, 2^9 = 512, pero tenemos que eliminar 2 direcciones (dirección de subred y dirección de difusión), por lo que tenemos 510 hosts utilizables.",
          "quizAnswer": "",
          "quizQuestion": "¡No hay preguntas, sigue adelante!",
          "slug": "enrutamientointerdominiosinclasescidr",
          "title": "CIDR"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 6,
          "lessonContent": "Hemos mencionado NAT (traducción de direcciones de red) antes pero no profundizamos en ello, cuando estamos trabajando en nuestra red, ¿significa eso que Internet puede ver nuestra dirección IP? No exactamente.\n\nNAT hace que un dispositivo como nuestro enrutador actúe como intermediario entre Internet y la red privada. Por lo tanto, solo se requiere una única dirección IP para representar a todo un grupo de computadoras.\n\nPiensa en NAT como un recepcionista en una oficina grande, si alguien quiere contactarte, solo conoce el número de toda la oficina, el recepcionista tendría que buscar tu número de extensión y transferir la llamada a ti.\n\n<b>¿Cómo funciona?</b>\n\nUn caso simple se vería así:\n\n<ol>\n<li>Patty quiere conectarse a www.google.com, por lo que su máquina envía esta solicitud a través del enrutador</li>\n<li>El enrutador toma esa solicitud y abre su propia conexión a google.com, luego envía la solicitud de Patty una vez que establece una conexión</li>\n<li>El enrutador es el intermediario entre Patty y www.google.com. Google no sabe acerca de Patty, en cambio, todo lo que puede ver es el enrutador.</li>\n</ol>\n\nNAT y el enrutamiento de paquetes en general pueden volverse bastante complicados, pero no profundizaremos en los detalles.",
          "quizAnswer": "NAT",
          "quizQuestion": "¿Qué se utiliza para representar una única dirección privada en Internet?",
          "slug": "traducciondedireccionesderednat",
          "title": "NAT"
        },
        {
          "exercise": "Verifique ifconfig para ver si tiene una dirección IPv6 listada.",
          "id": 7,
          "lessonContent": "Hemos escuchado el término IPv6 aquí y allá, pero ¿qué es? Cada dispositivo que se conecta a Internet obtiene su propia dirección IP, bueno, resulta que es un número finito al que pronto nos acercaremos en esta era digital. IPv6 fue creado para permitirnos conectar más hosts a Internet, viene con más mejoras en IP, sin embargo, su adopción es bastante lenta. No está destinado a reemplazar IPv4, están destinados a complementarse mutuamente. Los dos protocolos IP son muy similares y si conoces IPv4 entenderás IPv6, la diferencia principal es la forma en que se escribe la dirección. Así es como se ve una dirección IPv6 típica:\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "¿Qué dirección IP se utiliza para aumentar el número de hosts que pueden conectarse a Internet?",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "Subnetting"
    },
    {
      "description": "¡Aprende cómo se enrutan los paquetes a través de las redes!",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "Hemos utilizado este término enrutador antes, espero que sepas qué es, ya que probablemente tienes uno en tu casa. Un enrutador permite que las máquinas en una red se comuniquen entre sí, así como con otras redes. En un enrutador típico, tendrás puertos LAN que permiten que tus máquinas se conecten a la misma red de área local y también tendrás un puerto de enlace a Internet que te conecta a Internet, a veces verás que este puerto se etiqueta como WAN, porque esencialmente te conecta a una red más amplia. Cuando realizamos cualquier tipo de actividad de red, tiene que pasar por el enrutador. El enrutador decide hacia dónde van nuestros paquetes de red y cuáles entran. Enruta nuestros paquetes entre múltiples redes para llegar desde su host de origen a su host de destino. \n\n<b>¿Cómo funciona un enrutador?</b>\n\nPiensa en el enrutamiento de la misma manera que en la entrega de correo, tenemos una dirección a la que queremos enviar una carta, cuando la enviamos a la oficina de correos, ellos reciben la carta y ven, oh, esto va a California, la pondré en el camión que va a California (sinceramente no tengo idea de cómo funciona el sistema postal). Luego la carta se envía a San Francisco, dentro de San Francisco hay diferentes códigos postales, y luego en esos códigos postales hay códigos de direcciones más pequeños, hasta que finalmente alguien puede entregar tu carta a la dirección que querías. Por otro lado, si ya vivieras en San Francisco y en el mismo código postal, el repartidor de correo probablemente sabrá exactamente a dónde tiene que ir la carta sin entregársela a nadie más. \n\nCuando enrutamos paquetes, utilizan rutas de direcciones similares, como para llegar a la red A, enviar estos paquetes a la red B. Cuando no tenemos una ruta establecida para eso, tenemos una ruta predeterminada que utilizarán nuestros paquetes. Estas rutas se establecen en una tabla de enrutamiento que nuestro sistema utiliza para guiarnos a través de las redes.\n\n<b>Saltos</b>\n\nA medida que los paquetes se mueven a través de las redes, viajan en saltos, un salto es cómo medimos aproximadamente la distancia que el paquete debe recorrer para llegar desde el origen al destino. Digamos que tengo dos enrutadores conectando el host A con el host B, por lo tanto decimos que hay dos saltos entre el host A y el host B. Cada salto es un dispositivo intermedio como los enrutadores por los que debemos pasar.\n\n<b>Comprender la diferencia básica entre Conmutación, Enrutamiento y Difusión</b>\nLa CONMUTACIÓN de paquetes básicamente consiste en recibir, procesar y reenviar datos al dispositivo de destino.\nEl ENRUTAMIENTO es un proceso de creación de la tabla de enrutamiento, para que podamos hacer la CONMUTACIÓN de manera más eficiente.\nAntes del enrutamiento, se utilizaba la DIFUSIÓN. Si un enrutador no sabe a dónde enviar un paquete, entonces cada paquete entrante se envía a través de cada enlace de salida excepto por el que llegó.",
          "quizAnswer": "saltos",
          "quizQuestion": "¿Cómo miden distancia los paquetes?",
          "slug": "queesunenrutador",
          "title": "¿Qué es un enrutador?"
        },
        {
          "exercise": "Mira tu tabla de enrutamiento y ve a dónde pueden ir tus paquetes.",
          "id": 2,
          "lessonContent": "Mira la tabla de enrutamiento de tu máquina:\n\n<pre>\npete@icebox:~$ sudo route -n\nTabla de enrutamiento IP del kernel\nDestino         Puerta de enlace         Máscara de red         Banderas Métrica Ref    Uso Interfaz\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destino</b>\n\nEn el primer campo, tenemos una dirección IP de destino de 192.168.224.0, esto indica que cualquier paquete que intente ir a esta red, saldrá a través de mi cable Ethernet (eth0). Si yo fuera 192.168.224.5 y quisiera llegar a 192.168.224.7, simplemente usaría la interfaz de red eth0 directamente.\n\nObserva que tenemos direcciones de <b>0.0.0.0</b>, esto significa que no se especifica ninguna dirección o es desconocida. Entonces, si por ejemplo, quisiera enviar un paquete a la dirección IP 151.123.43.6, nuestra tabla de enrutamiento no sabe a dónde va eso, por lo que lo denota como 0.0.0.0 y por lo tanto enruta nuestro paquete hacia la Puerta de enlace.\n\n<b>Puerta de enlace</b>\n\nSi estamos enviando un paquete que no está en la misma red, se enviará a esta dirección de Puerta de enlace. Que recibe el nombre adecuado de ser una Puerta de enlace a otra red.\n\n<b>Máscara de red</b>\n\nEsta es la máscara de subred, utilizada para determinar qué direcciones IP coinciden con qué destino.\n\n<b>Banderas</b>\n\n<ul>\n<li>UG - La red está activa y es una Puerta de enlace</li>\n<li>U - La red está activa</li>\n</ul>\n\n<b>Interfaz</b>\n\nEsta es la interfaz por la cual nuestro paquete saldrá, eth0 generalmente representa el primer dispositivo Ethernet en tu sistema.",
          "quizAnswer": "Puerta de enlace",
          "quizQuestion": "¿A dónde se enrutan los paquetes si nuestra tabla de enrutamiento no lo sabe?",
          "slug": "tablaenrutamiento",
          "title": "Tabla de enrutamiento"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "<b>Veamos cómo viaja un paquete dentro de su red local</b>\n\n<ol>\n<li>Primero, la máquina local comparará la dirección IP de destino para ver si está en la misma subred mirando su máscara de subred.</li>\n<li>Cuando se envían paquetes, necesitan tener una dirección MAC de origen, dirección MAC de destino, dirección IP de origen y dirección IP de destino, en este punto no conocemos la dirección MAC de destino.</li>\n<li>Para llegar al host de destino, usamos ARP para difundir una solicitud en la red local para encontrar la dirección MAC del host de destino.</li>\n<li>¡Ahora el paquete puede ser enviado con éxito!</li>\n</ol>\n\n<b>Veamos cómo viaja un paquete fuera de su red</b>\n\n<ol>\n<li>Primero, la máquina local comparará la dirección IP de destino, como está fuera de nuestra red, no ve la dirección MAC del host de destino. Y no podemos usar ARP porque la solicitud ARP es una difusión a los hosts conectados localmente.</li>\n<li>Entonces nuestro paquete ahora mira la tabla de enrutamiento, no conoce la dirección de la IP de destino, por lo que la envía al gateway predeterminado (otro enrutador). Ahora nuestro paquete contiene nuestra IP de origen, IP de destino y MAC de origen, sin embargo no tenemos un MAC de destino. Recuerda que las direcciones MAC solo se alcanzan a través de la misma red. ¿Qué hace entonces? Envía una solicitud ARP para obtener la dirección MAC del gateway predeterminado.</li>\n<li>El enrutador mira el paquete y confirma la dirección MAC de destino, pero no es la dirección IP de destino final, por lo que sigue mirando la tabla de enrutamiento para reenviar el paquete a otra dirección IP que pueda ayudar al paquete a avanzar hacia su destino. Cada vez que el paquete se mueve, elimina las direcciones MAC de origen y destino antiguas y actualiza el paquete con las nuevas direcciones MAC de origen y destino.</li>\n<li>Una vez que el paquete se reenvía a la misma red, usamos ARP para encontrar la dirección MAC de destino final</li>\n<li>Durante este proceso, nuestro paquete no cambia la dirección IP de origen o destino.</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "¿Cómo encontramos la dirección MAC de una dirección IP?",
          "slug": "ruta-de-un-paquete",
          "title": "Ruta de un Paquete"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "Sería un dolor tener que configurar manualmente rutas en una tabla de enrutamiento para cada dispositivo en su red, por lo que en su lugar utilizamos lo que se conocen como protocolos de enrutamiento. Los protocolos de enrutamiento se utilizan para ayudar a nuestro sistema a adaptarse a los cambios de red, aprenden diferentes rutas, las construyen en la tabla de enrutamiento y luego enrutan nuestros paquetes de esa manera. Hay dos tipos principales de protocolos de enrutamiento, protocolos de vector de distancia y protocolos de estado de enlace.\n\n<b>Convergencia</b>\n\nAntes de hablar sobre los protocolos, deberíamos repasar un término utilizado en enrutamiento conocido como convergencia. Al utilizar protocolos de enrutamiento, los enrutadores se comunican entre sí para recopilar e intercambiar información sobre la red. Cuando están de acuerdo en cómo debería verse una red, cada tabla de enrutamiento mapea la topología completa de la red, por lo tanto, \"converge\". Cuando ocurre algo en la topología de la red, la convergencia se romperá temporalmente hasta que todos los enrutadores sean conscientes de este cambio.",
          "quizAnswer": "convergencia",
          "quizQuestion": "¿Cuál es el término utilizado cuando todas las tablas de enrutamiento conocen la topología de la red?",
          "slug": "protocolosde enrutamiento",
          "title": "Protocolos de enrutamiento"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "Los protocolos de vector de distancia determinan la ruta de otras redes utilizando el recuento de saltos que un paquete realiza a través de la red. Si la red A estaba a 3 saltos de distancia y la red B estaba al lado de la red A, entonces asumimos que debe estar a 4 saltos de distancia. En los protocolos de vector de distancia, la siguiente ruta sería la que tenga la menor cantidad de saltos.\n\nLos protocolos de vector de distancia son ideales para redes pequeñas, cuando las redes comienzan a escalar, los enrutadores tardan más en converger porque envían periódicamente la tabla de enrutamiento completa a cada enrutador. Otra desventaja de los protocolos de vector de distancia es la eficiencia, elige rutas que están más cerca en saltos, pero no siempre elige la ruta más eficiente.\n\nUno de los protocolos de vector de distancia comunes es RIP (Protocolo de Información de Enrutamiento), que difunde la tabla de enrutamiento a cada enrutador en la red cada 30 segundos. Para una red grande, esto puede requerir muchos recursos, debido a eso RIP limita su recuento de saltos a 15.",
          "quizAnswer": "falso",
          "quizQuestion": "Verdadero o falso, ¿los protocolos de distancia utilizan la ruta con la menor cantidad de ancho de banda?",
          "slug": "protocolosdevectoradedistancia",
          "title": "Protocolos de vector de distancia"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 6,
          "lessonContent": "Los protocolos de estado de enlace son ideales para redes a gran escala, son más complejos que los protocolos de vector de distancia, sin embargo, una gran ventaja es su capacidad para converger rápidamente, esto se debe a que en lugar de enviar periódicamente toda la tabla de enrutamiento, solo envían actualizaciones a las rutas vecinas. Utilizan un algoritmo diferente para calcular el camino más corto primero y construyen su topología de red en forma de grafo para mostrar qué enrutadores están conectados a otros enrutadores.\n\nUno de los protocolos de estado de enlace comunes es OSPF (Open Shortest Path First), solo actualiza las tablas de enrutamiento si hubo un cambio en la red. No tiene un límite de saltos.",
          "quizAnswer": "OSPF",
          "quizQuestion": "¿Cuál es uno de los protocolos de estado de enlace más comunes?",
          "slug": "protocolosdeestadoenlace",
          "title": "Protocolos de Estado de Enlace"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 7,
          "lessonContent": "El último protocolo importante que discutiremos es BGP, BGP es básicamente cómo funciona Internet. Se utiliza para recopilar e intercambiar información de enrutamiento entre sistemas autónomos. Piense en un sistema autónomo como un proveedor de servicios de Internet, una empresa, una universidad, cualquier organización, etc. Sin BGP, estos sistemas no sabrían cómo comunicarse entre sí, simplemente estarían aislados. En lugar de enrutamiento dentro de estos sistemas autónomos, BGP enruta entre ellos.\n\nDigamos que estás en tu red doméstica y yo estoy trabajando desde Starbucks, quiero poder comunicarme contigo, así que envío un correo electrónico y el paquete de red viaja a través de la red de Starbucks, rebota allí y atraviesa las tablas de enrutamiento en la red de Starbucks hasta que finalmente llega a un punto en el borde de la red de Starbucks y lo pasa a un enrutador de puerta de enlace de borde. Este enrutador contiene la información para que mi paquete salga de la red de Starbucks y atraviese otras redes.",
          "quizAnswer": "BGP",
          "quizQuestion": "¿Qué protocolo hace básicamente que funcione Internet?",
          "slug": "protocolodepuertadeenlacedebordebgp",
          "title": "Protocolo de puerta de enlace de borde"
        }
      ],
      "slug": "enrutamiento",
      "title": "Enrutamiento"
    },
    {
      "description": "¡Aprende sobre la configuración de red utilizando herramientas de Linux!",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "Intenta cambiar el estado de tus interfaces de red a arriba o abajo y observa qué sucede.\n\n¿Puedes cambiar tus interfaces de red con los comandos ifconfig e ip?",
          "id": 1,
          "lessonContent": "Una interfaz de red es cómo el kernel vincula el lado del software de la red con el lado del hardware. Ya hemos visto un ejemplo de esto: \n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> El comando ifconfig</b>\n\nLa herramienta <b>ifconfig</b> nos permite configurar nuestras interfaces de red, si no tenemos ninguna interfaz de red configurada, los controladores de dispositivos del kernel y la red no sabrán cómo comunicarse entre sí. Ifconfig se ejecuta al arrancar y configura nuestras interfaces a través de archivos de configuración, pero también podemos modificarlas manualmente. La salida de ifconfig muestra el nombre de la interfaz en el lado izquierdo y en el lado derecho muestra información detallada. Comúnmente verás interfaces nombradas eth0 (primera tarjeta Ethernet en la máquina), wlan0 (interfaz inalámbrica), lo (interfaz de bucle). La interfaz de bucle se utiliza para representar tu computadora, simplemente te devuelve a ti mismo. Esto es útil para depurar o conectarte a servidores que se ejecutan localmente. \n\nEl estado de las interfaces puede ser arriba o abajo, como puedes imaginar si quieres \"apagar\" una interfaz puedes establecerla en abajo. Los campos que probablemente verás más en la salida de ifconfig son HWaddr (dirección MAC de la interfaz), dirección inet (dirección IPv4) e inet6 (dirección IPv6). Por supuesto, también puedes ver que la máscara de subred y la dirección de difusión están allí. También puedes ver información de la interfaz en /etc/network/interfaces.\n\n<b>Para crear una interfaz y activarla</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nEsto asigna una dirección IP y máscara de red a la interfaz eth0 y también la activa.\n\n<b>Para activar o desactivar una interfaz</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> El comando ip </b>\n\nEl comando <b>ip</b> también nos permite manipular la pila de red de un sistema. Dependiendo de la distribución que estés utilizando, puede ser el método preferido para manipular la configuración de red. \n\nAquí tienes algunos ejemplos de su uso:\n\n<b>Para mostrar información de la interfaz para todas las interfaces </b>\n<pre>\n$ ip link show\n</pre>\n\n<b>Para mostrar las estadísticas de una interfaz</b>\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>Para mostrar las direcciones IP asignadas a las interfaces</b>\n\n<pre>\n$ ip address show\n</pre>\n\n<b>Para activar y desactivar interfaces</b>\n\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>Para agregar una dirección IP a una interfaz</b>\n\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "¿Cuál es el comando para configurar nuestras interfaces de red?",
          "slug": "interfacesdered",
          "title": "Interfaces de Red"
        },
        {
          "exercise": "No hay ejercicios para esta lección, pero puedes obtener más información sobre los comandos discutidos aquí en las páginas del manual\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "Ya hemos discutido cómo ver nuestras tablas de enrutamiento con el comando route, si deseas agregar o eliminar rutas, puedes hacerlo manualmente.\n\n<b>Agregar una nueva ruta</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>Eliminar una ruta</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nTambién puedes realizar estos cambios con el comando <b>ip</b>:\n\n<b>Para agregar una ruta</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>Para eliminar una ruta</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\no\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "¿Cuál es la bandera de comando para eliminar una ruta?",
          "slug": "ruta",
          "title": "ruta"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "Hemos discutido sobre DHCP antes y la mayoría de las veces nunca necesitarás configurar estáticamente tus direcciones IP, máscaras de subred, etc. ¡En su lugar, estarás usando DHCP! El dhclient se inicia al arrancar y obtiene una lista de interfaces de red del archivo dhclient.conf. Para cada interfaz listada, intenta configurar la interfaz utilizando el protocolo DHCP.\n\nEn el archivo dhclient.leases, dhclient lleva un registro de una lista de arrendamientos a través de reinicios del sistema, después de leer dhclient.conf, se lee el archivo dhclient.leases para saber qué arrendamientos ya ha asignado. \n\n<b>Para obtener una IP nueva</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "¿Qué intenta asignar direcciones IP con el protocolo DHCP?",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "Por supuesto, si deseas tener la red de tu sistema funcionando automáticamente, ya hay algo en su lugar para eso. La mayoría de las distribuciones utilizan el demonio NetworkManager para configurar sus redes automáticamente. \n\nNotarás NetworkManager en forma de un applet en algún lugar de la barra de tareas de tu escritorio si estás utilizando una interfaz gráfica. Como puedes ver, gestiona el hardware de red y la información de conexión. Por ejemplo, al iniciar, NetworkManager recopilará información del hardware de red, buscará conexiones inalámbricas, cableadas, etc. y luego las activará.\n\nTambién hay herramientas de línea de comandos para interactuar con NetworkManager:\n\n<b>nm-tool</b>\n\nnm-tool informa sobre el estado de NetworkManager y sus dispositivos\n\n<pre>\npete@icebox:/$ nm-tool\nHerramienta NetworkManager\n\nEstado: conectado (global)\n\n- Dispositivo: eth0  [Conexión por cable 1] -------------------------------------------\n  Tipo:              Cableado\n  Controlador:       pcnet32\n  Estado:            conectado\n  Predeterminado:    sí\n  Dirección HW:      12:3D:45:56:7D:CC\n\n  Capacidades:\n    Detección de portadora:  sí\n\n  Propiedades cableadas:\n    Portadora:         activada\n\n  Configuración IPv4:\n    Dirección:         192.168.22.1\n    Prefijo:           24 (255.255.255.0)\n    Puerta de enlace:  192.168.22.2\n\n    DNS:              192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nEl comando nmcli te permite controlar y modificar NetworkManager, consulta la página del manual para más detalles.",
          "quizAnswer": "nm-tool",
          "quizQuestion": "¿Cuál es el comando para ver la información de NetworkManager?",
          "slug": "networkmanager",
          "title": "Administrador de red"
        },
        {
          "exercise": "Observa qué sucede con tu caché ARP cuando reinicias tu máquina y luego haces algo en la red.",
          "id": 5,
          "lessonContent": "Recuerda que cuando buscamos una dirección MAC con ARP, primero verifica la caché ARP almacenada localmente en nuestro sistema, en realidad puedes ver esta caché: \n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nLa caché ARP en realidad está vacía cuando una máquina se inicia, se va llenando a medida que se envían paquetes a otros hosts. Si enviamos un paquete a un destino que no está en la caché ARP, sucede lo siguiente:\n\n<ol>\n<li>El host fuente crea el marco Ethernet con un paquete de solicitud ARP</li>\n<li>El host fuente difunde este marco a toda la red</li>\n<li>Si uno de los hosts en la red conoce la dirección MAC correcta, enviará un paquete de respuesta y un marco que contenga la dirección MAC</li>\n<li>El host fuente agrega el mapeo de dirección IP a dirección MAC a la caché ARP y luego procede a enviar el paquete</li>\n</ol>\n\nTambién puedes ver tu caché ARP a través del comando ip:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "¿Qué comando puedes usar para ver tu caché ARP?",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "Configuración de red"
    },
    {
      "description": "¡Aprende sobre herramientas de red comunes para ayudarte a diagnosticar y solucionar problemas!",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "El Protocolo de Mensajes de Control de Internet (ICMP) es parte de la suite de protocolos TCP/IP, se utiliza para enviar actualizaciones y mensajes de error y es un protocolo extremadamente útil utilizado para depurar problemas de red como una entrega de paquetes fallida.\n\nCada mensaje ICMP contiene un campo de tipo, código y checksum. El campo de tipo es el tipo de mensaje ICMP, el código es un subtipo y describe más información sobre el mensaje y el checksum se utiliza para detectar problemas con la integridad del mensaje.\n\nVeamos algunos tipos comunes de ICMP:\n\n<ul>\n<li>Tipo 0 - Respuesta de Eco</li>\n<li>Tipo 3 - Destino Inalcanzable</li>\n<li>Tipo 8 - Solicitud de Eco</li>\n<li>Tipo 11 - Tiempo Excedido</li>\n</ul>\n\nCuando un paquete no puede llegar a un destino, se genera un mensaje ICMP de Tipo 3, dentro de Tipo 3 hay 16 valores de código que describirán más por qué no puede llegar al destino:\n\n<ul>\n<li>Código 0 - Red Inalcanzable</li>\n<li>Código 1 - Host Inalcanzable</li>\netc..etc..\n</ul>\n\nEstos mensajes tendrán más sentido a medida que utilicemos algunas herramientas de solución de problemas de red.",
          "quizAnswer": "8",
          "quizQuestion": "¿Cuál es el tipo ICMP para la solicitud de eco?",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "Realiza un ping a un sitio web y observa la salida que recibes.",
          "id": 2,
          "lessonContent": "Una de las herramientas de red más simples <b>ping</b>, se utiliza para probar si un paquete puede llegar a un host. Funciona enviando paquetes de solicitud de eco ICMP (Tipo 8) al host de destino y esperando una respuesta de eco ICMP (Tipo 0). El ping es exitoso cuando un host envía el paquete de solicitud y recibe una respuesta del objetivo. Veamos un ejemplo: \n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) bytes of data.\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nEn este ejemplo, estamos usando ping para verificar si podemos llegar a www.google.com. La bandera -c (conteo) se utiliza para dejar de enviar paquetes de solicitud de eco después de que se haya alcanzado el conteo. \n\nLa primera parte dice que estamos enviando paquetes de 64 bytes a 74.125.239.112 (google.com) y el resto nos muestra los detalles del viaje. Por defecto, envía un paquete por segundo.\n\n<b>icmp_seq</b>\n\nEl campo icmp_seq se utiliza para mostrar el número de secuencia de los paquetes enviados, por lo que en este caso, envié 3 paquetes y podemos ver que 3 paquetes regresaron. Si haces un ping y te faltan algunos números de secuencia, eso significa que hay algún problema de conectividad y no todos tus paquetes están llegando. Si el número de secuencia está fuera de orden, tu conexión probablemente es muy lenta ya que tus paquetes están excediendo el valor predeterminado de un segundo. \n\n<b>ttl</b>\n\nEl campo Tiempo de Vida (ttl) se utiliza como contador de saltos, a medida que haces saltos, decrementa el contador en uno y una vez que el contador de saltos llega a 0, nuestro paquete muere. Esto está destinado a darle al paquete una vida útil, no queremos que nuestros paquetes viajen para siempre.\n\n<b>time</b>\n\nEl tiempo de ida y vuelta que tomó desde que enviaste el paquete de solicitud de eco hasta recibir una respuesta de eco.",
          "quizAnswer": "ms",
          "quizQuestion": "¿Cuál es la unidad de medida del tiempo de ida y vuelta?",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "Ejecuta el comando traceroute en tu máquina y observa la salida.",
          "id": 3,
          "lessonContent": "El comando traceroute se utiliza para ver cómo se están enrutando los paquetes. Funciona enviando paquetes con valores TTL crecientes, comenzando con 1. Así, el primer enrutador recibe el paquete y decrementa el valor TTL en uno, lo que hace que el paquete se descarte. El enrutador nos envía de vuelta un mensaje ICMP de Tiempo Excedido. Luego, el siguiente paquete recibe un TTL de 2, por lo que pasa el primer enrutador, pero cuando llega al segundo enrutador, el TTL es 0 y devuelve otro mensaje ICMP de Tiempo Excedido. Traceroute funciona de esta manera porque al enviar y descartar paquetes va construyendo una lista de enrutadores que los paquetes atraviesan, hasta que finalmente llega a su destino y recibe un mensaje ICMP de Respuesta de Eco. \n\nAquí tienes un pequeño fragmento de un traceroute: \n\n<pre>\n$ traceroute google.com                                                                          \ntraceroute a google.com (216.58.216.174), máx. 30 saltos, paquetes de 60 bytes                          \n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms                                  \n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms                                                                                 \n</pre>\n\nCada línea es un enrutador o máquina que se encuentra entre mí y mi objetivo. Muestra el nombre del objetivo y su dirección IP, y las últimas tres columnas corresponden al tiempo de ida y vuelta de un paquete para llegar a ese enrutador. Por defecto, enviamos tres paquetes a lo largo de la ruta.",
          "quizAnswer": "ttl",
          "quizQuestion": "¿Qué se decrementa en uno al hacer saltos a través de la red?",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "Mira la página del manual de netstat y aprende todas las funciones que tiene para ofrecer.",
          "id": 4,
          "lessonContent": "<b>Puertos Bien Conocidos</b>\n\nHemos discutido la transmisión de datos a través de puertos en nuestra máquina, veamos algunos puertos bien conocidos.\n\nPuedes obtener una lista de puertos bien conocidos mirando el archivo <b>/etc/services</b>: \n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..etc..\n</pre>\n\nLa primera columna es el nombre del servicio, luego el número de puerto y el protocolo de capa de transporte que utiliza.\n\n<b>netstat</b>\n\nUna herramienta extremadamente útil para obtener información detallada sobre tu red es <b>netstat</b>. Netstat muestra varias informaciones relacionadas con la red como conexiones de red, tablas de enrutamiento, información sobre interfaces de red y más, es la navaja suiza de las herramientas de red. Nos enfocaremos principalmente en una característica que tiene netstat y es el estado de las conexiones de red. Antes de ver un ejemplo, hablemos primero sobre sockets y puertos. Un socket es una interfaz que permite a los programas enviar y recibir datos mientras que un puerto se utiliza para identificar qué aplicación debe enviar o recibir datos. La dirección del socket es la combinación de la dirección IP y el puerto. Cada conexión entre un host y un destino requiere un socket único. Por ejemplo, HTTP es un servicio que se ejecuta en el puerto 80, sin embargo, podemos tener muchas conexiones HTTP y para mantener cada conexión se crea un socket por conexión.\n\n<pre>\npete@icebox:~$ netstat -at\nConexiones activas de Internet (servidores y establecidas)\nProto Recv-Q Send-Q Dirección local           Dirección remota         Estado      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nEl comando netstat -a muestra los sockets que escuchan y los que no escuchan para las conexiones de red, la bandera -t muestra solo las conexiones tcp. \n\nLas columnas son las siguientes de izquierda a derecha:\n\n<ul>\n<li>Proto: Protocolo utilizado, TCP o UDP.</li>\n<li>Recv-Q: Datos en cola para ser recibidos</li>\n<li>Send-Q: Datos en cola para ser enviados</li>\n<li>Dirección Local: Host conectado localmente</li>\n<li>Dirección Remota: Host conectado remotamente</li>\n<li>Estado: El estado del socket</li>\n</ul>\n\nConsulta la página del manual para ver una lista de estados de socket, pero aquí tienes algunos:\n\n<ul>\n<li>LISTENING: El socket está escuchando conexiones entrantes, recuerda que cuando hacemos una conexión TCP nuestro destino tiene que estar escuchando antes de que podamos conectar.</li>\n<li>SYN_SENT: El socket está intentando activamente establecer una conexión.</li>\n<li>ESTABLISHED: El socket tiene una conexión establecida</li>\n<li>CLOSE_WAIT: El host remoto se ha desconectado y estamos esperando que el socket se cierre</li>\n<li>TIME_WAIT: El socket está esperando después de cerrarse para manejar paquetes que aún están en la red</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "¿Qué puerto se utiliza para HTTPS?",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Descarga e instala la herramienta Wireshark y juega con la interfaz.",
          "id": 5,
          "lessonContent": "El tema del análisis de paquetes podría llenar un curso completo y hay muchos libros escritos solo sobre el análisis de paquetes. Sin embargo, hoy solo aprenderemos lo básico. Hay dos analizadores de paquetes extremadamente populares, Wireshark y tcpdump. Estas herramientas escanean las interfaces de red, capturan la actividad de los paquetes, analizan los paquetes y nos muestran la información. Nos permiten adentrarnos en los detalles del análisis de red y meternos en cosas de bajo nivel. Usaremos tcpdump ya que tiene una interfaz más simple, sin embargo, si decidieras incorporar el análisis de paquetes a tu cinturón de herramientas, te recomendaría investigar Wireshark.\n\n<b>Instalar tcpdump</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>Capturar datos de paquetes en una interfaz</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: salida detallada suprimida, usa -v o -vv para decodificación de protocolo completa\nescuchando en wlan0, tipo de enlace EN10MB (Ethernet), tamaño de captura 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitud de eco ICMP, id 1901, seq 2, longitud 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: respuesta de eco ICMP, id 1901, seq 2, longitud 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitud de eco ICMP, id 1901, seq 3, longitud 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: respuesta de eco ICMP, id 1901, seq 3, longitud 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitud de eco ICMP, id 1901, seq 4, longitud 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: respuesta de eco ICMP, id 1901, seq 4, longitud 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitud de eco ICMP, id 1901, seq 5, longitud 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: respuesta de eco ICMP, id 1901, seq 5, longitud 64\n11:28:30.674953 ARP, Solicitud de quién tiene 172.254.1.0 informa a ThePickleParty.lan, longitud 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, longitud 306\n</pre>\n\nNotarás que ocurren muchas cosas cuando ejecutas una captura de paquetes, bueno, se espera que haya mucha actividad de red en segundo plano. En mi ejemplo anterior, he tomado solo un fragmento de mi captura específicamente en el momento en que decidí hacer ping a www.google.com. \n\n<b>Entendiendo la salida</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: solicitud de eco ICMP, id 1901, seq 2, longitud 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: respuesta de eco ICMP, id 1901, seq 2, longitud 64\n</pre>\n\n<ul>\n<li>El primer campo es una marca de tiempo de la actividad de red</li>\n<li>IP, esto contiene la información del protocolo</li>\n<li>A continuación, verás la dirección de origen y destino: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq, este es el número de secuencia de inicio y finalización de los paquetes TCP</li>\n<li>longitud, longitud en bytes</li>\n</ul>\n\nComo se puede ver en nuestra salida de tcpdump, ¡estamos enviando un paquete de solicitud de eco ICMP a www.google.com y recibiendo un paquete de respuesta de eco ICMP a cambio! También ten en cuenta que diferentes paquetes mostrarán diferente información, consulta la página del manual para ver cuáles son.\n\n<b>Escribir la salida de tcpdump en un archivo</b>\n\n<pre>\n$ sudo tcpdump -w /algún/archivo\n</pre>\n\n\nAlgunas reflexiones finales: solo hemos arañado la superficie del tema del análisis de paquetes. Hay mucho que puedes explorar y ni siquiera hemos tocado el ir aún más profundo con la salida en Hex y ASCII. Hay muchas recursos en línea para ayudarte a aprender más sobre analizadores de paquetes y te insto a encontrarlos!",
          "quizAnswer": "-i",
          "quizQuestion": "¿Cuál es la bandera para capturar una interfaz específica con tcpdump?",
          "slug": "analisispaquetes",
          "title": "Análisis de paquetes"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "Solución de problemas"
    },
    {
      "description": "Todo y más de lo que querías saber sobre DNS.",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 1,
          "lessonContent": "Imagina si cada vez que quisieras hacer una búsqueda en Google tuvieras que escribir http://192.78.12.4 en lugar de www.google.com. Bueno, sin DNS (\"Sistema de Nombres de Dominio\") eso es exactamente lo que sucedería. La red de bajo nivel solo entiende la dirección IP cruda para identificar un host. DNS nos permite a los humanos hacer un seguimiento de sitios web y hosts por nombre en lugar de una dirección IP. Es como una lista de contactos para Internet. Si conoces el nombre de alguien pero no conoces su número de teléfono, simplemente puedes buscarlo en tu lista de contactos.\n\nDNS es fundamentalmente una base de datos distribuida de nombres de host a direcciones IP, gestionamos nuestra base de datos para que las personas sepan cómo llegar a nuestro sitio/dominio, y en otro lugar otra persona está gestionando su base de datos para que otros puedan llegar a su dominio. Estos dominios pueden entonces comunicarse entre sí y construir una enorme lista de contactos de Internet.\n\nEn este curso, repasaremos algunos conceptos básicos de DNS, pero ten en cuenta que DNS es un tema exhaustivo y si realmente quieres profundizar en él, necesitarás hacer una investigación adicional.",
          "quizAnswer": "falso",
          "quizQuestion": "Verdadero o falso, ¿DNS nos ayuda a encontrar direcciones MAC para nombres de host?",
          "slug": "queesdns",
          "title": "¿Qué es DNS?"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 2,
          "lessonContent": "La base de datos de DNS de Internet depende de sitios y organizaciones que proporcionan parte de esa base de datos. Para hacer eso, necesitan:\n\n<b>Servidor de nombres</b>\n\nConfiguramos DNS a través de \"servidores de nombres\", los servidores de nombres cargan nuestra configuración de DNS y responden a cualquier pregunta de clientes u otros servidores que quieran saber cosas como \"¿Quién es google.com?\". Si el servidor de nombres no conoce la respuesta a esa consulta, redirigirá la solicitud a otros servidores de nombres. Los servidores de nombres pueden ser \"autoritativos\", lo que significa que contienen los registros de DNS reales que estás buscando, o \"recursivos\", lo que significa que preguntarían a otros servidores y esos servidores preguntarían a otros servidores hasta encontrar un servidor autoritativo que contenga los registros de DNS. Los servidores recursivos también pueden tener la información que queremos en caché en lugar de llegar a un servidor autoritativo.\n\n<b>Archivo de zona</b>\n\nDentro de un servidor de nombres vive algo llamado archivos de zona. Los archivos de zona son cómo el servidor de nombres almacena información sobre el dominio o cómo llegar al dominio si no lo sabe.\n\n<b>Registros de recursos</b>\n\nUn archivo de zona está compuesto por entradas de registros de recursos. Cada línea es un registro y contiene información sobre hosts, servidores de nombres, otros recursos, etc. Los campos consisten en lo siguiente:\n\n<ul>\n<li>Nombre del registro</li>\n<li>TTL - El tiempo después del cual descartamos el registro y obtenemos uno nuevo, en DNS TTL se indica por tiempo, por lo que los registros podrían tener un TTL de una hora. La razón por la que hacemos esto es porque Internet está cambiando constantemente, un minuto un host puede estar mapeado a la dirección IP X y luego puede estar en la dirección IP Y</li>\n<li>Clase - Espacio de nombres de la información del registro, comúnmente se usa IN para Internet</li>\n<li>Tipo - Tipo de información almacenada en los datos del registro. No entraremos en los tipos de registros, pero probablemente hayas visto comunes como A para dirección, MX o intercambiador de correo, etc.</li>\n<li>Datos - Este campo puede contener una dirección IP si es un registro A o algo más dependiendo del tipo de registro.</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "¿Qué tipo de registro de recurso se utiliza para los intercambiadores de correo?",
          "slug": "componentes-dns",
          "title": "Componentes de DNS"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 3,
          "lessonContent": "Veamos un ejemplo de cómo tu host encuentra un dominio (catzontheinterwebz.com) con DNS. Básicamente, nos abrimos paso hasta llegar al servidor DNS que conoce ese dominio.\n\n<b>Servidor DNS Local</b>\n\nPrimero, nuestro host pregunta: \"¿Dónde está catzontheinterwebz.com?\". Nuestro servidor DNS local no lo sabe, así que comienza desde la parte superior del embudo para preguntar a los Servidores Raíz. Ten en cuenta que nuestro host no está haciendo estas solicitudes para encontrar catzontheinterwebz.com directamente, la mayoría de los usuarios hablan con un servidor DNS recursivo proporcionado por sus proveedores de servicios de Internet y ese servidor es el encargado de encontrar la ubicación de catzontheinterwebz.com.\n\n<b>Servidores Raíz</b>\n\nHay 13 Servidores Raíz para Internet, están duplicados y distribuidos en todo el mundo para manejar las solicitudes DNS de Internet, por lo que realmente hay cientos de servidores que están trabajando, son controlados por diferentes organizaciones y contienen información sobre Dominios de Nivel Superior. Los dominios de nivel superior son lo que conoces como direcciones .org, .com, .net, etc. Entonces, el Servidor Raíz no sabe dónde está catzontheinterwebz.com, así que nos dice que preguntemos al Servidor DNS de Dominio de Nivel Superior .com en una dirección IP que nos da.\n\n<b>Dominio de Nivel Superior</b>\n\nAhora enviamos otra solicitud al servidor de nombres que conoce las direcciones \".com\" y preguntamos si sabe dónde está catzontheinterwebz.com. El TLD no tiene catzontheinterwebz.com en sus archivos de zona, pero ve un registro para el servidor de nombres de catzontheinterwebz.com. Entonces nos da la dirección IP de ese servidor de nombres y nos dice que busquemos allí.\n\n<b>Servidor DNS Autorizado</b>\n\nAhora enviamos una solicitud final al servidor DNS que realmente tiene el registro que queremos. El servidor de nombres ve que tiene un archivo de zona para catzontheinterwebz.com y hay un registro de recursos para 'www' para este host. Luego nos da la dirección IP de este host y finalmente podemos ver algunos gatos en Internet.",
          "quizAnswer": "TLD",
          "quizQuestion": "¿Cuál es la abreviatura para los servidores de nombres donde se encuentran las direcciones .com, .net, .org, etc?",
          "slug": "dnsprocess",
          "title": "Proceso DNS"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 4,
          "lessonContent": "<p>Antes de que nuestra máquina realmente acceda al DNS para hacer una consulta, primero busca localmente en nuestras máquinas.</p><br><p><b>/etc/hosts</b></p><p>El archivo /etc/hosts contiene asignaciones de algunos nombres de host a direcciones IP. Los campos son bastante autoexplicativos, hay uno para la dirección IP, el nombre de host y luego cualquier alias para el host.</p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>Por lo general, verás tu dirección de localhost listada como predeterminada en este archivo. También puedes gestionar el acceso a los hosts modificando los archivos /etc/hosts.deny o /etc/hosts.allow. Sin embargo, si te preocupa la seguridad, este no es realmente el camino a seguir y deberías modificar las reglas de tu firewall en su lugar.</p><p>Vamos a ver un ejemplo divertido de /etc/hosts. Modifica el archivo y agrega una línea para:</p><pre>123.45.6.7  www.google.com</pre><p>Guarda el archivo y ahora ve a www.google.com. ¿Tienes problemas, verdad? Bueno, eso es porque acabamos de asignar www.google.com a una dirección IP completamente incorrecta. Dado que nuestros hosts primero buscan localmente asignaciones de direcciones IP, nunca llega al DNS para encontrar google.com.</p><p><b>/etc/resolv.conf</b></p><p>Tradicionalmente, hemos utilizado un archivo llamado /etc/resolv.conf para mapear servidores de nombres DNS para búsquedas más eficientes, sin embargo, con las mejoras realizadas en DNS este archivo a menudo es irrelevante, de hecho, puedes ver en mi ejemplo a continuación que /etc/resolv.conf no se gestiona manualmente. Consulta la configuración específica de tu distribución para gestionar los mapeos de servidores de nombres DNS.</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     NO EDITE ESTE ARCHIVO MANUALMENTE -- SUS CAMBIOS SERÁN SOBREESCRITOS<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "¿Qué archivo se utiliza para mapear nombres de host a direcciones IP en nuestras máquinas?",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "No hay ejercicios para esta lección.",
          "id": 5,
          "lessonContent": "No vamos a detenernos en la configuración de un servidor DNS, ya que sería un tutorial bastante extenso. En su lugar, aquí tienes una lista de comparación rápida de los servidores DNS populares para usar con Linux.\n\n<b>BIND</b>\n\nEl servidor DNS más popular en Internet, es el estándar que se utiliza con las distribuciones de Linux. Fue desarrollado originalmente en la Universidad de California en Berkeley, de ahí el nombre BIND (Berkeley Internet Name Domain). Si necesitas potencia y flexibilidad con todas las funciones, no te equivocarás con BIND.\n\n<b>DNSmasq</b>\n\nLiviano y mucho más fácil de configurar que BIND. Si buscas simplicidad y no necesitas todas las funciones de BIND, utiliza DNSmasq. Viene con todas las herramientas que necesitas para configurar DHCP y DNS, recomendado para una red más pequeña.\n\n<b>PowerDNS</b>\n\nCompleto y similar a BIND, te ofrece un poco más de flexibilidad con opciones. Lee información de múltiples bases de datos como MySQL, PostgreSQL, etc. para una administración más sencilla. Solo porque BIND ha sido la forma en que hacemos las cosas, no significa que tenga que seguir siendo así.\n\nEsta no es una lista completa, pero debería darte una idea de dónde buscar si estás configurando tu propio servidor DNS.",
          "quizAnswer": "BIND",
          "quizQuestion": "¿Cuál es el servidor DNS de facto para Linux?",
          "slug": "configuracion-dns",
          "title": "Configuración de DNS"
        },
        {
          "exercise": "Lee el manual de dig.",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\nLa herramienta \"búsqueda de servidor de nombres\" se utiliza para consultar servidores de nombres para encontrar información sobre registros de recursos. Vamos a encontrar dónde está el servidor de nombres de google.com:\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServidor:         127.0.1.1\nDirección:        127.0.1.1#53\n\nRespuesta no autoritativa:\nNombre:   www.google.com\nDirección: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig (domain information groper) es una herramienta poderosa para obtener información sobre servidores de nombres DNS, es más flexible que nslookup y excelente para solucionar problemas de DNS.\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; opciones globales: +cmd\n;; Recibida respuesta:\n;; ->>CABECERA<<- opcode: CONSULTA, estado: NOERROR, id: 42376\n;; flags: qr rd ra; CONSULTA: 1, RESPUESTA: 5, AUTORIDAD: 0, ADICIONAL: 1\n\n;; OPT PSEUDOSECCIÓN:\n; EDNS: versión: 0, flags:; MBZ: 0005 , udp: 512\n;; SECCIÓN DE PREGUNTA:\n;www.google.com.                        IN      A\n\n;; SECCIÓN DE RESPUESTA:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Tiempo de consulta: 27 msec\n;; SERVIDOR: 127.0.1.1#53(127.0.1.1)\n;; CUÁNDO: Dom Feb 07 10:14:00 PST 2016\n;; TAMAÑO DEL MENSAJE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "¿Qué herramienta se utiliza para obtener información detallada sobre servidores de nombres DNS?",
          "slug": "herramientas-dns",
          "title": "Herramientas DNS"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "Contenido",
      "exerciseAndQuiz": "Ejercicio y cuestionario"
    },
    "exerciseBox": {
      "exercise": "Ejercicio"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Una nueva vida para LinuxJourney, que ha ayudado a tantas personas a dar sus primeros pasos en el mundo de Linux.",
      "title": "Desbloquea el poder de Linux"
    },
    "navbar": {
      "home": "Inicio",
      "language": "Idioma",
      "lessons": "Lecciones",
      "resources": "Recursos",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "Volver a los capítulos",
      "checkAnswer": "Verificar respuesta",
      "correctAnswer": "Respuesta correcta: ",
      "nextLesson": "Siguiente lección",
      "placeholderAnswer": "Escribe tu respuesta aquí",
      "quiz": "Cuestionario",
      "showCorrectAnswer": "Mostrar respuesta correcta"
    },
    "resources": {
      "data": [
        {
          "description": "Una guía paso a paso para principiantes que explica la historia del terminal y comandos básicos",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "Tutorial oficial de Ubuntu"
        },
        {
          "description": "Una visión clara de cómo funciona el terminal, cómo ejecutar comandos y navegar por el sistema de archivos.",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "¡Uno de los libros más recomendados!",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "Cómo funciona Linux"
        },
        {
          "description": "Libro extremadamente completo para cada SysAdmin.",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "Manual de administración del sistema UNIX y Linux"
        },
        {
          "description": "Excelente guía completa para scripting de shell.",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Biblia de comandos de Linux"
        },
        {
          "description": "Para usuarios serios de Linux, un gran comienzo en la programación del kernel.",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "La interfaz de programación de Linux: Un sistema Linux y UNIX"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "Descubre libros, tutoriales y herramientas seleccionadas para profundizar en tu conocimiento de Linux.",
        "title": "Recursos"
      },
      "title": "Recursos"
    }
  }
}