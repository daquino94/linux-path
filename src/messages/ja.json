{
  "chapters": [
    {
      "description": "Linuxとは何ですか？ディストリビューションの選択とインストールを開始します。",
      "id": 1,
      "image": "/images/chapters/gettingStarted.png",
      "lessons": [
        {
          "exercise": "追加の読み物:\n<li><a href='https://www.gnu.org/home.en.html'>GNU</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Ken_Thompson'>Ken Thompson</a></li>\n<li><a href='https://stallman.org/'>Richard Stallman</a></li>\n<li><a href='https://en.wikipedia.org/wiki/Linus_Torvalds'>Linus Torvalds</a></li>",
          "id": 1,
          "lessonContent": "新人よ！Linuxという素晴らしい世界に飛び込むことを決めたのか？それなら覚悟しておくんだ。長くて険しい道のりになるぞ。私はペンギンのピートといい、この旅を案内するためにここにいる。Linuxの背景について少し始めてみよう。\n\nLinuxの始まりを知るためには、1969年にさかのぼってみよう。ベル研究所のケン・トンプソンとデニス・リッチーがUNIXオペレーティングシステムを開発した。後にC言語で書き直され、より移植性が高められ、広く使用されるオペレーティングシステムとなった。\n\n10年ほど後、リチャード・ストールマンはGNU（GNU is Not UNIX）プロジェクトに取り組み、Hurdと呼ばれるGNUカーネルを開発したが、残念ながら完成しなかった。この結果、GNU一般公衆利用許諾契約（GPL）というフリーソフトウェアライセンスも作成された。\n\nカーネルはオペレーティングシステムで最も重要な部分である。ハードウェアとソフトウェアの通信を可能にする。他にもたくさんのことを行うが、それについては別のコースで詳しく説明する。今のところは、カーネルがシステムで起こるほとんどのことを制御していることを知っておくといい。\n\nこの時期、BSD、MINIXなどのUNIXライクなシステムが開発された。しかし、これらのUNIXライクなシステムに共通していたのは、統一されたカーネルがなかったことだ。\n\nそして1991年、リーナス・トーバルズという若者が開発を始め、今日私たちが知っているLinuxカーネルが誕生した。",
          "quizAnswer": "リーナス・トーバルズ",
          "quizQuestion": "Linuxカーネルを開発したのは誰か？",
          "slug": "linuxhistory",
          "title": "歴史"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 2,
          "lessonContent": "前のレッスンで、1日に何百万ものデバイスを動かすLinuxカーネルについて学びました。次に進む前に、Linuxという用語は実際にはLinuxカーネルを指すので、実際にはやや誤解があると言えます。ただし、多くのディストリビューションはLinuxカーネルを使用しているため、一般的にLinuxオペレーティングシステムとして知られています。\n\nLinuxシステムは3つの主要な部分に分かれています:\n\n<ul>\n<li>ハードウェア - システムが動作するすべてのハードウェア、メモリ、CPU、ディスクなどが含まれます。</li>\n<li>Linuxカーネル - 上記で説明したように、カーネルはオペレーティングシステムの中核です。ハードウェアを管理し、システムとのやり取り方法を指示します。</li>\n<li>ユーザースペース - ここでは、あなたのようなユーザーがシステムと直接やり取りします。</li>\n</ul>\n\nしたがって、最初に取る必要があるステップは、Linuxをマシンにインストールすることです。選択肢はたくさんあり、このコースではLinuxディストリビューションを選択する際に情報提供し、スタートを切るのを手助けします。\n\n選択肢がたくさんあるLinuxディストリビューションの中から、最も人気のあるオプションを紹介します。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません、次に進んでください！",
          "slug": "choosingalinuxdistribution",
          "title": "Linuxディストリビューションの選択"
        },
        {
          "exercise": "Debianをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='https://www.debian.org/'>https://www.debian.org/</a>",
          "id": 3,
          "lessonContent": "<b>概要</b>\nDebianは、完全に無料でオープンソースのソフトウェアで構成されたオペレーティングシステムです。広く知られており、20年以上にわたって開発されています。使用できる3つのブランチがあります。Stable、Testing、Unstableです。\n\nStableは全体的に使いやすいブランチです。TestingとUnstableはローリングリリースです。これは、これらのブランチの増分変更が最終的にStableになることを意味します。たとえば、Windows 8からWindows 10にアップデートしたい場合、完全なWindows 10のインストールを行う必要があります。しかし、Testingリリースにいると、完全なインストールを行わずに次のオペレーティングシステムリリースになるまで自動的にアップデートを受け取ることができます。\n\n<b>パッケージ管理</b>\nDebianはDebianパッケージ管理ツールも使用しています。すべてのLinuxディストリビューションは異なる方法でパッケージをインストールおよび管理し、異なるパッケージ管理ツールを使用します。後のコースで詳しく説明します。\n\n<b>設定可能性</b>\nDebianは最新のアップデートを受け取らないかもしれませんが、非常に安定しています。良い「コア」オペレーティングシステムが必要な場合は、これが適しています。\n\n<b>用途</b>\nDebianはどんなプラットフォームにも適した優れたオペレーティングシステムです。",
          "quizAnswer": "ローリング",
          "quizQuestion": "TestingとUnstableはどのようなリリースですか？",
          "slug": "debian",
          "title": "Debian"
        },
        {
          "exercise": "RHELをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='http://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/'>https://www.redhat.com/rhel/</a>",
          "id": 4,
          "lessonContent": "<b>概要</b>\nRed Hat Enterprise Linuxは一般的にRHELと呼ばれ、Red Hatによって開発されています。RHELは厳格な規則によって無料再配布を制限していますが、依然としてソースコードを無料で提供しています。\n\n<b>パッケージ管理</b>\nRHELはDebianとは異なるパッケージマネージャー、RPMパッケージマネージャーを使用しており、後で学習することになります。\n\n<b>設定可能性</b>\nRHELベースのオペレーティングシステムは、Debianベースのオペレーティングシステムとわずかに異なります。最も顕著なのはパッケージ管理です。RHELを選択する場合は、それを扱うことになることを知っておくと良いでしょう。\n\n<b>用途</b>\nその名前が示すように、主にエンタープライズで使用されており、頑丈なサーバーOSが必要な場合は、これが良い選択肢です。",
          "quizAnswer": "RPM",
          "quizQuestion": "RHELはどのパッケージマネージャーを使用していますか？",
          "slug": "redhatenterpriselinux",
          "title": "Red Hat Enterprise Linux"
        },
        {
          "exercise": "Ubuntuをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：\n<a href='http://www.ubuntu.com/'>http://www.ubuntu.com/</a>",
          "id": 5,
          "lessonContent": "<b>概要</b>\n個人用マシン向けの最も人気のあるLinuxディストリビューションの1つがUbuntuです。Ubuntuはデフォルトで独自のデスクトップ環境マネージャUnityもリリースしています。\n\n<b>パッケージ管理</b>\nUbuntuはCanonicalによって開発されたDebianベースのオペレーティングシステムであり、コアとしてDebianパッケージ管理システムを使用しています。\n\n<b>設定可能性</b>\nLinuxに入門したい初心者にとってUbuntuは最適な選択肢です。Ubuntuは使いやすさと優れたユーザーインターフェース体験を提供し、広く採用されています。その使いやすさの点では、OSXやWindowsなどの他のオペレーティングシステムに最も似ています。\n\n<b>用途</b>\nどんなプラットフォーム、デスクトップ、ノートパソコン、サーバーにも最適です。",
          "quizAnswer": "Debian",
          "quizQuestion": "Ubuntuはどのオペレーティングシステムをベースにしていますか？",
          "slug": "ubuntu",
          "title": "Ubuntu"
        },
        {
          "exercise": "Fedora をオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='https://getfedora.org/'>https://getfedora.org/</a>",
          "id": 6,
          "lessonContent": "<b>概要</b>\nRed Hat の支援を受けて、Fedora プロジェクトはコミュニティ主導のオープンソースおよび無料ソフトウェアを含んでいます。Red Hat Enterprise Linux は Fedora から派生しており、Fedora を RHEL の上流バージョンと考えることができます。最終的には、RHEL は Fedora からのアップデートを受け取りますが、それは徹底的なテストと品質保証の後です。Fedora は、Debian ではなく Red Hat バックエンドを使用した Ubuntu の相当物と考えることができます。\n\n<b>パッケージ管理</b>\nRed Hat パッケージマネージャを使用します。\n\n<b>設定可能性</b>\nRed Hat ベースのオペレーティングシステムを使用したい場合、これはユーザーフレンドリーなバージョンです。\n\n<b>用途</b>\n価格タグなしで Red Hat ベースのオペレーティングシステムを使用したい場合、Fedora は最適です。デスクトップおよびノートパソコン向けに推奨されています。",
          "quizAnswer": "Fedora",
          "quizQuestion": "RHEL は何から派生していますか？",
          "slug": "fedora",
          "title": "Fedora"
        },
        {
          "exercise": "Linux Mintをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='http://linuxmint.com/'>http://linuxmint.com/</a>",
          "id": 7,
          "lessonContent": "<b>概要</b>\nLinux MintはUbuntuをベースにしています。Ubuntuのソフトウェアリポジトリを使用しているため、両方のディストリビューションで同じパッケージが利用可能です。Linux Mintは、UnityなどUbuntuに含まれる一部のプロプライエタリソフトウェアが含まれていないため、他の人々によって好まれています。\n\n<b>パッケージ管理</b>\nLinux MintはUbuntuベースなので、Debianパッケージマネージャを使用しています。\n\n<b>設定可能性</b>\n優れたユーザーインターフェースで、初心者向けであり、Ubuntuよりも軽量です。このコースではLinux Mintを使用しますが、他のディストリビューションでも使用できます。\n\n<b>用途</b>\nデスクトップやノートパソコン向けに優れています。",
          "quizAnswer": "Ubuntu",
          "quizQuestion": "Linux Mintは何をベースにしていますか？",
          "slug": "linuxmint",
          "title": "Linux Mint"
        },
        {
          "exercise": "Gentooをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='https://www.gentoo.org/'>https://www.gentoo.org/</a>",
          "id": 8,
          "lessonContent": "<b>概要</b>\nGentooは、価格を払うことでオペレーティングシステムの柔軟性を提供します。システムに手を汚すことを気にしない上級ユーザー向けに作られています。\n\n<b>パッケージ管理</b>\nGentooは独自のパッケージ管理システムであるPortageを使用しています。Portageパッケージ管理は非常にモジュラーでメンテナンスが容易であり、オペレーティングシステム全体の柔軟性に大きく貢献しています。\n\n<b>設定可能性</b>\nLinuxを始めたばかりで、より難しい道を選びたい場合は、GentooまたはArch Linuxをディストリビューションとして選択すると良いでしょう。\n\n<b>用途</b>\nデスクトップやノートパソコン向けに最適です。",
          "quizAnswer": "Portage",
          "quizQuestion": "Gentooはどのパッケージ管理システムを使用していますか？",
          "slug": "gentoo",
          "title": "Gentoo"
        },
        {
          "exercise": "Archをオペレーティングシステムとして使用したい場合は、インストールセクションに移動して試してみてください：<a href='https://www.archlinux.org/'>https://www.archlinux.org/</a>",
          "id": 9,
          "lessonContent": "<b>概要</b>\nArchは、コミュニティによって100%推進される軽量で柔軟なLinuxディストリビューションです。Debianと同様に、Archはローリングリリースモデルを採用しており、段階的な更新が最終的に安定版リリースとなります。システムとその機能を理解するためには手を汚す必要がありますが、その代わりにシステムを完全かつ総合的に制御できます。\n\n<b>パッケージ管理</b>\nArchは、独自のパッケージマネージャであるPacmanを使用してパッケージのインストール、更新、管理を行います。\n\n<b>設定可能性</b>\n軽量なオペレーティングシステムを求め、Linuxを本当に理解したい場合はArchを使用してください！学習曲線が少々ありますが、ハードコアなLinuxユーザーにとっては素晴らしい選択肢です。\n\n<b>用途</b>\nデスクトップやノートパソコンに最適です。Raspberry Piなどの小さなデバイスに軽量なOSを搭載したい場合は、Archが最適です。",
          "quizAnswer": "Pacman",
          "quizQuestion": "Arch Linuxはどのパッケージマネージャを使用していますか？",
          "slug": "archlinux",
          "title": "Arch Linux"
        },
        {
          "exercise": "openSUSEをオペレーティングシステムとして使用したい場合は、ダウンロードページにアクセスして試してみてください：<a href='https://software.opensuse.org/'>software.opensuse.org</a>",
          "id": 10,
          "lessonContent": "<b>概要</b>\nopenSUSE LinuxはopenSUSE Projectによって作成されています。Linuxの利用を促進し、世界中のフリーかつオープンソースソフトウェアコミュニティの一部として、オープンで透明性があり友好的な方法で協力しています。openSUSEは、現在も稼働している2番目に古いLinuxディストリビューションであり、SUSEの受賞歴のあるSUSE Linux Enterprise製品とベースシステムを共有しています。\n\n<b>パッケージ管理</b>\nRPMパッケージマネージャを使用します。\n\n<b>設定可能性</b>\nopenSUSEは新しいLinuxユーザーにとって優れた選択肢です。使いやすいグラフィカルインストーラー/管理アプリケーション（<a href=\"http://yast.github.io/\">YaST</a>）と整頓されたベースシステムを提供し、簡単にいじることができます。openSUSEには、インターネットを安全に楽しむために必要なすべてが含まれており、ウイルス/スパイウェアの心配なく、写真、ビデオ、音楽、コードなどを自由に楽しむことができます。\n\n<b>使用方法</b>\nopenSUSE LeapはデスクトップPCやノートパソコンで完全に使用することができます。",
          "quizAnswer": "yast",
          "quizQuestion": "openSUSEの管理/インストールツールの名前は何ですか？",
          "slug": "opensuse",
          "title": "openSUSE"
        }
      ],
      "slug": "gettingstarted",
      "title": "はじめに"
    },
    {
      "description": "コマンドラインの基本を学び、ファイルやディレクトリの移動などを行います。",
      "id": 2,
      "image": "/images/chapters/commandLine.png",
      "lessons": [
        {
          "exercise": "他のLinuxコマンドを試して、それらがどのような出力をするか確認してください：\n\n<ol>\n<li>$ date</li>\n<li>$ whoami</li>\n</ol>",
          "id": 1,
          "lessonContent": "世界はあなたの牡蠣です、実際には、殻があなたの牡蠣です。殻とは何でしょうか？殻とは、基本的にはキーボードからのコマンドを受け取り、それらを実行するためにオペレーティングシステムに送信するプログラムです。GUIを使用したことがある場合、「Terminal」や「Console」といったプログラムを見たことがあるかもしれませんが、これらは単なるシェルを起動するプログラムです。このコース全体で、私たちはシェルの素晴らしさについて学んでいきます。\n\nこのコースでは、bash（Bourne Again shell）というシェルプログラムを使用します。ほとんどのLinuxディストリビューションはbashシェルをデフォルトにします。ksh、zsh、tschなど他のシェルも利用可能ですが、これらについては触れません。\n\nさあ始めましょう！ディストリビューションによっては、シェルプロンプトが変わることがありますが、ほとんどの場合、次の形式に従うはずです：\n<pre>username@hostname:current_directory\npete@icebox:/home/pete $</pre>\n\nプロンプトの最後に$があることに注意してください。異なるシェルには異なるプロンプトがありますが、私たちの場合、$はBash、Bourne、またはKornシェルを使用する通常のユーザー向けです。コマンドを入力する際にプロンプト記号を追加する必要はありませんが、そこにあることを知っておいてください。\n\nまずは、簡単なコマンドであるechoから始めましょう。echoコマンドは、テキスト引数をディスプレイに出力するだけです。\n\n<pre>$ echo Hello World</pre>",
          "quizAnswer": "Hello World",
          "quizQuestion": "echo Hello Worldを入力したときにディスプレイに出力されるべき内容は何ですか？",
          "slug": "theshell",
          "title": "The Shell"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 2,
          "lessonContent": "Linux ではすべてがファイルです。Linux の世界に深く入っていくと、これを理解するようになりますが、今はとりあえず心に留めておいてください。すべてのファイルは階層的なディレクトリツリー内に整理されています。ファイルシステム内の最初のディレクトリは適切に 'root ディレクトリ' と呼ばれています。root ディレクトリには多くのフォルダとファイルがあり、その中にさらにフォルダやファイルを格納することができます。以下はディレクトリツリーの例です：\n\n<pre>/\n|-- bin\n|   |-- file1\n|   |-- file2\n|-- etc\n|   |-- file3\n|   `-- directory1\n|       |-- file4\n|       `-- file5\n|-- home\n|-- var\n</pre>\n\nこれらのファイルとディレクトリの場所は 'パス' と呼ばれます。たとえば、'home' というフォルダがあり、その中に 'pete' というフォルダとその中に 'Movies' というフォルダがある場合、そのパスは次のようになります： '/home/pete/Movies'。かなりシンプルですね？\n\nファイルシステムをナビゲートすることは、現実世界でのナビゲーションと同様に、自分がどこにいてどこに向かっているのかを知っていれば簡単です。自分がどこにいるかを確認するには、'pwd' コマンドを使用できます。このコマンドは “print working directory” を意味し、現在いるディレクトリを表示します。パスは root ディレクトリから派生していることに注意してください。\n\n<pre>$ pwd</pre>\n\nどこにいますか？私はどこにいますか？試してみてください。",
          "quizAnswer": "pwd",
          "quizQuestion": "現在いるディレクトリをどのようにして見つけますか？",
          "slug": "printworkingdirectorypwdcommand",
          "title": "pwd (Print Working Directory)"
        },
        {
          "exercise": "<ol>\n<li>フラグなしでcdコマンドを実行すると、どこに移動しますか？</li>\n</ol>",
          "id": 3,
          "lessonContent": "現在、あなたがどこにいるかわかったので、ファイルシステム内を少し移動してみましょう。パスを使用して進む必要があることを覚えておいてください。絶対パスと相対パスの2つの異なる指定方法があります。\n\n<ul>\n<li>絶対パス：これはルートディレクトリからのパスです。ルートはトップです。ルートディレクトリは一般的にスラッシュで表示されます。パスが/で始まるたびに、それはルートディレクトリから始まることを意味します。例：/home/pete/Desktop。</li>\n\n<li>相対パス：これは現在のファイルシステム内の場所からのパスです。/home/pete/Documentsにいて、Documents内のディレクトリであるtaxesに移動したい場合、/home/pete/Documents/taxesのようにルートからの完全なパスを指定する必要はありません。代わりにtaxes/に移動できます。</li>\n</ul>\n\nパスの動作方法を理解したので、目的のディレクトリに変更するのに役立つものが必要です。幸いにも、そのためにcdまたは「change directory」があります。\n\n<pre>$ cd /home/pete/Pictures</pre>\n\nこれで、ディレクトリの場所が/home/pete/Picturesに変更されました。\n\nこのディレクトリからHawaiiという名前のフォルダーがあり、そのフォルダーに移動できます。\n\n<pre>$ cd Hawaii</pre>\n\nフォルダーの名前だけを使用したことに気づきましたか？それはすでに/home/pete/Picturesにいたからです。\n\n絶対パスと相対パスで常にナビゲートするのはかなり疲れることがありますが、助けになるいくつかのショートカットがあります。\n\n<ul>\n<li>.（現在のディレクトリ）。これは現在いるディレクトリです。</li>\n<li>..（前のディレクトリ）。現在のディレクトリの上のディレクトリに移動します。</li>\n<li>~（ホームディレクトリ）。このディレクトリはデフォルトで「ホームディレクトリ」になります。たとえば/home/peteです。</li>\n<li>-（前のディレクトリ）。これはさっきいた前のディレクトリに移動します。</li>\n</ul>\n\n<pre>$ cd .\n$ cd ..\n$ cd ~\n$ cd -\n</pre>\n試してみてください！",
          "quizAnswer": "cd ..",
          "quizQuestion": "/home/pete/Picturesにいて/home/peteに移動したい場合、良いショートカットは何ですか？",
          "slug": "changedirectorycdcommand",
          "title": "cd (Change Directory)"
        },
        {
          "exercise": "異なるフラグを使用してlsを実行し、受け取った出力を確認してください。",
          "id": 4,
          "lessonContent": "システム内を移動する方法がわかったので、利用可能なものをどのように把握すればよいでしょうか？現時点では、まるで暗闇の中を移動しているようです。しかし、素晴らしいlsコマンドを使用してディレクトリの内容を一覧表示することができます。lsコマンドは、デフォルトで現在のディレクトリのディレクトリとファイルを一覧表示しますが、表示したいディレクトリのパスを指定することもできます。\n\n<pre>$ ls\n$ ls /home/pete</pre>\n\nlsは非常に便利なツールであり、表示しているファイルやディレクトリに関する詳細情報も表示します。\n\nまた、ディレクトリ内のすべてのファイルが表示されるわけではないことに注意してください。.で始まるファイル名は非表示ですが、lsコマンドを使用して-aフラグ（aはすべての意味）を渡すことで表示することができます。\n\n<pre>$ ls -a</pre>\n\nさらに、もう1つ便利なlsフラグがあります。-lはlongの略で、長い形式でファイルの詳細一覧を表示します。左から詳細情報が表示されます：ファイルの権限、リンク数、所有者名、所有者グループ、ファイルサイズ、最終変更日時、ファイル/ディレクトリ名。\n\n<pre>$ ls -l</pre>\n\n<pre>pete@icebox:~$ ls -l\ntotal 80\ndrwxr-x--- 7 pete penguingroup   4096 Nov 20 16:37 Desktop\ndrwxr-x--- 2 pete penguingroup   4096 Oct 19 10:46  Documents\ndrwxr-x--- 4 pete penguingroup   4096 Nov 20 09:30 Downloads\ndrwxr-x--- 2 pete penguingroup   4096 Oct  7 13:13   Music\ndrwxr-x--- 2 pete penguingroup   4096 Sep 21 14:02 Pictures\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Public\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Templates\ndrwxr-x--- 2 pete penguingroup   4096 Jul 27 12:41   Videos</pre>\n\nコマンドには、機能を追加するためのフラグ（または引数またはオプションと呼ばれるもの）があります。-aと-lを追加した方法を見てみましょう。これらを-lと-aの両方で追加することもできます。フラグの順序は、それがどの順序であるかを決定しますが、ほとんどの場合、それはあまり重要ではないため、ls -alとしても機能します。\n\n<pre>$ ls -la</pre>",
          "quizAnswer": "ls -a",
          "quizQuestion": "非表示ファイルを表示するために使用するコマンドは何ですか？",
          "slug": "listdirectorieslscommand",
          "title": "ls (ディレクトリの一覧表示)"
        },
        {
          "exercise": "<ol>\n<li>新しいファイルを作成する</li>\n<li>タイムスタンプをメモする</li>\n<li>ファイルにtouchを実行し、再度タイムスタンプを確認する</li>\n</ol>",
          "id": 5,
          "lessonContent": "ファイルの作成方法を学びましょう。非常に簡単な方法の1つは、touchコマンドを使用することです。Touchを使用すると、新しい空のファイルを作成できます。\n\n<pre>$ touch mysuperduperfile</pre>\n\nそして、新しいファイルができました！\n\nTouchは既存のファイルやディレクトリのタイムスタンプを変更するためにも使用されます。試してみてください。ファイルにls -lを実行してタイムスタンプを確認し、そのファイルにtouchを実行するとタイムスタンプが更新されます。\n\nリダイレクションやテキストエディタを使用した他のファイル作成方法もありますが、それについては「テキスト操作」コースで学びます。",
          "quizAnswer": "touch myfile",
          "quizQuestion": "myfileというファイルを作成する方法は？",
          "slug": "touchcommand",
          "title": "touch"
        },
        {
          "exercise": "いくつかの異なるディレクトリとファイルでfileコマンドを実行し、出力をメモしてください。",
          "id": 6,
          "lessonContent": "前のレッスンでは、touchについて学びました。少し戻ってみましょう。ファイル名がWindowsなどの他のオペレーティングシステムで見られるような標準の命名規則に準拠していないことに気づきましたか？通常、banana.jpegというファイルを期待し、JPEG画像ファイルを期待するでしょう。\n\nLinuxでは、ファイル名はファイルの内容を表す必要はありません。実際にはGIFではないfunny.gifというファイルを作成できます。\n\nファイルがどのような種類のファイルかを知るために、fileコマンドを使用できます。ファイルの内容の説明が表示されます。\n\n<pre>$ file banana.jpg</pre>",
          "quizAnswer": "file",
          "quizQuestion": "ファイルの種類を見つけるために使用できるコマンドは何ですか？",
          "slug": "filecommand",
          "title": "ファイル"
        },
        {
          "exercise": "異なるファイルやディレクトリでcatを実行してください。その後、複数のファイルをcatしてみてください。",
          "id": 7,
          "lessonContent": "ファイルをナビゲートするのももうすぐ終わりですが、まずファイルの読み方を学びましょう。使用する簡単なコマンドはcatコマンドです。これは連結を意味するもので、ファイルの内容を表示するだけでなく、複数のファイルを結合して出力を表示することもできます。\n\n<pre>$ cat dogfile birdfile</pre>\n\n大きなファイルを表示するには適しておらず、短いコンテンツに適しています。次のレッスンで議論する大きなテキストファイルを表示するために使用する他の多くのツールがあります。",
          "quizAnswer": "cat",
          "quizQuestion": "ファイルの内容を見る良い方法は何ですか？",
          "slug": "catcommand",
          "title": "猫"
        },
        {
          "exercise": "ファイルでlessを実行し、ページを上下に移動します。 特定の単語を検索してみてください。 ファイルの先頭または末尾に迅速に移動します。",
          "id": 8,
          "lessonContent": "テキストファイルを単純な出力よりも大きく表示する場合、lessが有用です。 （同様の機能を持つmoreというコマンドが実際に存在するため、これは皮肉です。） テキストはページ単位で表示されるため、テキストファイルをページごとにナビゲートできます。\n\nlessを使用してファイルの内容を表示してください。 lessコマンドに入ると、他のキーボードコマンドを使用してファイル内をナビゲートできます。\n\n<pre>$ less /home/pete/Documents/text1</pre>\n\nlessを使用してナビゲートするには、次のコマンドを使用してください：\n\n<ul>\n<li>q - lessを終了してシェルに戻るために使用します。</li>\n<li>Page up、Page down、Up、Down - 矢印キーとページキーを使用してナビゲートします。</li>\n<li>g - テキストファイルの先頭に移動します。</li>\n<li>G - テキストファイルの末尾に移動します。</li>\n<li>/search - テキストドキュメント内で特定のテキストを検索できます。 検索したい単語の前に/を付けます。</li>\n<li>h - lessの使用方法について少しヘルプが必要な場合は、ヘルプを使用します。</li>\n</ul>",
          "quizAnswer": "q",
          "quizQuestion": "lessコマンドを終了する方法は？",
          "slug": "lesscommand",
          "title": "less"
        },
        {
          "exercise": "前のコマンド履歴を上下キーでナビゲートしてください。ctrl-R逆検索を試してみてください。",
          "id": 9,
          "lessonContent": "シェルには、以前に入力したコマンドの履歴があります。これらのコマンドを実際に確認することができます。以前に使用したコマンドを再度見つけて実行したい場合に便利です。\n\n<pre>$ history</pre>\n\n以前に実行した同じコマンドを実行したい場合は、上矢印キーを押してください。\n\n同じコマンドを再入力せずに前のコマンドを実行したい場合は、!!を使用します。たとえば、file1を表示したい場合は、!!と入力するだけで前回実行したコマンドが実行されます。\n\nもう1つの履歴のショートカットは、ctrl-Rです。これは逆検索コマンドで、ctrl-Rを押してから使用したいコマンドの一部を入力すると、一致するコマンドが表示され、ctrl-Rキーを再度押してナビゲートできます。再度使用したいコマンドを見つけたら、Enterキーを押してください。\n\nターミナルが少しごちゃごちゃしてきたでしょう？少し整理しましょう。表示をクリアするには、clearコマンドを使用します。\n\n<pre>$ clear</pre>\n\nそれで見栄えが良くなりましたね？\n\n便利な機能について話している間に、コマンドライン環境で最も便利な機能の1つはタブ補完です。コマンドやファイル、ディレクトリなどの先頭を入力し、Tabキーを押すと、検索しているディレクトリ内で見つかったものに基づいて自動補完されます。たとえば、chromeコマンドを実行しようとしている場合、chrと入力してTabを押すと、chromeが自動補完されます。",
          "quizAnswer": "clear",
          "quizQuestion": "ターミナルをクリアするコマンドは何ですか？",
          "slug": "historycommand",
          "title": "履歴"
        },
        {
          "exercise": "いくつかのファイルをコピーしてください。 重要なものを上書きしないように注意してください。",
          "id": 10,
          "lessonContent": "これらのファイルのコピーを作成しましょう。 他のオペレーティングシステムでファイルをコピーして貼り付けるのと同様に、シェルはそれを行うさらに簡単な方法を提供します。\n\n<pre>$ cp mycoolfile /home/pete/Documents/cooldocs</pre>\n\nmycoolfile はコピーしたいファイルで、/home/pete/Documents/cooldocs はファイルをコピーする場所です。\n\n複数のファイルやディレクトリをコピーしたり、ワイルドカードを使用したりすることもできます。 ワイルドカードは、パターンに基づいた選択のために代替可能な文字であり、検索時に柔軟性を提供します。 柔軟性を高めるために、すべてのコマンドでワイルドカードを使用できます。\n\n<ul>\n<li>* ワイルドカードのワイルドカード、すべての単一文字または任意の文字列を表します。</li>\n<li>? 1 文字を表します</li>\n<li>[] 角かっこ内の任意の文字を表します</li>\n</ul>\n\n<pre>$ cp *.jpg /home/pete/Pictures</pre>\n\nこれにより、現在のディレクトリにある .jpg 拡張子のすべてのファイルが Pictures ディレクトリにコピーされます。\n\n便利なコマンドは -r フラグを使用することです。 これにより、ディレクトリ内のファイルとディレクトリが再帰的にコピーされます。\n\nDocuments ディレクトリにいくつかのファイルを含むディレクトリに cp を実行してみてください。 うまくいきませんでしたか？ それは、-r コマンドで内部のファイルとディレクトリもコピーする必要があるためです。\n\n<pre>$ cp -r Pumpkin/ /home/pete/Documents</pre>\n\n1 つ注意すべき点は、同じファイル名を持つディレクトリにファイルをコピーすると、ファイルが上書きされます。 これは、誤って上書きされたくないファイルがある場合には困ります。 ファイルを上書きする前にプロンプトを表示するには、-i フラグ（インタラクティブ）を使用できます。\n\n<pre>$ cp -i mycoolfile /home/pete/Pictures</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "ディレクトリをコピーするにはどのフラグを指定する必要がありますか？",
          "slug": "copycpcommand",
          "title": "cp (コピー)"
        },
        {
          "exercise": "ファイルの名前を変更し、そのファイルを別のディレクトリに移動してください。",
          "id": 11,
          "lessonContent": "ファイルを移動および名前変更するために使用されます。フラグや機能に関しては、cpコマンドと非常に似ています。\n\n次のようにファイルの名前を変更できます：\n\n<pre>$ mv oldfile newfile</pre>\n\nまた、ファイルを別のディレクトリに移動することもできます：\n\n<pre>$ mv file2 /home/pete/Documents</pre>\n\n複数のファイルを移動することもできます：\n\n<pre>$ mv file_1 file_2 /somedirectory</pre>\n\nディレクトリの名前も変更できます：\n\n<pre>$ mv directory1 directory2</pre>\n\ncpと同様に、ファイルやディレクトリをmvすると、同じディレクトリ内のものが上書きされます。したがって、上書きする前にプロンプトを表示するために-iフラグを使用できます。\n\n<pre>mv -i directory1 directory2</pre>\n\n以前のファイルを上書きしてmvしたい場合、そのファイルのバックアップを作成し、古いバージョンに~を付けてリネームします。\n\n<pre>$ mv -b directory1 directory2</pre>",
          "quizAnswer": "mv cat dog",
          "quizQuestion": "catという名前のファイルをdogにリネームする方法は？",
          "slug": "movemvcommand",
          "title": "mv (Move)"
        },
        {
          "exercise": "いくつかのディレクトリを作成し、そのディレクトリにいくつかのファイルを移動してください。",
          "id": 12,
          "lessonContent": "これまでに作業してきたファイルを保存するためにいくつかのディレクトリが必要になります。mkdirコマンド（Make Directory）はそのために便利です。ディレクトリが存在しない場合、ディレクトリを作成します。複数のディレクトリを同時に作成することもできます。\n\n<pre>$ mkdir books paintings</pre>\n\n-p（親フラグ）を使用して同時にサブディレクトリを作成することもできます。\n\n<pre>$ mkdir -p books/hemmingway/favorites</pre>",
          "quizAnswer": "mkdir",
          "quizQuestion": "ディレクトリを作成するために使用されるコマンドは何ですか？",
          "slug": "makedirectorymkdircommand",
          "title": "mkdir (Make Directory)"
        },
        {
          "exercise": "<ol>\n<li>-fileという名前のファイルを作成してください（ダッシュを忘れずに！）。</li>\n<li>そのファイルを削除してください。</li>\n</ol>",
          "id": 13,
          "lessonContent": "今、ファイルが多すぎると思いますので、いくつかのファイルを削除しましょう。ファイルを削除するには、rmコマンドを使用します。rm（remove）コマンドはファイルやディレクトリを削除するために使用されます。\n\n<pre>$ rm file1</pre>\n\nrmを使用する際は注意してください。削除されたファイルを取り出すことができる魔法のゴミ箱はありません。一度削除されると、元に戻すことはできませんので、注意してください。\n\n幸いなことに、いくつかの安全対策が施されていますので、一般のユーザーが重要なファイルを簡単に削除することはできません。書き込み保護されたファイルは削除する前に確認を求められます。ディレクトリが書き込み保護されている場合も簡単に削除することはできません。\n\nもし気にしないのであれば、たくさんのファイルを削除することができます。\n\n<pre>$ rm -f file1</pre>\n\n-fまたはforceオプションは、適切な権限があれば、ユーザーに確認を求めることなく、書き込み保護されているかどうかに関係なくすべてのファイルを削除するようrmに指示します。\n\n<pre>$ rm -i file</pre>\n\n他の多くのコマンドと同様に、-iフラグを追加すると、ファイルやディレクトリを実際に削除するかどうかを確認するプロンプトが表示されます。\n\n<pre>$ rm -r directory</pre>\n\nデフォルトではディレクトリを単にrmで削除することはできません。すべてのファイルとそれに含まれるサブディレクトリを削除するには、-rフラグ（再帰）を追加する必要があります。\n\nrmdirコマンドを使用してディレクトリを削除できます。\n\n<pre>$ rmdir directory</pre>",
          "quizAnswer": "",
          "quizQuestion": "myfileという名前のファイルを削除するにはどうすればよいですか？",
          "slug": "removermcommand",
          "title": "rm (Remove)"
        },
        {
          "exercise": "<ol>\n<li>ルートディレクトリから、net という単語が含まれるファイルを見つけてください。</li>\n</ol>",
          "id": 14,
          "lessonContent": "システム上にあるこれらのファイルを使って特定のファイルを見つけようとすると、少し忙しくなることがあります。 そのような場合に使用できるコマンドがあります、それが find です！\n\n<pre>$ find /home -name puppies.jpg</pre>\n\nfind を使用すると、検索するディレクトリを指定する必要があります。 今回は puppies.jpg という名前のファイルを見つけようとしています。\n\n検索しようとしているファイルの種類を指定することができます。\n\n<pre>$ find /home -type d -name MyFolder</pre>\n\nファイルの種類を (d) ディレクトリとして設定し、MyFolder という名前で検索しています。\n\nfind の便利な点の1つは、検索しているディレクトリで検索が停止するわけではなく、そのディレクトリが持つ任意のサブディレクトリの中も検索するということです。",
          "quizAnswer": "-name",
          "quizQuestion": "名前で検索する場合、find にどのオプションを指定すればよいですか？",
          "slug": "findcommand",
          "title": "find"
        },
        {
          "exercise": "echoコマンド、logoutコマンド、pwdコマンドに対してhelpを実行してください。",
          "id": 15,
          "lessonContent": "Linuxには、コマンドの使用方法を学ぶための優れた組み込みツールがいくつかあります。コマンドを実行する方法やコマンドで使用可能なフラグを確認するためのツールの1つに、helpという組み込みbashコマンドがあります（echo、logout、pwdなど）。\n\n<pre>$ help echo</pre>\n\nこれにより、echoを実行する際に使用できるオプションと説明が表示されます。他の実行可能プログラムでは、--helpなどのオプションを持つのが慣例です。\n\n<pre>$ echo --help</pre>\n\nすべての開発者がこの標準に従うわけではありませんが、プログラムのヘルプを見つけるための最善の手段と言えるでしょう。",
          "quizAnswer": "help",
          "quizQuestion": "組み込みbashコマンドのクイックコマンドラインヘルプを取得するにはどうすればよいですか？",
          "slug": "helpcommand",
          "title": "help"
        },
        {
          "exercise": "lsコマンドにmanコマンドを実行してください。",
          "id": 16,
          "lessonContent": "これらのプログラムのいくつかにマニュアルがあれば、それらについてのさらなる情報を見ることができるといいのですが。幸いにも、manページと呼ばれるものがあります。manコマンドを使用して、コマンドのマニュアルを表示できます。\n\n<pre>$ man ls</pre>\n\nmanページは、ほとんどのLinuxオペレーティングシステムにデフォルトで組み込まれているマニュアルです。コマンドやシステムの他の側面に関するドキュメントを提供します。\n\nそれらのいくつかのコマンドで試して、それらに関するさらなる情報を取得してみてください。",
          "quizAnswer": "man",
          "quizQuestion": "コマンドのマニュアルを表示する方法は？",
          "slug": "mancommand",
          "title": "man"
        },
        {
          "exercise": "Run the whatis command on the less command.",
          "id": 17,
          "lessonContent": "Whew, we’ve learned quite a bit of commands so far, if you are ever feeling doubtful about what a command does, you can use the whatis command. The whatis command provides a brief description of command line programs. \n\n<pre>$ whatis cat</pre>\n\nThe description gets sourced from the manual page of each command. If you ran whatis cat, you’d see there is a small blurb with a short description.",
          "quizAnswer": "whatis",
          "quizQuestion": "What command can you use to see a small description of a command?",
          "slug": "whatiscommand",
          "title": "whatis"
        },
        {
          "exercise": "いくつかのエイリアスを作成してから削除します。",
          "id": 18,
          "lessonContent": "コマンドを入力することが非常に繰り返しになる場合や、長いコマンドを何度も入力する必要がある場合は、そのために使用できるエイリアスが最適です。コマンドのエイリアスを作成するには、エイリアス名を指定してコマンドに設定するだけです。\n\n<pre>$ alias foobar='ls -la'</pre>\n\nこれで、ls -laを入力する代わりに、foobarを入力してそのコマンドを実行できます。かなり便利です。このコマンドは再起動後にエイリアスを保存しないことに注意してください。再起動後もエイリアスを維持したい場合は、次のようなファイルに永続的なエイリアスを追加する必要があります。\n\n<pre>~/.bashrc</pre>\n\nエイリアスはunaliasコマンドで削除できます。\n\n<pre>$ unalias foobar</pre>",
          "quizAnswer": "alias",
          "quizQuestion": "エイリアスを作成するために使用されるコマンドは何ですか？",
          "slug": "aliascommand",
          "title": "alias"
        },
        {
          "exercise": "シェルから終了して何が起こるかを確認してください。そのシェルで作業を続ける必要がないことを確認してください。",
          "id": 19,
          "lessonContent": "さて、基本を乗り越えるのにうまくやりましたね。今までのところは序の口に過ぎません。今度のコースでは、はうように歩く方法を教えます。\n\n今は、自分をほめて休憩を取ってください。シェルから終了するには、exit コマンドを使用できます\n\n<pre>$ exit</pre>\n\nまたは logout コマンド:\n\n<pre>$ logout</pre>\n\nまたは、ターミナル GUI で作業している場合は、ターミナルを単に閉じることができます。次のコースでお会いしましょう！",
          "quizAnswer": "exit",
          "quizQuestion": "シェルからどのように終了できますか？",
          "slug": "exitcommand",
          "title": "終了"
        }
      ],
      "slug": "commandline",
      "title": "コマンドライン"
    },
    {
      "description": "基本的なテキスト操作とナビゲーションの学習",
      "id": 3,
      "image": "/images/chapters/textManipolation.png",
      "lessons": [
        {
          "exercise": "いくつかのコマンドを試してみてください：\n\n<pre>\n$ ls -l /var/log > myoutput.txt\n$ echo Hello World > rm\n$ > somefile.txt \n</pre>",
          "id": 1,
          "lessonContent": "これまでに、多くのコマンドとその出力に慣れ親しんできました。これにより、次のトピックである入出力（I/O）ストリームに移ります。次のコマンドを実行し、その動作について説明します。\n\n<pre>$ echo Hello World > peanuts.txt</pre>\n\n何が起こったのでしょうか？そのコマンドを実行したディレクトリを確認してみてください。そこにpeanuts.txtというファイルがあるはずです。そのファイルを開くと、Hello Worldというテキストが表示されるはずです。この1つのコマンドでたくさんのことが起こったので、それを分解してみましょう。\n\nまず、最初の部分を分解しましょう。\n\n<pre>$ echo Hello World</pre>\n\nこれは、Hello Worldを画面に表示することを知っていますが、どのようにして表示されるのでしょうか？プロセスは入力を受け取り、出力を返すためにI/Oストリームを使用します。デフォルトでは、echoコマンドは入力（標準入力またはstdin）をキーボードから受け取り、出力（標準出力またはstdout）を画面に返します。ですから、シェルでecho Hello Worldと入力すると、画面にHello Worldが表示されるのです。ただし、I/Oリダイレクションを使用すると、このデフォルトの動作を変更して、より柔軟なファイル操作が可能になります。\n\n次に、コマンドの次の部分に進みましょう。\n\n<pre> > </pre>\n\n> は、標準出力の送り先を変更するリダイレクト演算子です。echo Hello Worldの出力を画面ではなくファイルに送ることができます。ファイルが存在しない場合は、新規作成されます。ただし、既に存在する場合は上書きされます（使用しているシェルに応じてこれを防ぐためのシェルフラグを追加できます）。\n\nこれが基本的なstdoutリダイレクションの動作です！\n\nさて、peanuts.txtを上書きしたくない場合、そのためのリダイレクト演算子もあります。>> です。\n\n<pre>$ echo Hello World >> peanuts.txt</pre>\n\nこれにより、Hello Worldがpeanuts.txtファイルの末尾に追加されます。ファイルが存在しない場合は、> リダイレクターと同様に作成されます！",
          "quizAnswer": ">>",
          "quizQuestion": "ファイルに出力を追加するために使用するリダイレクターは何ですか？",
          "slug": "stdoutstandardoutredirect",
          "title": "stdout (Standard Out)"
        },
        {
          "exercise": "いくつかのコマンドを試してみてください:\n<pre>\n$ echo <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ ls <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n$ pwd <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt\n</pre>",
          "id": 2,
          "lessonContent": "前のレッスンで、ファイルや画面などさまざまなstdoutストリームを使用できることを学びました。同様に、標準入力（stdin）ストリームもさまざまなものがあります。キーボードなどのデバイスからのstdinがあることはわかっていますが、ファイルや他のプロセスからの出力、端末も使用できます。例を見てみましょう。\n\n前のレッスンで peanuts.txt ファイルを使用しましょう。そのファイルには Hello World というテキストが含まれていました。\n\n<pre>$ cat <b>&lt;</b> peanuts.txt <b>&gt;</b> banana.txt </pre>\n\nstdoutリダイレクションに<b>&gt;</b>を使用していたのと同様に、stdinリダイレクションに<b>&lt;</b>を使用できます。\n\ncatコマンドでは通常、ファイルを送信してstdinとして使用しますが、この場合、peanuts.txt をstdinとしてリダイレクトしました。その後、Hello World である peanuts.txt の出力が banana.txt という別のファイルにリダイレクトされます。",
          "quizAnswer": "<",
          "quizQuestion": "stdinをリダイレクトするために使用するリダイレクターは何ですか？",
          "slug": "stdinstandardinredirect",
          "title": "stdin (標準入力)"
        },
        {
          "exercise": "次のコマンドは何をしていますか？\n\n<pre>$ ls /fake/directory >> /dev/null 2>&1</pre>",
          "id": 3,
          "lessonContent": "今度は少し違ったことを試してみましょう。システムに存在しないディレクトリの内容をリストアップし、再び出力を peanuts.txt ファイルにリダイレクトしてみましょう。\n\n<pre>$ ls /fake/directory > peanuts.txt </pre>\n\n表示されるのは次の通りです：\n\n<pre>ls: cannot access /fake/directory: No such file or directory</pre>\n\nおそらく「そのメッセージはファイルに送られるべきではなかったのでは？」と思っているかもしれません。実際には、ここで標準エラー（stderr）と呼ばれる別のI/Oストリームが動作しています。デフォルトでは、stderrは出力を画面に送信します。これはstdoutとはまったく別のストリームです。そのため、出力を別の方法でリダイレクトする必要があります。\n\n残念ながら、リダイレクタは<b>&lt;</b>や<b>&gt;</b>を使うのと同じくらい簡単ではありませんが、かなり近いです。ファイルディスクリプタを使用する必要があります。ファイルディスクリプタは、ファイルやストリームにアクセスするために使用される非負の数値です。後で詳細に説明しますが、今のところ、stdin、stdout、stderrのファイルディスクリプタはそれぞれ0、1、2です。\n\nしたがって、stderrをファイルにリダイレクトしたい場合は、次のようにします：\n\n<pre>$ ls /fake/directory 2> peanuts.txt</pre>\n\npeanuts.txt にはstderrメッセージのみが表示されます。\n\nでは、stderrとstdoutの両方を peanuts.txt ファイルに表示したい場合はどうすればよいでしょうか？これもファイルディスクリプタを使用して行うことができます：\n\n<pre>$ ls /fake/directory > peanuts.txt 2>&1</pre>\n\nこれにより、ls /fake/directory の結果が peanuts.txt ファイルに送信され、その後、2>&1 を使用してstderrをstdoutにリダイレクトします。ここで操作の順序が重要です。2>&1 は、stderrをstdoutが指す先に送信します。この場合、stdoutはファイルを指しているため、2>&1 もstderrをファイルに送信します。したがって、peanuts.txt ファイルを開くと、stderrとstdoutの両方が表示されるはずです。この場合、上記のコマンドはstderrのみを出力します。\n\nstdoutとstderrの両方をファイルにリダイレクトする簡単な方法があります：\n\n<pre>$ ls /fake/directory &> peanuts.txt</pre>\n\nさらに、すべての不要な情報を取り除き、stderrメッセージを完全に削除したい場合はどうすればよいでしょうか？特別なファイルである /dev/null に出力をリダイレクトすることもでき、入力を破棄します。\n\n<pre>$ ls /fake/directory 2> /dev/null</pre>",
          "quizAnswer": "2>",
          "quizQuestion": "stderrのリダイレクタは何ですか？",
          "slug": "stderrstandarderrorredirect",
          "title": "stderr (Standard Error)"
        },
        {
          "exercise": "次のコマンドを試してみてください：\n<pre>$ ls | tee peanuts.txt banan.txt</pre>",
          "id": 4,
          "lessonContent": "さあ、配管に入ってみましょう。実際にはそうでもないですが、まあそんな感じです。次のコマンドを試してみましょう：\n\n<pre>$ ls -la /etc</pre>\n\n非常に長いアイテムのリストが表示されるはずです。実際、少し読みにくいです。この出力をファイルにリダイレクトする代わりに、出力を別のコマンド（例：less）で表示できればいいですね。実際、できます！\n\n<pre>$ ls -la /etc | less </pre>\n\nパイプ演算子 | は、コマンドの標準出力を取得してそれを別のプロセスの標準入力にすることができます。この場合、ls -la /etc の標準出力を取得し、それを less コマンドに<i>パイプ</i>しました。パイプコマンドは非常に便利で、永遠に使用し続けます。\n\nでは、コマンドの出力を2つの異なるストリームに書き込みたい場合はどうすればよいでしょうか？ tee コマンドを使用すれば可能です：\n\n<pre>$ ls | tee peanuts.txt</pre>\n\nls の出力が画面に表示され、peanuts.txt ファイルを開くと同じ情報が表示されるはずです！",
          "quizAnswer": "|",
          "quizQuestion": "パイプ演算子を表すキーは何ですか？",
          "slug": "pipeteeredirect",
          "title": "パイプとティー"
        },
        {
          "exercise": "以下の出力は何を示していますか？なぜですか？\n<pre>$ echo $HOME</pre>",
          "id": 5,
          "lessonContent": "以下のコマンドを実行してください：\n\n<pre>$ echo $HOME</pre>\n\nホームディレクトリへのパスが表示されるはずです。私の場合は/home/peteのように見えます。\n\nこのコマンドはどうでしょうか？\n\n<pre>$ echo $USER </pre>\n\nユーザー名が表示されるはずです！\n\nこの情報はどこから来ているのでしょうか？環境変数から来ています。次のように入力することでこれらを表示できます\n\n<pre>$ env </pre>\n\nこれにより、現在設定されている環境変数に関する多くの情報が出力されます。これらの変数には、シェルや他のプロセスが使用できる便利な情報が含まれています。\n\n以下に短い例を示します：\n\n<pre>\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\nPWD=/home/user\nUSER=pete\n</pre>\n\n\n特に重要な変数の1つはPATH変数です。これらの変数には、次のように変数名の前に$を付けてアクセスできます：\n\n<pre>\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin\n</pre>\n\nこれにより、システムがコマンドを実行する際に検索するパスがコロンで区切られたリストが返されます。インターネットからパッケージを手動でダウンロードしてインストールし、標準ではないディレクトリに配置し、そのコマンドを実行したい場合を考えてみましょう。$ coolcommandと入力し、プロンプトがコマンドが見つかりませんと表示されたら、それはおかしいです。そのフォルダーにバイナリがあることを確認しているのに、エラーが発生しています。これは、$PATH変数がそのバイナリを検索しないためです。 \n\nそのディレクトリから実行したいバイナリがたくさんある場合、PATH変数を変更してそのディレクトリをPATH環境変数に含めるだけで、そのディレクトリから実行できます。",
          "quizAnswer": "env",
          "quizQuestion": "環境変数をどのように表示しますか？",
          "slug": "envenvironment",
          "title": "env (Environment)"
        },
        {
          "exercise": "次のコマンドは何をしますか？なぜですか？\n\n<pre>$ cut -c 5-10 sample.txt\n$ cut -c 5- sample.txt\n$ cut -c -5 sample.txt\n</pre>",
          "id": 6,
          "lessonContent": "テキストを処理するために使用できる便利なコマンドをいくつか学びます。始める前に、作業するファイルを作成しましょう。次のコマンドをコピーして貼り付け、その後、lazyとdogの間にTABを追加してください（Ctrl-v + TABを押してください）。\n\n<pre>$ echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt</pre>\n\n最初に学ぶコマンドはcutコマンドです。これはファイルからテキストの一部を抽出します。\n\n文字のリストによってコンテンツを抽出するには：\n\n<pre>$ cut -c 5 sample.txt</pre>\n\nこれにより、ファイルの各行の5番目の文字が出力されます。この場合、「q」です。スペースも1文字としてカウントされることに注意してください。\n\nフィールドによってコンテンツを抽出するには、少し変更する必要があります：\n\n<pre>$ cut -f 2 sample.txt</pre>\n\n-fまたはfieldフラグは、デフォルトでTABを区切り文字として使用し、TABで区切られたすべてがフィールドと見なされます。出力として「dog」が表示されるはずです。\n\nフィールドフラグと区切り文字フラグを組み合わせて、カスタム区切り文字によってコンテンツを抽出できます：\n\n<pre>$ cut -f 1 -d \";\" sample.txt</pre>\n\nこれにより、TAB区切り文字が「;」区切り文字に変更され、最初のフィールドを切り取るため、結果は「The quick brown」になります。",
          "quizAnswer": "cut -c 1",
          "quizQuestion": "ファイルの各行の最初の文字を取得するために使用するコマンドは何ですか？",
          "slug": "cutcommand",
          "title": "cut"
        },
        {
          "exercise": "複数のファイルを一緒に貼り付けてみて、何が起こるか試してみてください。",
          "id": 7,
          "lessonContent": "pasteコマンドはcatコマンドに似ており、ファイル内の行を結合します。次の内容を持つ新しいファイルを作成しましょう：\n\n<pre>\nsample2.txt\nThe\nquick\nbrown\nfox\n</pre>\n\nこれらのすべての行を1行に結合しましょう：\n\n<pre>$ paste -s sample2.txt</pre>\n\npasteのデフォルトの区切り文字はTABですので、今は1行に各単語を区切るTABがあります。\n\nこの区切り文字（-d）を少し読みやすいものに変更しましょう：\n\n<pre>$ paste -d ' ' -s sample2.txt</pre>\n\nこれですべてがスペースで区切られた1行になるはずです。",
          "quizAnswer": "-s",
          "quizQuestion": "すべてを1行にするためにpasteと一緒に使用するフラグは何ですか？",
          "slug": "pastecommand",
          "title": "paste"
        },
        {
          "exercise": "次のコマンドは何を行い、なぜですか？\n\n<pre>$ head -c 15 /var/log/syslog</pre>",
          "id": 8,
          "lessonContent": "非常に長いファイルがあるとしましょう。実際、選択肢がたくさんあります。/var/log/syslog を cat してみてください。ページごとにテキストが表示されるはずです。このテキストファイルの最初の数行だけを見たい場合はどうすればよいでしょうか？head コマンドを使用することでそれができます。デフォルトでは、head コマンドはファイルの最初の 10 行を表示します。\n\n<pre>$ head /var/log/syslog</pre>\n\n行数を任意に変更することもできます。たとえば、最初の 15 行を表示したい場合はどうすればよいでしょうか。\n\n<pre>$ head -n 15 /var/log/syslog</pre>\n\n-n フラグは行数を表します。",
          "quizAnswer": "-n",
          "quizQuestion": "head コマンドで表示する行数を変更するために使用するフラグは何ですか？",
          "slug": "headcommand",
          "title": "head"
        },
        {
          "exercise": "tailのmanページを参照し、今回取り上げなかった他のコマンドをいくつか読んでください。\n\n<pre>$ man tail</pre>",
          "id": 8,
          "lessonContent": "headコマンドと同様に、tailコマンドを使用すると、デフォルトでファイルの最後の10行を表示できます。\n\n<pre>$ tail /var/log/syslog</pre>\n\nheadと一緒に、表示したい行数を変更することもできます。\n\n<pre>$ tail -n 10 /var/log/syslog</pre>\n\nもう1つの便利なオプションは、-f（follow）フラグを使用することです。これにより、ファイルが成長するにつれてファイルを追跡できます。試してみて、何が起こるか見てみてください。\n\n<pre>$ tail -f /var/log/syslog</pre>\n\nあなたのsyslogファイルはシステムとやり取りする間に常に変化しており、tail -fを使用すると、そのファイルに追加されるすべての内容を見ることができます。",
          "quizAnswer": "-f",
          "quizQuestion": "tailでファイルを追跡するために使用されるフラグは何ですか？",
          "slug": "tailcommand",
          "title": "tail"
        },
        {
          "exercise": "ファイル入力なしでexpandとだけ入力した場合、何が起こりますか？",
          "id": 10,
          "lessonContent": "cutコマンドのレッスンでは、タブが含まれているsample.txtファイルを使用しました。通常、TABは明らかな違いを示すはずですが、一部のテキストファイルではそれがうまく表示されないことがあります。テキストファイルにTABが含まれていると、望ましいスペーシングにならないことがあります。TABをスペースに変換するには、expandコマンドを使用します。\n\n<pre>$ expand sample.txt</pre>\n\n上記のコマンドは、各TABがスペースのグループに変換された出力を表示します。この出力をファイルに保存するには、以下のように出力リダイレクションを使用します。\n\n<pre>$ expand sample.txt > result.txt</pre>\n\nexpandとは逆に、各スペースのグループをTABに変換するには、unexpandコマンドを使用します。\n\n<pre>$ unexpand -a result.txt</pre>",
          "quizAnswer": "expand",
          "quizQuestion": "TABをスペースに変換するために使用されるコマンドは何ですか？",
          "slug": "expandunexpandcommand",
          "title": "expand and unexpand"
        },
        {
          "exercise": "Join two files with different number of lines in each file, what happens?",
          "id": 11,
          "lessonContent": "The join command allows you to join multiple files together by a common field: \n\nLet's say I had two files that I wanted to join together:\n<pre>file1.txt\n1 John\n2 Jane\n3 Mary\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n\n$ join file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\nSee how it joined together my files? They are joined together by the first field by default and the fields have to be identical, if they are not you can sort them, so in this case the files are joined via 1, 2, 3. \n\nHow would we join the following files? \n\n<pre>file1.txt\nJohn 1\nJane 2\nMary 3\n\nfile2.txt\n1 Doe\n2 Doe\n3 Sue\n</pre>\n\nTo join this file you need to specify which fields you are joining, in this case we want field 2 on file1.txt and field 1 on file2.txt, so the command would look like this:\n\n<pre>\n$ join -1 2 -2 1 file1.txt file2.txt\n1 John Doe\n2 Jane Doe\n3 Mary Sue\n</pre>\n\n-1 refers to file1.txt and -2 refers to file2.txt. Pretty neat. You can also split a file up into different files with the split command: \n\n<pre>$ split somefile</pre>\n\nThis will split it into different files, by default it will split them once they reach a 1000 line limit. The files are named x** by default.",
          "quizAnswer": "join cat dog cow",
          "quizQuestion": "What command would you use to join files named cat dog cow?",
          "slug": "joinsplitcommand",
          "title": "join and split"
        },
        {
          "exercise": "sortの本当の力は他のコマンドと組み合わせることで発揮されます。次のコマンドを試して、何が起こるか見てみてください？\n\n<pre>$ ls /etc | sort -rn</pre>",
          "id": 12,
          "lessonContent": "sortコマンドは行をソートするのに便利です。\n\n<pre>\nfile1.txt\ndog\ncow\ncat\nelephant\nbird\n\n$ sort file1.txt\nbird\ncat\ncow\ndog\nelephant\n</pre>\n\nリバースソートもできます：\n\n<pre>$ sort -r file1.txt\nelephant\ndog\ncow\ncat\nbird\n</pre>\n\nまた、数値でソートすることもできます：\n\n<pre>$ sort -n file1.txt\nbird\ncat\ncow\nelephant\ndog\n</pre>",
          "quizAnswer": "-r",
          "quizQuestion": "リバースソートを行うために使用するフラグは何ですか？",
          "slug": "sortcommand",
          "title": "sort"
        },
        {
          "exercise": "次のコマンドを試してください。何が起こりますか？\n\n<pre>$ tr -d ello\nhello</pre>",
          "id": 13,
          "lessonContent": "tr (translate)コマンドを使用すると、1つの文字セットを別の文字セットに変換できます。すべての小文字を大文字に変換する例を試してみましょう。\n\n<pre>$ tr a-z A-Z\nhello\nHELLO</pre>\n\na-zの範囲をA-Zに変更し、入力したすべての小文字が大文字に変換されることがわかります。",
          "quizAnswer": "tr",
          "quizQuestion": "文字を変換するために使用されるコマンドは何ですか？",
          "slug": "trtranslatecommand",
          "title": "tr (Translate)"
        },
        {
          "exercise": "uniq -uc を試した場合、どの結果が得られますか?",
          "id": 14,
          "lessonContent": "uniq (ユニーク) コマンドは、テキストを解析するための別の便利なツールです。\n\nたくさんの重複があるファイルがあるとします:\n\n<pre>\nreading.txt\nbook\nbook\npaper\npaper\narticle\narticle\nmagazine\n</pre>\n\nそして重複を削除したい場合、uniq コマンドを使用できます:\n\n<pre>$ uniq reading.txt\nbook\npaper\narticle\nmagazine</pre>\n\n行の出現回数をカウントしましょう:\n\n<pre>$ uniq -c reading.txt\n2 book\n2 paper\n2 article\n1 magazine</pre>\n\nユニークな値のみを取得しましょう:\n\n<pre>$ uniq -u reading.txt\nmagazine</pre>\n\n重複する値のみを取得しましょう:\n\n<pre>$ uniq -d reading.txt\nbook\npaper\narticle\n</pre>\n\n<b>注意</b> : uniq は、隣接していない場合は重複した行を検出しません。例えば:\n\n隣接していない重複があるファイルがあるとします:\n\n<pre>\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle\n</pre>\n\n<pre>$ uniq reading.txt\nreading.txt\nbook\npaper\nbook\npaper\narticle\nmagazine\narticle</pre>\n\nuniq によって返される結果には、最初の例とは異なり、すべてのエントリが含まれます。\n\nuniq のこの制限を克服するために、sort と uniq を組み合わせて使用できます:\n\n<pre>\n$ sort reading.txt | uniq\narticle\nbook\nmagazine\npaper</pre>",
          "quizAnswer": "uniq",
          "quizQuestion": "ファイル内の重複を削除するために使用するコマンドは何ですか?",
          "slug": "uniquniquecommand",
          "title": "uniq (ユニーク)"
        },
        {
          "exercise": "nl ファイルを使用して行の合計数を取得するには、出力全体を検索せずにどのようにすればよいですか？ ヒント：このコースで学んだ他のコマンドを使用します。",
          "id": 15,
          "lessonContent": "wc（word count）コマンドはファイル内の単語の合計数を表示します。\n\n<pre>$ wc /etc/passwd\n 96     265    5925 /etc/passwd\n</pre>\n\nそれぞれ、行数、単語数、バイト数を表示します。\n\n特定のフィールドのカウントのみを表示するには、それぞれ -l、-w、-c を使用します。\n\n<pre>$ wc -l /etc/passwd\n96</pre>\n\nファイル内の行数を確認するために使用できる別のコマンドは、nl（number lines）コマンドです。\n\n<pre>\nfile1.txt\ni\nlike\nturtles\n</pre>\n\n<pre>$ nl file1.txt\n1. i\n2. like\n3. turtles\n</pre>",
          "quizAnswer": "wc -w",
          "quizQuestion": "ファイル内の単語の合計数と単語のみを取得するために使用するコマンドは何ですか？",
          "slug": "nlwccommand",
          "title": "wc and nl"
        },
        {
          "exercise": "egrepやfgrepについて聞いたことがあるかもしれませんが、これらは非推奨のgrep呼び出しであり、grep -Eおよびgrep -Fに置き換えられました。詳細についてはgrepのmanページを参照してください。",
          "id": 16,
          "lessonContent": "grepコマンドはおそらく使用する最も一般的なテキスト処理コマンドです。特定のパターンに一致する文字を検索することができます。あるディレクトリにファイルが存在するかどうかを知りたい場合や、ファイル内に特定の文字列が見つかったかどうかを知りたい場合は、grepを使用します。\n\n例として、sample.txtファイルを使用してみましょう：\n\n<pre>$ grep fox sample.txt</pre>\n\ngrepがsample.txtファイルでfoxを見つけたことがわかるはずです。\n\n-iフラグを使用して大文字小文字を区別しないパターンをgrepすることもできます：\n\n<pre>$ grep -i somepattern somefile</pre>\n\ngrepを他のコマンドと組み合わせてさらに柔軟に使用することもできます。\n\n<pre>$ env | grep -i User</pre>\n\ngrepは非常に柔軟です。パターンに正規表現を使用することもできます：\n\n<pre>$ ls /somedir | grep '.txt$'</pre>\n\nsomedir内の.txtで終わるすべてのファイルを返すはずです。",
          "quizAnswer": "grep",
          "quizQuestion": "特定のパターンを見つけるために使用するコマンドは何ですか？",
          "slug": "grepcommand",
          "title": "grep"
        }
      ],
      "slug": "textfu",
      "title": "Text-Fu"
    },
    {
      "description": "vim および emacs を使用して Linux のスパイダーモンキーのようにテキストをナビゲートします。",
      "id": 4,
      "image": "/images/chapters/textManipolationAdvance.png",
      "lessons": [
        {
          "exercise": "正規表現を grep と組み合わせて、いくつかのファイルを検索してみてください。\n\n<pre>\ngrep [ここに正規表現を入力] [ファイル]",
          "id": 1,
          "lessonContent": "正規表現は、パターンベースの選択を行うための強力なツールです。* ワイルドカードなど、すでに遭遇した特殊な表記法を使用します。\n\nいくつかの最も一般的な正規表現を見ていきます。これらは、どんなプログラミング言語でもほぼ共通しています。\n\nテスト文字列としてこのフレーズを使用します:\n<pre>\nsally sells seashells \nby the seashore\n</pre>\n\n<b>1. 行の先頭を ^ で指定する</b>\n\n<pre>\n<b>^</b>by\nは行 \"by the seashore\" と一致します\n</pre>\n\n<b>2. 行の末尾を $ で指定する</b>\n\n<pre>\nseashore<b>$</b>\nは行 \"by the seashore\" と一致します\n</pre>\n\n<b>3. . で任意の1文字に一致する</b>\n\n<pre>\nb<b>.</b>\nは by に一致します\n</pre>\n\n<b>4. [] と () を使用したブラケット表記</b>\n\nこれは少しややこしいかもしれませんが、ブラケットを使用すると、ブラケット内にある文字を指定できます。\n\n<pre>\nd<b>[iou]</b>g\nは次のものに一致します: dig, dog, dug\n</pre>\n\nブラケット内で使用される ^ は、ブラケット内の文字以外の任意の文字を意味します。\n\n<pre>\nd<b>[^i]</b>g\nは dig 以外の dog および dug に一致します\n</pre>\n\nブラケットは範囲を指定するために使用することもできます。\n\n<pre>\nd<b>[a-c]</b>g\nは dag、dbg、dcg などのパターンに一致します\n</pre>\n\nただし、ブラケットは大文字と小文字を区別します:\n\n<pre>\nd<b>[A-C]</b>g\nは dAg、dBg、dCg に一致しますが、dag、dbg、dcg には一致しません\n</pre>\n\n以上が基本的な正規表現です。",
          "quizAnswer": ".",
          "quizQuestion": "1文字に一致させるためにどの正規表現を使用しますか？",
          "slug": "regularexpressionsregex",
          "title": "正規表現 (Regular Expressions)"
        },
        {
          "exercise": "Vimとemacsの小さなツアーをしてみましょう:\n\n<a href=\"http://www.vim.org/\">Vim</a>\n<a href=\"https://www.gnu.org/software/emacs/\">emacs</a>",
          "id": 2,
          "lessonContent": "もし部屋に熱狂的なLinuxユーザーを数人集めて、どのテキストエディタが最適か尋ねると、vimまたはemacsの神聖さについての絶え間ない議論が聞こえてきます。GUIエディタの使用を持ち出すのはやめておいた方がいいでしょう。\n\nVimとemacsは、ほとんどのLinuxディストリビューションにデフォルトでインストールされており、それぞれに長所と短所があります。システムを忍者のように操作したい場合は、これらのテキストエディタのうちの1つを使う必要があります。基本的に、これらはコーディング、ワード文書処理、基本的にはすべてを行うエディタです。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません。次に進んでください！",
          "slug": "texteditorsvimoremacs",
          "title": "テキストエディタ"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "Vimはvi（Improved）の略で、その名前の通り、viテキストエディタコマンドの改良版を表しています。\n\n非常に軽量で、Vimを使用してファイルを開いたり編集したりするのは迅速で簡単です。ほとんどの場合、ランダムなLinuxディストリビューションを起動した場合、vimがデフォルトでインストールされている可能性が高いです。\n\nVimを起動するには、単に次のように入力します：<pre>vim</pre>",
          "quizAnswer": "",
          "quizQuestion": "質問はありません、次に進んでください！",
          "slug": "vimtexteditor",
          "title": "Vim (Vi Improved)"
        },
        {
          "exercise": "検索キーを使って遊んでみてください。vimでテキストファイルを開いてください: vim [textfile] そして検索を始めてください！",
          "id": 4,
          "lessonContent": "式を検索するには、vimセッション中に/キーを入力し、検索結果を入力します。Enterを押すと、検索結果を前方に進むには\"n\"、後方に進むには\"N\"を押すことができます。\n\n<pre>\nMy pretty file is very pretty.\n\n/pretty\n\nテキストファイル内のprettyワードを見つけます。\n</pre>\n\n\n?検索コマンドは、テキストファイルを後方に検索します。したがって、前の例では、最後のprettyが最初に表示されます。\n<pre>\nMy pretty file is very pretty.\n\n?pretty\n\nテキストファイル内のprettyワードを見つけます。\n</pre>",
          "quizAnswer": "/",
          "quizQuestion": "Vimで検索に使用されるキーは何ですか？",
          "slug": "vimsearchpatterns",
          "title": "Vimの検索パターン"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 5,
          "lessonContent": "今、お気づきかもしれませんが、ここではマウスは一切使用されていません。Vimでテキストドキュメントをナビゲートするには、次のキーを使用します：\n\n<ul>\n<li>hまたは左矢印 - 1文字左に移動します</li>\n<li>kまたは上矢印 - 1行上に移動します</li>\n<li>jまたは下矢印 - 1行下に移動します</li>\n<li>lまたは右矢印 - 1文字右に移動します</li>\n</ul>",
          "quizAnswer": "j",
          "quizQuestion": "下に移動するために使用される文字は何ですか？",
          "slug": "vimnavigation",
          "title": "Vimナビゲーション"
        },
        {
          "exercise": "挿入モードとコマンドモードを出入りしてみましょう。",
          "id": 6,
          "lessonContent": "<p>もし何かを入力しようとしたらできないことに気づいたかもしれません。それはコマンドモードにいるためです。これは、ファイルを開いてテキストを入力したいだけの場合に特に混乱することがあります。コマンドモードは、h、j、k、l などのコマンドを入力するときに使用されます。テキストを挿入するには、最初に挿入モードに入る必要があります。</p><p></p><ul><br><li>i - カーソルの前にテキストを挿入</li><br><li>O - 前の行にテキストを挿入</li><br><li>o - 次の行にテキストを挿入</li><br><li>a - カーソルの後にテキストを追加</li><br><li>A - 行の末尾にテキストを追加</li><br></ul><p></p><p>これらの挿入モードのいずれかを入力すると、vim がシェルの下部に挿入モードに入ったことが表示されることに気づくでしょう。挿入モードを終了してコマンドモードに戻るには、単に Esc キーを押します。</p>",
          "quizAnswer": "i",
          "quizQuestion": "カーソルの前にテキストを挿入するために使用されるキーは何ですか？",
          "slug": "viminsertingappendingtext",
          "title": "Vim テキストの追加"
        },
        {
          "exercise": "このレッスンで少し変わったことが追加されました。テキストエディタを開いてこれらを試してみてください。",
          "id": 7,
          "lessonContent": "いくつかの行を書いたので、それをもう少し編集して不要な部分を削除しましょう。<br><p></p><ul><br><li>x - 選択したテキストをカットするために使用され、文字を削除するためにも使用されます</li><br><li>dd - 現在の行を削除するために使用されます</li><br><li>y - 選択されたものをコピーまたはヤンクする</li><br><li>yy - 現在の行をコピーまたはヤンクする</li><br><li>p - カーソルの前にコピーしたテキストを貼り付ける</li><br></ul><p></p>",
          "quizAnswer": "dd",
          "quizQuestion": "どの文字が行全体を削除するために使用されますか？",
          "slug": "vimediting",
          "title": "Vim Editing"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 8,
          "lessonContent": "編集が完了したら、Vimを保存して終了する時が来ました:\n\n<ul>\n<li>:w - ファイルを書き込みまたは保存します</li>\n<li>:q - Vimを終了します</li>\n<li>:wq - 書き込んでから終了します</li>\n<li>:q! - ファイルを保存せずにVimを終了します</li>\n<li>ZZ - :wqと同等ですが、1文字速いです</li>\n\n<li>u - 直前の操作を取り消します</li>\n<li>Ctrl-r - 直前の操作をやり直します</li>\n</ul>\n\nZZが必要ないと思うかもしれませんが、いずれ:finger:は:wqの代わりにこれに傾く傾向があることに気づくでしょう。\n\nVimについての情報がたくさんありましたね。基本的なコマンドやナビゲーションを知ったので、いくつかのテキストファイルを編集し始めることができます。テキストエディタをマスターするための能力を向上させるために、Vimのオンラインガイドに進んで参照してください。",
          "quizAnswer": ":q!",
          "quizQuestion": "Vimを保存せずに終了する方法は？",
          "slug": "vimsavingandexiting",
          "title": "Vimの保存と終了"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 9,
          "lessonContent": "Emacsは、非常に強力なテキストエディタを求めるユーザー向けであり、実質的にEmacs内で作業を行うことになるため、それを単なる言い過ぎとすることもできます。Emacs内でコードの編集、ファイルの操作など、すべてを行うことができます。Vimよりも起動がやや遅く、学習曲線も急ですが、非常に拡張性の高い強力なエディタをお探しの場合は、これがおすすめです。拡張性と言いますと、文字通りEmacs用のスクリプトを作成して機能を拡張することができます。\n\nEmacsを起動するには、次のコマンドを使用します:\n\n<pre>emacs</pre>\n\nデフォルトのウェルカムバッファが表示されるはずです。\n\nEmacsにおけるバッファとは、テキストが格納される場所です。つまり、ファイルを開くと、そのファイルの内容を格納するためにバッファが使用されます。複数のバッファを同時に開いて、簡単に切り替えることができます。",
          "quizAnswer": "",
          "quizQuestion": "問題はありません、次に進んでください！",
          "slug": "emacstexteditor",
          "title": "Emacs"
        },
        {
          "exercise": "ファイルを開いたり保存したりしてみてください。",
          "id": 10,
          "lessonContent": "Emacsのドキュメントの多く（もしくはすべて）で、C-[letter]という構文を見ることがあります。これは単にCtrl-レターを押すことを意味しますが、簡略化のために、CtrlをCと呼ぶことがあります。M-[letter]という構文を見た場合、一般的にAltキーを使用することを意味します。\n\n<b>ファイルの保存</b>\n\n<pre>\nC-x C-s - ファイルを保存\nC-x C-w - ファイルを名前を付けて保存\nC-x s - すべてを保存\n</pre>\n\n保存オプションは、各ファイルを保存するかどうかを尋ねます。\n\n<b>ファイルの開き方</b>\n\n<pre>\nC-x C-f\n</pre>\n\nこれにより、開くファイルの名前を入力するように求められます。既存のファイルがない場合、新しいファイルが作成されます。ディレクトリを読み込むこともできます。",
          "quizAnswer": "C-x C-f",
          "quizQuestion": "ファイルを開くために使用されるコマンドは何ですか？",
          "slug": "emacsmanipulatefiles",
          "title": "Emacsファイルの操作"
        },
        {
          "exercise": "バッファを操作してみてください。",
          "id": 11,
          "lessonContent": "バッファ（または訪れているファイル）を移動するには、次のコマンドを使用します：\n\n<b>バッファの切り替え</b>\n\n<pre>\nC-x b - バッファの切り替え\nC-x right arrow - バッファを右にサイクル\nC-x left arrow - バッファを左にサイクル\n</pre>\n\n<b>バッファを閉じる</b>\n\n<pre>C-x k</pre>\n\n<b>現在のバッファを分割する</b>\n\n<pre>C-x 2</pre>\n\nこれにより、1つの画面で複数のバッファを表示できます。これらのバッファ間を移動するには、C-x o を使用します。\n\n<b>1つのバッファを現在の画面に設定する</b>\n\n<pre>C-x 1</pre>\n\nもし、screen や tmux のようなターミナルマルチプレクサを使用したことがある場合、バッファのコマンドは非常に馴染み深いものに感じるでしょう。",
          "quizAnswer": "C-x k",
          "quizQuestion": "バッファを閉じる方法は？",
          "slug": "emacsbuffernavigation",
          "title": "Emacsバッファナビゲーション"
        },
        {
          "exercise": "テキストナビゲーションを試してみてください。",
          "id": 12,
          "lessonContent": "<b>テキストナビゲーション</b>\n\n<pre>\nC-up arrow : 段落を1つ上に移動\nC-down arrow: 段落を1つ下に移動\nC-left arrow: 単語を1つ左に移動\nC-right arrow: 単語を1つ右に移動\nM-> : バッファの末尾に移動\n</pre>\n\nテキストナビゲーションを使用すると、通常のテキストボタン（home、end、page up、page down、矢印キーなど）が正しく機能します。\n\n<b>切り取りと貼り付け</b>\n\nEmacsで切り取り（kill）または貼り付け（yank）を行うには、まずテキストを選択できる必要があります。 テキストを選択するには、カーソルを切り取るまたは貼り付けたい場所に移動し、<pre>C-space キー</pre>を押してから、テキストを選択するためにナビゲーションキーを使用できます。 これで、次のように切り取りと貼り付けを行うことができます：\n\n<pre>\nC-w : 切り取り\nC-y : 貼り付け\n</pre>",
          "quizAnswer": "M->",
          "quizQuestion": "バッファの末尾に移動する方法は？",
          "slug": "emacsediting",
          "title": "Emacs Editing"
        },
        {
          "exercise": "Emacs サイトを訪れてさらなるコマンドについて学びましょう。 <a href=\"https://www.gnu.org/software/emacs/\">Emacs</a>",
          "id": 13,
          "lessonContent": "<b>Emacs を終了する</b>\n\n<pre>C-x C-c</pre>\n\nもし開いているバッファがあれば、Emacs を終了する前に保存するかどうか尋ねられます。\n\n<b>分からないことがあれば？</b>\n\n<pre>C-h C-h：ヘルプメニュー</pre>\n\n<b>元に戻す</b>\n\n<pre>C-x u</pre>\n\nEmacs には多くの機能があるため、学習コストは少し高くなります。しかし、その代わり非常に強力なテキストエディタが手に入ります。",
          "quizAnswer": "C-h C-h",
          "quizQuestion": "ヘルプメニューにアクセスする方法は？",
          "slug": "emacsexitingandhelp",
          "title": "Emacs Exiting and Help"
        }
      ],
      "slug": "advancedtextfu",
      "title": "Advanced Text-Fu"
    },
    {
      "description": "ユーザーの役割と管理について学びます。",
      "id": 5,
      "image": "/images/chapters/userManagment.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "どんな従来のオペレーティングシステムでも、ユーザーとグループが存在します。これらはアクセスと権限のために存在します。プロセスを実行する際、そのプロセスの所有者として実行されます。ファイルへのアクセスと所有権も権限に依存します。JaneがBobのドキュメントを見ることは望ましくないでしょうし、その逆も同様です。\n\n各ユーザーはユーザー固有のファイルが保存されるホームディレクトリを持っています。通常は/home/usernameにありますが、ディストリビューションによって異なります。\n\nシステムはユーザーID（UID）を使用してユーザーを管理し、ユーザー名はユーザーを識別するための親しみやすい方法ですが、システムはUIDでユーザーを識別します。システムは権限を管理するためにグループも使用します。グループは権限が設定されたユーザーのセットであり、システムによってグループID（GID）で識別されます。\n\nLinuxでは、システムを使用する通常のヒトに加えてユーザーが存在します。これらのユーザーは、システムの機能を維持するために常にプロセスを実行するシステムデーモンであることがあります。最も重要なユーザーの1つはrootまたはスーパーユーザーです。rootはシステム上で最も強力なユーザーであり、どのファイルにもアクセスし、どのプロセスも開始および終了できます。そのため、常にrootとして操作することは危険です。システムの重要なファイルを削除する可能性があります。幸いなことに、rootアクセスが必要である場合、ユーザーがrootアクセスを持っている場合、sudoコマンドを使用して代わりにrootとしてコマンドを実行できます。sudoコマンド（スーパーユーザー実行）はrootアクセスでコマンドを実行するために使用されます。後のレッスンでユーザーがrootアクセスを受け取る方法について詳しく説明します。\n\n次は、/etc/shadowなどの保護されたファイルを表示しようとしてみてください:\n\n<pre>$ cat /etc/shadow</pre>\n\nアクセスが拒否されることに注目してください。権限を確認するには次のコマンドを実行してください: \n\n<pre>$ ls -la /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nまだ権限については説明していませんが、ここで起こっていることは、rootがファイルの所有者であり、内容を読むにはrootアクセスが必要であるか、shadowグループの一員である必要があるということです。次にsudoを使ってコマンドを実行してください:\n\n<pre>$ sudo cat /etc/shadow</pre>\n\nこれでファイルの内容を見ることができます!",
          "quizAnswer": "sudo",
          "quizQuestion": "rootとして実行するために使用するコマンドは何ですか？",
          "slug": "usersandgroups",
          "title": "ユーザーとグループ"
        },
        {
          "exercise": "/etc/sudoersファイルを開いて、マシン上の他のユーザーが持つスーパーユーザー権限を確認してください。",
          "id": 2,
          "lessonContent": "sudoコマンドを使用してスーパーユーザーアクセスを取得する方法を見てきました。 suコマンドを使用してもスーパーユーザーとしてコマンドを実行することができます。このコマンドは「ユーザーを置き換え」、ユーザー名が指定されていない場合はルートシェルを開きます。パスワードを知っていれば、どのユーザーにも置き換えることができます。\n\n<pre>$ su</pre>\n\nこの方法を使用するといくつかの欠点があります。すべてをルートで実行すると致命的なミスを犯しやすくなり、システム構成を変更するために使用したコマンドの記録が残りません。基本的に、スーパーユーザーとしてコマンドを実行する必要がある場合は、sudoに従ってください。\n\nスーパーユーザーとして実行するコマンドを知ったので、次の問題は誰がそれを行う権限を持っているかを知ることです。システムはすべてのユーザーにスーパーユーザーとしてコマンドを実行させるわけではないので、どうやって知っているのでしょうか？ /etc/sudoersファイルというファイルがあります。このファイルにはsudoを実行できるユーザーがリストされています。このファイルは<b>visudo</b>コマンドで編集できます。",
          "quizAnswer": "/etc/sudoers",
          "quizQuestion": "どのファイルがsudoへのアクセス権を持つユーザーを表示しますか？",
          "slug": "rootuser",
          "title": "root"
        },
        {
          "exercise": "自分の/etc/passwdファイルを見て、いくつかのユーザーを確認し、それらが持つアクセス権をメモしてください。",
          "id": 3,
          "lessonContent": "ユーザー名は実際にはユーザーの識別子ではありません。システムはユーザーを識別するためにユーザーID（UID）を使用します。どのユーザーがどのIDにマップされているかを知りたい場合は、/etc/passwdファイルを見てください。\n\n<pre>$ cat /etc/passwd</pre>\n\nこのファイルにはユーザーのリストとそれに関する詳細情報が表示されます。たとえば、このファイルの最初の行はおそらく次のようになります：\n\n<pre>root:x:0:0:root:/root:/bin/bash</pre>\n\n各行は1人のユーザーの情報を表示し、ほとんどの場合、最初の行にはrootユーザーが表示されます。コロンで区切られた多くのフィールドがあり、ユーザーに関する追加情報が示されます。すべてを見てみましょう：\n\n<ol>\n<li>ユーザー名</li>\n<li>ユーザーのパスワード - パスワードは実際にはこのファイルに保存されていません。通常は/etc/shadowファイルに保存されます。/etc/shadowについては次のレッスンで詳しく説明しますが、今のところは、暗号化されたユーザーパスワードが含まれていることを知っておいてください。このフィールドにはさまざまな記号が表示されます。\"x\"が表示されている場合、パスワードは/etc/shadowファイルに保存されていることを意味し、\"*\"が表示されている場合はユーザーがログインアクセス権限を持っていないことを示し、空白のフィールドがある場合はユーザーにパスワードが設定されていないことを意味します。</li>\n<li>ユーザーID - rootのUIDは0であることがわかります</li>\n<li>グループID</li>\n<li>GECOSフィールド - これはユーザーやアカウントに関するコメントを一般的に残すために使用されます。実際の名前や電話番号などが含まれます。コンマで区切られています。</li>\n<li>ユーザーのホームディレクトリ</li>\n<li>ユーザーのシェル - おそらく、多くのユーザーがデフォルトでbashを使用しているのを見るでしょう</li>\n</ol>\n\n通常、ユーザー設定ページでは、人間のユーザーのみが表示されることが期待されます。ただし、/etc/passwdには他のユーザーも含まれていることに注意してください。ユーザーは、異なる権限でプロセスを実行するためにシステムに存在するだけであることを覚えておいてください。時々、事前に決められた権限でプロセスを実行したい場合があります。たとえば、デーモンユーザーはデーモンプロセスに使用されます。\n\nまた、ユーザーを追加したり情報を変更したりする場合は、手動で/etc/passwdファイルを編集することができますが、そのようなことは<b>vipw</b>ツールなど、後のレッスンで説明するツールに任せるのが最善です。",
          "quizAnswer": "*",
          "quizQuestion": "ユーザーがログインアクセス権限を持っていない場合、/etc/passwdでどのように示されますか？",
          "slug": "etcpasswdfile",
          "title": "/etc/passwd"
        },
        {
          "exercise": "/etc/shadowファイルを見てみましょう",
          "id": 4,
          "lessonContent": "The /etc/shadowファイルはユーザー認証に関する情報を格納するために使用されます。スーパーユーザーの読み取り権限が必要です。\n\n<pre>$ sudo cat /etc/shadow\n\nroot:MyEPTEa$6Nonsense:15000:0:99999:7:::\n</pre>\n\n/etc/passwdの内容と非常に似ていることに気づくでしょうが、パスワードフィールドには暗号化されたパスワードが表示されます。フィールドは次のようにコロンで区切られています:\n\n<ol>\n<li>ユーザー名</li>\n<li>暗号化されたパスワード</li>\n<li>最終パスワード変更日 - 1970年1月1日からの日数で表されます。0の場合、ユーザーは次回ログイン時にパスワードを変更する必要があります</li>\n<li>最小パスワード有効期間 - ユーザーが再度パスワードを変更できるまでの日数</li>\n<li>最大パスワード有効期間 - ユーザーがパスワードを変更する必要がある最大日数</li>\n<li>パスワード警告期間 - パスワードの有効期限が切れる前の日数</li>\n<li>パスワード無効期間 - パスワードの有効期限が切れた後、パスワードでログインを許可する日数</li>\n<li>アカウント有効期限日 - ユーザーがログインできなくなる日付</li>\n<li>将来の利用のために予約されたフィールド</li>\n</ol>\n\nほとんどのディストリビューションでは、現在、ユーザー認証は/etc/shadowファイルだけに依存していません。PAM（Pluggable Authentication Modules）などの他のメカニズムが認証を置き換える場合があります。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません、次に進んでください！",
          "slug": "etcshadowfile",
          "title": "/etc/shadow"
        },
        {
          "exercise": "<b>groups</b> コマンドを実行してください。何が表示されますか？",
          "id": 5,
          "lessonContent": "ユーザー管理で使用される別のファイルは /etc/group ファイルです。このファイルを使用すると、異なる権限を持つ異なるグループを作成できます。\n\n<pre>$ cat /etc/group\n\nroot:*:0:pete\n</pre>\n\n/etc/password フィールドと非常に似ていますが、/etc/group フィールドは以下のようになっています：\n\n<ol>\n<li>グループ名</li>\n<li>グループパスワード - グループパスワードを設定する必要はありません。sudo のような昇格特権を使用するのが標準です。デフォルト値として \"*\" が入ります。</li>\n<li>グループ ID (GID)</li>\n<li>ユーザーのリスト - 特定のグループに含めたいユーザーを手動で指定できます</li>\n</ol>",
          "quizAnswer": "0",
          "quizQuestion": "root の GID は何ですか？",
          "slug": "etcgroupfile",
          "title": "/etc/group"
        },
        {
          "exercise": "新しいユーザーを作成し、そのパスワードを変更して新しいユーザーとしてログインしてください。",
          "id": 6,
          "lessonContent": "ほとんどのエンタープライズ環境では、ユーザー、アカウント、パスワードを管理するために管理システムを使用しています。ただし、単一のマシンコンピューターでは、ユーザーを管理するために実行する便利なコマンドがあります。\n\n<b>ユーザーの追加</b>\n\nadduserコマンドまたはuseraddコマンドを使用できます。adduserコマンドには、ホームディレクトリを作成するなど、より便利な機能が含まれています。新しいユーザーを追加するための構成ファイルがあり、デフォルトユーザーに割り当てる内容に応じてカスタマイズできます。\n\n<pre>$ sudo useradd bob</pre>\n\n上記のコマンドを実行すると、bobのために/etc/passwdにエントリが作成され、デフォルトのグループが設定され、/etc/shadowファイルにエントリが追加されます。\n\n<b>ユーザーの削除</b>\n\nユーザーを削除するには、userdelコマンドを使用できます。\n\n<pre>$ sudo userdel bob</pre>\n\nこれにより、useraddによるファイルの変更が元に戻されます。\n\n<b>パスワードの変更</b>\n\n<pre>$ passwd bob</pre>\n\nこれにより、自分自身または他のユーザー（rootである場合）のパスワードを変更できます。",
          "quizAnswer": "passwd",
          "quizQuestion": "パスワードを変更するために使用されるコマンドは何ですか？",
          "slug": "usermanagementtools",
          "title": "ユーザー管理ツール"
        }
      ],
      "slug": "usermanagement",
      "title": "ユーザー管理"
    },
    {
      "description": "権限レベルと権限の変更について学ぶ。",
      "id": 6,
      "image": "/images/chapters/permissions.png",
      "lessons": [
        {
          "exercise": "複数のファイルに対してls -lコマンドを使用し、そのアクセス権限、ユーザー、グループを暗記してください。",
          "id": 1,
          "lessonContent": "以前に学んだように、ファイルには異なるアクセス権限またはファイルモードがあります。例を見てみましょう：\n\n<pre>$ ls -l Desktop/\ndrwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .\n</pre>\n\nファイルのアクセス権限には4つの部分があります。最初の部分はファイルタイプで、アクセス権限内の最初の文字で示されます。今回はディレクトリを見ているので、ファイルタイプとして<b>d</b>が表示されます。通常、通常のファイルには<b>-</b>が表示されます。\n\nファイルモードの次の3つの部分は実際のアクセス権限です。アクセス権限はそれぞれ3ビットずつにグループ化されます。最初の3ビットはユーザーのアクセス権限、次にグループのアクセス権限、そしてその他のアクセス権限です。区切りを明確にするためにパイプを追加しました。\n\n<pre>d | rwx | r-x | r-x </pre>\n\n各文字は異なるアクセス権限を表します：\n<ul>\n<li>r: 読み取り可能</li>\n<li>w: 書き込み可能</li>\n<li>x: 実行可能（基本的に実行可能なプログラム）</li>\n<li>-: 空</li>\n</ul>\n\nしたがって、上記の例では、ユーザーpeteはファイルに対して読み取り、書き込み、実行の権限を持っていることがわかります。グループpenguinsは読み取りと実行の権限を持っています。そして最後に、その他のユーザー（他の全員）は読み取りと実行の権限を持っています。",
          "quizAnswer": "x",
          "quizQuestion": "実行可能に使用される権限ビットは何ですか？",
          "slug": "filepermissions",
          "title": "ファイルのアクセス権限"
        },
        {
          "exercise": "基本的なテキストファイルの権限を変更し、ls -lを実行するとビットが変わるのを確認してください。",
          "id": 2,
          "lessonContent": "権限の変更は、<b>chmod</b>コマンドを使用して簡単に行うことができます。\n\nまず、変更したい権限セット（ユーザー、グループ、その他）を選択します。権限を追加または削除するには、<b>+</b>または<b>-</b>を使用します。いくつかの例を見てみましょう。\n\n<b>ファイルに権限ビットを追加</b>\n<pre>$ chmod u+x myfile</pre>\n\n上記のコマンドは次のように読み取れます：myfileの権限を変更し、ユーザーセットに実行権限ビットを追加します。したがって、ユーザーはこのファイルに対して実行権限を持つようになります！\n\n<b>ファイルから権限ビットを削除</b>\n<pre>$ chmod u-x myfile</pre>\n\n<b>ファイルに複数の権限ビットを追加</b>\n<pre>$ chmod ug+w</pre>\n\n権限を数値形式で変更する別の方法もあります。この方法では、一度にすべての権限を変更できます。権限を表すためにr、w、またはxを使用する代わりに、単一の権限セットの数値表現を使用します。gやuでグループやユーザーを指定する必要はありません。\n\n数値表現は以下の通りです：\n\n<ul>\n<li>4：読み取り権限</li>\n<li>2：書き込み権限</li>\n<li>1：実行権限</li>\n</ul>\n\n例を見てみましょう：\n\n<pre>$ chmod 755 myfile</pre>\n\nこのファイルにどの権限を与えているか推測できますか？これを分解してみましょう。したがって、755はすべてのセットの権限をカバーしています。最初の数字（7）はユーザー権限を表し、2番目の数字（5）はグループ権限を表し、最後の5はその他の権限を表します。\n\nちょっと待って、7と5は上記にリストされていませんでしたが、これらの数字はどこから取得しているのでしょうか？これらの権限を1つの数字に組み合わせているため、数学を使う必要があります。\n\n7 = 4 + 2 + 1 なので、7はユーザー権限であり、読み取り、書き込み、実行権限があります\n\n5 = 4 + 1、グループには読み取りと実行権限があります\n\n5 = 4 + 1、その他のユーザーには読み取りと実行権限があります\n\n注意すべき点：権限を適当に変更するのは良い考えではありません。機密ファイルを誰でも変更できるように公開してしまう可能性がありますが、権限を変更する場合は慎重にchmodコマンドを使用してください。",
          "quizAnswer": "4",
          "quizQuestion": "数値形式を使用して読み取り権限を表すのは何番ですか？",
          "slug": "modifyingpermissions",
          "title": "権限の変更"
        },
        {
          "exercise": "いくつかのテストファイルのグループとユーザーを変更してください。その後、ls -l で権限を確認してください。",
          "id": 3,
          "lessonContent": "ファイルの権限を変更するだけでなく、ファイルのグループとユーザーの所有権も変更できます。\n\n<b>ユーザー所有権の変更</b>\n\n<pre>$ sudo chown patty myfile</pre>\n\nこのコマンドは、myfile の所有者を patty に設定します。\n\n<b>グループ所有権の変更</b>\n\n<pre>$ sudo chgrp whales myfile</pre>\n\nこのコマンドは、myfile のグループを whales に設定します。\n\n<b>ユーザーとグループの両方の所有権を同時に変更する</b>\nユーザーの後にコロンとグループ名を追加すると、ユーザーとグループを同時に設定できます。\n\n<pre>$ sudo chown patty:whales myfile</pre>",
          "quizAnswer": "chown",
          "quizQuestion": "ユーザー所有権を変更するために使用するコマンドは何ですか？",
          "slug": "ownershippermissions",
          "title": "所有権の権限"
        },
        {
          "exercise": "<ol>\n<li>新しいファイルを作成し、そのアクセス許可をメモしてください。</li>\n<li>umaskを変更してから別の新しいファイルを作成します。</li>\n<li>新しいファイルのアクセス許可をもう一度確認し、何を期待しますか？</li>\n<ol>",
          "id": 4,
          "lessonContent": "作成されるすべてのファイルにはデフォルトのアクセス許可が付属しています。 そのデフォルトのアクセス許可を変更したい場合は、umaskコマンドを使用できます。 このコマンドは、数値パーミッションで見る3ビットのパーミッションセットを取ります。\n\nただし、これらのパーミッションを追加するのではなく、umaskはこれらのパーミッションを取り除きます。\n\n<pre>$ umask 021</pre>\n\n上記の例では、新しいファイルのデフォルトのアクセス許可をユーザーにすべてのアクセスを許可するように設定し、グループには書き込み権限を取り除き、その他のユーザーには実行権限を取り除くように指定しています。 ほとんどのディストリビューションのデフォルトのumaskは022であり、すべてのユーザーアクセスを意味しますが、グループおよびその他のユーザーに対する書き込みアクセスはありません。\n\numaskコマンドを実行すると、新しいファイルにそのデフォルトのアクセス許可が付与されます。 ただし、それを永続化したい場合は、スタートアップファイル（.profile）を変更する必要がありますが、それについては後のレッスンで説明します。",
          "quizAnswer": "umask",
          "quizQuestion": "デフォルトのファイルアクセス許可を変更するために使用されるコマンドは何ですか？",
          "slug": "umask",
          "title": "Umask"
        },
        {
          "exercise": "/etc/passwd のパーミッションを詳しく見て、他に気づく点はありますか？ SUID が有効になっているファイルは簡単に見分けることができます。",
          "id": 5,
          "lessonContent": "通常のユーザーが作業を行う際に昇格アクセスが必要なケースが多くあります。システム管理者が保護されたファイルにアクセスが必要なたびに root パスワードを入力するわけにはいかないので、このような振る舞いを許可する特別なファイルパーミッションビットがあります。Set User ID（SUID）は、ユーザーが自分自身ではなくプログラムファイルの所有者としてプログラムを実行できるようにします。\n\n例を見てみましょう：\n\nたとえば、パスワードを変更したいとします。簡単ですよね？ passwd コマンドを使用するだけです：\n\n<pre>$ passwd</pre>\n\nパスワードコマンドは何をしているのでしょうか？ いくつかのファイルを変更していますが、最も重要なのは /etc/shadow ファイルを変更していることです。そのファイルを見てみましょう：\n\n<pre>$ ls -l /etc/shadow\n\n-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow\n</pre>\n\nちょっと待ってください、このファイルは root が所有していますか？ root が所有するファイルをどのように変更できるのでしょうか？\n\n実行したコマンドの別のパーミッションセットを見てみましょう：\n\n<pre>$ ls -l /usr/bin/passwd\n\n-rwsr-xr-x 1 root root 47032 Dec 1 11:45 /usr/bin/passwd\n</pre>\n\nここで新しいパーミッションビット <b>s</b> が見られます。このパーミッションビットは SUID で、ファイルにこのパーミッションが設定されていると、プログラムを起動したユーザーはファイル所有者の権限と実行権限（この場合は root）を取得できます。つまり、ユーザーがパスワードコマンドを実行している間、root として実行されているということです。\n\nこれが passwd コマンドを実行すると /etc/shadow のような保護されたファイルにアクセスできる理由です。もしもそのビットを削除すると、/etc/shadow を変更してパスワードを変更することができなくなることがわかります。\n\n<b>SUID の変更</b>\n\n通常のパーミッションと同様に、SUID パーミッションを変更する方法は2つあります。\n\n<i>シンボリックな方法：</i>\n<pre>$ sudo chmod u+s myfile</pre>\n\n<i>数値的な方法：</i>\n<pre> sudo chmod 4755 myfile</pre>\n\nSUID は 4 で表され、パーミッションセットの前に付加されます。SUID は大文字の <b>S</b> で表されることもありますが、これは同じ機能を持っていますが、実行権限はありません。",
          "quizAnswer": "4",
          "quizQuestion": "SUID を表す数値は何ですか？",
          "slug": "setuidsetuserid",
          "title": "Setuid"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 6,
          "lessonContent": "ユーザー ID 許可ビットに類似して、グループ ID (SGID) 許可ビットがあります。このビットを使用すると、プログラムをそのグループのメンバーであるかのように実行できます。\n\n1 つの例を見てみましょう:\n\n<pre>$ ls -l /usr/bin/wall\n-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall\n</pre>\n\n今、許可ビットがグループ許可セットにあることがわかります。\n\n<b>SGID の変更</b>\n\n<pre>$ sudo chmod g+s myfile\n$ sudo chmod 2555 myfile\n</pre>\n\nSGID の数値表現は 2 です。",
          "quizAnswer": "2",
          "quizQuestion": "SGID を表す数値は何ですか？",
          "slug": "setgidsetgroupid",
          "title": "Setgid"
        },
        {
          "exercise": "まだプロセスについては議論していませんが、実際に変更がリアルタイムで発生しているのを見てみましょう:\n\n<ol>\n<li>1 つ目のターミナルウィンドウを開き、次のコマンドを実行します: <b>watch -n 1 \"ps aux | grep passwd\"</b>。これにより passwd プロセスが監視されます。</li>\n<li>2 つ目のターミナルウィンドウを開き、<b>passwd</b> を実行します</li>\n<li>1 つ目のターミナルウィンドウを見てください。passwd のプロセスが表示されます。プロセステーブルの最初の列は有効ユーザー ID ですが、root ユーザーであることがわかります！</li>\n</ol>",
          "id": 7,
          "lessonContent": "少しプロセス権限について話してみましょう。SUID パーミッションビットを有効にして passwd コマンドを実行すると、プログラムが root として実行されることを覚えていますか？ それは事実ですが、では一時的に root として実行されるため、他のユーザーのパスワードを変更できるということでしょうか？ いいえ、幸いにもそうではありません！\n\nこれは Linux が実装している多くの UID のおかげです。すべてのプロセスには 3 つの UID が関連付けられています:\n\nプロセスを起動すると、そのプロセスは起動したユーザーまたはグループと同じ権限で実行されます。これは <b>有効ユーザー ID</b> として知られています。この UID はプロセスにアクセス権を付与するために使用されます。したがって、たとえば Bob が touch コマンドを実行した場合、プロセスは彼として実行され、作成されたファイルは彼の所有権の下に置かれます。\n\nもう 1 つの UID があり、それは <b>実ユーザー ID</b> と呼ばれ、これはプロセスを起動したユーザーの ID です。これらはプロセスを起動したユーザーを追跡するために使用されます。\n\n最後の UID は <b>保存ユーザー ID</b> で、プロセスが有効 UID と実 UID の間を切り替えることを可能にします。これは、プロセスが常に昇格された権限で実行されることを避けたいために役立ちます。特定のタイミングで特別な権限を使用するのは良い習慣です。\n\nこれで、もう一度 passwd コマンドを見てみましょう。\n\npasswd コマンドを実行すると、有効 UID はユーザー ID です。仮に今は 500 とします。しかし、待ってください、passwd コマンドには SUID パーミッションが有効になっていることを覚えていますか。ですので、実行すると、有効 UID は今や 0 です（0 は root の UID です）。このプログラムは今や root としてファイルにアクセスできます。\n\nちょっとした権力を手に入れて Sally のパスワードを変更したいとします。Sally の UID は 600 です。しかし、幸運なことに、このプロセスにはあなたの実 UID である 500 も含まれています。あなたの UID が 500 であることを知っているため、UID が 600 のパスワードを変更できません。（もちろん、マシン上のスーパーユーザーであり、すべてを制御および変更できる場合は常にこれをバイパスできます）。\n\npasswd を実行した場合、プロセスはあなたの実 UID を使用して開始し、ファイルの所有者の UID（有効 UID）を保存するため、2 つの間を切り替えることができます。必要がない場合は、すべてのファイルを root アクセスで変更する必要はありません。\n\nほとんどの場合、実 UID と有効 UID は同じですが、passwd コマンドのような場合は変更されます。",
          "quizAnswer": "effective",
          "quizQuestion": "どの UID がアクセス権を決定しますか？",
          "slug": "processpermissions",
          "title": "プロセス権限"
        },
        {
          "exercise": "他にどのファイルやディレクトリにスティッキービットが有効になっていると思いますか？",
          "id": 8,
          "lessonContent": "最後に話したい特別なパーミッションビットはスティッキービットです。\n\nこのパーミッションビットは、「ファイル/ディレクトリを固定する」という意味で、所有者またはルートユーザーのみがファイルを削除または変更できます。これは共有ディレクトリに非常に便利です。以下の例をご覧ください：\n\n<pre>$ ls -ld /tmp\ndrwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp\n</pre>\n\nここで最後に特別なパーミッションビット <b>t</b> が表示されます。これは、誰でも/tmpディレクトリ内でファイルを追加したり、ファイルを書き込んだり、ファイルを変更したりできますが、/tmpディレクトリを削除できるのはルートのみです。\n\n<b>スティッキービットの変更</b>\n\n<pre>$ sudo chmod +t mydir\n\n$ sudo chmod 1755 mydir</pre>\n\nスティッキービットの数値表現は <b>1</b> です。",
          "quizAnswer": "t",
          "quizQuestion": "スティッキービットを表す記号は何ですか？",
          "slug": "stickybit",
          "title": "The Sticky Bit"
        }
      ],
      "slug": "permissions",
      "title": "権限"
    },
    {
      "description": "システム上で実行中のプロセスについて学びます。",
      "id": 7,
      "image": "/images/chapters/processes.png",
      "lessons": [
        {
          "exercise": "異なるフラグを使用してpsコマンドを使用し、出力がどのように変わるかを確認してください。",
          "id": 1,
          "lessonContent": "プロセスは、マシン上で実行されているプログラムです。これらはカーネルによって管理され、各プロセスには<b>プロセスID（PID）</b>と呼ばれる関連付けられたIDがあります。このPIDは、プロセスが作成された順に割り当てられます。\n\n続けて、実行中のプロセスのリストを表示するためにpsコマンドを実行してください:\n\n<pre>$ ps\n\nPID        TTY     STAT   TIME          CMD\n41230    pts/4    Ss        00:00:00     bash\n51224    pts/4    R+        00:00:00     ps\n</pre>\n\nこれにより、現在のプロセスのクイックスナップショットが表示されます:\n\n<ul>\n<li>PID: プロセスID</li>\n<li>TTY: プロセスに関連付けられたコントロール端末（後で詳細に説明します）</li>\n<li>STAT: プロセスの状態コード</li>\n<li>TIME: 累計CPU使用時間</li>\n<li>CMD: 実行可能ファイル/コマンドの名前</li>\n</ul>\n\npsのmanページを見ると、渡すことができる多くのコマンドオプションがあることがわかります。使用するオプションによって異なります - BSD、GNU、またはUnix。個人的にはBSDスタイルがより一般的だと考えていますので、それを選択します。スタイルの違いは使用するダッシュの量とフラグです。\n\n<pre>$ ps aux</pre>\n\n<b>a</b>は、他のユーザーによって実行されているプロセスを含むすべての実行中のプロセスを表示します。 <b>u</b>はプロセスに関する詳細情報を表示します。そして最後に、<b>x</b>はTTYが関連付けられていないすべてのプロセスをリストアップします。これらのプログラムはTTYフィールドに?が表示され、システム起動時に一緒に起動するデーモンプロセスで一般的です。\n\n今、多くのフィールドが表示されることに気づくかもしれませんが、すべてを覚える必要はありません。高度なプロセスに関する後のコースでは、これらのいくつかについて再度説明します:\n\n<ul>\n<li>USER: 有効なユーザー（アクセス権を使用しているユーザー）</li>\n<li>PID: プロセスID</li>\n<li>%CPU: プロセスが実行されてからのCPU時間の使用率</li>\n<li>%MEM: プロセスの常駐セットサイズをマシン上の物理メモリに対する比率</li>\n<li>VSZ: プロセス全体の仮想メモリ使用量</li>\n<li>RSS: 常駐セットサイズ、タスクが使用したスワップされていない物理メモリ</li>\n<li>TTY: プロセスに関連付けられたコントロール端末</li>\n<li>STAT: プロセスの状態コード</li>\n<li>START: プロセスの開始時間</li>\n<li>TIME: 累計CPU使用時間</li>\n<li>COMMAND: 実行可能ファイル/コマンドの名前</li>\n</ul>\n\npsコマンドは見るのが少し複雑になることがあります。今のところ、最もよく見るフィールドはPID、STAT、COMMANDです。\n\nもう1つ非常に便利なコマンドは<b>top</b>コマンドです。topはスナップショットではなく、システム上で実行中のプロセスについてリアルタイムの情報を提供します。デフォルトでは、10秒ごとにリフレッシュされます。Topは、リソースを多く消費しているプロセスを確認するための非常に便利なツールです。\n\n<pre>$ top</pre>",
          "quizAnswer": "u",
          "quizQuestion": "プロセスに関する詳細情報を表示するために使用されるpsフラグは何ですか？",
          "slug": "monitorprocessespscommand",
          "title": "ps (プロセス)"
        },
        {
          "exercise": "ps出力を見て、すべての一意のTTY値をリストアップしてください。",
          "id": 2,
          "lessonContent": "ps出力にTTYフィールドがあることを説明しました。TTYはコマンドを実行したターミナルです。\n\nターミナルには、通常の<b>ターミナルデバイス</b>と<b>疑似ターミナルデバイス</b>の2種類があります。通常のターミナルデバイスは、システムに入力を行い、出力を送信できるネイティブなターミナルデバイスです。これは、シェルにアクセスするために起動しているターミナルアプリケーションのように聞こえますが、実際には違います。\n\nこのアクションを見てみましょう。Ctrl-Alt-F1を入力してTTY1（最初の仮想コンソール）に入ると、グラフィックなどは何も表示されず、ターミナルのみが表示されることに気づくでしょう。これは通常のターミナルデバイスと見なされます。Ctrl-Alt-F7で終了できます。\n\n疑似ターミナルは、通常作業しているものです。シェルターミナルウィンドウをエミュレートし、PTSで示されます。再びpsを見ると、pts/*の下にシェルプロセスが表示されます。\n\nさて、コントロールターミナルに戻ります。プロセスは通常、コントロールターミナルにバインドされています。たとえば、シェルウィンドウでプログラム（例：find）を実行していてウィンドウを閉じた場合、プロセスも終了します。\n\nシステムを稼働させ続ける特別なプロセスであるデーモンプロセスなど、コントロールターミナルにバインドされていない特別なプロセスもあります。ps出力では、TTYが<b>?</b>としてリストされており、コントロールターミナルにバインドされていないことを示しています。",
          "quizAnswer": "?",
          "quizQuestion": "コントロールターミナルを持たないプロセスにはどの値が与えられますか？",
          "slug": "controllingterminal",
          "title": "コントロールターミナル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "プロセスのより実践的な応用に入る前に、まずはプロセスが何か、どのように動作するかを理解する必要があります。この部分は詳細に突っ込んでいるため、理解が難しいかもしれません。その場合は後でこのレッスンに戻っても構いません。\n\n前述のように、プロセスはシステム上で実行されているプログラムであり、より正確には、システムがメモリ、CPU、I/Oを割り当ててプログラムを実行させているものです。プロセスは実行中のプログラムのインスタンスであり、3つの端末ウィンドウを開いてください。2つのウィンドウで<b>cat</b>コマンドをオプションなしで実行します（catプロセスは標準入力を待っているため、プロセスとして開いたままになります）。そして、3番目のウィンドウで<b>ps aux | grep cat</b>を実行します。同じプログラムを呼び出していても、catに対して2つのプロセスがあることがわかります。\n\nカーネルはプロセスを管理しており、プログラムを実行するとカーネルはプログラムのコードをメモリに読み込み、リソースを決定・割り当て、そして各プロセスを監視します。カーネルは以下の情報を把握しています：\n\n<ul>\n<li>プロセスの状態</li>\n<li>プロセスが使用しているリソースおよび受信しているリソース</li>\n<li>プロセスの所有者</li>\n<li>シグナルハンドリング（後で詳しく説明します）</li>\n<li>基本的にその他すべて</li>\n</ul>\n\nすべてのプロセスはリソースを確保しようとしており、プロセスの要求に応じて適切なリソース量を提供するのがカーネルの役割です。プロセスが終了すると、使用したリソースは他のプロセスに解放されます。",
          "quizAnswer": "カーネル",
          "quizQuestion": "プロセスを管理し制御するのは何ですか？",
          "slug": "processdetails",
          "title": "プロセスの詳細"
        },
        {
          "exercise": "実行中のプロセスを確認して、他のプロセスがどのプロセスを親として持っているかを見つけられますか？",
          "id": 4,
          "lessonContent": "このレッスンと次のレッスンは、あなたがプロセスをもう少し扱ってみた後に戻ってきてもらうための情報です。\n\n新しいプロセスが作成されると、既存のプロセスは基本的にフォークシステムコールを使用して自身をクローンします（システムコールについては遠い未来に議論されます）。フォークシステムコールはほぼ同一の子プロセスを作成し、この子プロセスは新しいプロセスID（PID）を引き継ぎ、元のプロセスは親プロセスとなり、親プロセスID <b>PPID</b> というものを持ちます。その後、子プロセスは、親が以前に使用していたプログラムを引き続き使用するか、より頻繁には execve システムコールを使用して新しいプログラムを起動します。このシステムコールは、そのプロセスのためにカーネルが設定したメモリ管理を破壊し、新しいプログラムのために新しいメモリ管理をセットアップします。\n\nこれを実際に見てみましょう:\n\n<pre>$ ps l</pre>\n\nl オプションは、実行中のプロセスの「長い形式」またはさらに詳細な表示を提供します。 <b>PPID</b> というラベルが付いた列があります。次に、ターミナルを見てください。シェルが実行されているプロセスが表示されます。私のシステムでは、bash が実行されているプロセスがあります。次に、ps l コマンドを実行したとき、bash が実行されているプロセスから実行していたことを思い出してください。すると、bash シェルの <b>PID</b> が <b>ps l</b> コマンドの <b>PPID</b> になっていることがわかります。\n\nしたがって、すべてのプロセスには親プロセスが必要であり、それらはお互いにフォークされたものであるなら、すべてのプロセスの親であるプロセスが存在するはずですよね？正しいです、システムが起動すると、カーネルは <b>init</b> というプロセスを作成します。そのPIDは1です。init プロセスはシステムがシャットダウンされるまで終了できません。root 権限で実行され、システムを稼働させるために多くのプロセスを実行します。init については、システムの起動時のコースで詳しく見ていきますが、今のところは他のすべてのプロセスを生成するプロセスであることを知っておいてください。",
          "quizAnswer": "fork",
          "quizQuestion": "新しいプロセスを作成するシステムコールは何ですか？",
          "slug": "processcreation",
          "title": "プロセスの作成"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 5,
          "lessonContent": "プロセスが作成される際に何が起こるかを知ったので、それが不要になったときに何が起こっているのでしょうか？覚悟してください、時々Linuxは少し暗くなることがあります...\n\nプロセスは _exit システムコールを使用して終了することができ、これによりそのプロセスが使用していたリソースが再割り当てされます。したがって、プロセスが終了する準備ができたときに、終了ステータスというものでカーネルになぜ終了するのかを知らせます。一般的に、ステータス 0 はプロセスが成功したことを意味します。ただし、プロセスを完全に終了させるにはそれだけでは不十分です。親プロセスは、子プロセスの終了を認識するために wait システムコールを使用する必要があります。これにより、子プロセスの終了ステータスが確認されます。考えるのは残酷かもしれませんが、wait コールは必要不可欠です。やはり、どの親も自分の子供がどのように死んだのか知りたくないでしょうか？\n\nプロセスを終了する別の方法があり、それはシグナルを使用することです。これについては近々説明します。\n\n<b>孤児プロセス</b>\n\n親プロセスが子プロセスよりも先に終了した場合、カーネルは wait コールを受け取らないことを知ります。そのため、これらのプロセスを「孤児」として扱い、init（すべてのプロセスの母）の管理下に置きます。Init は最終的にこれらの孤児のために wait システムコールを実行して終了させます。\n\n<b>ゾンビプロセス</b>\n\n子プロセスが終了し、親プロセスがまだ wait を呼び出していない場合、子プロセスがどのように終了したかを確認したいと思います。したがって、子プロセスが終了したにもかかわらず、カーネルは子プロセスをゾンビプロセスに変えます。子プロセスが使用したリソースは他のプロセスに引き継がれますが、このゾンビのためにプロセステーブルにエントリが残ります。ゾンビプロセスは「死んでいる」ため、シグナルを使用して殺すことはできません。最終的に親プロセスが wait システムコールを呼び出すと、ゾンビは消えます。これを「リーピング」と呼びます。親プロセスが wait コールを実行しない場合、init がゾンビを引き取り、自動的に wait を実行してゾンビを削除します。ゾンビプロセスが多すぎると問題になることがあります。プロセステーブルにスペースを取られ、それがいっぱいになると他のプロセスの実行を妨げる可能性があります。",
          "quizAnswer": "0",
          "quizQuestion": "プロセスが成功する場合の最も一般的な終了ステータスは何ですか？",
          "slug": "processtermination",
          "title": "プロセスの終了"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 6,
          "lessonContent": "シグナルは、プロセスに何かが起こったことを通知するものです。\n\n<b>シグナルの必要性</b>\n\nそれらはソフトウェア割り込みであり、多くの用途があります:\n\n<ul>\n<li>ユーザーは特別な端末文字（Ctrl-C）または（Ctrl-Z）を入力してプロセスを終了、中断、または一時停止できます</li>\n<li>ハードウェアの問題が発生し、カーネルがプロセスに通知したい場合</li>\n<li>ソフトウェアの問題が発生し、カーネルがプロセスに通知したい場合</li>\n<li>基本的にプロセス間で通信する方法です</li>\n</ul>\n\n<b>シグナル処理</b>\n\nイベントによってシグナルが生成されると、それはプロセスに配信され、配信されるまで保留状態になります。プロセスが実行されると、シグナルが配信されます。ただし、プロセスにはシグナルマスクがあり、指定された場合にシグナルの配信をブロックできます。シグナルが配信されると、プロセスはさまざまなことを行うことができます:\n\n<ul>\n<li>シグナルを無視する</li>\n<li>シグナルを\"キャッチ\"して特定のハンドラルーチンを実行する</li>\n<li>通常の終了システムコールとは異なり、プロセスを終了させる</li>\n<li>シグナルをブロックする（シグナルマスクに応じて）</li>\n</ul>\n\n<b>一般的なシグナル</b>\n\n各シグナルは、SIGxxxという形式の象徴的な名前を持つ整数で定義されています。最も一般的なシグナルのいくつかは次のとおりです:\n\n<ul>\n<li>SIGHUPまたはHUPまたは1: ハングアップ</li>\n<li>SIGINTまたはINTまたは2: 中断</li>\n<li>SIGKILLまたはKILLまたは9: 終了</li>\n<li>SIGSEGVまたはSEGVまたは11: セグメンテーション違反</li>\n<li>SIGTERMまたはTERMまたは15: ソフトウェア終了</li>\n<li>SIGSTOPまたはSTOP: 停止</li>\n</ul>\n\nシグナルごとに数字が異なる場合があるため、通常は名前で参照されます。\n\n一部のシグナルはブロックできないものもあり、その1つがSIGKILLシグナルです。KILLシグナルはプロセスを破壊します。",
          "quizAnswer": "SIGKILL",
          "quizQuestion": "どのシグナルがブロックできないですか？",
          "slug": "processsignals",
          "title": "シグナル"
        },
        {
          "exercise": "異なるシグナルを使用していくつかのプロセスを終了させてください。",
          "id": 7,
          "lessonContent": "プロセスを終了させるシグナルを送信することができます。このようなコマンドは適切にkillコマンドと呼ばれます。\n\n<pre>$ kill 12445</pre>\n\n12445は終了させたいプロセスのPIDです。デフォルトではTERMシグナルが送信されます。SIGTERMシグナルは、プロセスにそのリソースをきれいに解放し、状態を保存することを許可して終了を要求するために送信されます。\n\nkillコマンドでシグナルを指定することもできます。\n\n<pre>$ kill -9 12445</pre>\n\nこれにより、SIGKILLシグナルが実行され、プロセスが終了します。\n\n<b>SIGHUP、SIGINT、SIGTERM、SIGKILL、SIGSTOPの違いは？</b>\n\nこれらのシグナルはすべてかなり似ていますが、それぞれに違いがあります。\n\n<ul>\n<li>SIGHUP - 切断、制御端末が閉じられたときにプロセスに送信されます。たとえば、プロセスが実行されている端末ウィンドウを閉じた場合、SIGHUPシグナルが送信されます。つまり、あなたは切断されたということです</li>\n<li>SIGINT - 割り込みシグナルで、Ctrl-Cを使用してシステムがプロセスをきれいに終了しようとします</li>\n<li>SIGTERM - プロセスを終了しますが、最初にいくつかのクリーンアップを行います</li>\n<li>SIGKILL - プロセスを終了し、クリーンアップは行いません</li>\n<li>SIGSTOP - プロセスを停止/中断します</li>\n</ul>",
          "quizAnswer": "SIGTERM",
          "quizQuestion": "デフォルトのkillコマンドのシグナル名は何ですか？",
          "slug": "killingprocesses",
          "title": "kill (終了)"
        },
        {
          "exercise": "どのプロセスがあまり優しくないですか？その理由は何ですか？",
          "id": 8,
          "lessonContent": "コンピューターで複数のアプリケーションを同時に実行すると、Chrome、Microsoft Word、Photoshopなどが同時に実行されているように見えるかもしれませんが、それは完全に真実ではありません。\n\nプロセスは、タイムスライスと呼ばれる短い時間だけCPUを使用します。その後、数ミリ秒の間隔で一時停止し、別のプロセスが少しのタイムスライスを取得します。デフォルトでは、プロセスのスケジューリングはこのラウンドロビン方式で行われます。プロセスが処理を終えるまで、各プロセスに十分なタイムスライスが割り当てられます。カーネルはこれらのプロセスの切り替えをすべて処理し、ほとんどの場合、それをかなりうまく行います。\n\nプロセスはCPUの時間をいつ、どれだけ取得するかを決定することはできません。すべてのプロセスが正常に動作すれば、おおよそ等しいCPU時間を取得します。ただし、nice値を使用してカーネルのプロセススケジューリングアルゴリズムに影響を与える方法があります。Nicenessはかなり奇妙な名前ですが、これはプロセスがCPUの優先順位を決定するための数値を持っていることを意味します。高い数値はプロセスが優しく、CPUに対する優先順位が低いことを示し、低いまたは負の数値はプロセスがあまり優しくなく、可能な限りCPUを取得したいことを示します。\n\n<pre>$ top</pre>\n\n現在、NIの列が表示されています。これはプロセスのnicenessレベルです。\n\nnicenessレベルを変更するには、niceおよびreniceコマンドを使用できます。\n\n<pre>$ nice -n 5 apt upgrade</pre>\n\nniceコマンドは新しいプロセスの優先順位を設定するために使用されます。reniceコマンドは既存のプロセスの優先順位を設定するために使用されます。\n\n<pre>$ renice 10 -p 3245</pre>",
          "quizAnswer": "低い",
          "quizQuestion": "プロセスにより多くのCPU優先度を与えたい場合、より低いまたは高いnice数を使用しますか？",
          "slug": "processniceness",
          "title": "niceness"
        },
        {
          "exercise": "システム上で実行中のプロセスを確認し、そのプロセスの状態をチェックしてください。",
          "id": 9,
          "lessonContent": "ps auxコマンドをもう一度見てみましょう:\n\n<pre>$ ps aux</pre>\n\nSTAT列にはたくさんの値が表示されます。Linuxプロセスはさまざまな状態にあることがあります。以下に、よく見る状態コードを説明します:\n\n<ul>\n<li>R: 実行中または実行可能で、CPUが処理を待っている</li>\n<li>S: 割り込み可能なスリープ、ターミナルからの入力などのイベントの完了を待っている</li>\n<li>D: 割り込み不可能なスリープ、シグナルで終了させることができないプロセスで、再起動するか問題を修正する必要がある</li>\n<li>Z: ゾンビ、以前のレッスンで説明したように、終了したプロセスで、状態が収集されるのを待っている</li>\n<li>T: 停止中、中断/停止されたプロセス</li>\n</ul>",
          "quizAnswer": "D",
          "quizQuestion": "割り込み不可能なスリープを表すのに使用されるSTATコードは何ですか？",
          "slug": "processstates",
          "title": "プロセスの状態"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 10,
          "lessonContent": "Linux ではすべてがファイルであり、プロセスも例外ではありません。プロセス情報は /proc ファイルシステムとして知られる特別なファイルシステムに格納されています。\n\n<pre>$ ls /proc</pre>\n\nここに複数の値が表示されるはずです。各 PID に対するサブディレクトリがあります。ps の出力で PID を見た場合、/proc ディレクトリでそれを見つけることができます。\n\nプロセスの1つに入り、そのファイルを見てみてください:\n\n<pre>$ cat /proc/12345/status</pre>\n\nプロセスの状態情報や詳細情報が表示されるはずです。/proc ディレクトリはカーネルがシステムを表示する方法であり、ps で見る情報よりもここにはさらに多くの情報が含まれています。",
          "quizAnswer": "/proc",
          "quizQuestion": "どのファイルシステムがプロセス情報を保存していますか？",
          "slug": "procfilesystem",
          "title": "/proc ファイルシステム"
        },
        {
          "exercise": "バックグラウンドとフォアグラウンドの間でジョブを移動する",
          "id": 11,
          "lessonContent": "1 つの端末ウィンドウで作業していて、時間がかかるコマンドを実行しているとします。それが完了するまでシェルとやり取りすることはできませんが、私たちはマシンで作業を続けたいので、そのシェルを開いたままにしておきたいです。幸いなことに、ジョブを使ってプロセスの実行方法を制御することができます:\n\n<b>ジョブをバックグラウンドに送信する</b>\n\nコマンドにアンパサンド(&)を追加すると、それをバックグラウンドで実行してシェルを引き続き使用できます。例を見てみましょう:\n\n<pre>$ sleep 1000 &\n$ sleep 1001 &\n$ sleep 1002 &\n</pre>\n\n<b>すべてのバックグラウンドジョブを表示する</b>\n\n今、バックグラウンドに送信したジョブを表示できます。\n\n<pre>$ jobs\n\n[1]    Running     sleep 1000 &\n[2]-   Running     sleep 1001 &\n[3]+   Running     sleep 1002 &\n\n</pre>\n\nこれにより、最初の列にジョブ ID、次にステータス、そして実行されたコマンドが表示されます。ジョブ ID の横にある <b>+</b> は、最も最近に開始されたバックグラウンドジョブを示します。 <b>-</b> が付いているジョブは 2 番目に最近のコマンドです。\n\n<b>既存のジョブをバックグラウンドに送信する</b>\n\nすでにジョブを実行しており、それをバックグラウンドに送信したい場合、それを終了して最初からやり直す必要はありません。まず、Ctrl-Z でジョブを一時停止し、その後 <b>bg</b> コマンドを実行してバックグラウンドに送信します。\n\n<pre>\npete@icebox ~ $ sleep 1003\n^Z\n[4]+    Stopped     sleep 1003\n\npete@icebox ~ $ bg\n[4]+    sleep 1003 &\n\npete@icebox ~ $ jobs\n\n[1]    Running     sleep 1000 &\n[2]    Running     sleep 1001 &\n[3]-   Running     sleep 1002 &\n[4]+   Running     sleep 1003 &\n</pre>\n\n<b>バックグラウンドからフォアグラウンドにジョブを移動する</b>\n\nバックグラウンドからジョブを取り出すには、移動したいジョブ ID を指定します。オプションを指定せずに fg を実行すると、最も最近のバックグラウンドジョブ (＋記号の付いたジョブ) を取り戻します。\n\n<pre>$ fg %1</pre>\n\n<b>バックグラウンドジョブを終了する</b>\n\nバックグラウンドからジョブを取り出すのと同様に、ジョブ ID を使用してプロセスを終了するために同じ形式を使用できます。\n\n<pre>kill %1</pre>",
          "quizAnswer": "jobs",
          "quizQuestion": "バックグラウンドジョブをリストするために使用されるコマンドは何ですか？",
          "slug": "jobcontrol",
          "title": "ジョブ制御"
        }
      ],
      "slug": "processes",
      "title": "プロセス"
    },
    {
      "description": "dpkg、apt-get、rpm、yum パッケージ管理ツールについて学びます。",
      "id": 8,
      "image": "/images/chapters/packages.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "システムは、インターネットブラウザ、テキストエディタ、メディアプレーヤーなどの多くのパッケージで構成されています。これらのパッケージはパッケージマネージャを介して管理され、システムにソフトウェアをインストールおよび維持します。ただし、すべてのパッケージがパッケージマネージャを介してインストールされるわけではありません。一般的に、パッケージをソースコードから直接インストールすることができます（すぐに説明します）。ただし、ほとんどの場合、パッケージマネージャを使用してソフトウェアをインストールします。最も一般的なパッケージの種類はDebian（.deb）およびRed Hat（.rpm）です。Debianスタイルのパッケージは、Debian、Ubuntu、LinuxMintなどのディストリビューションで使用されます。Red Hatスタイルのパッケージは、Red Hat Enterprise Linux、Fedora、CentOSなどで見られます。\n\nパッケージとは何ですか？Chrome、Photoshopなどとして知っているかもしれませんが、実際には、多くのファイルが1つにコンパイルされたものです。このソフトウェアを作成する人々（または時には1人の人物）は、<b>upstreamプロバイダ</b>として知られており、彼らはコードをコンパイルし、インストール方法を記述します。これらのupstreamプロバイダは、新しいソフトウェアをリリースし、既存のソフトウェアを更新する作業に取り組んでいます。世界にリリースする準備が整ったとき、彼らはそのパッケージを<b>パッケージメンテナ</b>に送り、このソフトウェアをユーザーの手に届けます。これらのパッケージメンテナは、このソフトウェアをパッケージの形式でレビュー、管理、配布します。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません、次に進んでください！",
          "slug": "softwaredistribution",
          "title": "ソフトウェア配布"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 2,
          "lessonContent": "インターネットにアップロードされたパッケージがどのようにして私たちのコンピュータに入るのでしょうか？欲しいパッケージのダウンロードページに行って、ダウンロードしてインストールするだけですか？実際、それはできますが、パッケージリポジトリという便利なものがあります。リポジトリは、パッケージのための中央保管場所です。たくさんのパッケージを保持しているたくさんのリポジトリがあり、何よりもインターネット上で見つかるので、面倒なインストールディスクは不要です。あなたのマシンは、あなたが明示的にどこを探すかを教えない限り、これらのリポジトリをどこに探すかわかりません。\n\n例えば、私が自分のマシンにWackyWidgetsソフトウェアを入れたいとします。WackyWidgetsは、ウィジェットパッケージ用の独自のリポジトリを管理しており、このリポジトリにはCoolWidgetパッケージ、SuperWidgetパッケージなどが含まれています。WackyWidgetsは、このリポジトリを次のソースリンクでホストしています：http://download.widgets/linux/deb/\n\nこれで、パッケージを直接ダウンロードするために彼らのウェブサイトに行く代わりに、マシンにWackyWidgetsソフトウェアをソースリンクから見つけるように指示できます。\n\nあなたのディストリビューションには、パッケージを取得するための事前承認済みソースがすでに付属しており、これによりシステム上で見るすべての基本パッケージがインストールされます。Debianシステムでは、このソースファイルは<b>/etc/apt/sources.list</b>ファイルです。あなたのマシンはそこを見て、追加したソースリポジトリをチェックするようになります。",
          "quizAnswer": "/etc/apt/sources.list",
          "quizQuestion": "Debianシステムにおけるソースファイルの場所は？",
          "slug": "packagerepositories",
          "title": "パッケージリポジトリ"
        },
        {
          "exercise": "tar のドキュメントを確認し、man ページで利用可能な他のオプションを見てください。",
          "id": 3,
          "lessonContent": "パッケージのインストールや異なるマネージャーに取り組む前に、ファイルのアーカイブ化と圧縮について話し合う必要があります。インターネットでソフトウェアを探す際には、おそらくこれらに遭遇することが多いでしょう。\n\nおそらくすでにファイルアーカイブというものを知っているでしょう。.rar や .zip などのファイル形式に遭遇したことがあるかもしれません。これらはファイルのアーカイブであり、1 つのアーカイブとして非常に整然とした単一のファイルに多くのファイルが含まれています。\n\n<b>gzip を使用したファイルの圧縮</b>\n\ngzip は Linux でファイルを圧縮するためのプログラムで、.gz 拡張子で終わります。\n\nファイルを圧縮するには:\n<pre>$ gzip mycoolfile</pre>\n\nファイルを解凍するには:\n<pre>$ gunzip mycoolfile.gz</pre>\n\n<b>tar を使用したアーカイブの作成</b>\n残念ながら、gzip は複数のファイルを 1 つのアーカイブに追加することができません。幸いにも、これを行う tar プログラムがあります。tar を使用してアーカイブを作成すると、.tar 拡張子が付きます。\n\n<pre>$ tar cvf mytarfile.tar mycoolfile1 mycoolfile 2</pre>\n\n<ul>\n<li>c - 作成</li>\n<li>v - プログラムに冗長モードで動作させ、何を行っているかを表示させる</li>\n<li>f - tar ファイルのファイル名はこのオプションの後に記入する必要があります。tar ファイルを作成する場合は、名前を考える必要があります</li>\n</ul>\n\n<b>tar を使用したアーカイブの展開</b>\n\ntar ファイルの内容を抽出するには、次のようにします:\n\n<pre>$ tar xvf mytarfile.tar</pre>\n\n<ul>\n<li>x - 抽出</li>\n<li>v - プログラムに冗長モードで動作させ、何を行っているかを表示させる</li>\n<li>f - 抽出したいファイル</li>\n</ul>\n\n<b>tar と gzip を使用したアーカイブの圧縮/解凍</b>\n\n多くの場合、mycompressedarchive.tar.gz などの圧縮された tar ファイルが見られます。圧縮を解除するにはまず gunzip で圧縮を解除し、その後 tar ファイルを展開します。または tar に <b>z</b> オプションを使用することもできます。これは gzip または gunzip ユーティリティを使用するように指示するだけです。\n\n圧縮された tar ファイルを作成:\n<pre>$ tar czf myfile.tar.gz</pre>\n\n解凍して展開:\n<pre>$ tar xzf file.tar</pre>\n\nヘルプが必要な場合は、次を覚えておいてください: すべてのファイルを e<b>X</b>tract し、<b>Z</b>ee の <b>F</b>iles を処理します！\n\ntar は非常に重要なコマンドの 1 つですが、実際にはあまり覚えていないコマンドの 1 つです。関連する xkcd: <a href=\"https://xkcd.com/1168/\">https://xkcd.com/1168/</a>\n\n<b>その他のユーティリティ</b>\n\nLinux の旅の途中で、bzip2、compress、zip、unzip などの他のアーカイブや圧縮形式に遭遇することがあります。これらは少し一般的でないかもしれませんが、異なるユーティリティには異なるコマンドが必要であることを覚えておいてください。",
          "quizAnswer": "c",
          "quizQuestion": "アーカイブを作成するために使用される tar フラグは何ですか？",
          "slug": "compressedarchivestar",
          "title": "tar and gzip"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 4,
          "lessonContent": "パッケージはほとんど単独で機能することはめったにありません。ほとんどの場合、実行を支援するための依存関係が付属しています。たとえば、レストランのグループがあるとします。これらのレストランはすべて異なる料理を提供していますが、すべてが同じ農場から食材を入手しています。彼らの食べ物は農場の供給に依存しており、もし農場が突然食材の供給を停止したら、それではレストランはかなり困ることになります。\n\nLinuxでは、これらの依存関係はしばしば他のパッケージや共有ライブラリです。共有ライブラリは、他のプログラムが使用したいコードのライブラリであり、自分で書き直したくないものです。再びレストランを考えてみてください。すべてのレストランが自分の食材を栽培するとしたら、どれだけの作業が必要でしょうか？あまりにも多すぎます。\n\n私たちはファイルシステムコースで共有ライブラリについて詳しく説明しますので、今のところは、パッケージには実行を支援するための依存関係があることを覚えておいてください。それらの依存関係が他のパッケージやライブラリである場合でも、依存関係が存在しないと、パッケージは壊れた状態になり、ほとんどの場合、インストールさえできなくなります。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません。次に進んでください！",
          "slug": "packagedependencies",
          "title": "Package Dependencies"
        },
        {
          "exercise": "Google Chrome のようなシステムにインストールしたいプログラムを見つけ、これらのコマンドのいずれかを使用してインストールしてください。",
          "id": 5,
          "lessonContent": "このコースのほとんどはパッケージ管理システムについてです（パッケージ管理のバットマン）、しかし私たちはロビンについて忘れてはいけません。非常に便利で信頼性がありますが、甘いバットモービルやユーティリティベルトは付属していません。\n\n.exe が単一の実行可能ファイルであるように、.deb や .rpm も同様です。通常、パッケージリポジトリを使用している場合はこれらを見ることはありませんが、直接パッケージをダウンロードすると、おそらくこれらの人気のある形式で取得することになります。明らかに、これらはそれぞれのディストリビューションに固有であり、Debian ベースの場合は .deb、Red Hat ベースの場合は .rpm です。\n\nこれらの直接パッケージをインストールするには、パッケージ管理コマンド rpm と dpkg を使用できます。これらのツールはパッケージファイルをインストールするために使用されますが、パッケージの依存関係はインストールされません。つまり、パッケージに 10 個の依存関係がある場合、それらのパッケージを別々にインストールし、その依存関係を続けてインストールする必要があります。ご覧の通り、これが後で議論する完全な管理システムを導入した理由の1つでした。\n\nこれらのツールを使用してパッケージをインストール、クエリ、確認する必要がある場面が何度もあることを覚えておいてください。\n\n<b>パッケージをインストール</b>\n\n<pre>\nDebian: $ dpkg -i some_deb_package.deb\nRPM: $ rpm -i some_rpm_package.rpm\n</pre>\n\n<b>i</b> はインストールを表します。--install のより長い形式も使用できます。\n\n<b>パッケージを削除</b>\n\n<pre>\nDebian: $ dpkg -r some_deb_package.deb\nRPM: $ rpm -e some_rpm_package.rpm\n</pre>\n\nDebian: <b>r</b> は削除のため\nRPM: <b>e</b> は削除のため\n\n<b>インストールされているパッケージの一覧</b>\n\n<pre>\nDebian: $ dpkg -l\nRPM: $ rpm -qa\n</pre>\n\nDebian: <b>l</b> はリストのため\nRPM: <b>q</b> はクエリのため、<b>a</b> はすべてのため",
          "quizAnswer": "dpkg",
          "quizQuestion": ".deb ファイル用のパッケージ管理ツールは何ですか？",
          "slug": "packageinstalltools",
          "title": "rpm と dpkg"
        },
        {
          "exercise": "これらのパッケージコマンドを実行し、受け取る出力を確認してください。",
          "id": 6,
          "lessonContent": "パッケージ管理のバットマン、これらのシステムはパッケージのインストール、削除、変更を容易にするためのすべての機能を備えており、パッケージの依存関係をインストールすることもできます。最も人気のある管理システムの2つは <b>yum</b> と <b>apt</b> です。Yum は Red Hat ファミリー専用であり、apt は Debian ファミリー専用です。\n\n<b>リポジトリからパッケージをインストール</b>\n\n<pre>\nDebian: $ apt install パッケージ名\nRPM: $ yum install パッケージ名\n</pre>\n\n<b>パッケージを削除</b>\n\n<pre>\nDebian: $ apt remove パッケージ名\nRPM: $ yum erase パッケージ名\n</pre>\n\n<b>リポジトリのパッケージを更新</b>\n\nパッケージをインストールおよび更新する前に、パッケージリポジトリを常に最新の状態に更新するのがベストプラクティスです。\n\n<pre>\nDebian: apt update; apt upgrade\nRPM: yum update\n</pre>\n\n<b>インストールされたパッケージに関する情報を取得</b>\n\n<pre>\nDebian: apt show パッケージ名\nRPM: yum info パッケージ名\n</pre>",
          "quizAnswer": "apt show",
          "quizQuestion": "Debian システムでパッケージ情報を表示するために使用されるコマンドは何ですか？",
          "slug": "packagemanagementsystems",
          "title": "yum と apt"
        },
        {
          "exercise": "信頼できるサイトからソースコードプログラムを見つけ、ソースからインストールしてください。",
          "id": 7,
          "lessonContent": "しばしば、純粋なソースコードの形でしか提供されていないマイナーなパッケージに遭遇することがあります。そのソースコードパッケージをコンパイルしてシステムにインストールするためには、いくつかのコマンドを使用する必要があります。\n\nまず最初に、ソースコードをコンパイルするためのツールをインストールするソフトウェアが必要です。\n\n<pre>$ sudo apt install build-essential</pre>\n\nそれを行ったら、おそらく .tar.gz ファイルであるパッケージファイルの内容を展開します。\n\n<pre>$ tar -xzvf package.tar.gz</pre>\n\n何をする前に、パッケージ内の README や INSTALL ファイルを見てください。時々、特定のインストール手順が記載されています。\n\n開発者が使用したコンパイル方法に応じて、cmake やその他のコマンドを使用する必要があることがあります。\n\nただし、最も一般的には基本的な make コンパイルが見られるため、それについて説明します。\n\nパッケージの内容には configure スクリプトが含まれており、このスクリプトはシステム上の依存関係をチェックし、何かが不足している場合はエラーが表示され、それらの依存関係を修正する必要があります。\n\n<pre>$ ./configure</pre>\n\n<b>./</b> は、現在のディレクトリでスクリプトを実行することを可能にします。\n\n<pre>$ make</pre>\n\nパッケージの内容には、ソフトウェアを構築するためのルールが含まれた Makefile というファイルがあります。make コマンドを実行すると、このファイルを参照してソフトウェアを構築します。\n\n<pre>$ sudo make install</pre>\n\nこのコマンドは実際にパッケージをインストールし、正しいファイルを正しい場所にコピーします。\n\nパッケージをアンインストールしたい場合は、次のコマンドを使用します。\n\n<pre>$ sudo make uninstall</pre>\n\nmake install を使用する際は注意が必要です。バックグラウンドで何が行われているかを実際には理解していないかもしれません。このパッケージを削除することに決めた場合、実際にはすべてを削除していないかもしれません。代わりに、私が説明した make install についてすべてを忘れて、<b>checkinstall</b> コマンドを使用してください。このコマンドは、簡単にインストールおよびアンインストールできる .deb ファイルを作成します。\n\n<pre>$ sudo checkinstall</pre>\n\nこのコマンドは基本的に「make install」を行い、.deb パッケージをビルドしてインストールします。後でパッケージを簡単に削除できるようになります。",
          "quizAnswer": "checkinstall",
          "quizQuestion": "make install の代わりに常に何を使用すべきですか？",
          "slug": "compilesourcecode",
          "title": "ソースコードのコンパイル"
        }
      ],
      "slug": "packages",
      "title": "パッケージ"
    },
    {
      "description": "Linux デバイスについて学び、それらがカーネルとユーザースペースとどのようにやり取りするかを理解します。",
      "id": 9,
      "image": "/images/chapters/devices.png",
      "lessons": [
        {
          "exercise": "/dev ディレクトリの内容を確認し、なじみのあるデバイスを認識できますか？",
          "id": 1,
          "lessonContent": "デバイスをマシンに接続するとき、通常、デバイスが正常に機能するためにはデバイスドライバが必要です。デバイスドライバとやり取りするには、デバイスファイルまたはデバイスノードを介します。これらは通常のファイルのように見える特別なファイルです。これらのデバイスファイルは通常、/dev ディレクトリに保存されています。システム上の /dev ディレクトリを ls してみてください。システムにある多くのデバイスファイルが表示されます。\n\n<pre>$ ls /dev </pre>\n\nこれらのデバイスのうち、/dev/null など、すでに使用してやり取りしたものがあります。/dev/null に出力を送信すると、カーネルはこのデバイスがすべての入力を受け取り、単に破棄することを知っているため、何も返されません。\n\n昔は、システムにデバイスを追加したい場合、/dev にデバイスファイルを追加してから、おそらくそれを忘れてしまうことがよくありました。これを何度も繰り返すと、問題が発生することがわかります。/dev ディレクトリは、長らく使用していないデバイスの静的なデバイスファイルでごったがえしてしまいます。デバイスは、カーネルがそれらを見つけた順番でデバイスファイルが割り当てられます。したがって、システムを再起動するたびに、デバイスは発見されたタイミングによって異なるデバイスファイルを持つ可能性があります。\n\n幸いなことに、もはやその方法は使用されておらず、現在は、システムで使用中のデバイスを動的に追加および削除するために使用するものがあり、これについては今後のレッスンで議論します。",
          "quizAnswer": "/dev",
          "quizQuestion": "システム上のデバイスファイルはどこに保存されていますか？",
          "slug": "devdirectory",
          "title": "/dev ディレクトリ"
        },
        {
          "exercise": "/devディレクトリを見て、どの種類のデバイスが見つかるか確認してください。",
          "id": 2,
          "lessonContent": "デバイスの管理方法について話す前に、実際にいくつかのデバイスを見てみましょう。\n\n<pre>$ ls -l /dev\nbrw-rw----   1 root disk      8,   0 Dec 20 20:13 sda\ncrw-rw-rw-   1 root root      1,   3 Dec 20 20:13 null\nsrw-rw-rw-   1 root root           0 Dec 20 20:13 log\nprw-r--r--   1 root root           0 Dec 20 20:13 fdata\n</pre>\n\n左から右に列は次のようになります:\n\n<ul>\n<li>権限</li>\n<li>所有者</li>\n<li>グループ</li>\n<li>メジャーデバイス番号</li>\n<li>マイナーデバイス番号</li>\n<li>タイムスタンプ</li>\n<li>デバイス名</li>\n</ul>\n\nlsコマンドでは、各行の最初のビットでファイルの種類を確認できます。デバイスファイルは次のように示されます:\n\n<ul>\n<li>c - キャラクター</li>\n<li>b - ブロック</li>\n<li>p - パイプ</li>\n<li>s - ソケット</li>\n</ul>\n\n<b>キャラクターデバイス</b>\n\nこれらのデバイスはデータを1文字ずつ転送します。キャラクターデバイスとして擬似デバイス(/dev/nullなど)が多く見られます。これらのデバイスは物理的にマシンに接続されていませんが、オペレーティングシステムにより高度な機能が提供されます。\n\n<b>ブロックデバイス</b>\n\nこれらのデバイスはデータを大きな固定サイズのブロックで転送します。ハードドライブ、ファイルシステムなど、データブロックを利用するデバイスがブロックデバイスとして最も一般的です。\n\n<b>パイプデバイス</b>\n\n名前付きパイプを使用すると、2つ以上のプロセス間で通信できます。これらはキャラクターデバイスに似ていますが、デバイスに出力を送る代わりに、他のプロセスに送信されます。\n\n<b>ソケットデバイス</b>\n\nソケットデバイスはプロセス間の通信を可能にし、パイプデバイスに似ていますが、複数のプロセスと通信できます。\n\n<b>デバイスの特性</b>\n\nデバイスは<b>メジャーデバイス番号</b>と<b>マイナーデバイス番号</b>の2つの数字を使用して特徴付けられます。上記のlsの例でこれらの数字を確認できます。これらの数字はコンマで区切られています。例えば、デバイスのデバイス番号が<b>8, 0</b>だったとします:\n\nメジャーデバイス番号は使用されているデバイスドライバを表し、この場合は8で、これはしばしばsdブロックデバイスのメジャーナンバーです。マイナーナンバーは、カーネルに対してこのドライバクラス内のどのユニークなデバイスかを示します。この場合、0は最初のデバイス(a)を表します。",
          "quizAnswer": "c",
          "quizQuestion": "ls -lコマンドでキャラクターデバイスのシンボルは何ですか？",
          "slug": "devicetypes",
          "title": "デバイスタイプ"
        },
        {
          "exercise": "疑似デバイスに書き込んで何が起こるかを確認し、これらのデバイスにディスクを書き込まないように注意してください！",
          "id": 3,
          "lessonContent": "ここには、よく遭遇するであろうデバイス名が示されています：\n\n<b>SCSI デバイス</b>\n\nマシンに何らかの大容量記憶装置がある場合、それはおそらく SCSI (発音は「スカジー」) プロトコルを使用しています。SCSI は Small Computer System Interface の略で、ディスク、プリンタ、スキャナなどの周辺機器とシステム間の通信を可能にするためのプロトコルです。現代のシステムでは実際には使用されていない SCSI デバイスについては聞いたことがあるかもしれませんが、Linux システムでは SCSI ディスクを /dev におけるハードディスクドライブと対応付けています。これらは sd (SCSI ディスク) の接頭辞で表されます：\n\n一般的な SCSI デバイスファイル：\n\n<ul>\n<li>/dev/sda - 第1ハードディスク</li>\n<li>/dev/sdb - 第2ハードディスク</li>\n<li>/dev/sda3 - 第1ハードディスクの第3パーティション</li>\n</ul>\n\n<b>疑似デバイス</b>\n\n先に述べたように、疑似デバイスは実際には物理的にシステムに接続されていません。最も一般的な疑似デバイスはキャラクタデバイスです：\n\n<ul>\n<li>/dev/zero - すべての入力を受け入れて破棄し、NULL (ゼロ値) バイトの連続ストリームを生成します</li>\n<li>/dev/null - すべての入力を受け入れて破棄し、出力を生成しません</li>\n<li>/dev/random - ランダムな数値を生成します</li>\n</ul>\n\n<b>PATA デバイス</b>\n\n古いシステムでは、ハードディスクが hd 接頭辞で参照されることがあります：\n\n<ul>\n<li>/dev/hda - 第1ハードディスク</li>\n<li>/dev/hdd2 - 第4ハードディスクの第2パーティション</li>\n</ul>",
          "quizAnswer": "sdb1",
          "quizQuestion": "第2の SCSI ディスクの最初のパーティションのデバイス名は一般的に何ですか？",
          "slug": "devicenames",
          "title": "デバイス名"
        },
        {
          "exercise": "/sysディレクトリの内容を確認し、そこにどのファイルがあるかを確認してください。",
          "id": 4,
          "lessonContent": "Sysfsは、以前作成され、/devディレクトリがうまく管理できなかったシステム上のデバイスをよりよく管理するために作成されました。Sysfsは仮想ファイルシステムであり、ほとんどの場合/sysディレクトリにマウントされます。/devディレクトリで見ることができる情報よりも詳細な情報を提供してくれます。/sysディレクトリと/devディレクトリの両方は非常に似ているように見えますが、いくつかの点で大きな違いがあります。基本的に、/devディレクトリはシンプルで、他のプログラムがデバイス自体にアクセスできるようにしますが、/sysファイルシステムは情報を表示しデバイスを管理するために使用されます。\n\n/sysファイルシステムには、システム上のすべてのデバイスの情報が含まれており、製造元やモデル、デバイスが接続されている場所、デバイスの状態、デバイスの階層などが含まれます。ここで見るファイルはデバイスノードではないため、実際には/sysディレクトリからデバイスとやり取りするのではなく、デバイスを管理しています。\n\n/sysディレクトリの内容を見てみましょう:\n\n<pre>\npete@icebox:~$ ls /sys/block/sda\nalignment_offset  discard_alignment  holders   removable  sda6       trace\nbdi               events             inflight  ro         size       uevent\ncapability        events_async       power     sda1       slaves\ndev               events_poll_msecs  queue     sda2       stat\ndevice            ext_range          range     sda5       subsystem\n</pre>",
          "quizAnswer": "/sys",
          "quizQuestion": "デバイスの詳細情報を表示するために使用されるディレクトリは何ですか？",
          "slug": "sysfs",
          "title": "sysfs"
        },
        {
          "exercise": "与えられたudevadmコマンドを実行し、入力を確認してください。",
          "id": 5,
          "lessonContent": "昔ながらの方法と今でも、本当に必要ならば、次のようなコマンドを使用してデバイスノードを作成することができます：\n\n<pre>$ mknod /dev/sdb1 b 8 3</pre>\n\nこのコマンドは、デバイスノード/dev/sdb1を作成し、それをブロックデバイス（b）にし、メジャーナンバーを8、マイナーナンバーを3にします。\n\nデバイスを削除するには、単純に/devディレクトリ内のデバイスファイルを<b>rm</b>します。\n\n幸いなことに、これをもうやる必要はありません。udevのおかげで、デバイスファイルが動的に作成および削除されます。udevシステムには、システムで実行されているudevdデーモンがあり、システムに接続されたデバイスに関するカーネルからのメッセージを受信します。udevdはその情報を解析し、/etc/udev/rules.dで指定されたルールとデータを照合し、おそらくそのルールに基づいてデバイスノードとシンボリックリンクを作成します。独自のudevルールを作成することもできますが、このレッスンの範囲外です。幸いにも、システムには多くのudevルールが含まれているため、独自のルールを作成する必要がないかもしれません。\n\nまた、<b>udevadm</b>コマンドを使用してudevデータベースとsysfsを表示することもできます。このツールは非常に便利ですが、時々非常に複雑になることがあります。デバイスの情報を表示するための簡単なコマンドは次のとおりです：\n\n<pre>$ udevadm info --query=all --name=/dev/sda</pre>",
          "quizAnswer": "udev",
          "quizQuestion": "何がデバイスを動的に追加および削除しますか？",
          "slug": "udev",
          "title": "udev"
        },
        {
          "exercise": "これらのコマンドを試して、受け取る出力を確認してください。",
          "id": 6,
          "lessonContent": "lsコマンドを使用してファイルやディレクトリの一覧を表示するのと同様に、デバイスに関する情報をリストするための類似したツールを使用できます。\n\n<b>USBデバイスのリスト表示</b>\n\n<pre>$ lsusb </pre>\n\n<b>PCIデバイスのリスト表示</b>\n\n<pre>$ lspci </pre>\n\n<b>SCSIデバイスのリスト表示</b>\n\n<pre>$ lsscsi </pre>",
          "quizAnswer": "lsusb",
          "quizQuestion": "USBデバイスを表示するために使用できるコマンドは何ですか？",
          "slug": "listingdevices",
          "title": "lsusb, lspci, lssci"
        },
        {
          "exercise": "ddコマンドを使用してドライブのバックアップを作成し、出力を.imgファイルに設定します。",
          "id": 7,
          "lessonContent": "ddツールはデータの変換やコピーに非常に便利です。ファイルまたはデータストリームから入力を読み取り、ファイルまたはデータストリームに書き込みます。\n\n次のコマンドを考えてみましょう:\n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1024 </pre>\n\nこのコマンドは、backup.imgの内容を/dev/sdbにコピーしています。データは1024バイトのブロックでコピーされ、データのコピーが完了するまで続きます。\n\n<ul>\n<li>if=file - 入力ファイル、標準入力ではなくファイルから読み取る</li>\n<li>of=file - 出力ファイル、標準出力ではなくファイルに書き込む</li>\n<li>bs=bytes - ブロックサイズ、このサイズのデータを一度に読み取り、書き込みます。サイズをk（キロバイト）、m（メガバイト）などで示すことで異なるサイズのメトリックを使用できます。したがって、1024バイトは1kです</li>\n<li>count=number - コピーするブロック数。</li>\n</ul>\n\n通常、1メガバイトのファイルをコピーする場合、countオプションを使用するddコマンドがいくつかあります。コピーが完了したときにファイルを1メガバイトとして表示したい場合がほとんどです。次のコマンドを実行するとします:\n\n<pre>$ dd if=/home/pete/backup.img of=/dev/sdb bs=1M count=2</pre>\n\n私たちのbackup.imgファイルは10Mですが、このコマンドでは1Mを2回コピーするよう指定しているため、2Mだけがコピーされ、コピーされたデータが不完全なままになります。多くの状況でcountは便利ですが、データを単にコピーする場合はcountやbsを省略しても問題ありません。データ転送を最適化したい場合は、これらのオプションを使用する必要があります。\n\nddは非常に強力であり、バックアップの作成やディスク全体のドライブの復元など、あらゆるもののバックアップに使用できます。何をしているのかよくわからない場合は、その強力なツールが高価な代償をもたらす可能性があるので注意してください。",
          "quizAnswer": "bs",
          "quizQuestion": "ブロックサイズのddオプションは何ですか？",
          "slug": "ddcommand",
          "title": "dd"
        }
      ],
      "slug": "devices",
      "title": "Devices"
    },
    {
      "description": "Linuxファイルシステム、異なるタイプのファイルシステム、パーティショニングなどについて学びます。",
      "id": 10,
      "image": "/images/chapters/filesystem.png",
      "lessons": [
        {
          "exercise": "/usrディレクトリの中を見て、どのような情報がそこにあるか確認してください。",
          "id": 1,
          "lessonContent": "この時点で、おそらくシステムのディレクトリ構造によく精通しているはずです。そうでない場合は、すぐに慣れるでしょう。ファイルシステムは構造が異なることがありますが、ほとんどの場合、ファイルシステム階層標準に準拠する必要があります。\n\n<b>ls -l /</b>を実行して、ルートディレクトリにリストされているディレクトリを確認してください。あなたのものは私のと異なるかもしれませんが、ディレクトリは大部分が以下のように見えるはずです：\n\n<ul>\n<li>/ - ファイルシステム階層全体のルートディレクトリで、すべてのものがこのディレクトリの下に収められています。</li>\n<li>/bin - 必要な実行可能プログラム（バイナリ）が含まれ、lsやcpなどの最も基本的なコマンドが含まれています。</li>\n<li>/boot - カーネルブートローダーファイルが含まれています。</li>\n<li>/dev - デバイスファイル。</li>\n<li>/etc - コアシステム構成ディレクトリで、構成ファイルのみを保持し、バイナリは含まれません。</li>\n<li>/home - ユーザーの個人ディレクトリで、ドキュメント、ファイル、設定などが保存されています。</li>\n<li>/lib - バイナリが使用できるライブラリファイルが保存されています。</li>\n<li>/media - USBドライブなどのリムーバブルメディアの添付ポイントとして使用されます。</li>\n<li>/mnt - 一時的にマウントされたファイルシステム。</li>\n<li>/opt - オプションのアプリケーションソフトウェアパッケージ。</li>\n<li>/proc - 現在実行中のプロセスに関する情報。</li>\n<li>/root - ルートユーザーのホームディレクトリ。</li>\n<li>/run - 前回の起動以降の実行中システムに関する情報。</li>\n<li>/sbin - 重要なシステムバイナリが含まれており、通常はrootユーザーのみが実行できます。</li>\n<li>/srv - システムによって提供されるサイト固有のデータ。</li>\n<li>/tmp - 一時ファイルのためのストレージ</li>\n<li>/usr - 残念ながら名前が不適切ですが、ほとんどの場合、ユーザーファイル（ホームフォルダの意味で）を含んでいません。これはユーザーがインストールしたソフトウェアやユーティリティのために使用されるものですが、個人ディレクトリを追加できないというわけではありません。このディレクトリ内には、/usr/bin、/usr/localなどのサブディレクトリがあります。</li>\n<li>/var - 変数ディレクトリで、システムのログ記録、ユーザーの追跡、キャッシュなどに使用されます。基本的には常に変更される可能性のあるものです。</li>\n</ul>",
          "quizAnswer": "/var",
          "quizQuestion": "ログを保存するために使用されるディレクトリは何ですか？",
          "slug": "filesystemhierarchy",
          "title": "ファイルシステム階層"
        },
        {
          "exercise": "他のファイルシステムタイプ（ReiserFS、ZFS、JFSなど）についてオンラインで少し調査してください。",
          "id": 2,
          "lessonContent": "利用可能なさまざまなファイルシステムの実装があります。いくつかは他のものよりも速く、一部はより大容量のストレージをサポートし、他のものは小容量のストレージでのみ動作します。異なるファイルシステムには、データを整理する異なる方法があり、どのような種類のファイルシステムがあるかについて詳細に説明します。さまざまな実装が利用可能なため、アプリケーションは異なる操作に対処する方法が必要です。そのために、仮想ファイルシステム（VFS）抽象化レイヤーというものがあります。これはアプリケーションと異なるファイルシステムタイプの間にあるレイヤーであり、どのファイルシステムを使用しているかに関係なく、アプリケーションがそれと連携できるようになります。\n\nディスクには複数のファイルシステムを持つことができ、それはパーティション方法によります。これについては後続のレッスンで説明します。\n\n<b>ジャーナリング</b>\n\nほとんどのファイルシステムタイプにはデフォルトでジャーナリングがありますが、念のためそうでない場合もあります。大きなファイルをコピーしている途中で突然電源が落ちた場合を考えてみましょう。ジャーナリングのないファイルシステムでは、ファイルが壊れ、ファイルシステムが不整合になり、再起動時にシステムがファイルシステムのチェックを行います。ただし、修復にはファイルシステムのサイズに応じて時間がかかる場合があります。\n\n一方、ジャーナリングシステムでは、マシンが実際にファイルをコピーする前に、行う作業をログファイル（ジャーナル）に書き込みます。ファイルのコピーが完了すると、ジャーナルはそのタスクを完了したとマークします。このため、ファイルシステムは常に一貫した状態にあり、したがって、マシンが突然シャットダウンされた場合でも、どこで作業を中断したかを正確に把握します。これにより、ブート時間が短縮され、ファイルシステム全体をチェックするのではなく、ジャーナルを確認するだけで済みます。\n\n<b>一般的なデスクトップファイルシステムの種類</b>\n\n<ul>\n<li>ext4 - これはネイティブLinuxファイルシステムの最新バージョンです。古いext2およびext3バージョンと互換性があります。1エクサバイトまでのディスク容量と16テラバイトまでのファイルサイズをサポートし、Linuxファイルシステムの標準選択肢です。</li>\n<li>Btrfs - \"Better or Butter FS\" は、スナップショット、増分バックアップ、パフォーマンス向上などを備えた新しいLinuxファイルシステムです。広く利用可能ですが、まだ安定しておらず、互換性がありません。</li>\n<li>XFS - 大容量ファイルなどのシステムに適した高性能ジャーナリングファイルシステム。</li>\n<li>NTFSおよびFAT - Windowsファイルシステム</li>\n<li>HFS+ - Macintoshファイルシステム</li>\n</ul>\n\nマシンにどのファイルシステムがあるかを確認してください：\n\n<pre>\npete@icebox:~$ df -T\nFilesystem     Type     1K-blocks    Used Available Use% Mounted on\n/dev/sda1      ext4       6461592 2402708   3707604  40% /\nudev           devtmpfs    501356       4    501352   1% /dev\ntmpfs          tmpfs       102544    1068    101476   2% /run\n/dev/sda6      xfs       13752320  460112  13292208   4% /home\n</pre>\n\n<b>df</b>コマンドはファイルシステムのディスクスペース使用状況やその他の詳細を報告し、後でこのツールについて詳しく説明します。",
          "quizAnswer": "ext4",
          "quizQuestion": "一般的なLinuxファイルシステムタイプは何ですか？",
          "slug": "filesystemtypes",
          "title": "ファイルシステムの種類"
        },
        {
          "exercise": "自分のマシンで<b>parted -l</b>を実行し、結果を評価してください。",
          "id": 3,
          "lessonContent": "ハードディスクはパーティションに分割でき、複数のブロックデバイスを作成できます。 例として、/dev/sda1や/dev/sda2などが挙げられます。/dev/sdaはディスク全体を指し、/dev/sda1はそのディスク上の最初のパーティションを指します。 パーティションはデータを分離するのに非常に役立ち、特定のファイルシステムが必要な場合、ディスク全体を1つのファイルシステムタイプにする代わりに、簡単にパーティションを作成できます。\n\n<b>パーティションテーブル</b>\n\nすべてのディスクにはパーティションテーブルがあり、このテーブルはディスクがどのようにパーティションされているかをシステムに伝えます。 このテーブルには、パーティションの開始と終了位置、ブート可能なパーティション、ディスクのどのセクタがどのパーティションに割り当てられているかなどが記載されます。 使用される主なパーティションテーブルスキームには、Master Boot Record（MBR）とGUID Partition Table（GPT）があります。\n\n<b>パーティション</b>\n\nディスクはデータを整理するのに役立つパーティションで構成されています。 ディスク上に複数のパーティションを持つことができ、これらは互いに重なることはありません。 パーティションに割り当てられていないスペースがある場合、それは未割り当て領域と呼ばれます。 パーティションの種類はパーティションテーブルに依存します。 パーティション内にはファイルシステムを持つか、スワップなど他の用途のためにパーティションを割り当てることができます。\n\n<i>MBR</i>\n\n<ul>\n<li>従来のパーティションテーブルで、標準として使用されていました</li>\n<li>プライマリ、拡張、論理パーティションを持つことができます</li>\n<li>MBRはプライマリパーティションを4つまでしか持つことができません</li>\n<li>追加のパーティションは、プライマリパーティションを拡張パーティションに変更することで作成できます（ディスク上には1つの拡張パーティションしか存在できません）。 その後、拡張パーティション内に論理パーティションを追加します。 論理パーティションは他のパーティションと同様に使用されます。</li>\n<li>2テラバイトまでのディスクをサポート</li>\n</ul>\n\n<i>GPT</i>\n\n<ul>\n<li>GUID Partition Table（GPT）は、ディスクのパーティション分割の新しい標準となっています</li>\n<li>1種類のパーティションのみを持ち、複数作成できます</li>\n<li>各パーティションにはグローバルに一意なID（GUID）があります</li>\n<li>UEFIベースのブートに主に使用されます（別のコースで詳細を説明します）</li>\n</ul>\n\n<b>ファイルシステム構造</b>\n\n前のレッスンから、ファイルシステムがファイルとディレクトリの整理されたコレクションであることを知っています。 最も単純な形態では、ファイルシステムはファイルを管理するデータベースと実際のファイル自体で構成されていますが、もう少し詳しく説明します。\n\n<ul>\n<li>ブートブロック - これはファイルシステムの最初の数セクタにあり、実際にはファイルシステムには使用されません。 代わりに、オペレーティングシステムの起動に使用される情報が含まれています。 オペレーティングシステムには1つのブートブロックしか必要ありません。 複数のパーティションがある場合、それぞれにブートブロックがありますが、そのうちの多くは使用されません。</li>\n<li>スーパーブロック - これはブートブロックの後に続く単一のブロックで、ファイルシステムのサイズ、inodeテーブルのサイズ、論理ブロックのサイズ、ファイルシステムのサイズなどの情報が含まれています。</li>\n<li>inodeテーブル - これはファイルを管理するデータベースと考えてください（inodeに関する詳細なレッスンがありますので、心配しないでください）。 各ファイルやディレクトリにはinodeテーブル内で一意のエントリがあり、ファイルに関するさまざまな情報が含まれています。</li>\n<li>データブロック - これはファイルとディレクトリの実際のデータです。</li>\n</ul>\n\n異なるパーティションテーブルを見てみましょう。 以下は、MBRパーティションテーブル（msdos）を使用したパーティションの例です。 マシン上のプライマリ、拡張、論理パーティションが表示されます。\n\n<pre>\npete@icebox:~$ sudo parted -l\nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\n\nこの例はGPTを使用し、パーティションには一意のIDが使用されています。\n\n<pre>\nModel: Thumb Drive (scsi)\nDisk /dev/sdb: 4041MB\nSector size (logical/physical): 512B/512B\nPartition Table: gpt\n\nNumber  Start   End     Size     File system  Name        Flags\n 1      17.4kB  1000MB  1000MB                first\n 2      1000MB  4040MB  3040MB                second\n</pre>",
          "quizAnswer": "extended",
          "quizQuestion": "MBRパーティショニングスキームで4つ以上のパーティションを作成するために使用されるパーティションタイプは何ですか？",
          "slug": "anatomyofadisk",
          "title": "ディスクの解剖"
        },
        {
          "exercise": "USB ドライブを半分に分割し、片方を ext4 として、もう片方を空きスペースとして使用します。",
          "id": 4,
          "lessonContent": "USB ドライブ上でファイルシステムに関する実用的な作業を行いましょう。USB ドライブがなくても心配はありません。次のいくつかのレッスンに従って進めることができます。\n\nまず、ディスクをパーティション分割する必要があります。これを行うためには多くのツールが利用可能です。\n\n<ul>\n<li>fdisk - 基本的なコマンドラインパーティショニングツールで、GPT はサポートされていません</li>\n<li>parted - MBR と GPT の両方をサポートするコマンドラインツール</li>\n<li>gparted - parted の GUI バージョン</li>\n<li>gdisk - fdisk ですが、MBR はサポートしておらず、GPT のみをサポートしています</li>\n</ul>\n\nパーティショニングには parted を使用しましょう。USB デバイスを接続し、デバイス名が /dev/sdb2 であるとします。\n\n<b>parted を起動</b>\n\n<pre>$ sudo parted</pre>\n\nparted ツールに入力され、ここでデバイスをパーティション分割するコマンドを実行できます。\n\n<b>デバイスを選択</b>\n\n<pre>select /dev/sdb2</pre>\n\n作業するデバイスを選択するには、デバイス名で選択します。\n\n<b>現在のパーティションテーブルを表示</b>\n\n<pre>\n(parted) print                                                            \nModel: Seagate (scsi)\nDisk /dev/sda: 21.5GB\nSector size (logical/physical): 512B/512B\nPartition Table: msdos\n\nNumber  Start   End     Size    Type      File system     Flags\n 1      1049kB  6860MB  6859MB  primary   ext4            boot\n 2      6861MB  21.5GB  14.6GB  extended\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n 6      7381MB  21.5GB  14.1GB  logical   xfs\n</pre>\n\nここでは、デバイス上の利用可能なパーティションが表示されます。 <b>start</b> と <b>end</b> のポイントは、パーティションがハードドライブ上で占有するスペースの場所です。パーティションの開始および終了位置を適切に見つける必要があります。\n\n<b>デバイスをパーティション分割</b>\n\n<pre>mkpart primary 123 4567</pre>\n\n開始点と終了点を選択してパーティションを作成し、使用したテーブルに応じてパーティションの種類を指定する必要があります。\n\n<b>パーティションのサイズを変更</b>\n\n空き容量がない場合は、パーティションのサイズを変更することもできます。\n\n<pre>resize 2 1245 3456</pre>\n\nパーティション番号を選択し、それをリサイズしたい開始点と終了点を指定します。\n\nParted は非常に強力なツールですので、ディスクのパーティション分割を行う際は注意が必要です。",
          "quizAnswer": "mkpart",
          "quizQuestion": "パーティションを作成する parted のコマンドは何ですか？",
          "slug": "diskpartitioning",
          "title": "ディスクのパーティショニング"
        },
        {
          "exercise": "USB ドライブに ext4 ファイルシステムを作成してください。",
          "id": 5,
          "lessonContent": "ディスクを実際にパーティション分割したので、ファイルシステムを作成しましょう！\n\n<pre>$ sudo mkfs -t ext4 /dev/sdb2</pre>\n\nそれだけです！<b>mkfs</b>（ファイルシステムを作成する）ツールを使用して、作成したいファイルシステムのタイプと場所を指定できます。新しくパーティション分割されたディスク上にファイルシステムを作成したい場合、または古いディスクを再パーティション分割する場合にのみファイルシステムを作成する必要があります。既存のファイルシステムの上に新たに作成しようとすると、おそらくファイルシステムが破損する可能性が高いです。",
          "quizAnswer": "mkfs",
          "quizQuestion": "ファイルシステムを作成するために使用されるコマンドは何ですか？",
          "slug": "creatingfilesystems",
          "title": "ファイルシステムの作成"
        },
        {
          "exercise": "mount と umount のmanページを参照し、使用可能な他のオプションを確認してください。",
          "id": 6,
          "lessonContent": "ファイルシステムの内容を表示する前に、マウントする必要があります。そのためには、デバイスの場所、ファイルシステムの種類、マウントポイントが必要です。マウントポイントは、ファイルシステムをアタッチするシステム上のディレクトリです。つまり、デバイスをマウントポイントにマウントしたいということです。\n\nまず、マウントポイントを作成します。この場合、<b>mkdir /mydrive</b> とします。\n\n<pre>$ sudo mount -t ext4 /dev/sdb2 /mydrive</pre>\n\nこれで完了です！/mydrive に移動すると、ファイルシステムの内容が表示されます。ここで、<b>-t</b> はファイルシステムの種類を指定し、次にデバイスの場所、そしてマウントポイントが続きます。\n\nマウントポイントからデバイスをアンマウントするには:\n\n<pre>$ sudo umount /mydrive \nまたは \n$ sudo umount /dev/sdb2</pre>\n\nデバイスは、見つかった順にカーネルが名前を付けます。マウントした後にデバイス名が何らかの理由で変更された場合はどうなるでしょうか？幸いなことに、デバイスの一意な識別子（UUID）を使用できます。\n\nブロックデバイスのUUIDを表示するには:\n\n<pre>\npete@icebox:~$ sudo blkid\n/dev/sda1: UUID=\"130b882f-7d79-436d-a096-1e594c92bb76\" TYPE=\"ext4\" \n/dev/sda5: UUID=\"22c3d34b-467e-467c-b44d-f03803c2c526\" TYPE=\"swap\" \n/dev/sda6: UUID=\"78d203a0-7c18-49bd-9e07-54f44cdb5726\" TYPE=\"xfs\" \n</pre>\n\nデバイス名、対応するファイルシステムの種類、UUIDが表示されます。これで、マウントする際には次のようにします:\n\n<pre>$ sudo mount UUID=130b882f-7d79-436d-a096-1e594c92bb76 /mydrive</pre>\n\nほとんどの場合、UUIDを使用してデバイスをマウントする必要はありません。USBドライブなどの一般的なデバイスをマウントする場合は、デバイス名を使用する方が簡単です。ただし、セカンダリハードドライブなどを起動時に自動的にマウントする必要がある場合は、UUIDを使用する必要があります。次のレッスンでその方法について説明します。",
          "quizAnswer": "mount",
          "quizQuestion": "ファイルシステムをアタッチするために使用されるコマンドは何ですか？",
          "slug": "mountingandunmountingfilesystems",
          "title": "mount と umount"
        },
        {
          "exercise": "作業中の USB ドライブを /etc/fstab にエントリとして追加し、再起動してもマウントされた状態で表示されるようにしてください。",
          "id": 7,
          "lessonContent": "自動的にファイルシステムを起動時にマウントしたい場合は、/etc/fstab というファイルに追加することができます（発音は「エフ エス タブ」ではなく「エフ スタブ」です）。これはファイルシステムテーブルの略です。このファイルにはマウントされているファイルシステムの永続的なリストが含まれています。\n\n<pre>\npete@icebox:~$ cat /etc/fstab\nUUID=130b882f-7d79-436d-a096-1e594c92bb76 /               ext4    relatime,errors=remount-ro 0       1\nUUID=78d203a0-7c18-49bd-9e07-54f44cdb5726 /home           xfs     relatime        0       2\nUUID=22c3d34b-467e-467c-b44d-f03803c2c526 none            swap    sw              0       0\n</pre>\n\n各行は1つのファイルシステムを表し、フィールドは次のとおりです：\n\n<ul>\n<li>UUID - デバイス識別子</li>\n<li>マウントポイント - ファイルシステムがマウントされるディレクトリ</li>\n<li>ファイルシステムの種類</li>\n<li>オプション - その他のマウントオプション、詳細については man ページを参照</li>\n<li>Dump - バックアップを作成するタイミングを決定するために dump ユーティリティによって使用され、デフォルトは 0 にしておくべきです</li>\n<li>Pass - fsck によって使用され、ファイルシステムがチェックされる順序を決定するため、値が 0 の場合はチェックされません</li>\n</ul>\n\nエントリを追加するには、上記のエントリ構文を使用して /etc/fstab ファイルを直接変更してください。このファイルを変更する際は注意してください。間違えると、生活が少し厳しくなる可能性があります。",
          "quizAnswer": "/etc/fstab",
          "quizQuestion": "ファイルシステムがどのようにマウントされるかを定義するために使用されるファイルは何ですか？",
          "slug": "etcfstabfilesystemtable",
          "title": "/etc/fstab"
        },
        {
          "exercise": "USBドライブの空き容量をスワップスペース用にパーティション化します。",
          "id": 8,
          "lessonContent": "前の例では、パーティションテーブルを表示する方法を示しました。その例をもう一度見てみましょう。特にこの行：\n\n<pre>\nNumber  Start   End     Size    Type      File system     Flags\n 5      6861MB  7380MB  519MB   logical   linux-swap(v1)\n</pre>\n\nこのスワップパーティションとは何でしょうか？スワップは、システムに仮想メモリを割り当てるために使用されます。メモリが不足している場合、システムはこのパーティションを使用してアイドルプロセスのメモリの一部をディスクに「スワップ」し、メモリが不足しないようにします。\n\n<b>スワップスペースとしてパーティションを使用する</b>\n\n/dev/sdb2のパーティションをスワップスペースとして設定したいとします。\n\n<ol>\n<li>最初にパーティションに何もないことを確認します</li>\n<li>実行：mkswap /dev/sdb2 でスワップ領域を初期化します</li>\n<li>実行：swapon /dev/sdb2 これによりスワップデバイスが有効になります</li>\n<li>スワップパーティションを起動時に維持したい場合は、/etc/fstabファイルにエントリを追加する必要があります。使用するファイルシステムのタイプはswです。</li>\n<li>スワップを削除するには：swapoff /dev/sdb2</li>\n</ol>\n\n通常、メモリ量の約2倍のスワップスペースを割り当てるべきです。ただし、現代のシステムは通常、十分に強力で十分なRAMを持っています。",
          "quizAnswer": "swapon",
          "quizQuestion": "デバイスでスワップスペースを有効にするコマンドは何ですか？",
          "slug": "swapspace",
          "title": "swap"
        },
        {
          "exercise": "duとdfの両方を使用してディスクの使用状況と空き容量を確認してください。",
          "id": 9,
          "lessonContent": "ディスクの利用状況を確認するために使用できるツールがいくつかあります：\n\n<pre>\npete@icebox:~$ df -h\nFilesystem     1K-blocks    Used Available Use% Mounted on\n/dev/sda1       6.2G  2.3G  3.6G  40% /\n</pre>\n\ndfコマンドは現在マウントされているファイルシステムの利用状況を表示します。-hフラグは人間が読み取り可能な形式を提供します。デバイスと使用容量、利用可能な容量がどれくらいかを確認できます。\n\nディスクがいっぱいになってきて、どのファイルやディレクトリがそのスペースを占有しているか知りたい場合は、<b>du</b>コマンドを使用できます。\n\n<pre>$ du -h</pre>\n\nこれにより、現在のディレクトリのディスク使用量が表示されます。<b>du -h /</b>を使用してルートディレクトリを覗いてみることもできますが、少し混乱するかもしれません。\n\nこれらのコマンドは構文が非常に似ているため、どちらを使用すべきか覚えるのが難しいかもしれません。ディスクの<b>空き容量</b>を確認するにはdfを使用し、<b>ディスク使用量</b>を確認するにはduを使用します。",
          "quizAnswer": "df",
          "quizQuestion": "ディスク上の空き容量を表示するために使用されるコマンドは何ですか？",
          "slug": "diskusage",
          "title": "Disk Usage"
        },
        {
          "exercise": "fsck の man ページを見て、他に何ができるかを確認してください。",
          "id": 10,
          "lessonContent": "時々、私たちのファイルシステムは常に最良の状態にあるわけではありません。突然のシャットダウンが発生すると、データが壊れる可能性があります。システムは、私たちを作業可能な状態に戻そうとします（もちろん、自分で試すこともできます）。\n\n<b>fsck</b>（ファイルシステムチェック）コマンドは、ファイルシステムの整合性をチェックし、修復を試みるために使用されます。通常、ディスクを起動すると、fsck が実行され、ディスクがマウントされる前にすべてが正常であることを確認します。しかし、ディスクが非常に悪い状態の場合、手動で行う必要があることもあります。ただし、マウントされていないファイルシステムにアクセスできるレスキューディスクなどで行うようにしてください。\n\n<pre>$ sudo fsck /dev/sda</pre>",
          "quizAnswer": "fsck",
          "quizQuestion": "ファイルシステムの整合性をチェックするために使用されるコマンドは何ですか？",
          "slug": "filesystemrepair",
          "title": "ファイルシステムの修復"
        },
        {
          "exercise": "異なるファイルのinode番号を観察し、通常どれが最初に作成されますか？",
          "id": 11,
          "lessonContent": "ファイルシステムは、実際のファイルとそれらのファイルを管理するデータベースから構成されていることを覚えていますか？このデータベースはinodeテーブルとして知られています。\n\n<b>inodeとは何ですか？</b>\n\ninode（インデックスノード）はこのテーブル内のエントリであり、すべてのファイルに1つずつ存在します。ファイルに関するすべての情報を記述しており、以下のようなものが含まれます：\n\n<ul>\n<li>ファイルの種類 - 通常のファイル、ディレクトリ、文字デバイスなど</li>\n<li>所有者</li>\n<li>グループ</li>\n<li>アクセス権限</li>\n<li>タイムスタンプ - mtime（最終ファイル変更時刻）、ctime（最終属性変更時刻）、atime（最終アクセス時刻）</li>\n<li>ファイルへのハードリンクの数</li>\n<li>ファイルのサイズ</li>\n<li>ファイルに割り当てられたブロック数</li>\n<li>ファイルのデータブロックへのポインタ - 最も重要な情報！</li>\n</ul>\n\n基本的に、inodeはファイルに関するすべての情報を保存しますが、ファイル名とファイル自体は保存しません！\n\n<b>inodeはいつ作成されますか？</b>\n\nファイルシステムが作成されると、inode用のスペースも割り当てられます。ディスクの容量などに応じて、どれだけのinodeスペースが必要かを決定するアルゴリズムが存在します。人生の中でディスク容量不足のエラーを見たことがあるかもしれません。同様に、inodeの不足も発生し、その結果、新しいファイルを作成できなくなることがあります。データの保存はデータとデータベース（inode）の両方に依存することを覚えておいてください。\n\nシステムに残っているinodeの数を確認するには、<b>df -i</b>コマンドを使用します。\n\n<b>inode情報</b>\n\ninodeは番号で識別され、ファイルが作成されるとinode番号が割り当てられます。番号は連続して割り当てられますが、inodeが削除されると他のファイルに再利用されることがあるため、新しいファイルを作成する際に他のファイルよりも低いinode番号が割り当てられることがあります。inode番号を表示するには、<b>ls -li</b>を実行します：\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nこのコマンドの最初のフィールドにはinode番号がリストされています。\n\nまた、statを使用してファイルの詳細情報を表示できます。これにより、inodeに関する情報も表示されます。\n\n<pre>\npete@icebox:~$ stat ~/Desktop/\n  File: ‘/home/pete/Desktop/’\n  Size: 6               Blocks: 0          IO Block: 4096   directory\nDevice: 806h/2054d      Inode: 140         Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: ( 1000/   pete)   Gid: ( 1000/   pete)\nAccess: 2016-01-20 20:13:50.647435982 -0800\nModify: 2016-01-20 20:13:06.191675843 -0800\nChange: 2016-01-20 20:13:06.191675843 -0800\n Birth: -\n</pre>\n\n\n<b>inodeはファイルをどのように特定するのですか？</b>\n\nデータがディスク上のどこかにあることはわかっていますが、残念ながら通常は連続して保存されていないため、inodeを使用する必要があります。inodeはファイルの実際のデータブロックを指します。典型的なファイルシステムでは（すべてが同じ方法で動作するわけではありません）、各inodeには15個のポインタが含まれており、最初の12個のポインタは直接データブロックを指します。13番目のポインタは、さらに多くのブロックを指すポインタを含むブロックを指し、14番目のポインタは別のネストされたポインタブロックを指し、15番目のポインタはさらに別のポインタブロックを指します！混乱するかもしれませんが、この方法で行われる理由は、すべてのinodeでinodeの構造を同じに保ちつつ、異なるサイズのファイルを参照できるようにするためです。小さなファイルの場合、最初の12個の直接ポインタを使用して迅速に見つけることができ、大きなファイルはポインタのネストで見つけることができます。いずれにしても、inodeの構造は同じです。",
          "quizAnswer": "df -i",
          "quizQuestion": "システムに残っているinodeの数をどのように確認しますか？",
          "slug": "inodes",
          "title": "Inodes"
        },
        {
          "exercise": "シンボリックリンクとハードリンクを作成し、いくつか削除して結果を確認してみてください。",
          "id": 12,
          "lessonContent": "以前の i ノード 情報の例を使用しましょう：\n\n<pre>\npete@icebox:~$ ls -li\n140 drwxr-xr-x 2 pete pete 6 Jan 20 20:13 Desktop\n141 drwxr-xr-x 2 pete pete 6 Jan 20 20:01 Documents\n</pre>\n\nls コマンドの 3 番目のフィールドを無視してきたことに気づいたかもしれませんが、そのフィールドはリンク数です。リンク数はファイルが持つハードリンクの総数であり、現時点ではそれが何を意味するかわかりません。ですので、まずはリンクについて説明しましょう。\n\n<b>シンボリックリンク</b>\n\nWindows オペレーティングシステムでは、ショートカットと呼ばれるものがあります。ショートカットは他のファイルへのエイリアスに過ぎません。元のファイルに何かを行うと、ショートカットが壊れる可能性があります。Linux では、ショートカットの相当物はシンボリックリンク（またはソフトリンクまたはシンボリックリンク）です。シンボリックリンクを使用すると、ファイル名で他のファイルにリンクできます。Linux で見られる他のタイプのリンクはハードリンクです。これらは実際には i ノード へのリンクを持つ別のファイルです。シンボリックリンクから始めて、実践的な例を見てみましょう。\n\n<pre>\npete@icebox:~/Desktop$ echo 'myfile' > myfile\npete@icebox:~/Desktop$ echo 'myfile2' > myfile2\npete@icebox:~/Desktop$ echo 'myfile3' > myfile3\n\npete@icebox:~/Desktop$ ln -s myfile myfilelink\npete@icebox:~/Desktop$ ls -li\ntotal 12\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n</pre>\n\nmyfile にポイントする myfilelink という名前のシンボリックリンクを作成しました。シンボリックリンクは -> で示されます。新しい i ノード番号が取得されたことに注意してください。シンボリックリンクは単にファイルであり、ファイル名にポイントします。シンボリックリンクを変更すると、ファイルも変更されます。i ノード番号はファイルシステムに固有であり、1 つのファイルシステム内で同じ i ノード番号を持つことはできません。つまり、i ノード番号で異なるファイルシステムのファイルを参照することはできません。ただし、シンボリックリンクを使用すると、i ノード番号ではなくファイル名が使用されるため、異なるファイルシステム間で参照できます。\n\n<b>ハードリンク</b>\n\nハードリンクの例を見てみましょう：\n\n<pre>\npete@icebox:~/Desktop$ ln myfile2 myhardlink\npete@icebox:~/Desktop$ ls -li\ntotal 16\n  151 -rw-rw-r-- 1 pete pete 7 Jan 21 21:36 myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myfile2\n93402 -rw-rw-r-- 1 pete pete 8 Jan 21 21:36 myfile3\n93403 lrwxrwxrwx 1 pete pete 6 Jan 21 21:39 myfilelink -> myfile\n93401 -rw-rw-r-- 2 pete pete 8 Jan 21 21:36 myhardlink\n</pre>\n\nハードリンクは単に同じ i ノードへのリンクを持つ別のファイルを作成します。したがって、myfile2 または myhardlink の内容を変更した場合、両方に変更が反映されますが、myfile2 を削除した場合でも、ファイルは myhardlink を介してアクセスできます。ここで、ls コマンドのリンク数が重要になります。リンク数は i ノードが持つハードリンクの数であり、ファイルを削除するとリンク数が減少します。i ノードは、i ノードへのすべてのハードリンクが削除されたときにのみ削除されます。ファイルを作成すると、そのリンク数は 1 になります。それは、その i ノードを指す唯一のファイルであるためです。シンボリックリンクとは異なり、ハードリンクはファイルシステムに固有のため、ファイルシステムをまたがることはできません。\n\n<b>シンボリックリンクの作成</b>\n\n<pre>\n$ ln -s myfile mylink</pre>\n\nシンボリックリンクを作成するには、ln コマンドを使用し、-s オプションでシンボリックを指定し、対象ファイルとリンク名を指定します。\n\n<b>ハードリンクの作成</b>\n\n<pre>\n$ ln somefile somelink</pre>\n\nシンボリックリンクの作成と同様ですが、今回は -s を省略します。",
          "quizAnswer": "ln -s",
          "quizQuestion": "シンボリックリンクを作成するために使用されるコマンドは何ですか？",
          "slug": "symlinks",
          "title": "シンボリックリンク"
        }
      ],
      "slug": "thefilesystem",
      "title": "ファイルシステム"
    },
    {
      "description": "Linuxの起動プロセスの段階について学ぶ。",
      "id": 11,
      "image": "/images/chapters/boot.png",
      "lessons": [
        {
          "exercise": "システムを再起動して、マシンの起動時に各ステップを見つけることができるかどうか確認してください。",
          "id": 1,
          "lessonContent": "Linuxの重要なコンポーネントのいくつかにかなり理解が得られたので、システムの起動方法について学んでみましょう。マシンの電源を入れると、ロゴ画面が表示され、さまざまなメッセージが表示され、最後にログインウィンドウが表示されます。しかし、電源ボタンを押すとログインするまでに実際にはたくさんのことが起こっており、このコースでそれらについて議論します。\n\nLinuxの起動プロセスは、4つの単純な段階に分解できます：\n\n<b>1. BIOS</b>\n\nBIOS（\"Basic Input/Output System\"の略）はハードウェアを初期化し、Power-on self test（POST）ですべてのハードウェアが正常に動作することを確認します。 BIOSの主な仕事はブートローダーを読み込むことです。\n\n<b>2. Bootloader</b>\n\nブートローダーはカーネルをメモリに読み込み、一連のカーネルパラメータでカーネルを起動します。最も一般的なブートローダーの1つはGRUBで、これは汎用Linux標準です。\n\n<b>3. Kernel</b>\n\nカーネルが読み込まれると、すぐにデバイスとメモリを初期化します。カーネルの主な仕事はinitプロセスを読み込むことです。\n\n<b>4. Init</b>\n\ninitプロセスは最初に起動されるプロセスであり、システム上の重要なサービスプロセスを開始および停止します。Linuxディストリビューションには3つの主要なinitの実装があります。それらについて簡単に説明し、別のコースで詳しく説明します。\n\nこれがLinuxの起動プロセスの（非常に）簡単な説明です。次のレッスンでこれらの段階について詳細に説明します。",
          "quizAnswer": "init",
          "quizQuestion": "Linuxの起動プロセスの最後の段階は何ですか？",
          "slug": "bootprocessoverview",
          "title": "Boot Process Overview"
        },
        {
          "exercise": "BIOSメニューに入り、UEFIブートが有効になっているか確認してください。",
          "id": 2,
          "lessonContent": "<b>BIOS</b>\n\nLinuxのブートプロセスの最初のステップはBIOSであり、システムの整合性チェックを実行します。BIOSはIBM PC互換コンピュータで最も一般的なファームウェアであり、今日のコンピュータの主要なタイプです。おそらくBIOSファームウェアを使用して、ハードディスクのブート順序を変更したり、システム時刻を確認したり、マシンのMACアドレスを確認したりしています。BIOSの主な目標はシステムブートローダを見つけることです。\n\nしたがって、BIOSがハードドライブをブートすると、システムをブートする方法を特定するためにブートブロックを検索します。ディスクのパーティション方法に応じて、マスターブートレコード（MBR）またはGPTを参照します。MBRはハードドライブの最初のセクタにあり、最初の512バイトです。MBRには、ディスクの他の場所に別のプログラムをロードするコードが含まれており、このプログラムは実際にブートローダを起動します。\n\nGPTでディスクをパーティション分割した場合、ブートローダの場所が若干変わります。\n\n<b>UEFI</b>\n\nBIOSを使用せずにシステムをブートする別の方法があり、それがUEFI（「統一拡張可能ファームウェアインターフェース」の略）です。UEFIはBIOSの後継として設計され、ほとんどのハードウェアにはUEFIファームウェアが組み込まれています。Macintoshマシンは長年に渡りEFIブートを使用しており、Windowsはほとんどの機能をUEFIブートに移行しています。GPT形式はEFIと併用することを意図しています。GPTディスクをブートする場合、EFIは必要ありません。GPTディスクの最初のセクタは、「保護MBR」を予約しており、BIOSベースのマシンでブートできるようにしています。\n\nUEFIは、すべての起動情報を.efiファイルに保存します。このファイルは、ハードウェア上のEFIシステムパーティションと呼ばれる特別なパーティションに保存されます。このパーティションにはブートローダが含まれます。UEFIには、従来のBIOSファームウェアから多くの改善点があります。ただし、Linuxを使用しているため、私たちの大部分はBIOSを使用しています。したがって、これらのレッスンはすべてその前提で進めていきます。",
          "quizAnswer": "ブートローダ",
          "quizQuestion": "BIOSは何をロードしますか？",
          "slug": "bootprocessbios",
          "title": "Boot Process: BIOS"
        },
        {
          "exercise": "ブートローダーとしてGRUBを使用している場合は、'e'キーでGRUBメニューに入り、設定を確認してください。",
          "id": 3,
          "lessonContent": "ブートローダーの主な責務は次のとおりです：\n\n<ul>\n<li>オペレーティングシステムにブートすること、Linux以外のオペレーティングシステムにもブートできます</li>\n<li>使用するカーネルを選択する</li>\n<li>カーネルパラメータを指定する</li>\n</ul>\n\nLinux用の最も一般的なブートローダーはGRUBです。おそらくあなたのシステムで使用しているでしょう。LILO、efilinux、coreboot、SYSLINUXなど、他にも使用できるブートローダーがたくさんあります。ただし、私たちはGRUBをブートローダーとして使用します。\n\nしたがって、ブートローダーの主な目標はカーネルをロードすることですが、カーネルはどこで見つけるのでしょうか？ それを見つけるには、カーネルパラメータを見る必要があります。 'e'キーを使用して起動時にGRUBメニューに入ることで、パラメータを見つけることができます。 GRUBがない場合は心配しないでください、次のレッスンで詳しく説明します。\n\n<ul>\n<li>initrd - 初期RAMディスクの場所を指定します（次のレッスンで詳しく説明します）。</li>\n<li>BOOT_IMAGE - カーネルイメージの場所です</li>\n<li>root - ルートファイルシステムの場所、カーネルはこの場所内を検索してinitを見つけます。 これは、UUIDまたは/dev/sda1などのデバイス名で表されることが一般的です。</li>\n<li>ro - このパラメータはかなり標準的で、ファイルシステムを読み取り専用モードでマウントします。</li>\n<li>quiet - これを追加すると、ブート中にバックグラウンドで表示されているメッセージが表示されなくなります。</li>\n<li>splash - これによりスプラッシュ画面が表示されます。</li>\n</ul>",
          "quizAnswer": "quiet",
          "quizQuestion": "ブートアップメッセージを表示しないようにするカーネルパラメータは何ですか？",
          "slug": "bootprocessbootloader",
          "title": "Boot Process: Bootloader"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 4,
          "lessonContent": "ブートローダーが必要なパラメータを渡したので、それがどのように開始されるかを見てみましょう。\n\n<b>Initrd vs Initramfs</b>\n\nカーネルの起動について話すとき、少し鶏と卵の問題があります。カーネルはシステムのハードウェアを管理しますが、起動中にすべてのドライバがカーネルで利用可能ではありません。そのため、カーネルが残りのハードウェアにアクセスするために必要な基本モジュールだけを含む一時的なルートファイルシステムに依存しています。古いバージョンのLinuxでは、この仕事はinitrd（初期RAMディスク）に与えられました。カーネルはinitrdをマウントし、必要な起動ドライバを取得し、必要なすべてのものを読み込んだ後、実際のルートファイルシステムでinitrdを置き換えました。現在では、initramfsというものがあります。これは、実際のルートファイルシステムのために必要なすべてのドライバをロードするためにカーネル自体に組み込まれた一時的なルートファイルシステムです。そのため、initrdファイルを探す必要はありません。\n\n<b>ルートファイルシステムのマウント</b>\n\n今、カーネルにはルートデバイスを作成し、ルートパーティションをマウントするために必要なすべてのモジュールが揃いました。しかし、さらに進む前に、ルートパーティションは最初に読み取り専用モードでマウントされているため、fsckが安全に実行され、システムの整合性がチェックされます。その後、ルートファイルシステムを読み書き可能モードで再マウントします。その後、カーネルはinitプログラムを見つけて実行します。",
          "quizAnswer": "initramfs",
          "quizQuestion": "現代のシステムで一時的なルートファイルシステムをロードするために使用されるものは何ですか？",
          "slug": "bootprocesskernel",
          "title": "Boot Process: Kernel"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 5,
          "lessonContent": "以前のレッスンでinitについて話し合い、それが最初に起動されるプロセスであり、システム上の他のすべての重要なサービスを開始することを知っています。しかし、どのようにして？\n\nLinuxには実際に3つの主要なinitの実装があります：\n\n<b>System V init (sysv)</b>\n\nこれは伝統的なinitシステムです。起動スクリプトに基づいてプロセスを順次開始および停止します。マシンの状態はランレベルで示され、各ランレベルは異なる方法でマシンを起動または停止します。\n\n<b>Upstart</b>\n\nこれは古いUbuntuインストールで見つけることができるinitです。Upstartはジョブとイベントの考え方を使用し、イベントに応じて特定のアクションを実行するジョブを開始することで機能します。\n\n<b>Systemd</b>\n\nこれはinitの新しい標準であり、ゴール指向です。基本的に達成したいゴールがあり、systemdはゴールを完了するためにゴールの依存関係を満たそうとします。\n\n私たちはInitシステムに関する完全なコースを持っており、これらのシステムそれぞれに詳細に入り込みます。",
          "quizAnswer": "systemd",
          "quizQuestion": "initの最新の標準は何ですか？",
          "slug": "bootprocessinit",
          "title": "Boot Process: Init"
        }
      ],
      "slug": "bootthesystem",
      "title": "システムの起動"
    },
    {
      "description": "Linuxシステムの最も重要な部分であり、その動作方法や構成方法について学びます。",
      "id": 12,
      "image": "/images/chapters/kernel.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "これまで学んできたように、カーネルはオペレーティングシステムの中核です。オペレーティングシステムの他の部分については話し合ってきましたが、それらがどのように連携して動作するかはまだ示していません。Linuxオペレーティングシステムは、3つの異なる抽象化レベルに分類できます。\n\n最も基本的なレベルはハードウェアであり、これにはCPU、メモリ、ハードディスク、ネットワーキングポートなどが含まれます。実際にマシンが何を行っているかを計算する物理層です。\n\n次のレベルはカーネルであり、プロセスおよびメモリ管理、デバイス通信、システムコール、ファイルシステムの設定などを担当します。カーネルの役割は、ハードウェアと通信して、プロセスが行うべき動作を実行するようにすることです。\n\nそして、おなじみのレベルであるユーザースペースは、シェル、実行するプログラム、グラフィックスなどが含まれます。\n\nこのコースでは、カーネルに焦点を当て、その詳細を学んでいきます。",
          "quizAnswer": "カーネル",
          "quizQuestion": "オペレーティングシステムのどのレベルがデバイスを管理しますか？",
          "slug": "kerneloverview",
          "title": "カーネルの概要"
        },
        {
          "exercise": "このレッスンには練習問題はありません。",
          "id": 2,
          "lessonContent": "次のいくつかのレッスンはかなり理論的ですので、実用的な情報をお探しの場合は先に進んで後で戻ってきてください。\n\nユーザースペースとカーネル用の異なる抽象化レイヤーがあるのはなぜでしょうか？なぜ両方の権限を1つのレイヤーに組み合わせることができないのでしょうか？これら2つのレイヤーが別々に存在する非常に重要な理由があります。それぞれが異なるモードで動作しており、カーネルはカーネルモードで動作し、ユーザースペースはユーザーモードで動作します。\n\nカーネルモードでは、カーネルはハードウェアへの完全なアクセス権を持ち、すべてを制御します。ユーザースペースモードでは、アクセスできる安全なメモリとCPUの量が非常に少ないです。基本的に、ディスクからデータを読み取ったり、ディスクにデータを書き込んだり、ネットワークを制御したりする場合、すべてカーネルモードで行われます。なぜこれが必要なのでしょうか？もしスパイウェアに感染したマシンがあったら、そのスパイウェアがシステムのハードウェアに直接アクセスできるとは望ましくありません。すべてのデータやウェブカメラなどにアクセスできてしまいます。これは良くありません。\n\nこれらの異なるモードは特権レベル（あなたが得る特権のレベルにふさわしく命名されています）と呼ばれ、保護リングとしてしばしば説明されます。このイメージを描きやすくするために、例えばブリトニー・スピアーズが地元のクラブでライブをやっていることがわかりました。彼女は自分のファン、その後、個人のボディーガード、そしてクラブの外の用心棒によって保護されています。彼女のサインをもらいたい（なぜなら、なぜなら？）と思っても、彼女に近づくことはできません。リングは同じように機能し、最も内側のリングが最高の特権レベルに対応します。x86コンピューターアーキテクチャには主に2つのレベルまたはモードがあります。リング＃3はユーザーモードアプリケーションが実行される特権であり、リング＃0はカーネルが実行される特権です。リング＃0は任意のシステム命令を実行でき、完全な信頼を与えられます。では、これらの特権レベルがどのように機能するかを知った今、どのようにしてハードウェアに書き込むことができるのでしょうか？私たちは常にカーネルとは異なるモードにいるのではないでしょうか？\n\nその答えはシステムコールです。システムコールを使用すると、カーネルモードで特権のある命令を実行し、ユーザーモードに戻ることができます。",
          "quizAnswer": "0",
          "quizQuestion": "最も特権のあるリング番号は何ですか？",
          "slug": "kernelprivilegelevels",
          "title": "特権レベル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "前のレッスンでブリトニーを覚えていますか？ 彼女に会い、一緒に飲みに行きたいとしましょう。人混みの外で立っている状態から、彼女の最も内側のサークルに入るにはどうすればよいでしょうか？ それにはシステムコールを使用します。 システムコールは、あなたをブリトニーの直接つながる秘密の裏口に導くVIPパスのようなものです。\n\nシステムコール（syscall）は、ユーザースペースのプロセスに、カーネルに何かを依頼する方法を提供します。 カーネルは、システムコールAPIを介して特定のサービスを利用可能にします。 これらのサービスにより、ファイルへの読み書き、メモリ使用量の変更、ネットワークの変更などが可能になります。 サービスの数は固定されているため、システムコールを勝手に追加することはできません。 すでにシステムには存在するシステムコールの表があり、各システムコールには固有のIDがあります。\n\nシステムコールの詳細については触れませんが、それには少しのC言語の知識が必要です。 ただし、基本的な考え方は、lsのようなプログラムを呼び出すとき、このプログラム内のコードにはシステムコールラッパー（実際のシステムコールではない）が含まれています。 このラッパー内でシステムコールが呼び出され、トラップが実行され、そのトラップがシステムコールハンドラによって捕捉され、システムコールテーブル内のシステムコールを参照します。 たとえば、stat()システムコールを呼び出そうとしているとします。これはシステムコールIDで識別され、stat()システムコールの目的はファイルの状態をクエリすることです。 そして、lsプログラムを特権モードで実行していなかったことを覚えておいてください。 したがって、システムコールを行おうとしていることがわかると、ユーザーモードからカーネルモードに切り替えられ、そこで多くの処理が行われますが、最も重要なのは、システムコール番号を検索し、そのIDに基づいてテーブル内で見つけ、実行したい関数を実行します。 完了したら、ユーザーモードに戻り、プロセスは成功したかエラーが発生したかに応じた戻りステータスを受け取ります。 システムコールの内部動作は非常に詳細になりますので、さらに学習したい場合はオンライン情報を参照することをお勧めします。\n\nプロセスが行うシステムコールをstraceコマンドで表示することができます。 straceコマンドは、プログラムの実行方法をデバッグするのに役立ちます。\n\n<pre>$ strace ls</pre>",
          "quizAnswer": "システムコール",
          "quizQuestion": "ユーザーモードからカーネルモードに切り替えるために使用されるものは何ですか？",
          "slug": "systemcalls",
          "title": "システムコール"
        },
        {
          "exercise": "<ol>\n<li>システムのカーネルバージョンを調べる。</li>\n<li>利用可能な異なるカーネルバージョンを調査する。</li>\n</ol>",
          "id": 4,
          "lessonContent": "さて、退屈な話は終わりましたので、実際にカーネルのインストールと修正について話しましょう。システムに複数のカーネルをインストールできます。ブートプロセスのレッスンを覚えていますか？GRUBメニューでブートするカーネルを選択できます。\n\nシステムにどのカーネルバージョンがあるかを確認するには、次のコマンドを使用します：\n\n<pre>$ uname -r\n3.19.0-43-generic</pre>\n\nunameコマンドはシステム情報を出力し、-rコマンドはカーネルリリースバージョンをすべて出力します。\n\nLinuxカーネルをインストールする方法はさまざまです。ソースパッケージをダウンロードしてソースからコンパイルするか、パッケージ管理ツールを使用してインストールすることができます。\n\n<pre>$ sudo apt install linux-generic-lts-vivid</pre>\n\nそして、インストールしたカーネルに再起動するだけです。簡単ですね？まあ、他のLinuxパッケージ（例：linux-headers、linux-image-genericなど）もインストールする必要があります。バージョン番号を指定することもできますので、上記のコマンドは次のようになります。<b>sudo apt install 3.19.0-43-generic</b>\n\nまた、更新されたカーネルバージョンだけが必要な場合は、dist-upgradeを使用します。これはシステム上のすべてのパッケージをアップグレードします：\n\n<pre>$ sudo apt dist-upgrade</pre>\n\nさまざまなカーネルバージョンがあります。一部はLTS（長期サポート）として使用され、一部は最新で最高ですが、カーネルバージョン間の互換性は非常に異なる場合があるため、さまざまなカーネルを試してみたいかもしれません。",
          "quizAnswer": "uname -r",
          "quizQuestion": "システムのカーネルバージョンを確認する方法は？",
          "slug": "kernelinstallation",
          "title": "カーネルのインストール"
        },
        {
          "exercise": "bootディレクトリに移動して、そこにどのファイルがあるかを確認してください。",
          "id": 5,
          "lessonContent": "新しいカーネルをインストールすると何が起こるのでしょうか？ 実際には、いくつかのファイルがシステムに追加されます。 これらのファイルは通常、/bootディレクトリに追加されます。\n\n異なるカーネルバージョン用に複数のファイルが表示されます:\n\n<ul>\n<li>vmlinuz - これが実際のLinuxカーネルです</li>\n<li>initrd - 前に説明したように、initrdはカーネルをロードする前に一時的なファイルシステムとして使用されます</li>\n<li>System.map - シンボリックルックアップテーブル</li>\n<li>config - カーネルの構成設定、独自のカーネルをコンパイルしている場合、どのモジュールをロードできるかを設定できます</li>\n</ul>\n\n/bootディレクトリの容量が不足する場合、古いバージョンのこれらのファイルを削除するか、パッケージマネージャを使用することができますが、このディレクトリでメンテナンスを行う際は注意して、使用中のカーネルを誤って削除しないようにしてください。",
          "quizAnswer": "vmlinuz",
          "quizQuestion": "/bootディレクトリにあるカーネルイメージは何と呼ばれますか？",
          "slug": "kernellocation",
          "title": "カーネルの場所"
        },
        {
          "exercise": "modprobeを使用してBluetoothモジュールをアンロードし、何が起こるかを確認してください。これを修正する方法は？",
          "id": 6,
          "lessonContent": "私たちが素敵な車に乗っているとしましょう。たくさんの時間とお金を投資しました。スポイラーやフック、バイクラックなど、さまざまなものを追加しました。これらのコンポーネントは実際には車のコア機能を変更しませんし、簡単に取り外したり追加したりできます。カーネルは、カーネルモジュールを使用して同じコンセプトを使用します。\n\nカーネル自体はモノリシックなソフトウェアです。新しいタイプのキーボードに対応するために追加したい場合、そのコードを直接カーネルコードに書き込むわけではありません。車にバイクラックを溶接しないように（まあ、一部の人はそうするかもしれませんが）。カーネルモジュールは、必要に応じてカーネルにロードおよびアンロードできるコードの断片です。これにより、カーネルのコアコードに追加せずにカーネルの機能を拡張できます。ほとんどの場合、システムを再起動せずにモジュールを追加および削除できます。\n\n<b>現在ロードされているモジュールのリストを表示</b>\n\n<pre>$ lsmod</pre>\n\n<b>モジュールをロード</b>\n\n<pre>$ sudo modprobe bluetooth</pre>\n\nModprobeは、<b>/lib/modules/(カーネルバージョン)/kernel/drivers</b>からモジュールを試みます。カーネルモジュールには依存関係がある場合があり、modprobeは依存モジュールをロードしていない場合にそれらをロードします。\n\n<b>モジュールを削除</b>\n\n<pre>$ sudo modprobe -r bluetooth</pre>\n\n<b>起動時にロード</b>\n\n一時的にmodprobeでロードするのではなく、システム起動時にモジュールをロードすることもできます。単に<b>/etc/modprobe.d</b>ディレクトリを変更し、次のような構成ファイルを追加します。\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\noptions peanut_butter type=almond\n</pre>\n\n少々奇抜な例ですが、peanut_butterというモジュールがあり、type=almondのカーネルパラメータを追加したい場合は、この構成ファイルを使用して起動時にロードできます。また、カーネルモジュールには独自のカーネルパラメータがあるため、詳細を確認するためにモジュールについて読む必要があります。\n\n<b>起動時にロードしない</b>\n\nモジュールが起動時にロードされないようにするには、次のような構成ファイルを追加します。\n\n<pre>pete@icebox:~$ /etc/modprobe.d/peanutbutter.conf\n\nblacklist peanut_butter\n</pre>",
          "quizAnswer": "modprobe -r",
          "quizQuestion": "モジュールをアンロードするために使用されるコマンドは何ですか？",
          "slug": "kernelmodules",
          "title": "カーネルモジュール"
        }
      ],
      "slug": "kernel",
      "title": "カーネル"
    },
    {
      "description": "異なるinitシステム、SysV、Upstart、およびsystemdについて学びます。",
      "id": 13,
      "image": "/images/chapters/init.png",
      "lessons": [
        {
          "exercise": "Sys V を実行している場合、マシンのデフォルトのランレベルを他のものに変更してみて、何が起こるかを確認してください。",
          "id": 1,
          "lessonContent": "init の主な目的は、システム上の重要なプロセスを開始および停止することです。Linux には、System V、Upstart、systemd の 3 つの主要な init 実装があります。このレッスンでは、最も伝統的な init のバージョンである System V init または Sys V（発音は 'System Five'）について説明します。\n\nSys V init 実装を使用しているかどうかを確認するには、/etc/inittab ファイルがある場合、おそらく Sys V を実行しています。\n\nSys V はプロセスを順次開始および停止するため、例えば、foo-b が動作する前に foo-a というサービスを起動したい場合、foo-a が既に実行されていることを確認する必要があります。Sys V はスクリプトを使用してこれを行います。これらのスクリプトはサービスの開始および停止を行います。独自のスクリプトを記述するか、ほとんどの場合、オペレーティングシステムに組み込まれている既存のスクリプトを使用して、重要なサービスをロードします。\n\nこの init 実装を使用する利点は、依存関係を比較的簡単に解決できることです。foo-a が foo-b よりも前に来ることを知っているためですが、一度に通常は 1 つのものが開始または停止しているため、パフォーマンスはあまり良くありません。\n\nSys V を使用すると、マシンの状態は 0 から 6 までのランレベルで定義されます。これらの異なるモードはディストリビューションによって異なりますが、ほとんどの場合、次のようになります：\n\n<ul>\n<li>0: シャットダウン</li>\n<li>1: シングルユーザーモード</li>\n<li>2: ネットワークなしのマルチユーザーモード</li>\n<li>3: ネットワーク付きのマルチユーザーモード</li>\n<li>4: 未使用</li>\n<li>5: ネットワークと GUI 付きのマルチユーザーモード</li>\n<li>6: 再起動</li>\n</ul>\n\nシステムが起動すると、どのランレベルにいるかを確認し、そのランレベル構成内にあるスクリプトを実行します。スクリプトは <b>/etc/rc.d/rc[ランレベル番号].d/</b> または <b>/etc/init.d</b> に配置されています。S（開始）または K（停止）で始まるスクリプトは、それぞれ起動時とシャットダウン時に実行されます。これらの文字の横にある数字は、実行される順序を示しています。\n\n例：\n\n<pre>\npete@icebox:/etc/rc.d/rc0.d$ ls\nK10updates  K80openvpn        \n</pre>\n\nランレベル 0 またはシャットダウンモードに切り替えると、アップデートサービスを停止するスクリプトが実行され、次に openvpn が実行されます。マシンが起動するランレベルを確認するには、/etc/inittab ファイルでデフォルトのランレベルを確認できます。このファイルでデフォルトのランレベルを変更することもできます。\n\nSys V が徐々に置き換えられつつあることに注意してください。今日はもちろん、数年後でさえもかもしれません。ただし、他の init 実装でランレベルが表示されることがあるかもしれません。これは主に、System V init スクリプトを使用してのみ開始または停止されるサービスをサポートするためです。",
          "quizAnswer": "0",
          "quizQuestion": "シャットダウンに通常使用されるランレベルは何ですか？",
          "slug": "sysvoverview",
          "title": "System V Overview"
        },
        {
          "exercise": "いくつかのサービスを管理し、その状態を変更してみて、何が観察されますか？",
          "id": 2,
          "lessonContent": "Sys Vサービスを管理するために使用できる多くのコマンドラインツールがあります。\n\n<b>サービスの一覧</b>\n\n<pre>$ service --status-all</pre>\n\n<b>サービスの開始</b>\n\n<pre>$ sudo service networking start</pre>\n\n<b>サービスの停止</b>\n\n<pre>$ sudo service networking stop</pre>\n\n<b>サービスの再起動</b>\n\n<pre>$ sudo service networking restart</pre>\n\nこれらのコマンドはSys V initシステムに固有のものではありません。これらのコマンドはUpstartサービスを管理するためにも使用できます。Linuxは従来のSys V initスクリプトから移行しようとしているため、その移行を支援するための仕組みがまだ残っています。",
          "quizAnswer": "sudo service peanut stop",
          "quizQuestion": "Sys Vでpeanutという名前のサービスを停止するコマンドは何ですか？",
          "slug": "sysvservices",
          "title": "System V Service"
        },
        {
          "exercise": "/etc/init内のジョブ構成を理解できるかどうかを確認してください。",
          "id": 3,
          "lessonContent": "UpstartはCanonicalによって開発されました。そのため、Ubuntuではしばらくの間initの実装として使用されていましたが、現代のUbuntuインストールではsystemdが使用されています。UpstartはSys Vの問題点（厳格な起動プロセス、タスクのブロックなど）を改善するために作成されました。Upstartのイベントとジョブ駆動モデルにより、イベントが発生するとそれに応答できます。\n\nUpstartを使用しているかどうかを確認するには、/usr/share/upstartディレクトリがあるかどうかを確認します。これはかなりの指標です。\n\nジョブはUpstartが実行するアクションであり、イベントは他のプロセスから受信したメッセージで、ジョブをトリガーします。ジョブとその構成のリストを表示するには:\n\n<pre>\npete@icebox:~$ ls /etc/init\nacpid.conf                   mountnfs.sh.conf\nalsa-restore.conf            mtab.sh.conf\nalsa-state.conf              networking.conf\nalsa-store.conf              network-interface.conf\nanacron.conf                 network-interface-container.conf\n</pre>\n\nこれらのジョブ構成には、ジョブを開始する方法やいつジョブを開始するかに関する情報が含まれています。\n\nたとえば、networking.confファイルでは、次のように記述されているかもしれません:\n<pre>\nstart on runlevel [235]\nstop on runlevel [0]\n</pre>\n\nこれは、ランレベル2、3、または5でネットワーキングの設定を開始し、ランレベル0でネットワーキングを停止することを意味します。構成ファイルを書く方法はさまざまあり、利用可能な異なるジョブ構成を見るとわかります。\n\nUpstartの動作方法は次のとおりです:\n\n<ol>\n<li>最初に、/etc/initからジョブ構成を読み込みます</li>\n<li>起動イベントが発生すると、そのイベントによってトリガーされたジョブが実行されます。</li>\n<li>これらのジョブは新しいイベントを作成し、それらのイベントがさらにジョブをトリガーします</li>\n<li>Upstartは、必要なすべてのジョブを完了するまでこれを続けます</li>\n</ol>",
          "quizAnswer": "upstart",
          "quizQuestion": "Ubuntuで使用されているinitの実装は何ですか？",
          "slug": "upstartoverview",
          "title": "Upstartの概要"
        },
        {
          "exercise": "Upstartジョブのリストを観察し、今日学んだコマンドの1つでジョブの状態を変更してください。その後、何に気づきますか？",
          "id": 4,
          "lessonContent": "Upstartは多くのイベントとジョブをトリガーできますが、イベントやジョブの起源を簡単に確認する方法はありません。そのため、/etc/init内のジョブ構成を調べる必要があります。ほとんどの場合、Upstartジョブ構成ファイルを見る必要はありませんが、特定のジョブをより簡単に制御したい場合があります。Upstartシステムで使用できる便利なコマンドがたくさんあります。\n\n<b>ジョブを表示</b>\n\n<pre>initctl list\n\nshutdown stop/waiting\nconsole stop/waiting\n...\n</pre>\n\n異なるステータスが適用されたUpstartジョブのリストが表示されます。各行で、ジョブ名が最初の値であり、2番目のフィールド（/の前）が実際にジョブのゴールであり、3番目の値（/の後）が現在のステータスです。したがって、shutdownジョブは最終的に停止することを望んでいますが、現在はwaiting状態です。ジョブのステータスとゴールは、ジョブを開始または停止すると変わります。\n\n<b>特定のジョブを表示</b>\n\n<pre>initctl status networking\nnetworking start/running\n</pre>\n\nUpstartジョブ構成を書く方法の詳細には触れませんが、ジョブがこれらの構成で停止、開始、再起動されることはすでにわかっています。これらのジョブはイベントも発行するため、他のジョブを開始できます。Upstart操作の手順を手動で説明しますが、興味がある場合は、.confファイルをより詳しく調査してください。\n\n<b>ジョブを手動で開始</b>\n\n<pre>$ sudo initctl start networking</pre>\n\n<b>ジョブを手動で停止</b>\n\n<pre>$ sudo initctl stop networking</pre>\n\n<b>ジョブを手動で再起動</b>\n\n<pre>$ sudo initctl restart networking</pre>\n\n<b>イベントを手動で発行</b>\n\n<pre>$ sudo initctl emit some_event</pre>",
          "quizAnswer": "sudo initctl restart peanuts",
          "quizQuestion": "Upstartジョブのpeanutsという名前のジョブを手動で再起動する方法は？",
          "slug": "upstartjobs",
          "title": "Upstart Jobs"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 5,
          "lessonContent": "Systemdは、イニシャライズの新たな標準として徐々に台頭しています。/usr/lib/systemd ディレクトリがある場合、おそらくsystemdを使用しています。\n\nSystemdは、システムを起動して実行するためのゴールを使用します。基本的に、達成したいターゲットがあり、このターゲットには達成する必要がある依存関係もあります。Systemdは非常に柔軟で堅牢であり、プロセスを起動するための厳密なシーケンスに従いません。典型的なsystemdの起動時に何が起こるかは次のとおりです：\n\n<ol>\n<li>最初に、systemdは通常 /etc/systemd/system または /usr/lib/systemd/system にある構成ファイルを読み込みます</li>\n<li>次に、通常は default.target である起動ゴールを決定します</li>\n<li>Systemdは起動ターゲットの依存関係を把握し、それらをアクティブ化します</l>\n</ol>\n\nSys V ランレベルと同様に、systemdは異なるターゲットにブートします：\n\n<ul>\n<li>poweroff.target - システムをシャットダウン</li>\n<li>rescue.target - シングルユーザーモード</li>\n<li>multi-user.target - ネットワークを備えたマルチユーザー</li>\n<li>graphical.target - ネットワークと GUI を備えたマルチユーザー</li>\n<li>reboot.target - 再起動</li>\n</ul>\n\ndefault.target のデフォルトブートゴールは通常 graphical.target を指します。\n\nSystemdが操作する主要なオブジェクトはユニットとして知られています。Systemdは単にサービスを停止・開始するだけでなく、ファイルシステムをマウントしたり、ネットワークソケットを監視したりすることができます。その堅牢性のため、操作するユニットの種類が異なります。最も一般的なユニットは次のとおりです：\n\n<ul>\n<li>Service units - 開始および停止しているサービスです。これらのユニットファイルは .service で終わります</li>\n<li>Mount units - ファイルシステムをマウントします。これらのユニットファイルは .mount で終わります</li>\n<li>Target units - 他のユニットをグループ化します。ファイルは .target で終わります</li>\n</ul>\n\n例えば、default.target にブートしたとします。このターゲットは、networking.service ユニット、crond.service ユニットなどをグループ化します。したがって、1つのユニットをアクティブ化すると、そのユニット以下のすべてがアクティブ化されます。",
          "quizAnswer": "target",
          "quizQuestion": "他のユニットをグループ化するために使用されるユニットは何ですか？",
          "slug": "systemdoverview",
          "title": "Systemd Overview"
        },
        {
          "exercise": "ユニットの状態を表示し、いくつかのサービスを開始および停止してください。何が観察されますか？",
          "id": 6,
          "lessonContent": "systemd ユニットファイルの詳細については触れません。ただし、ユニットファイルの概要とユニットの手動制御について簡単に説明します。\n\nこちらは基本的なサービスユニットファイルです: foobar.service\n\n<pre>\n[Unit]\nDescription=My Foobar\nBefore=bar.target\n\n[Service]\nExecStart=/usr/bin/foobar\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n\nこれは単純なサービスターゲットで、ファイルの先頭に [Unit] のセクションがあり、ここではユニットファイルに説明を付けたり、ユニットをアクティブにする順序を制御したりできます。次の部分は [Service] セクションで、ここではサービスの開始、停止、再読み込みができます。[Install] セクションは依存関係に使用されます。systemd ファイルの書き方についてはこれだけの紹介ですので、もっと知りたい場合は詳細を読んでください。\n\nさて、systemd ユニットで使用できるいくつかのコマンドについて説明します:\n\n<b>ユニットの一覧表示</b>\n\n<pre>$ systemctl list-units</pre>\n\n<b>ユニットの状態を表示</b>\n\n<pre>$ systemctl status networking.service</pre>\n\n<b>サービスの開始</b>\n\n<pre>$ sudo systemctl start networking.service</pre>\n\n<b>サービスの停止</b>\n\n<pre>$ sudo systemctl stop networking.service</pre>\n\n<b>サービスの再起動</b>\n\n<pre>$ sudo systemctl restart networking.service</pre>\n\n<b>ユニットの有効化</b>\n\n<pre>$ sudo systemctl enable networking.service</pre>\n\n<b>ユニットの無効化</b>\n\n<pre>$ sudo systemctl disable networking.service</pre>\n\nsystemd の深いところについてはまだ見ていないので、さらに学びたい場合は詳細を読んでください。",
          "quizAnswer": "sudo systemctl start peanut.service",
          "quizQuestion": "peanut.service というサービスを開始するコマンドは何ですか？",
          "slug": "systemdgoals",
          "title": "Systemd Goals"
        },
        {
          "exercise": "システムをシャットダウンするときにinitで何が起こっていると思いますか？",
          "id": 7,
          "lessonContent": "コマンドラインを通じてシステムの状態を制御する方法について実際に議論していないことは信じがたいですが、initについて話すとき、システムを起動させるモードだけでなく、システムを停止させるモードについても話します。\n\nシステムをシャットダウンするには:\n\n<pre>$ sudo shutdown -h now</pre>\n\nこれによりシステムが停止されます（電源が切れます）、また、この操作を行う時間を指定する必要があります。指定した時間（分単位）後にシステムをシャットダウンすることもできます。\n\n<pre>$ sudo shutdown -h +2</pre>\n\nこれによりシステムが2分後にシャットダウンされます。シャットダウンコマンドを使用して再起動することもできます:\n\n<pre>$ sudo shutdown -r now</pre>\n\nまたは、rebootコマンドを使用することもできます:\n\n<pre>$ sudo reboot</pre>",
          "quizAnswer": "sudo shutdown -h +4",
          "quizQuestion": "システムを4分後に電源オフにするコマンドは何ですか？",
          "slug": "powerstates",
          "title": "電源状態"
        }
      ],
      "slug": "init",
      "title": "Init"
    },
    {
      "description": "top、ロード平均、iostatなどを使用したリソースモニタリングの学習",
      "id": 14,
      "image": "/images/chapters/processUtilization.png",
      "lessons": [
        {
          "exercise": "topコマンドを使って、どのプロセスが最も多くのリソースを使用しているかを確認してみてください。",
          "id": 1,
          "lessonContent": "このコースでは、システム上のリソース利用状況を読み取り、分析する方法について説明します。このレッスンでは、プロセスの動作をトラッキングする必要があるときに使用する優れたツールを紹介します。\n\n<b>top</b>\n\n以前にtopについて説明しましたが、実際に表示されている内容について詳しく説明します。topは、プロセスによるシステムの利用状況をリアルタイムで表示するために使用するツールです。\n\n<pre>\ntop - 18:06:26 up 6 days,  4:07,  2 users,  load average: 0.92, 0.62, 0.59\nTasks: 389 total,   1 running, 387 sleeping,   0 stopped,   1 zombie\n%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem:  32870888 total, 27467976 used,  5402912 free,   518808 buffers\nKiB Swap: 33480700 total,    39892 used, 33440808 free. 19454152 cached Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                             \n 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome                             \n 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome \n</pre>\n\nこの出力の意味について説明します。これを暗記する必要はありませんが、参照が必要なときに戻ってきてください。\n\n<b>1行目: uptimeコマンドを実行した場合に表示される情報と同じです</b>\n\nフィールドは左から右に次のとおりです:\n<ol>\n<li>現在時刻</li>\n<li>システムの稼働時間</li>\n<li>現在ログインしているユーザー数</li>\n<li>システムの平均負荷（後述）</li>\n</ol>\n\n<b>2行目: 実行中、スリープ中、停止中、ゾンビ状態のタスク</b>\n\n<b>3行目: CPU情報</b>\n\n<ol>\n<li>us: ユーザーCPU時間 - nicedされていないユーザープロセスのCPU時間の割合</li>\n<li>sy: システムCPU時間 - カーネルとカーネルプロセスの実行に費やされるCPU時間の割合</li>\n<li>ni: nice CPU時間 - nicedプロセスの実行に費やされるCPU時間の割合</li>\n<li>id: CPUアイドル時間 - アイドル状態で費やされるCPU時間の割合</li>\n<li>wa: I/O待機 - I/Oを待機しているCPU時間の割合。この値が低い場合、問題はおそらくディスクまたはネットワークI/Oではありません</li> \n<li>hi: ハードウェア割り込み - ハードウェア割り込みに費やされるCPU時間の割合</li>\n<li>si: ソフトウェア割り込み - ソフトウェア割り込みに費やされるCPU時間の割合</li>\n<li>st: スティール時間 - 仮想マシンを実行している場合、他のタスクに割り当てられたCPU時間の割合</li>\n</ol>\n\n<b>4行目と5行目: メモリ使用量とスワップ使用量</b>\n\n<b>現在使用中のプロセスリスト</b>\n\n<ol>\n<li>PID: プロセスのID</li>\n<li>USER: プロセスの所有者</li>\n<li>PR: プロセスの優先度</li>\n<li>NI: nice値</li>\n<li>VIRT: プロセスが使用する仮想メモリ</li>\n<li>RES: プロセスが使用する物理メモリ</li>\n<li>SHR: プロセスの共有メモリ</li>\n<li>S: プロセスの状態を示す: S=スリープ、R=実行中、Z=ゾンビ、D=割り込み不可、T=停止</li>\n<li>%CPU - このプロセスが使用するCPUの割合</li>\n<li>%MEM - このプロセスが使用するRAMの割合</li>\n<li>TIME+ - このプロセスの活動時間の合計</li>\n<li>COMMAND - プロセスの名前</li>\n</ol>\n\n特定のプロセスを追跡したい場合は、プロセスIDを指定することもできます:\n\n<pre>$ top -p 1</pre>",
          "quizAnswer": "uptime",
          "quizQuestion": "topの最初の行と同じ出力を表示するコマンドは何ですか？",
          "slug": "trackingprocessestop",
          "title": "プロセスのトラッキング: top"
        },
        {
          "exercise": "lsof と fuser の man ページを読んでください。これらのツールをより柔軟に使用できる多くの情報が提供されています。",
          "id": 2,
          "lessonContent": "USB ドライブを接続していくつかのファイルで作業を開始したとします。作業が終わったら USB デバイスをアンマウントしようとすると、「デバイスまたはリソースがビジー状態です」というエラーが表示されます。USB ドライブ内でまだ使用中のファイルを特定するにはどうすればよいでしょうか？ 実際には、このために使用できるツールが 2 つあります：\n\n<b>lsof</b>\n\nファイルはテキストファイルや画像などだけでなく、システム上のすべてのもの（ディスク、パイプ、ネットワークソケット、デバイスなど）です。プロセスが使用しているものを確認するには、lsof コマンド（\"list open files\" の略）を使用します。これにより、すべてのオープンファイルとそれに関連するプロセスのリストが表示されます。\n\n<pre>\npete@icebox:~$ lsof .\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nlxsession 1491 pete  cwd    DIR    8,6     4096  131 .\nupdate-no 1796 pete  cwd    DIR    8,6     4096  131 .\nnm-applet 1804 pete  cwd    DIR    8,6     4096  131 .\nindicator 1809 pete  cwd    DIR    8,6     4096  131 .\nxterm     2205 pete  cwd    DIR    8,6     4096  131 .\nbash      2207 pete  cwd    DIR    8,6     4096  131 .\nlsof      5914 pete  cwd    DIR    8,6     4096  131 .\nlsof      5915 pete  cwd    DIR    8,6     4096  131 .\n</pre>\n\nこれで、デバイス/ファイルを現在保持しているプロセスがわかります。USB の例では、これらのプロセスを終了してから、この厄介なドライブをアンマウントできます。\n\n<b>fuser</b>\n\nプロセスを追跡する別の方法は、fuser コマンド（\"file user\" の略）を使用することです。これにより、ファイルを使用しているプロセスまたはファイルユーザーに関する情報が表示されます。\n\n<pre>\npete@icebox:~$ fuser -v .\n                     USER        PID ACCESS COMMAND\n/home/pete:         pete  1491 ..c.. lxsession\n                     pete  1796 ..c.. update-notifier\n                     pete  1804 ..c.. nm-applet\n                     pete  1809 ..c.. indicator-power\n                     pete  2205 ..c.. xterm\n                     pete  2207 ..c.. bash\n</pre>\n\n現在 /home/pete ディレクトリを使用しているプロセスがわかります。lsof と fuser ツールは非常に似ており、これらのツールに慣れて、次回ファイルやプロセスを追跡する際に使用してみてください。",
          "quizAnswer": "lsof",
          "quizQuestion": "オープンされているファイルとそれに関連するプロセス情報をリストするために使用されるコマンドは何ですか？",
          "slug": "trackingprocesseslsoffuser",
          "title": "lsof と fuser"
        },
        {
          "exercise": "<b>ps m</b>コマンドを実行して、実行中のプロセスのうちマルチスレッドであるものを確認してください。",
          "id": 3,
          "lessonContent": "あなたはシングルスレッドおよびマルチスレッドプロセスという用語を聞いたことがあるかもしれません。スレッドはプロセスと非常に似ており、同じプログラムを実行するために使用され、しばしば軽量プロセスと呼ばれます。プロセスに1つのスレッドがあるとき、それはシングルスレッドであり、プロセスに複数のスレッドがあるとき、それはマルチスレッドです。ただし、すべてのプロセスには少なくとも1つのスレッドがあります。\n\nプロセスは独自の隔離されたシステムリソースで動作しますが、スレッドはこれらのリソースを容易に共有できるため、お互いに通信しやすく、ときにはマルチスレッドアプリケーションを持つ方がマルチプロセスアプリケーションよりも効率的です。\n\n基本的に、LibreOffice WriterとChromeを開いたとします。それぞれが独自のプロセスです。そして、Writerに入ってテキストを編集し始めると、テキストを編集すると自動的に保存されます。保存と編集という並行して行われる「軽量プロセス」はスレッドです。\n\nプロセススレッドを表示するには、次のコマンドを使用できます：\n\n<pre>\npete@icebox:~$ ps m\n  PID TTY      STAT   TIME COMMAND\n 2207 pts/2    -      0:01 bash\n    - -        Ss     0:01 -\n 5252 pts/2    -      0:00 ps m\n    - -        R+     0:00 -\n</pre>\n\nプロセスはそれぞれのPIDで示され、プロセスの下にスレッド（--で示される）があります。したがって、上記のプロセスがどちらもシングルスレッドであることがわかります。",
          "quizAnswer": "真",
          "quizQuestion": "すべてのプロセスは最初はシングルスレッドで始まる。これは真か偽か。",
          "slug": "processthreads",
          "title": "プロセススレッド"
        },
        {
          "exercise": "システムの負荷平均を確認し、その状況を確認してください。",
          "id": 4,
          "lessonContent": "便利なコマンド、<b>uptime</b>について見ていきましょう。\n\n<pre>\npete@icebox:~$ uptime\n 17:23:35 up 1 day,  5:59,  2 users,  load average: 0.00, 0.02, 0.05\n</pre>\n\nこのコースの最初のレッスンでuptimeについて話しましたが、ロード平均フィールドについてはまだ説明していません。ロード平均は、システムのCPU負荷を確認する良い方法です。これらの数字は、1分、5分、15分の間隔での平均CPU負荷を表します。CPU負荷とは何か、CPU負荷とはCPUによって実行されるプロセスの平均数です。\n\nたとえば、シングルコアCPUを持っているとします。このコアを交通の1車線と考えてみてください。高速道路がラッシュアワーで混雑している場合、この車線は非常に混雑しており、交通は100%または負荷1になります。今、交通が非常に悪化し、高速道路が混雑して通常の道路も車の数が2倍になっているとします。この場合、負荷は200%または2になります。次に、交通が少し緩和され、高速道路車線に車が半分しかいない場合、車線の負荷は0.5と言えます。交通がないときには、家に早く帰れるので、負荷は非常に低く、午前2時の交通量が少ない状態です。この場合の車はプロセスであり、これらのプロセスはただ高速道路を降りて家に帰るのを待っているだけです。\n\n負荷平均が1であるからといって、コンピューターが遅くなっているわけではありません。現代のほとんどのマシンは複数のコアを持っています。たとえば、クアッドコアプロセッサー（4つのコア）を持っていて、負荷平均が1である場合、実際にはCPUの25%しか影響を受けません。各コアを交通の車線と考えてください。システムにあるコアの数は<b>cat /proc/cpuinfo</b>で確認できます。\n\n負荷平均を観察する際には、コア数を考慮する必要があります。常に平均以上の負荷を使用している場合、何か問題が発生している可能性があります。",
          "quizAnswer": "uptime",
          "quizQuestion": "負荷平均を確認するために使用できるコマンドは何ですか？",
          "slug": "cpumonitoring",
          "title": "CPUモニタリング"
        },
        {
          "exercise": "iostat を使用してディスク使用状況を表示します。",
          "id": 5,
          "lessonContent": "便利なツールである <b>iostat</b> を使用して CPU 使用率やディスク使用状況を監視することもできます。\n\n<pre>\npete@icebox:~$ iostat\nLinux 3.13.0-39-lowlatency (icebox)     01/28/2016      _i686_  (1 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           0.13    0.03    0.50    0.01    0.00   99.33\n\nDevice:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               0.17         3.49         1.92     385106     212417\n</pre>\n\n最初の部分は CPU 情報です:\n\n<ul>\n<li>%user - アプリケーションで実行された CPU 利用率の割合を表示します。</li>\n<li>%nice - nice 優先度で実行されたユーザーレベルの CPU 利用率の割合を表示します。</li>\n<li>%system - カーネルで実行された CPU 利用率の割合を表示します。</li>\n<li>%iowait - システムが未処理のディスク I/O 要求を持っている間に CPU または CPU がアイドル状態であった割合を表示します。</li>\n<li>%steal - 仮想 CPU が他の仮想プロセッサをサービスしている間に仮想 CPU または CPU が非自発的な待機に費やした時間の割合を表示します。</li>\n<li>%idle - CPU または CPU がアイドル状態であり、システムが未処理のディスク I/O 要求を持っていなかった割合を表示します。</li>\n</ul>\n\n2 番目の部分はディスクの利用状況です:\n\n<ul>\n<li>tps - デバイスに発行された秒間転送数を示します。転送はデバイスへの I/O 要求です。複数の論理要求を単一のデバイスへの I/O 要求に組み合わせることができます。転送のサイズは不定です。</li>\n<li>kB_read/s - デバイスから読み取られたデータ量を秒単位のキロバイトで表します。</li>\n<li>kB_wrtn/s - デバイスに書き込まれたデータ量を秒単位のキロバイトで表します。</li>\n<li>kB_read - 読み取られた総キロバイト数です。</li>\n<li>kB_wrtn - 書き込まれた総キロバイト数です。</li>\n</ul>",
          "quizAnswer": "iostat",
          "quizQuestion": "I/O および CPU 使用状況を表示するために使用できるコマンドは何ですか？",
          "slug": "iomonitoring",
          "title": "I/O モニタリング"
        },
        {
          "exercise": "vmstat でメモリ使用状況を確認してください。",
          "id": 6,
          "lessonContent": "CPU モニタリングと I/O モニタリングに加えて、<b>vmstat</b> を使用してメモリ使用状況をモニタリングできます。\n\n<pre>\npete@icebox:~$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 396528  38816 384036    0    0     4     2   38   79  0  0 99  0  0\n</pre>\n\n以下は各フィールドです:\n\n<b>procs</b>\n<ul>\n<li>r - 実行時間のプロセス数</li>\n<li>b - 割り込み不可能なスリープ中のプロセス数</li>\n</ul>\n\n<b>memory</b>\n<ul>\n<li>swpd - 使用されている仮想メモリ量</li>\n<li>free - 空きメモリ量</li>\n<li>buff - バッファとして使用されているメモリ量</li>\n<li>cache - キャッシュとして使用されているメモリ量</li>\n</ul>\n\n<b>swap</b>\n<ul>\n<li>si - ディスクからスワップインされたメモリ量</li>\n<li>so - ディスクにスワップアウトされたメモリ量</li>\n</ul>\n\n<b>io</b>\n<ul>\n<li>bi - ブロックデバイスから受信したブロックの量</li>\n<li>bo - ブロックデバイスに送信されたブロックの量</li>\n</ul>\n\n<b>system</b>\n<ul>\n<li>in - 1 秒あたりの割り込み数</li>\n<li>cs - 1 秒あたりのコンテキストスイッチ数</li>\n</ul>\n\n<b>cpu</b>\n<ul>\n<li>us - ユーザ時間で費やされた時間</li>\n<li>sy - カーネル時間で費やされた時間</li>\n<li>id - アイドルで費やされた時間</li>\n<li>wa - IO を待っている時間</li>\n</ul>",
          "quizAnswer": "vmstat",
          "quizQuestion": "メモリ使用率を表示するために使用されるツールは何ですか？",
          "slug": "memorymonitoring",
          "title": "メモリーモニタリング"
        },
        {
          "exercise": "システムに sar をインストールし、システムリソースの利用状況を収集および分析を開始します。",
          "id": 7,
          "lessonContent": "これらの監視ツールは、マシンに問題が発生しているときに見るのに適していますが、見ていないときに問題が発生しているマシンはどうでしょう。そのような場合には、連続監視ツールを使用する必要があります。システムのアクティビティ情報を収集、レポート、保存するツールです。このレッスンでは、使用するのに最適なツールである <b>sar</b> について説明します。\n\n<b>sar のインストール</b>\nsar は、システムの履歴分析に使用されるツールです。まず、sysstat パッケージをインストールしていることを確認してください。<b>sudo apt install sysstat</b>。\n\n<b>データ収集の設定</b>\n通常、sysstat をインストールすると、システムは自動的にデータの収集を開始します。開始しない場合は、/etc/default/sysstat の ENABLED フィールドを変更して有効にできます。\n\n<b>sar の使用</b>\n\n<pre>$ sudo sar -q</pre>\n\nこのコマンドは、その日の開始からの詳細をリストします。\n\n<pre>$ sudo sar -r</pre>\n\nこれにより、その日の開始からのメモリ使用量の詳細がリストされます。\n\n<pre>$ sudo sar -P</pre>\n\nこれにより、CPU 使用量の詳細がリストされます。\n\n別の日のビューを表示するには、/var/log/sysstat/saXX に移動して、XX が表示したい日になります。\n\n<pre>$sar -q /var/log/sysstat/sa02</pre>",
          "quizAnswer": "sar",
          "quizQuestion": "システムリソースを監視するのに適したツールは何ですか？",
          "slug": "continuousmonitoring",
          "title": "連続監視"
        },
        {
          "exercise": "スケジュールされた時間に実行したい cron ジョブを作成してください。",
          "id": 8,
          "lessonContent": "リソースの利用について話してきましたが、Linux でスケジュールされたタスクを実行するために使用される便利なツールについて触れるいい機会だと思います。cron を使用してタスクをスケジュールするためのサービスがあります。指定した時間にプログラムを実行するサービスです。たとえば、/home/pete/scripts/change_wallpaper にあるスクリプトを毎朝使用して壁紙を変更するとします。しかし、毎朝このスクリプトを手動で実行する必要があります。代わりに、cron を使用してスクリプトを実行する cron ジョブを作成することができます。実行したい cron ジョブの時間を指定し、スクリプトを実行できます。\n\n<pre>30 08 * * * /home/pete/scripts/change_wallpaper</pre>\n\n左から右に次のフィールドがあります:\n<ul>\n<li>分 - (0-59)</li>\n<li>時 - (0-23)</li>\n<li>月の日付 - (1-31)</li>\n<li>月 - (1-12)</li>\n<li>曜日 - (0-7). 0 と 7 は日曜日を表します</li>\n</ul>\n\nフィールド内のアスタリスクはすべての値と一致することを意味します。したがって、上記の例では、毎日毎月午前8時30分に実行したいと考えています。\n\ncron ジョブを作成するには、crontab ファイルを編集します:\n\n<pre>crontab -e</pre>",
          "quizAnswer": "crontab -e",
          "quizQuestion": "cron ジョブを編集するコマンドは何ですか？",
          "slug": "cronjobs",
          "title": "Cron Jobs"
        }
      ],
      "slug": "processutilization",
      "title": "プロセス利用率"
    },
    {
      "description": "システムログと /var/log ディレクトリについて学びます。",
      "id": 15,
      "image": "/images/chapters/logging.png",
      "lessons": [
        {
          "exercise": "自分のマシンで/var/log/syslogファイルを見て、他に何が起こっているかを確認してください。",
          "id": 1,
          "lessonContent": "システム上のサービス、カーネル、デーモンなどは常に何かを行っており、このデータは実際にログとしてシステムに保存されます。これにより、システムで起こっているイベントの人間が読めるジャーナルを持つことができます。このデータは通常、/varディレクトリに保持されます。/varディレクトリは、ログなどの変数データを保持する場所です！\n\nこれらのメッセージはどのようにシステムで受信されているのでしょうか？ syslogと呼ばれるサービスがこの情報をシステムロガーに送信しています。\n\nSyslogには実際に多くのコンポーネントが含まれており、重要なものの1つは、イベントメッセージが発生するのを待ち、それについて知りたいものをフィルタリングするデーモンであるsyslogd（新しいLinuxディストリビューションではrsyslogdを使用）です。そして、そのメッセージに対して何をすべきかに応じて、ファイルに送信したり、コンソールに送信したり、何もしなかったりします。\n\nこのシステムロガーがログを管理する中央の場所であると思うかもしれませんが、残念ながらそうではありません。多くのアプリケーションが独自のログルールを書き込み、異なるログファイルを生成しますが、一般的にログの形式にはタイムスタンプとイベントの詳細が含まれるべきです。\n\n以下はsyslogからの1行の例です：\n\n<pre>\npete@icebox:~$ less /var/log/syslog\nJan 27 07:41:32 icebox anacron[4650]: Job `cron.weekly' started\n</pre>\n\nここでは、1月27日07:41:32にcronサービスがcron.weeklyジョブを実行したことがわかります。 syslogが収集したすべてのイベントメッセージは、/var/log/syslogファイルで確認できます。",
          "quizAnswer": "rsyslogd",
          "quizQuestion": "新しいLinuxシステムでログを管理するデーモンは何ですか？",
          "slug": "systemlogging",
          "title": "システムのロギング"
        },
        {
          "exercise": "自分の/etc/rsyslog.d構成ファイルを見て、システムロガーを介して他に何がログに記録されているかを確認してください。",
          "id": 2,
          "lessonContent": "Syslogサービスはログを管理し、システムロガーに送信します。RsyslogはSyslogの高度なバージョンであり、ほとんどのLinuxディストリビューションはこの新しいバージョンを使用しているはずです。Syslogサービスが収集したすべてのログの出力は/var/log/syslogにあります（認証メッセージを除くすべてのメッセージ）。\n\nシステムロガーが管理しているファイルを確認するには、/etc/rsyslog.d内の構成ファイルを見てください:\n\n<pre>\npete@icebox:~$ less /etc/rsyslog.d/50-default.conf \n#\nauth,authpriv.*                 /var/log/auth.log\n*.*;auth,authpriv.none          -/var/log/syslog\n#cron.*                         /var/log/cron.log\n#daemon.*                       -/var/log/daemon.log\nkern.*                          -/var/log/kern.log\n#lpr.*                          -/var/log/lpr.log\nmail.*                          -/var/log/mail.log\n#user.*                         -/var/log/user.log\n</pre>\n\nこれらのルールはログファイルを示すセレクタ（左列）とアクション（右列）で表されます。アクションは、ログ情報をどこに送信するかを示します（ファイル、コンソールなど）。すべてのアプリケーションやサービスがログを管理するためにrsyslogを使用しているわけではないので、具体的に何がログに記録されているか知りたい場合は、このディレクトリの中を見る必要があります。\n\n実際にログを見てみましょう。loggerコマンドを使用して手動でログを送信できます:\n\n<pre>\nlogger -s Hello\n</pre>\n\n次に、/var/log/syslogを見て、ログにこのエントリが表示されているはずです！",
          "quizAnswer": "logger",
          "quizQuestion": "メッセージを手動でログに記録するために使用できるコマンドは何ですか？",
          "slug": "syslog",
          "title": "最初にいくつかの標準ログファイル。ファシリティごとのログ。"
        },
        {
          "exercise": "/var/log/messages と /var/log/syslog ファイルを見て、違いを確認してください。",
          "id": 3,
          "lessonContent": "システム上で表示できる多くのログファイルがあります。重要なものの多くは /var/log 以下にあります。全てを説明することはしませんが、いくつかの主要なログについては議論します。\n\nシステムの動作を一部把握するために表示できる一般的なログファイルが2つあります:\n\n<b>/var/log/messages</b>\n\nこのログには、非クリティカルで非デバッグメッセージが含まれており、ブートアップ時（dmesg）、認証、cron、デーモンなどのログが含まれています。マシンの動作を一部把握するのに非常に役立ちます。\n\n<b>/var/log/syslog</b>\n\nこのログは認証メッセージを除くすべてを記録し、マシン上のエラーのデバッグに非常に役立ちます。\n\nこれら2つのログは、システムの問題をトラブルシューティングする際には十分です。ただし、特定のログコンポーネントを表示したい場合は、それらのための個別のログもあります。",
          "quizAnswer": "syslog",
          "quizQuestion": "どのログファイルが認証メッセージを除くすべてを記録しますか？",
          "slug": "generallogging",
          "title": "一般的なログ記録"
        },
        {
          "exercise": "dmesg と kern ログを見て、どのような違いがあるかを確認してください。",
          "id": 4,
          "lessonContent": "<b>/var/log/dmesg</b>\nブート時にシステムはカーネルリングバッファに関する情報をログに記録します。これにはハードウェアドライバ、ブート時のカーネル情報やステータスなどが含まれます。このログファイルは /var/log/dmesg にあり、起動時にリセットされます。現時点ではあまり有用性を感じないかもしれませんが、起動時やハードウェアの問題が発生した場合には、dmesg を確認するのが最適です。dmesg コマンドを使用してこのログを表示することもできます。\n\n<b>/var/log/kern.log</b>\nカーネル情報を表示するために使用できる別のログファイルが /var/log/kern.log です。このファイルにはシステム上のカーネル情報やイベントが記録され、dmesg の出力も記録されます。",
          "quizAnswer": "dmesg",
          "quizQuestion": "カーネルの起動メッセージを表示するために使用できるコマンドは何ですか？",
          "slug": "kernellogging",
          "title": "Kernel Logging"
        },
        {
          "exercise": "いくつかの失敗したログインを行い、その後成功したログインを行い、/var/log/auth.logを確認して何が起こったかを見てください。",
          "id": 5,
          "lessonContent": "認証ログ記録は、ログインに問題がある場合に非常に役立ちます。\n\n<b>/var/log/auth.log</b>\n\nこれには、ユーザーログインや使用された認証方法などのシステム認可ログが含まれています。\n\nサンプルスニペット:\n\n<pre>\nJan 31 10:37:50 icebox pkexec: pam_unix(polkit-1:session): session opened for user root by (uid=1000)\n</pre>",
          "quizAnswer": "auth.log",
          "quizQuestion": "ユーザー認証に使用されるログは何ですか？",
          "slug": "authenticationlogging",
          "title": "認証ログ記録"
        },
        {
          "exercise": "logrotateの設定ファイルを確認し、いくつかのログがどのように管理されているかを確認してください。",
          "id": 6,
          "lessonContent": "ログファイルは多くのデータを生成し、このデータをハードディスクに保存しますが、これには多くの問題があります。ほとんどの場合、新しいログを表示したいだけであり、ディスクスペースを効率的に管理したいと考えています。では、これらをすべてどのように行うのでしょうか？答えはlogrotateです。\n\nlogrotateユーティリティはログ管理を行います。設定ファイルを持ち、保持するログの数や種類、ログを圧縮してスペースを節約する方法などを指定できます。logrotateツールは通常、cronから1日1回実行され、設定ファイルは/etc/logrotate.dにあります。\n\nログを管理するために使用できる他のログローテーションツールもありますが、logrotateが最も一般的です。",
          "quizAnswer": "logrotate",
          "quizQuestion": "ログを管理するために使用されるユーティリティは何ですか？",
          "slug": "managinglogfiles",
          "title": "ログファイルの管理"
        }
      ],
      "slug": "logging",
      "title": "ログ記録"
    },
    {
      "description": "rsync、scp、nfsなどを使用したネットワーク共有について学びます。",
      "id": 16,
      "image": "/images/chapters/networkSharing.png",
      "lessons": [
        {
          "exercise": "scpを使用して1台のマシンから別のマシンにファイルをコピーしてみてください。",
          "id": 1,
          "lessonContent": "通常、ネットワーク上にはあなた以外にもコンピューターが存在します。特に商業環境で作業している場合はそのようなケースが多いです。1台のマシンから別のマシンにデータを転送したい場合、USBドライブを接続して手動でコピーすることもあります。しかし、ほとんどの場合、同じネットワーク上のマシンとデータを転送する方法はネットワークファイル共有を使用します。\n\nこのコースでは、ネットワーク上の異なるマシン間でデータをコピーするいくつかの異なる方法について説明します。簡単なファイルコピーについて説明し、その後、別のドライブとして機能するマシン上のディレクトリ全体をマウントする方法について説明します。\n\n1つの簡単なファイル共有ツールは<b>scp</b>コマンドです。scpコマンドはセキュアコピーの略で、cpコマンドと同じように機能しますが、同じネットワーク上の1つのホストから別のホストにコピーすることができます。ssh経由で動作するため、すべての操作がsshと同じ認証とセキュリティを使用します。\n\n<b>ローカルホストからリモートホストにファイルをコピーするには</b>\n\n<pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>\n\n<b>リモートホストからローカルホストにファイルをコピーするには</b>\n\n<pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>\n\n<b>ローカルホストからリモートホストにディレクトリ全体をコピーするには</b>\n\n<pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>",
          "quizAnswer": "scp",
          "quizQuestion": "1つのホストから別のホストに安全にファイルをコピーするために使用できるコマンドは何ですか？",
          "slug": "networkfilesharing",
          "title": "ファイル共有の概要"
        },
        {
          "exercise": "ディレクトリを別のディレクトリに同期するためにrsyncを使用し、重要なディレクトリを上書きしないようにしてください！",
          "id": 2,
          "lessonContent": "異なるホストからデータをコピーするために使用される別のツールはrsync（リモート同期の略）です。rsyncはscpに非常に似ていますが、主な違いがあります。rsyncは、すでにコピーしようとしているデータがあるか事前にチェックする特別なアルゴリズムを使用し、差分のみをコピーします。たとえば、ファイルをコピーしている途中でネットワークが途切れた場合、コピーが途中で停止します。最初からすべてを再コピーする代わりに、rsyncはコピーされなかった部分のみをコピーします。\n\nまた、チェックサムを使用してコピーするファイルの整合性を検証します。これらの小さな最適化により、ファイル転送の柔軟性が向上し、rsyncはリモートおよびローカルでのディレクトリ同期、データバックアップ、大規模データ転送などに最適です。\n\nよく使用されるrsyncオプション:\n\n<ul>\n<li>v -冗長な出力</li>\n<li>r -ディレクトリに再帰</li>\n<li>h -人間に読みやすい出力</li>\n<li>z -圧縮された転送、遅い接続に最適</li>\n</ul>\n\n<b>同じホスト上でファイルをコピー/同期する</b>\n\n<pre>$ rsync -zvr /my/local/directory/one /my/local/directory/two</pre>\n\n<b>リモートホストからローカルホストにファイルをコピー/同期する</b>\n\n<pre>$ rsync /local/directory username@remotehost.com:/remote/directory</pre>\n\n<b>ローカルホストからリモートホストにファイルをコピー/同期する</b>\n\n<pre>$ rsync username@remotehost.com:/remote/directory /local/directory</pre>",
          "quizAnswer": "rsync",
          "quizQuestion": "データバックアップに役立つコマンドは何ですか？",
          "slug": "rsync",
          "title": "rsync"
        },
        {
          "exercise": "SimpleHTTPServerを設定してみてください！",
          "id": 3,
          "lessonContent": "PythonにはHTTP経由でファイルを提供するための非常に便利なツールがあります。これは、ネットワーク上の他のマシンがアクセスできるクイックなネットワーク共有を作成したい場合に便利です。それを行うには、共有したいディレクトリに移動して次のコマンドを実行します:\n\n<pre>$ python -m SimpleHTTPServer</pre>\n\nこれにより、アクセスできる基本的なWebサーバーが設定されます。したがって、これを実行したマシンのIPアドレスを取得し、別のマシンでブラウザで次のようにアクセスします: http://IP_ADDRESS:8000。自分のマシンでは、Webブラウザでhttp://localhost:8000と入力することで利用可能なファイルを表示できます。\n\nこれはnodeでも行うことができますし、Python 3を実行している場合は、構文が少し異なります。",
          "quizAnswer": "SimpleHTTPServer",
          "quizQuestion": "Pythonでシンプルなhttpサーバーを作成するために使用できるツールは何ですか？",
          "slug": "simplehttpserver",
          "title": "シンプルなHTTPサーバー"
        },
        {
          "exercise": "NFS の man ページを読んでさらに学習してください。",
          "id": 4,
          "lessonContent": "Linux における最も標準的なネットワークファイル共有は NFS (Network File System) です。NFS を使用すると、サーバーがネットワークを介して1台以上のクライアントとディレクトリやファイルを共有できます。\n\nNFS サーバーの作成方法の詳細については触れませんが、NFS クライアントの設定については議論します。\n\n<b>NFS クライアントの設定</b>\n\n<pre>$ sudo service nfsclient start\n$ sudo mount server:/directory /mount_directory</pre>\n\n<b>自動マウント</b>\n\nNFS サーバーを頻繁に使用し、常時マウントしたい場合、通常は /etc/fstab ファイルを編集すると考えるかもしれませんが、サーバーへの接続が常に確立されない可能性があり、起動時に問題が発生することがあります。その代わりに、必要な時に NFS サーバーに接続できるように自動マウントを設定することが望ましいです。これは <b>automount</b> ツールまたは最近の Linux のバージョンでは <b>amd</b> を使用して行われます。指定されたディレクトリ内のファイルにアクセスすると、automount はリモートサーバーを検索し、自動的にマウントします。",
          "quizAnswer": "automount",
          "quizQuestion": "マウントポイントを自動的に管理するために使用されるツールは何ですか？",
          "slug": "nfsnetworkfileshare",
          "title": "NFS"
        },
        {
          "exercise": "Samba 共有を設定し、まだ設定していない場合は smb.conf を開いて構成ファイル内のオプションを把握してください。",
          "id": 5,
          "lessonContent": "コンピューティングの初期に、Windows マシンと Linux マシンがファイルを共有する必要性が生じ、その結果 Server Message Block (SMB) プロトコルが誕生しました。SMB は Windows オペレーティングシステム間（Mac も SMB でファイル共有しています）でファイルを共有するために使用され、後に Common Internet File System (CIFS) プロトコルとしてクリーンアップおよび最適化されました。\n\nSamba とは、Linux 上で CIFS を操作するためのユーティリティのことです。ファイル共有に加えて、プリンターなどのリソースを共有することもできます。\n\n<b>Samba を使用してネットワーク共有を作成する</b>\n\nWindows マシンがアクセスできるネットワーク共有を作成する基本的な手順を見ていきましょう。\n\n<b>Samba をインストールする</b>\n\n<pre>$ sudo apt update\n$ sudo apt install samba</pre>\n\n<b>smb.conf を設定する</b>\n\nSamba の構成ファイルは /etc/samba/smb.conf にあります。このファイルには、共有するディレクトリ、アクセス許可、その他のオプションなどが記述されている必要があります。デフォルトの smb.conf には、すでに多くのコメント付きコードが含まれており、これらを使用して独自の構成を記述する例として利用できます。\n\n<pre>$ sudo vi /etc/samba/smb.conf</pre>\n\n<b>Samba のパスワードを設定する</b>\n\n<pre>$ sudo smbpasswd -a [ユーザー名]</pre>\n\n<b>共有ディレクトリを作成する</b>\n\n<pre>$ mkdir /my/directory/to/share</pre>\n\n<b>Samba サービスを再起動する</b>\n\n<pre>$ sudo service smbd restart</pre>\n\n<b>Windows を介した Samba 共有へのアクセス</b>\n\nWindows では、実行プロンプトにネットワーク接続を入力するだけです: \\\\HOST\\共有名。\n\n<b>Linux を介した Samba/Windows 共有へのアクセス</b>\n\n<pre>$ smbclient //HOST/directory -U user</pre>\n\nSamba パッケージには、Windows または Samba サーバーにアクセスするために使用できる <b>smbclient</b> というコマンドラインツールが含まれています。共有に接続したら、ファイルを移動したり、転送したりすることができます。\n\n<b>システムに Samba 共有をアタッチする</b>\n\n1 つずつファイルを転送する代わりに、ネットワーク共有をシステムにマウントすることができます。\n\n<pre>$ sudo mount -t cifs servername:directory mountpount -o user=username,pass=password</pre>",
          "quizAnswer": "CIFS",
          "quizQuestion": "Windows と Linux 間のファイル転送に使用されている最新のプロトコルは何ですか？",
          "slug": "samba",
          "title": "Samba"
        }
      ],
      "slug": "networksharing",
      "title": "ネットワーク共有"
    },
    {
      "description": "ネットワークの基礎とTCP/IPモデルについて学びます。",
      "id": 17,
      "image": "/images/chapters/networkFundamentals.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "典型的な家庭用ネットワークを見てみましょう。いくつかの異なるコンポーネントがあります。\n\n<ul>\n<li>ISP - インターネットサービスプロバイダー、家でインターネットを利用するために支払いを行う会社です。</li>\n<li>Router - ルーターはネットワーク上の各機器がインターネットに接続できるようにします。ほとんどの現代のルーターでは、無線またはイーサネットケーブルを介して接続できます。</li>\n<li>WAN - ワイドエリアネットワーク、これはルーターとインターネットなどの広域ネットワークの間にあるネットワークを指します。</li>\n<li>WLAN - ワイヤレスローカルエリアネットワーク、これはルーターとノートパソコンなどの無線デバイスとの間のネットワークを指します。</li>\n<li>LAN - ローカルエリアネットワーク、これはルーターとデスクトップPCなどの有線デバイスとの間のネットワークを指します。</li>\n<li>ホスト - ネットワーク上の各機器はホストとして知られています。</li>\n</ul>\n\nネットワークを介して送信されるデータと情報はパケットとして知られており、Networking Nomadセクションの最後までに、パケットがホスト間をどのように移動するかについて詳しく理解するでしょう。",
          "quizAnswer": "LAN",
          "quizQuestion": "ローカルエリアネットワークは何と呼ばれていますか？",
          "slug": "networkbasics",
          "title": "ネットワークの基礎"
        },
        {
          "exercise": "OSIモデルについて詳しく読む: <a href=\"https://en.wikipedia.org/wiki/OSI_model\">https://en.wikipedia.org/wiki/OSI_model</a>",
          "id": 2,
          "lessonContent": "実用的なネットワーキングに取り組む前に、以前に聞いたことがあるかもしれない退屈な専門用語を見ていかなければなりません。 OSI（Open Systems Interconnection）モデルは、ネットワーキングの理論モデルです。 このモデルは、パケットがネットワークを7つの異なるレイヤーを通過する方法を示しています。 このモデルの詳細には触れませんが、ほとんどのネットワーキングコースはTCP/IPモデルに焦点を当てているため、そのような理論的なネットワーキングモデルが存在し、実際に今日使用しているTCP/IPネットワーキングモデルに大きな影響を与えていることを述べておくべきです。",
          "quizAnswer": "OSI",
          "quizQuestion": "ネットワーキングの理論モデルとして何が使用されていますか？",
          "slug": "osimodel",
          "title": "OSIモデル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "OSIモデルは、最終的にTCP/IPモデルとなるものを生み出し、このモデルが実際にインターネットの基盤となっています。これはネットワーキングの実際の実装です。TCP/IPモデルは、TCP/IPプロトコルスイートを使用しており、一般的にTCP/IPと呼ばれています。これらのプロトコルは、データの収集、アドレス付け、転送、およびネットワークを経由してデータがどのようにルーティングされるかを指定するために連携して動作します。TCP/IPモデルを使用することで、これらのプロトコルがネットワークを通じてパケットがどのように移動するかを示す分解方法を見ることができます。\n\n<b>アプリケーション層</b>\n\nTCP/IPモデルの最上位層。コンピュータのプログラム（Webブラウザなど）がデータを表示するためにトランスポート層サービスとどのようにインタフェースするかを決定します。\n\nこの層では以下を使用します:\n<ul>\n<li>HTTP（ハイパーテキスト転送プロトコル）- インターネット上のWebページに使用されます。</li>\n<li>SMTP（シンプルメール転送プロトコル）- 電子メールの送信</li>\n</ul>\n\n<b>トランスポート層</b>\n\nデータの転送方法を決定し、正しいポートの確認、データの整合性、基本的にはパケットの配信を行います。\n\nこの層では以下を使用します:\n<ul>\n<li>TCP（Transmission Control Protocol）- 信頼性のあるデータ配信</li>\n<li>UDP（User Datagram Protocol）- 信頼性のないデータ配信</li>\n</ul>\n\n<b>ネットワーク層</b>\n\nこの層は、ホスト間およびネットワーク間でパケットを移動する方法を指定します。\n\nこの層では以下を使用します:\n<ul>\n<li>IP（インターネットプロトコル）- 1台のマシンから別のマシンへのパケットのルーティングを支援します。</li>\n<li>ICMP（インターネット制御メッセージプロトコル）- エラーメッセージやデバッグ情報など、何が起こっているかを教えてくれます。</li>\n</ul>\n\n<b>リンク層</b>\n\nこの層は、データを物理的なハードウェアを介して送信する方法を指定します。たとえば、Ethernet、ファイバーなどを介してデータを送信する方法です。\n\n上記の各層が使用するプロトコルのリストは完全ではなく、他にも多くのプロトコルが関与することになります。\n\n次のレッスンでは、これらの各層を詳しく説明し、パケットがネットワークを通過する際のTCP/IPモデルの視点でどのように移動するかについて議論します（パケットがネットワークを横断する方法には多くの視点がありますが、すべてを見るわけではありませんが、存在することを認識してください）。",
          "quizAnswer": "アプリケーション",
          "quizQuestion": "TCP/IPモデルの最上位層は何ですか？",
          "slug": "tcpipmodel",
          "title": "TCP/IPモデル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 4,
          "lessonContent": "ネットワーク上をパケットが移動する仕組みを見る前に、いくつかの用語に慣れておかなければなりません。手紙を送るときは、誰に送られているか、どこから来ているかを知っている必要があります。パケットも同じ情報が必要で、私たちのホストや他のホストはMAC（メディアアクセス制御）アドレスとIPアドレスを使用して識別されます。人間にとってわかりやすくするために、ホストを識別するためにホスト名を使用します。\n\n<b>MACアドレス</b>\n\nMACアドレスはハードウェアアドレスとして使用される一意の識別子です。このアドレスは決して変わりません。インターネットにアクセスする場合、あなたのマシンはネットワークインターフェースカードと呼ばれるデバイスを持っている必要があります。このネットワークアダプタには、あなたのマシンを識別するために使用される独自のハードウェアアドレスがあります。イーサネットデバイスのMACアドレスは、00:C4:B5:45:B2:43のように見えます。MACアドレスは製造時にネットワークアダプタに割り当てられます。各製造業者には、製造業者を識別するための組織固有識別子（OUI）があります。このOUIはMACアドレスの最初の3バイトで示されます。たとえば、Dellは00-14-22を持っているので、Dellのネットワークアダプタは00-14-22-34-B2-C2のようなMACアドレスを持つかもしれません。\n\n<b>IPアドレス</b>\n\nIPアドレスはネットワーク上のデバイスを識別するために使用され、ハードウェアに依存せず、IPv4またはIPv6を使用しているかによって構文が異なる場合があります（後で詳しく説明します）。今のところ、IPv4を使用していると仮定し、典型的なIPアドレスは10.24.12.4のように見えます。IPアドレスはネットワーキングのソフトウェア側で使用されます。システムがインターネットに接続されるたびにIPアドレスが必要です。ネットワークが変更されるとIPアドレスも変更される場合があり、インターネット全体で一意です（これはNATについて学ぶと必ずしもそうではないことがあります）。\n\nパケットをネットワーク上で移動させるには、ソフトウェアとハードウェアの両方が必要です。そのため、それぞれにMAC（ハードウェア）とIP（ソフトウェア）の2つの識別子があります。\n\n<b>ホスト名</b>\n\nマシンを識別する最後の方法はホスト名を使用することです。ホスト名はIPアドレスを取り、そのアドレスを人間が読みやすい名前に紐付けることができます。192.12.41.4を覚える代わりに、myhost.comを覚えておくことができます。",
          "quizAnswer": "4",
          "quizQuestion": "IPv4アドレスには何バイトありますか？",
          "slug": "networkaddressing",
          "title": "ネットワークアドレッシング"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 5,
          "lessonContent": "Patty にメールを送信したいとします。TCP/IP レイヤーごとにこの動作を確認します。\n\nパケットはネットワークを横断してデータを送信するために使用されます。パケットはヘッダーとペイロードで構成されます。ヘッダーにはパケットの送信先や送信元に関する情報が含まれます。ペイロードは実際に転送されるデータです。パケットがネットワークを通過すると、各レイヤーがパケットのヘッダーに情報を追加します。また、異なるレイヤーでは「パケット」に異なる用語が使用されます。トランスポートレイヤーではデータをセグメントにカプセル化し、リンクレイヤーではこれをフレームと呼びますが、パケットという用語が同じものを指すことを知っておいてください。\n\nまず最初にアプリケーションレイヤーから始めます。メールクライアントを介してメールを送信すると、アプリケーションレイヤーがこのデータをカプセル化します。アプリケーションレイヤーは指定されたポートを介してトランスポートレイヤーと通信し、このポートを介してデータを送信します。メールを送信する際にはアプリケーションレイヤープロトコル SMTP（シンプルメール転送プロトコル）を使用したいと考えます。データはトランスポートプロトコルを介して送信され、このポートに接続が開かれます（SMTP にはポート 25 が使用されます）。したがって、このポートを介してデータが送信され、そのデータはセグメントにカプセル化されるためにトランスポートレイヤーに送信されます。",
          "quizAnswer": "Application",
          "quizQuestion": "パケットデータをユーザーフレンドリーな形式で表示するために使用されるレイヤーは何ですか？",
          "slug": "applicationlayer",
          "title": "Application Layer"
        },
        {
          "exercise": "このレッスンには練習問題はありません。",
          "id": 6,
          "lessonContent": "トランスポート層は、ネットワークが読み取れるようにデータを転送するのに役立ちます。データをチャンクに分割し、それらを転送して正しい順序で再構築します。これらのチャンクはセグメントとして知られています。セグメントを使用すると、データをネットワーク全体で転送しやすくなります。\n\n<b>ポート</b>\n\nIPアドレスを介してデータを送信先を知っていても、それだけでは特定のプロセスやサービスにデータを送信するのに十分ではありません。HTTPなどのサービスは、ポートを介した通信チャネルを使用します。Webページデータを送信したい場合、HTTPポート（ポート80）を介して送信する必要があります。セグメントの形成に加えて、トランスポート層はセグメントにソースポートと宛先ポートを添付します。したがって、受信者が最終パケットを受信するときに使用するポートを知ることができます。\n\n<b>UDP</b>\n\nUDPとTCPの2つの人気のあるトランスポートプロトコルがあります。UDPについては簡単に説明し、TCPについてはほとんどの時間を費やします。なぜなら、TCPが最も一般的に使用されるからです。\n\nUDPはデータを転送する信頼性のない方法であり、実際、元のデータがすべて届くかどうかはあまり気にしません。これはひどいように聞こえるかもしれませんが、メディアストリーミングなどには使用されます。いくつかのフレームが失われても構わないので、データを少し早く取得できます。\n\n<b>TCP</b>\n\nTCPは信頼性のある接続指向のデータストリームを提供します。TCPはホスト間でデータを送受信するためにポートを使用します。アプリケーションは、自分のホストの1つのポートからリモートホストの別のポートへの接続を開きます。この接続を確立するために、TCPハンドシェイクを使用します。\n\n<ul>\n<li>クライアント（接続プロセス）は、接続を要求するためにサーバーにSYNセグメントを送信します</li>\n<li>サーバーは、クライアントの接続要求を確認するためにSYN-ACKセグメントをクライアントに送信します</li>\n<li>クライアントは、サーバーの接続要求を確認するためにACKをサーバーに送信します</li>\n</ul>\n\nこの接続が確立されると、TCP接続を介してデータをやり取りできます。データは異なるセグメントで送信され、TCPシーケンス番号で追跡されるため、配信時に正しい順序で配置されます。電子メールの例では、トランスポート層は送信元ホストの宛先ポート（25）を添付します。",
          "quizAnswer": "TCP",
          "quizQuestion": "信頼性のあるトランスポートプロトコルは何ですか？",
          "slug": "transportlayer",
          "title": "Transport Layer"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 7,
          "lessonContent": "ネットワーク層は、ソースホストから宛先ホストへのパケットのルーティングを決定します。幸いなことに、この例では、パケットは同じネットワーク内を移動していますが、インターネットは多くのネットワークから構成されています。インターネットを構成するこれらの小さなネットワークはサブネットとして知られています。すべてのサブネットはある方法で互いに接続されており、それが www.google.com にアクセスできる理由です。サブネットについては詳細には触れませんが、ネットワーク層に関しては、IPアドレスが異なるサブネットへの移動規則を定義していることを知っておいてください。\n\nネットワーク層では、トランスポート層から来たセグメントを受け取り、このセグメントをIPパケットにカプセル化し、パケットヘッダにソースホストのIPアドレスと宛先ホストのIPアドレスを添付します。この時点で、パケットにはどこに行くか、どこから来たかに関する情報が含まれています。そして、このパケットを物理ハードウェア層に送信します。",
          "quizAnswer": "サブネット",
          "quizQuestion": "インターネットを構成する小さなネットワークは何と呼ばれますか？",
          "slug": "networklayer",
          "title": "ネットワーク層"
        },
        {
          "exercise": "このレッスンには練習問題はありません。",
          "id": 8,
          "lessonContent": "TCP/IPモデルの最下層にはリンク層があります。この層はハードウェア固有の層です。\n\nリンク層では、パケットは再びフレームと呼ばれるものにカプセル化されます。フレームヘッダーには、ホストのソースと宛先MACアドレス、チェックサム、パケットセパレータが添付され、受信者がパケットの終了を判断できます。\n\n幸いなことに、私たちは同じネットワーク上にいるので、パケットは遠くには移動しません。最初に、リンク層は私のソースMACアドレスをフレームヘッダーに添付しますが、パティのMACアドレスも知る必要があります。それをどのように知り、インターネット上にないので私がそれを見つける方法は何でしょうか？ ARPを使用します！\n\n<b>ARP（アドレス解決プロトコル）</b>\n\nARPはIPアドレスに関連付けられたMACアドレスを見つけます。ARPは同じネットワーク内で使用されます。パティが同じネットワーク上にいない場合、パケットを受け取る次のルーターを決定するためにルーティングシステムを使用し、同じネットワーク上にいるとARPを使用できます。\n\n同じネットワーク上にいると、システムはまずARPルックアップテーブルを使用して、どのIPアドレスがどのMACアドレスに関連付けられているかの情報を格納します。その値がそこにない場合、ARPが使用されます。その後、システムはARPプロトコルを使用してネットワークにブロードキャストメッセージを送信し、IPアドレス10.10.1.4を持つホストがどれかを調べます。ブロードキャストメッセージは、ネットワーク上のすべてのホストに送信される特別なメッセージです（ブロードキャスト送信のために適切に名前が付けられています）。要求されたIPアドレスを持つ任意のマシンは、IPアドレスとMACアドレスを含むARPパケットで応答します。\n\n必要なデータ、つまりIPアドレスとMACアドレスをすべて取得したら、リンク層はこのフレームをネットワークインターフェースカードを介して転送し、次のデバイスに送り、パティのネットワークを見つけます。このステップは、私が説明した方法よりも少し複雑ですが、ルーティングコースで詳細を説明します。\n\nこれがTCP/IP層を下って単純（またはそうでない）なパケットの移動です。パケットはこのように一方通行で移動するわけではありません。まだパティのネットワークに到達していません！ネットワークを通過する際には、データを送受信する前に少なくともTCP/IPモデルを2回通過する必要があります。実際には、このパケットの見た目は次のようになります：\n\n<b>パケットの移動</b>\n\n<ol>\n<li>PeteがPattyにメールを送信：このデータはトランスポート層に送信されます。</li>\n<li>トランスポート層はデータをTCPまたはUDPヘッダーにカプセル化してセグメントを形成し、セグメントは宛先とソースのTCPまたはUDPポートを添付し、セグメントはネットワーク層に送信されます。</li>\n<li>ネットワーク層はTCPセグメントをIPパケット内にカプセル化し、ソースと宛先IPアドレスを添付します。その後、パケットをリンク層にルーティングします。</li>\n<li>パケットは次にPeteの物理ハードウェアに到達し、フレームにカプセル化されます。ソースと宛先MACアドレスがフレームに追加されます。</li>\n<li>Pattyはこのデータフレームを物理層を介して受信し、各フレームをデータの整合性をチェックし、その後フレームの内容を取り出してIPパケットをネットワーク層に送信します。</li>\n<li>ネットワーク層は以前に添付されたソースと宛先IPを見つけるためにパケットを読み取ります。自分のIPが宛先IPと同じかどうかをチェックし、同じであれば！パケットをデカプセル化してセグメントをトランスポート層に送信します。</li>\n<li>トランスポート層はセグメントをデカプセル化し、TCPまたはUDPポート番号をチェックし、そのポート番号に基づいてアプリケーション層に接続を行います。</li>\n<li>アプリケーション層は、指定されたポートでトランスポート層からデータを受信し、最終的なメールメッセージとしてPattyに表示します。</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "同じネットワーク上でMACアドレスを見つけるために使用されるものは何ですか？",
          "slug": "linklayer",
          "title": "リンク層"
        },
        {
          "exercise": "このレッスンには練習問題はありません。",
          "id": 9,
          "lessonContent": "まだ説明していない重要なネットワーキングの概念は、DHCP（Dynamic Host Configuration Protocol）です。\n\nDHCPは、IPアドレス、サブネットマスク、ゲートウェイを私たちの機器に割り当てます。たとえば、携帯電話を持っており、人と話すために携帯電話番号を取得したい場合を考えてみましょう。携帯電話会社に電話をかけ、番号をもらいます。請求書を支払い続ければ、携帯電話を使用し続けることができます。この場合、DHCPは携帯電話会社であり、他のIPアドレスと通信できるようにIPアドレスを提供します。また、IPアドレスがリースされます。これらは一定期間有効であり、リース設定に応じて更新されます。\n\nDHCPには多くの利点があります。ネットワーク管理者はIPアドレスの割り当てを気にする必要がなくなり、重複したIPアドレスの設定も防ぎます。物理ネットワークごとに独自のDHCPサーバーを持つべきであり、ホストがIPアドレスを要求できるようにします。通常、家庭用の設定では、ルーターがDHCPサーバーとして機能します。\n\nDHCPがすべての動的ホスト情報を取得する方法は次のとおりです。\n\n<ol>\n<li>DHCP DISCOVER - このメッセージは、DHCPサーバーを検索するためにブロードキャストされます。</li>\n<li>DHCP OFFER - ネットワーク内のDHCPサーバーが提供メッセージで応答します。提供には、DHCPリース時間、サブネットマスク、IPアドレスなどが含まれます。</li>\n<li>DHCP REQUEST - クライアントは、受け入れた提供をすべてのDHCPサーバーに知らせるために別のブロードキャストを送信します。</li>\n<li>DHCP ACK - サーバーから確認が送信されます。</li>\n</ol>\n\nDHCPはこれ以上のこともありますが、これがその要点です。",
          "quizAnswer": "DISCOVER、OFFER、REQUEST、ACK",
          "quizQuestion": "DHCPリクエストの手順は何ですか？",
          "slug": "dhcpoverview",
          "title": "DHCPの概要"
        }
      ],
      "slug": "networkbasics",
      "title": "ネットワークの基礎"
    },
    {
      "description": "サブネットについて学び、サブネット演算の方法を学びます！",
      "id": 18,
      "image": "/images/chapters/subnetting.png",
      "lessons": [
        {
          "exercise": "'ifconfig'を使用してIPアドレスを見つけてください。",
          "id": 1,
          "lessonContent": "各ネットワークホストには固有のアドレスがあり、各固有のアドレスはネットワーク内でホストを特定するために使用できます。これらの固有のアドレスは「IPアドレス」として知られています。IPv4アドレスは次のように見えます:\n\n<pre>204.23.124.23</pre>\n\nこのアドレスには実際に2つの部分が含まれています。ネットワーク部分（どのネットワークに属しているかを識別する）とホスト部分（ホストを識別する）です。このコースでは、一般的に「IPアドレス」として言及されるIPv4アドレスについて主に議論します。\n\nIPアドレスはピリオドでオクテットに分かれています。IPv4アドレスには4つのオクテットがあります。コンピュータサイエンスの知識があれば、オクテットが8ビットであることを知っているはずで、8ビットが実際に1バイトに等しいことも知っているはずです。つまり、IPv4アドレスには4バイトあります。サブネットやIPアドレスを扱う際には、ビットを頻繁に使用します。\n\n'ifconfig -a'コマンドでIPアドレスを表示できます:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n私のIPv4アドレスは次の通りです: 192.168.1.129",
          "quizAnswer": "4",
          "quizQuestion": "IPv4アドレスには何バイトありますか？",
          "slug": "ipv4",
          "title": "IPv4"
        },
        {
          "exercise": "ifconfigを使用してサブネットマスクを表示します。",
          "id": 2,
          "lessonContent": "パティと同じネットワークにいるかどうかをどのように知ることができますか？サブネット（サブネットワークの略）を見ればわかります。サブネットは特定の方法で類似したIPアドレスを持つホストのグループです。これらのホストは通常、お互いに近い場所にあり、同じサブネット上のホストにデータを簡単に送受信できます。同じ郵便番号に郵便物を送るようなもので、別の州に郵便物を送るよりも簡単です。\n\n例えば、IPアドレスが123.45.67で始まるすべてのホストは同じサブネット上にあります。私のホストのIPは123.45.67.8で、パティのIPは123.45.67.9です。共通の数字は私のネットワークプレフィックスであり、8と9は私たちのホストです。したがって、私のネットワークはパティのネットワークと同じです。サブネットはネットワークプレフィックス（例：123.45.67.0）とサブネットマスクに分割されます。\n\n<b>サブネットマスク</b>\n\nサブネットマスクは、IPアドレスのどの部分がネットワーク部分であり、どの部分がホスト部分であるかを決定します。\n\n典型的なサブネットマスクは次のようになります：\n\n<pre>255.255.255.0</pre>\n\n255の部分が実際にマスクです。これを少し理解しやすくするために、各オクテットを8ビットと呼ぶ方法を覚えておいてください。コンピュータサイエンスでは、ビットはバイナリ形式で0または1で示されます。バイナリ数が使用されると、1はオンを意味し、0はオフを意味します。では、8つの0または1は何に等しいでしょうか？\n\nGoogleで「バイナリから10進数の計算機」を検索し、11111111を10進数形式に変換してみてください。何が得られますか？255です！したがって、オクテットの範囲は0から255です。したがって、サブネットマスクが255.255.255.0で、IPアドレスが192.168.1.0の場合、そのサブネットには何台のホストがいますか？サブネット数学のレッスンでその答えを見つけます。\n\nまた、サブネットについて話すとき、通常はネットワークプレフィックスに続いてサブネットマスクを示します：\n\n<pre>123.234.0.0/255.255.0.0</pre>\n\n<b>なぜ？</b>\n\nなぜ私たちはサブネットを作成するのでしょうか？サブネット化はネットワークをセグメント化し、そのネットワーク内のトラフィックの流れを制御するために使用されます。したがって、1つのサブネット上のホストは、異なるサブネット上の別のホストとはやり取りできません。\n\nしかし、ちょっと待ってください。yahoo.comのような他のホストに接続したい場合はどうすればよいでしょうか？その場合、サブネットを接続する必要があります。サブネットを接続するには、複数のサブネットに接続されているホストを見つけるだけです。たとえば、私のホストが192.168.1.129でローカルネットワークに接続されている場合、そのネットワーク上の任意のホストに到達できます。インターネットの残りのホストに到達するには、ルータを介して通信する必要があります。通常、サブネットマスクが255.255.255.0のほとんどのネットワークでは、ルータはサブネットのアドレス1にあります。つまり、192.168.1.1です。そのルータには、他のサブネットに接続するポートがあります（ルーティングコースで詳しく説明します）。特定のIPアドレス（プライベートネットワーク）はインターネットには見えず、NATなどの仕組みがあります（後で詳しく説明します）。",
          "quizAnswer": "True",
          "quizQuestion": "真偽、サブネットはサブネットマスクとネットワークプレフィックスで構成されていますか？",
          "slug": "subnets",
          "title": "サブネット"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "サブネットマスクは、サブネット上で何台のホストを持つことができるかを把握するために重要であることを知っています。では、それは何台のホストになるでしょうか？\n\nIPアドレスが<b>192.168.1.0</b>で、サブネットマスクが<b>255.255.255.0</b>だとします。これらの数値をバイナリ形式で並べてみましょう。今のところ、オンライン計算機を使用してこれらの値を10進数から2進数に変換してください。\n\n<pre>\n192.168.1.165  = 11000000.10101000.00000001.10100101\n255.255.255.0  = 11111111.11111111.11111111.00000000\n</pre>\n\nIPアドレスはサブネットマスクでマスクされており、1が表示されるとマスクされ、見えないものとして扱います。したがって、持つことができるホストは00000000の領域からのみです。2進数で11111111は255に相当し、ホスト番号として0も考慮されますので、256のオプションがあります。ただし、256のオプションがあるように見えるかもしれませんが、ブロードキャストアドレスとサブネットアドレスを考慮する必要があるため、実際には2つのホストを引く必要があり、サブネット上で持つことができるホストは254台になります。つまり、IPアドレスが192.168.1.1から192.168.1.254までの範囲のホストを持つことができることがわかります。",
          "quizAnswer": "11111111",
          "quizQuestion": "255の2進数表現は何ですか？",
          "slug": "subnetmath",
          "title": "サブネット計算"
        },
        {
          "exercise": "IPアドレスとサブネットマスクを見て、サブネット内でいくつのホストを持つことができるかを確認してください。",
          "id": 4,
          "lessonContent": "このセクションを追加しなければならないことを嫌います。実際の世界では、通常サブネットの計算を手作業で行う必要はほとんどないでしょう。ただし、これについて面接を受ける場合は、サブネットのバイナリ形式への変換方法を知っている必要があります。幸いなことに、覚えられる算術のチートがあります。\n\nまず、基本的な2進数の計算を覚えてください:\n\n<ul>\n<li>2^1 = 2</li>\n<li>2^2 = 4</li>\n<li>2^3 = 8</li>\n<li>2^4 = 16</li>\n<li>2^5 = 32</li>\n<li>2^6 = 64</li>\n<li>2^7 = 128</li>\n<li>2^8 = 256</li>\n<li>2^9 = 512</li>\n<li>2^10 = 1024</li>\n<li>2^11 = 2048</li>\n<li>2^12 = 4096</li>\n</ul>\n\n<b>10進数から2進数への変換チャート</b>\n\n<pre>\n1   1  1  1  1 1 1 1\n128 64 32 16 8 4 2 1\n</pre>\n\n以下のチャートがこのようになる理由はたくさんあります。興味がある場合は、オンラインリソースがたくさんあります。\n\nこれらを覚えましたか？ さっそく10進数から2進数への変換を行いましょう:\n\n<b>192.168.23.43を2進数に変換</b>\n\n覚えておくこと: 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\n\n最初のオクテットを2進数に変換する手順を見ていき、残りの手順がどのように機能するかを理解します。\n\n<ol>\n<li>192から128を引くことができますか？ はい、したので最初のビットは1です</li>\n<li>192 - 128 = 64、チャートの次の数は64です。64から64を引くことができますか？ はい、したので2番目のビットは1です</li>\n<li>引く数がなくなったので、192の2進数形式は11000000です</li>\n</ol>\n\n<b>2進数11000000を10進数に変換</b>\n\n2進数から10進数への変換では、1の数を合計します。つまり:\n\n128 + 64 + 0 + 0 + 0 + 0 + 0 + 0 = 192!",
          "quizAnswer": "1111011",
          "quizQuestion": "123の2進数変換は何ですか？",
          "slug": "subnettingcheats",
          "title": "サブネットチート"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 5,
          "lessonContent": "CIDR（クラスレスインタードメインルーティング）は、サブネットマスクをよりコンパクトな方法で表現するために使用されます。CIDR表記でサブネットを見ることがあり、たとえば10.42.3.0/255.255.255.0のようなサブネットが10.42.3.0/24と書かれることがあります。これは、サブネットプレフィックスとサブネットマスクの両方を含むことを意味します。\n\nIPアドレスは4バイトまたは32ビットで構成されることを覚えておいてください。CIDRはネットワークプレフィックスとして使用されるビット数を示します。したがって、123.12.24.0/23は最初の23ビットが使用されていることを意味します。では、それは何を意味するのでしょうか？ それは何人のホストを意味するのでしょうか？\n\nIPアドレスが持つことができる合計ビット数（32）からCIDRアドレス（23）を引く簡単なトリックを使うと、残りは9ビットになります。2^9 = 512ですが、サブネットアドレスとブロードキャストアドレスを除かなければならないので、利用可能なホスト数は510です。",
          "quizAnswer": "",
          "quizQuestion": "質問はありません。次に進んでください！",
          "slug": "classlessinterdomainroutingcidr",
          "title": "CIDR"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 6,
          "lessonContent": "NAT（ネットワークアドレス変換）について以前触れましたが、ネットワークを構築しているとき、インターネットは私たちのIPアドレスを見ることができるのでしょうか？ そうではありません。\n\nNATは、ルーターなどのデバイスがインターネットとプライベートネットワークの間に中継者として機能するようにします。そのため、一意のIPアドレスだけで複数のコンピューターを表すことができます。\n\nNATは、大きなオフィスの受付係のようなものです。誰かがあなたに連絡したい場合、その人はオフィス全体の番号しか知らないため、受付係はあなたの内線番号を探して通話を転送する必要があります。\n\n<b>どのように機能するのか？</b>\n\n簡単なケースは次のようになります：\n\n<ol>\n<li>Pattyがwww.google.comに接続したいと思ったので、彼女のマシンはこのリクエストをルーターを介して送信します</li>\n<li>ルーターはそのリクエストを受け取り、google.comへの接続を開き、接続を確立したらPattyのリクエストを送信します</li>\n<li>ルーターはPattyとwww.google.comの間の中継者です。GoogleはPattyについては何も知らず、見えるのはルーターだけです。</li>\n</ol>\n\nNATやパケットルーティング全般はかなり複雑になることがありますが、詳細には立ち入りません。",
          "quizAnswer": "NAT",
          "quizQuestion": "インターネット上で単一のプライベートアドレスを表すために使用されるものは何ですか？",
          "slug": "natnetworkaddresstranslation",
          "title": "NAT"
        },
        {
          "exercise": "IPv6アドレスがリストされているかどうかを確認するには、ifconfigを確認してください。",
          "id": 7,
          "lessonContent": "IPv6はここそこで用語として聞いたことがありますが、それは何でしょうか？ インターネットに接続するすべてのデバイスには独自のIPアドレスが割り当てられますが、それはデジタル時代に迫っている有限な数です。IPv6は、より多くのホストをインターネットに接続できるようにするために作成されました。IPv6にはより多くのIPの改善点がありますが、その普及はかなり遅いです。IPv4を置き換えるためではなく、お互いを補完するために作成されています。 2つのIPプロトコルは非常に似ており、IPv4を知っていればIPv6も理解できます。主な違いはアドレスの書き方です。以下は典型的なIPv6アドレスの例です：\n\n<pre>\n2dde:1235:1256:3:200:f8ed:fe23:59cf\n</pre>",
          "quizAnswer": "IPv6",
          "quizQuestion": "インターネットに接続できるホストの数を増やすのに使用されるIPアドレスは何ですか？",
          "slug": "ipv6",
          "title": "IPv6"
        }
      ],
      "slug": "subnetting",
      "title": "サブネット"
    },
    {
      "description": "ネットワークを横断してパケットがどのようにルーティングされるかを学びます！",
      "id": 19,
      "image": "/images/chapters/routing.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "以前にもこの用語「ルーター」を使用していますが、おそらくご自宅にも1台あるので、その意味をご存知かと思います。ルーターは、ネットワーク上の機器同士や他のネットワークと通信することを可能にします。典型的なルーターには、LANポートがあり、これにより機器が同じローカルエリアネットワークに接続できます。また、インターネットに接続するためのインターネットアップリンクポートもあります。このポートは広いネットワークに接続するため、WANとラベル付けされることがあります。ネットワーク活動を行う際には、必ずルーターを経由します。ルーターは、ネットワークパケットの送受信先を決定し、複数のネットワーク間でパケットをルーティングして送信元ホストから宛先ホストまで到達させます。\n\n<b>ルーターはどのように動作するのか？</b>\n\nルーティングは郵便物の配達と同様に考えることができます。送りたい宛先がある住所があり、郵便局に送ると、郵便局は「ああ、これはカリフォルニア行きだな」と判断し、カリフォルニア行きのトラックに積み込みます。その手紙はサンフランシスコに送られ、サンフランシスコ内には異なる郵便番号があり、その郵便番号内にはさらに小さな住所コードがあります。最終的に誰かがあなたが望む宛先に手紙を配達できるようになります。一方、もしすでにサンフランシスコに住んでいて同じ郵便番号内にいる場合、郵便配達員はおそらく他の誰かに手紙を渡さずに、手紙を正確な宛先に配達するでしょう。\n\nパケットをルーティングする際には、同様のアドレス「ルート」を使用します。たとえば、ネットワークAに到達するには、これらのパケットをネットワークBに送信します。そのようなルートが設定されていない場合、パケットはデフォルトルートを使用します。これらのルートは、システムがネットワーク間を移動するために使用するルーティングテーブルに設定されています。\n\n<b>ホップ</b>\n\nパケットがネットワークを移動する際には、ホップを経由して移動します。ホップは、パケットが送信元から宛先まで移動するために必要な距離をおおまかに測定する方法です。たとえば、ホストAとホストBを接続する2つのルーターがある場合、ホストAとホストBの間に2つのホップがあると言います。各ホップは、ルーターなどの中間デバイスを通過する必要があるものです。\n\n<b>スイッチング、ルーティング、フラッディングの基本的な違いを理解する</b>\nパケットスイッチングは基本的に、データを受信し、処理して宛先デバイスに転送することです。\nルーティングは、ルーティングテーブルを作成するプロセスであり、これによりスイッチングをより効率的に行うことができます。\nルーティングの前には、フラッディングが使用されていました。ルーターがパケットをどのように送信すべきかわからない場合、到着したパケットは、到着したリンク以外のすべての出力リンクを介して送信されました。",
          "quizAnswer": "ホップ",
          "quizQuestion": "パケットの距離をどのように測定しますか？",
          "slug": "whatisarouter",
          "title": "ルーターとは何ですか？"
        },
        {
          "exercise": "ルーティングテーブルを確認し、パケットがどこに送られるかを確認してください。",
          "id": 2,
          "lessonContent": "自分のマシンのルーティングテーブルを見てみましょう：\n\n<pre>\npete@icebox:~$ sudo route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         192.168.224.2   0.0.0.0         UG    0      0        0 eth0\n192.168.224.0   0.0.0.0         255.255.255.0   U     1      0        0 eth0\n</pre>\n\n<b>Destination</b>\n\n最初のフィールドには、宛先IPアドレスが192.168.224.0とあります。これは、このネットワークに向けられたパケットは、私のEthernetケーブル（eth0）を介して送信されることを意味します。たとえば、私が192.168.224.5であり、192.168.224.7に到達したい場合、ネットワークインターフェースeth0を直接使用します。\n\n<b>Gateway</b>\n\n同じネットワーク上にないパケットを送信する場合、このゲートウェイアドレスに送信されます。これは、別のネットワークへのゲートウェイであるという名前が適切です。\n\n<b>Genmask</b>\n\nこれは、IPアドレスがどの宛先に一致するかを把握するために使用されるサブネットマスクです。\n\n<b>Flags</b>\n\n<ul>\n<li>UG - ネットワークがアップでゲートウェイである</li>\n<li>U - ネットワークがアップ</li>\n</ul>\n\n<b>Iface</b>\n\nこれは、パケットが送信されるインターフェースです。eth0は通常、システム上の最初のEthernetデバイスを表します。",
          "quizAnswer": "Gateway",
          "quizQuestion": "ルーティングテーブルが宛先を知らない場合、パケットはどこにルーティングされますか？",
          "slug": "routingtable",
          "title": "ルーティングテーブル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "<b>パケットがローカルネットワーク内を移動する方法を見てみましょう</b>\n\n<ol>\n<li>最初に、ローカルマシンは、サブネットマスクを見て、宛先IPアドレスが同じサブネット内にあるかどうかを比較します。</li>\n<li>パケットを送信する際には、送信元MACアドレス、宛先MACアドレス、送信元IPアドレス、宛先IPアドレスが必要ですが、この時点では宛先MACアドレスはわかりません。</li>\n<li>宛先ホストに到達するために、ARPを使用して、宛先ホストのMACアドレスを見つけるためにローカルネットワークにリクエストをブロードキャストします。</li>\n<li>これでパケットを正常に送信できます！</li>\n</ol>\n\n<b>パケットがネットワーク外を移動する方法を見てみましょう</b>\n\n<ol>\n<li>最初に、ローカルマシンは宛先IPアドレスを比較しますが、ネットワーク外にあるため、宛先ホストのMACアドレスは見えません。また、ARPを使用することはできません。なぜならARPリクエストはローカルに接続されたホストにブロードキャストされるからです。</li>\n<li>したがって、パケットはルーティングテーブルを参照し、宛先IPのアドレスがわからないため、デフォルトゲートウェイ（別のルーター）に送信されます。したがって、パケットには送信元IP、宛先IP、送信元MACが含まれますが、宛先MACはありません。MACアドレスは同じネットワーク内でのみ到達できることを覚えておいてください。では、どうするのでしょうか？ デフォルトゲートウェイのMACアドレスを取得するためにARPリクエストを送信します。</li>\n<li>ルーターはパケットを見て宛先MACアドレスを確認しますが、これは最終的な宛先IPアドレスではありません。そのため、パケットを次のIPアドレスに転送するためにルーティングテーブルを確認し、パケットを目的地に進めるのに役立つIPアドレスに転送します。パケットが移動するたびに、古い送信元および宛先MACアドレスを剥がし、新しい送信元および宛先MACアドレスでパケットを更新します。</li>\n<li>パケットが同じネットワークに転送されると、最終的な宛先MACアドレスを見つけるためにARPを使用します</li>\n<li>このプロセス中、パケットは送信元または宛先IPアドレスを変更しません。</li>\n</ol>",
          "quizAnswer": "ARP",
          "quizQuestion": "IPアドレスのMACアドレスをどのように見つけますか？",
          "slug": "pathofapacket",
          "title": "パケットの経路"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 4,
          "lessonContent": "ネットワーク上のすべてのデバイスのために手動でルーティングテーブルにルートを設定するのは面倒です。その代わりに、ルーティングプロトコルとして知られるものを使用します。ルーティングプロトコルは、ネットワークの変更に適応するために使用され、異なるルートを学習し、それらをルーティングテーブルに構築してパケットをその経路を通じてルーティングします。主要なルーティングプロトコルのタイプには、ディスタンスベクトルプロトコルとリンクステートプロトコルの2つがあります。\n\n<b>収束</b>\n\nプロトコルについて話す前に、ルーティングで使用される用語である収束について説明します。ルーティングプロトコルを使用すると、ルーターは他のルーターと通信してネットワークに関する情報を収集および交換します。ネットワークがどのように見えるべきかに合意すると、すべてのルーティングテーブルがネットワークの完全なトポロジをマップし、したがって「収束」します。ネットワークトポロジに何かが発生すると、収束は一時的に中断され、すべてのルーターがこの変更に気付くまで再開されません。",
          "quizAnswer": "収束",
          "quizQuestion": "すべてのルーティングテーブルがネットワークトポロジを知っているときに使用される用語は何ですか？",
          "slug": "routingprotocols",
          "title": "ルーティングプロトコル"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 5,
          "lessonContent": "距離ベクトルプロトコルは、パケットがネットワーク全体を横断するホップ数を使用して他のネットワークの経路を決定します。ネットワークAが3ホップ先にあり、ネットワークBがネットワークAの隣にある場合、ネットワークBは4ホップ先にあると仮定されます。距離ベクトルプロトコルでは、次の経路は最もホップ数の少ないものになります。\n\n距離ベクトルプロトコルは小規模ネットワークに適しており、ネットワークが拡大すると収束するのに時間がかかるため、ルーターが定期的に全ルーティングテーブルをすべてのルーターに送信するからです。距離ベクトルプロトコルのもう1つの欠点は効率性で、ホップ数が近い経路を選択しますが、常に最も効率的な経路を選択するわけではありません。\n\n一般的な距離ベクトルプロトコルの1つはRIP（ルーティング情報プロトコル）で、30秒ごとにネットワーク内のすべてのルーターにルーティングテーブルをブロードキャストします。大規模ネットワークの場合、これはかなりのリソースを必要とするため、RIPはホップ数を15に制限しています。",
          "quizAnswer": "false",
          "quizQuestion": "距離プロトコルは、帯域幅が最も少ない経路を使用しますか？",
          "slug": "distancevectorprotocols",
          "title": "距離ベクトルプロトコル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 6,
          "lessonContent": "リンクステートプロトコルは大規模ネットワークに適しており、距離ベクトルプロトコルよりも複雑ですが、収束する能力が速いのが大きな利点です。これは、定期的にルーティングテーブル全体を送信するのではなく、隣接するルートにのみ更新を送信するためです。最短経路を計算するための異なるアルゴリズムを使用し、ネットワークトポロジをグラフの形で構築して、どのルーターが他のルーターに接続されているかを示します。\n\n一般的なリンクステートプロトコルの1つはOSPF（Open Shortest Path First）です。ネットワークに変更があった場合にのみルーティングテーブルを更新します。ホップ制限はありません。",
          "quizAnswer": "OSPF",
          "quizQuestion": "最も一般的なリンクステートプロトコルは何ですか？",
          "slug": "linkstateprotocols",
          "title": "リンクステートプロトコル"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 7,
          "lessonContent": "最後に重要なプロトコルであるBGPについて説明します。BGPは基本的にインターネットの動作原理です。自律システム間でルーティング情報を収集および交換するために使用されます。自律システムは、インターネットサービスプロバイダー、企業、大学、組織などを指します。BGPがなければ、これらのシステムはお互いに通信方法を知らず、孤立してしまいます。自律システム内ではなく、BGPはこれらの自律システム間をルーティングします。\n\nたとえば、自宅のネットワークにいるあなたと、スターバックスで作業している私がいます。私はあなたと通信したいので、メールを送信します。ネットワークパケットはスターバックスのネットワークを経由して移動し、そこでバウンスし、最終的にスターバックスのネットワークのルーティングテーブルを通過して、最終的にスターバックスのネットワークの境界に到達し、Border Gatewayルーターにパケットを渡します。このルーターには、私のパケットがスターバックスのネットワークを離れて他のネットワークを通過するための情報が含まれています。",
          "quizAnswer": "BGP",
          "quizQuestion": "インターネットを動作させる基本的なプロトコルは何ですか？",
          "slug": "bgpbordergatewayprotocol",
          "title": "Border Gateway Protocol"
        }
      ],
      "slug": "routing",
      "title": "ルーティング"
    },
    {
      "description": "Linuxツールを使用したネットワーク構成について学びます！",
      "id": 20,
      "image": "/images/chapters/networkConfiguration.png",
      "lessons": [
        {
          "exercise": "ネットワークインターフェースの状態をupまたはdownに変更して、何が起こるか観察してみてください。\n\nifconfigコマンドとipコマンドの両方を使用して、ネットワークインターフェースを変更できますか？",
          "id": 1,
          "lessonContent": "ネットワークインターフェースは、カーネルがネットワーキングのソフトウェア側とハードウェア側をリンクさせる方法です。これについてはすでに例を見ています:\n\n<pre>\npete@icebox:~$ ifconfig -a\neth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce  \n          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link\n</pre>\n\n<b> ifconfigコマンド</b>\n\n<b>ifconfig</b>ツールを使用すると、ネットワークインターフェースを構成できます。ネットワークインターフェースが設定されていない場合、カーネルのデバイスドライバとネットワークはお互いに通信できません。ifconfigは起動時に実行され、設定ファイルを介してインターフェースを構成しますが、手動で変更することもできます。ifconfigの出力には、インターフェース名が左側に表示され、右側に詳細情報が表示されます。一般的には、eth0（マシン内の最初のイーサネットカード）、wlan0（無線インターフェース）、lo（ループバックインターフェース）という名前のインターフェースが表示されます。ループバックインターフェースはコンピュータを表すために使用され、自分自身に戻します。これはデバッグやローカルで実行されているサーバに接続するために便利です。\n\nインターフェースの状態は、upまたはdownになります。インターフェースを「オフ」にしたい場合は、downに設定できます。ifconfigの出力で最もよく見るフィールドは、HWaddr（インターフェースのMACアドレス）、inet address（IPv4アドレス）、inet6（IPv6アドレス）です。もちろん、サブネットマスクとブロードキャストアドレスも表示されます。また、/etc/network/interfacesでインターフェース情報を表示することもできます。\n\n<b>インターフェースを作成して起動する</b>\n\n<pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>\n\nこれにより、eth0インターフェースにIPアドレスとネットマスクが割り当てられ、さらに起動されます。\n\n<b>インターフェースを起動または停止する</b>\n\n<pre>\n$ ifup eth0\n$ ifdown eth0\n</pre>\n\n<b> ipコマンド </b>\n\n<b>ip</b>コマンドを使用すると、システムのネットワークスタックを操作できます。使用しているディストリビューションによっては、ネットワーク設定を操作するための推奨される方法かもしれません。\n\n以下はその使用例です:\n\n<b>すべてのインターフェースの情報を表示する</b>\n<pre>\n$ ip link show\n</pre>\n\n<b>インターフェースの統計を表示する</b>\n\n<pre>\n$ ip -s link show eth0\n</pre>\n\n\n<b>インターフェースに割り当てられたIPアドレスを表示する</b>\n<pre>\n$ ip address show\n</pre>\n\n<b>インターフェースを起動または停止する</b>\n<pre>\n$ ip link set eth0 up\n$ ip link set eth0 down\n</pre>\n\n<b>インターフェースにIPアドレスを追加する</b>\n<pre>\n$ ip address add 192.168.1.1/24 dev eth0\n</pre>",
          "quizAnswer": "ifconfig",
          "quizQuestion": "ネットワークインターフェースを構成するコマンドは何ですか？",
          "slug": "networkinterfaces",
          "title": "ネットワークインターフェース"
        },
        {
          "exercise": "このレッスンには練習問題はありませんが、ここで説明したコマンドに関する詳細情報は、manページで確認できます。\n\n<pre>$ man route</pre>\n\n<pre>$ man ip-route</pre>",
          "id": 2,
          "lessonContent": "すでに、routeコマンドを使用してルーティングテーブルを表示する方法について説明しました。ルートを追加または削除したい場合は、手動で行うことができます。\n\n<b>新しいルートを追加</b>\n\n<pre>\n$ sudo route add -net 192.168.2.1/23 gw 10.11.12.3\n</pre>\n\n<b>ルートを削除</b>\n\n<pre>\n$ sudo route del -net 192.168.2.1/23 \n</pre>\n\nこれらの変更は、<b>ip</b>コマンドでも実行できます:\n\n<b>ルートを追加する</b>\n<pre>\n$ ip route add 192.168.2.1/23 via 10.11.12.3\n</pre>\n\n<b>ルートを削除する</b>\n<pre>\n$ ip route delete 192.168.2.1/23 via 10.11.12.3\nまたは\n$ ip route delete 192.168.2.1/23\n</pre>",
          "quizAnswer": "del",
          "quizQuestion": "ルートを削除するためのコマンドフラグは何ですか？",
          "slug": "route",
          "title": "ルート"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 3,
          "lessonContent": "以前にDHCPについて説明しましたが、ほとんどの場合、IPアドレス、サブネットマスクなどを静的に設定する必要はありません。代わりに、DHCPを使用します！ dhclientは起動時に起動し、dhclient.confファイルからネットワークインターフェイスのリストを取得します。リストされている各インターフェイスについて、DHCPプロトコルを使用してインターフェイスを構成しようとします。\n\ndhclient.leasesファイルでは、dhclientはシステム再起動を超えてリースのリストを追跡し、dhclient.confを読み込んだ後、dhclient.leasesファイルが読み込まれ、すでに割り当てられているリースを知らせます。\n\n<b>新しいIPを取得するには</b>\n\n<pre>$ sudo dhclient</pre>",
          "quizAnswer": "dhclient",
          "quizQuestion": "どのプログラムがDHCPプロトコルを使用してIPアドレスを割り当てようとしますか？",
          "slug": "dhclient",
          "title": "dhclient"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 4,
          "lessonContent": "もちろん、システムのネットワーキングを自動的に設定したい場合は、すでにそのための仕組みが用意されています。ほとんどのディストリビューションは、ネットワークを自動的に構成するために NetworkManager デーモンを利用しています。\n\nGUI を使用している場合、デスクトップのタスクバーのどこかに NetworkManager のアプレットが表示されているのがわかるでしょう。それはネットワークのハードウェアや接続情報を管理しています。たとえば、起動時に NetworkManager はネットワークハードウェア情報を収集し、ワイヤレス、有線などの接続を検索し、それをアクティブにします。\n\nNetworkManager とやり取りするためのコマンドラインツールもあります:\n\n<b>nm-tool</b>\n\nnm-tool は NetworkManager の状態とデバイスを報告します\n\n<pre>\npete@icebox:/$ nm-tool\nNetworkManager Tool\n\nState: connected (global)\n\n- Device: eth0  [Wired connection 1] -------------------------------------------\n  Type:              Wired\n  Driver:            pcnet32\n  State:             connected\n  Default:           yes\n  HW Address:        12:3D:45:56:7D:CC\n\n  Capabilities:\n    Carrier Detect:  yes\n\n  Wired Properties\n    Carrier:         on\n\n  IPv4 Settings:\n    Address:         192.168.22.1\n    Prefix:          24 (255.255.255.0)\n    Gateway:         192.168.22.2\n\n    DNS:             192.168.22.2\n</pre>\n\n<b>nmcli</b>\n\nnmcli コマンドを使用すると、NetworkManager を制御および変更できます。詳細については man ページを参照してください。",
          "quizAnswer": "nm-tool",
          "quizQuestion": "NetworkManager の情報を表示するコマンドは何ですか？",
          "slug": "networkmanager",
          "title": "ネットワークマネージャ"
        },
        {
          "exercise": "マシンを再起動してからネットワークで何かを行ったときに ARP キャッシュに何が起こるかを観察してください。",
          "id": 5,
          "lessonContent": "ARP を使用して MAC アドレスを検索する際、最初にシステムに保存されている ARP キャッシュを確認します。このキャッシュは実際に表示することができます:\n\n<pre>\npete@icebox:~$ arp\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n192.168.22.1            ether   00:12:24:fc:12:cc   C                     eth0\n192.168.22.254          ether   00:12:45:f2:84:64   C                     eth0\n</pre>\n\nARP キャッシュは実際にはマシンが起動すると空になり、他のホストにパケットが送信されるとデータが追加されます。ARP キャッシュにない宛先にパケットを送信すると、以下のようなことが起こります:\n\n<ol>\n<li>ソースホストは ARP リクエストパケットを含む Ethernet フレームを作成します</li>\n<li>ソースホストはこのフレームをネットワーク全体にブロードキャストします</li>\n<li>ネットワーク内のホストのうち正しい MAC アドレスを知っているホストがあれば、MAC アドレスを含む応答パケットとフレームを送信します</li>\n<li>ソースホストは IP と MAC アドレスのマッピングを ARP キャッシュに追加し、その後パケットの送信を続行します</li>\n</ol>\n\narp キャッシュは ip コマンドを使用して表示することもできます:\n\n<pre>\n$ ip neighbour show\n</pre>",
          "quizAnswer": "arp",
          "quizQuestion": "ARP キャッシュを表示するために使用できるコマンドは何ですか？",
          "slug": "arpcommand",
          "title": "arp"
        }
      ],
      "slug": "networkconfig",
      "title": "ネットワーク構成"
    },
    {
      "description": "一般的なネットワークツールについて学び、問題の診断とトラブルシューティングをサポートします！",
      "id": 21,
      "image": "/images/chapters/networkTroubleshooting.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 1,
          "lessonContent": "Internet Control Message Protocol（ICMP）はTCP/IPプロトコルスイートの一部であり、更新とエラーメッセージを送信するために使用され、パケットの配信に失敗したネットワークの問題をデバッグするために非常に役立つプロトコルです。\n\n各ICMPメッセージには、タイプ、コード、およびチェックサムフィールドが含まれています。タイプフィールドはICMPメッセージのタイプであり、コードはサブタイプであり、メッセージに関する詳細情報を記述し、チェックサムはメッセージの整合性に問題がないかを検出するために使用されます。\n\nいくつかの一般的なICMPタイプを見てみましょう:\n\n<ul>\n<li>タイプ0 - エコーリプライ</li>\n<li>タイプ3 - 宛先到達不能</li>\n<li>タイプ8 - エコーリクエスト</li>\n<li>タイプ11 - 時間切れ</li>\n</ul>\n\nパケットが宛先に到達できない場合、タイプ3のICMPメッセージが生成されます。タイプ3には、宛先に到達できない理由をさらに説明する16個のコード値があります:\n\n<ul>\n<li>コード0 - ネットワークに到達できません</li>\n<li>コード1 - ホストに到達できません</li>\nなどなど\n</ul>\n\nこれらのメッセージは、ネットワークトラブルシューティングツールを使用するとより理解できるでしょう。",
          "quizAnswer": "8",
          "quizQuestion": "エコーリクエストのICMPタイプは何ですか？",
          "slug": "icmp",
          "title": "ICMP"
        },
        {
          "exercise": "ウェブサイトに ping を実行し、受信した出力を確認してください。",
          "id": 2,
          "lessonContent": "最もシンプルなネットワーキングツールの1つである <b>ping</b> は、パケットがホストに到達できるかどうかをテストするために使用されます。これは、ICMPエコーリクエスト（タイプ8）パケットを宛先ホストに送信し、ICMPエコーリプライ（タイプ0）を待機することで機能します。ホストがリクエストパケットを送信し、ターゲットからの応答を受信した場合、Ping は成功です。例を見てみましょう：\n\n<pre>\npete@icebox:~$ ping -c 3 www.google.com\nPING www.google.com (74.125.239.112) 56(84) bytes of data.\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=1 ttl=128 time=29.0 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=2 ttl=128 time=23.7 ms\n64 bytes from nuq05s01-in-f16.1e100.net (74.125.239.112): icmp_seq=3 ttl=128 time=15.1 ms\n</pre>\n\nこの例では、www.google.com に到達できるかどうかを確認するために ping を使用しています。-c フラグ（カウント）は、指定された回数のエコーリクエストパケットを送信した後に送信を停止するために使用されます。\n\n最初の部分では、74.125.239.112（google.com）に64バイトのパケットを送信しており、残りの部分では旅行の詳細を示しています。デフォルトでは、1秒ごとに1つのパケットが送信されます。\n\n<b>icmp_seq</b>\n\nicmp_seq フィールドは、送信されたパケットのシーケンス番号を示すために使用されます。この場合、3つのパケットを送信し、3つのパケットが戻ってきたことがわかります。ping を実行してシーケンス番号が欠落している場合、接続の問題が発生しており、すべてのパケットが通過していないことを意味します。シーケンス番号が順番通りでない場合、接続はおそらく非常に遅くなっており、パケットが1秒のデフォルトを超えています。\n\n<b>ttl</b>\n\nTime To Live（TTL）フィールドは、ホップカウンターとして使用され、ホップを行うたびにカウンターが1つ減少し、ホップカウンターが0に達すると、パケットが破棄されます。これは、パケットに寿命を与えるためのものであり、パケットが永遠に旅行することは望ましくありません。\n\n<b>time</b>\n\nエコーリクエストパケットの送信からエコーリプライを受信するまでの往復時間。",
          "quizAnswer": "ms",
          "quizQuestion": "往復時間の単位は何ですか？",
          "slug": "ping",
          "title": "ping"
        },
        {
          "exercise": "自分のマシンでtracerouteコマンドを実行し、出力を観察してください。",
          "id": 3,
          "lessonContent": "tracerouteコマンドは、パケットの経路を確認するために使用されます。TTL値を増やしながらパケットを送信することで動作します。最初のルーターはパケットを受け取り、TTL値を1減算してパケットを破棄します。その後、ルーターはICMP Time Exceededメッセージを返します。次のパケットはTTLが2になるため、最初のルーターを通過しますが、2番目のルーターに到達するとTTLが0になり、別のICMP Time Exceededメッセージが返されます。Tracerouteは、パケットを送信して破棄することで、パケットが通過するルーターのリストを構築し、最終的に宛先に到達してICMP Echo Replyメッセージを受信します。\n\n以下はtracerouteの一部です：\n\n<pre>\n$ traceroute google.com\ntraceroute to google.com (216.58.216.174), 30 hops max, 60 byte packets\n 1  192.168.4.254 (192.168.4.254)  0.028 ms  0.009 ms  0.008 ms\n 2  100.64.1.113 (100.64.1.113)  1.227 ms  1.226 ms 0.920 ms\n 3  100.64.0.20 (100.64.0.20)  1.501 ms 1.556 ms  0.855 ms\n</pre>\n\n各行は、自分と目標の間にあるルーターまたは機器を示しています。ターゲットの名前とIPアドレスが表示され、最後の3つの列はそのルーターまでのパケットのラウンドトリップ時間に対応しています。デフォルトでは、経路に沿って3つのパケットを送信します。",
          "quizAnswer": "ttl",
          "quizQuestion": "ネットワークを横断する際に1つずつ減算されるのは何ですか？",
          "slug": "traceroute",
          "title": "traceroute"
        },
        {
          "exercise": "netstat の man ページを参照して、提供されているすべての機能を学んでください。",
          "id": 4,
          "lessonContent": "<b>Well Known Ports</b>\n\nマシン上のポートを介したデータ転送について説明しましたが、いくつかのよく知られたポートを見てみましょう。\n\n<b>/etc/services</b> ファイルを見ることでよく知られたポートのリストを取得できます：\n\n<pre>\nftp             21/tcp\nssh             22/tcp\nsmtp            25/tcp \ndomain          53/tcp  # DNS\nhttp            80/tcp\nhttps           443/tcp\n..etc..\n</pre>\n\n最初の列はサービスの名前で、次にポート番号と使用されるトランスポート層プロトコルが表示されます。\n\n<b>netstat</b>\n\nネットワークに関する詳細な情報を取得するための非常に便利なツールは <b>netstat</b> です。Netstat は、ネットワーク接続、ルーティングテーブル、ネットワークインターフェースに関する情報など、さまざまなネットワーク関連情報を表示します。ネットワークツールのスイスアーミーナイフです。netstat が持つ主な機能の1つであるネットワーク接続の状態に焦点を当てます。例を見る前に、まずソケットとポートについて話しましょう。ソケットはプログラムがデータの送受信を行うためのインターフェースであり、ポートはどのアプリケーションがデータの送受信を行うかを識別するために使用されます。ソケットアドレスは IP アドレスとポートの組み合わせです。ホストと宛先の間のすべての接続にはユニークなソケットが必要です。たとえば、HTTP はポート 80 で実行されるサービスですが、多くの HTTP 接続が可能であり、それぞれの接続を維持するために接続ごとにソケットが作成されます。\n\n<pre>\npete@icebox:~$ netstat -at\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State      \ntcp        0      0 icebox:domain           *:*                     LISTEN     \ntcp        0      0 localhost:ipp           *:*                     LISTEN     \ntcp        0      0 icebox.lan:44468        124.28.28.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34751        124.28.29.50:http       TIME_WAIT  \ntcp        0      0 icebox.lan:34604        economy.canonical.:http TIME_WAIT  \ntcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     \ntcp6       1      0 ip6-localhost:35094     ip6-localhost:ipp       CLOSE_WAIT \ntcp6       0      0 ip6-localhost:ipp       ip6-localhost:35094     FIN_WAIT2\n</pre>\n\nnetstat -a コマンドはネットワーク接続のリスニングおよび非リスニングソケットを表示し、-t フラグは TCP 接続のみを表示します。\n\n左から右への列は次のとおりです：\n\n<ul>\n<li>Proto: 使用されているプロトコル、TCP または UDP。</li>\n<li>Recv-Q: 受信待ちのデータ</li>\n<li>Send-Q: 送信待ちのデータ</li>\n<li>Local Address: ローカルに接続されたホスト</li>\n<li>Foreign Address: リモートに接続されたホスト</li>\n<li>State: ソケットの状態</li>\n</ul>\n\nソケットの状態のリストについては man ページを参照してくださいが、いくつかの状態を以下に示します：\n\n<ul>\n<li>LISTENING: ソケットは着信接続を待機しています。TCP 接続を確立する前に、接続先が私たちを待機している必要があります。</li>\n<li>SYN_SENT: ソケットは接続を確立しようとしています。</li>\n<li>ESTABLISHED: ソケットには確立された接続があります</li>\n<li>CLOSE_WAIT: リモートホストがシャットダウンし、私たちはソケットが閉じるのを待っています</li>\n<li>TIME_WAIT: ネットワーク内にまだ存在するパケットを処理するために、ソケットは閉じた後に待機しています</li>\n </ul>",
          "quizAnswer": "443",
          "quizQuestion": "HTTPS に使用されるポートは何番ですか？",
          "slug": "netstat",
          "title": "netstat"
        },
        {
          "exercise": "Wireshark ツールをダウンロードしてインストールし、インタフェースを操作してみてください。",
          "id": 5,
          "lessonContent": "パケット解析の話題は独自のコースを埋めるほど多くの書籍があります。ただし、今日は基本のみを学びます。非常に人気のあるパケット解析ツールには、Wireshark と tcpdump があります。これらのツールはネットワークインターフェースをスキャンし、パケットアクティビティをキャプチャし、パケットを解析して情報を出力します。これにより、ネットワーク解析の詳細な部分や低レベルの情報にアクセスできます。私たちは、インターフェースがシンプルなため tcpdump を使用しますが、ツールベルトにパケット解析を追加する場合は Wireshark を検討することをお勧めします。\n\n<b>tcpdump のインストール</b>\n\n<pre>\n$ sudo apt install tcpdump\n</pre>\n\n<b>インターフェースでパケットデータをキャプチャする</b>\n\n<pre>\npete@icebox:~$ sudo tcpdump -i wlan0\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n11:28:24.960464 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 3, length 64\n11:28:24.979299 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 3, length 64\n11:28:25.961869 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 4, length 64\n11:28:25.976176 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 4, length 64\n11:28:26.963667 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 5, length 64\n11:28:26.976137 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 5, length 64\n11:28:30.674953 ARP, Request who-has 172.254.1.0 tell ThePickleParty.lan, length 28\n11:28:31.190665 IP ThePickleParty.lan.51056 > 192.168.86.255.rfe: UDP, length 306\n</pre>\n\nパケットキャプチャを実行すると多くの情報が表示されますが、背景で多くのネットワークアクティビティが発生しているためです。上記の例では、www.google.com に ping を実行した時のキャプチャの一部だけを取得しました。\n\n<b>出力の理解</b>\n\n<pre>\n11:28:23.958840 IP icebox.lan > nuq04s29-in-f4.1e100.net: ICMP echo request, id 1901, seq 2, length 64\n11:28:23.970928 IP nuq04s29-in-f4.1e100.net > icebox.lan: ICMP echo reply, id 1901, seq 2, length 64\n</pre>\n\n<ul>\n<li>最初のフィールドはネットワークアクティビティのタイムスタンプです</li>\n<li>IP はプロトコル情報を含みます</li>\n<li>次に、ソースと宛先アドレスが表示されます: icebox.lan > nuq04s29-in-f4.1e100.net</li>\n<li>seq は TCP パケットの開始と終了のシーケンス番号です</li>\n<li>length はバイト数です</li>\n</ul>\n\ntcpdump の出力からわかるように、www.google.com に ICMP エコーリクエストパケットを送信し、ICMP エコーリプライパケットを受信しています！また、異なるパケットには異なる情報が出力されることに注意してください。詳細は man ページを参照してください。\n\n<b>tcpdump の出力をファイルに書き込む</b>\n\n<pre>\n$ sudo tcpdump -w /some/file\n</pre>\n\n最後に: パケット解析の話題はまだ表面をかいただけです。さらに深く Hex と ASCII の出力を探ることもできます。パケット解析ツールについてさらに学ぶためのオンラインリソースがたくさんありますので、ぜひ見つけてみてください！",
          "quizAnswer": "-i",
          "quizQuestion": "tcpdump で特定のインタフェースをキャプチャするフラグは何ですか？",
          "slug": "packetanalysis",
          "title": "Packet Analysis"
        }
      ],
      "slug": "networktroubleshooting",
      "title": "トラブルシューティング"
    },
    {
      "description": "DNS について知りたかったすべてともっともの。",
      "id": 22,
      "image": "/images/chapters/dns.png",
      "lessons": [
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 1,
          "lessonContent": "Googleで検索をするたびに、www.google.comの代わりにhttp://192.78.12.4を入力しなければならなかったらどうでしょうか。それがDNS（\"Domain Name System\"）がないと起こることです。低レベルのネットワーキングは、ホストを識別するために生のIPアドレスしか理解しません。DNSによって、私たち人間はIPアドレスの代わりにウェブサイトやホストを名前で追跡できるようになります。それはインターネットの連絡先リストのようなものです。誰かの名前はわかるけれども電話番号がわからない場合、連絡先リストを見るだけで済みます。\n\nDNSは基本的にホスト名からIPアドレスへの分散データベースです。私たちは自分たちのデータベースを管理して、他の人が私たちのサイト/ドメインにアクセスする方法を知ってもらいます。他の場所では別の人が自分のデータベースを管理して、他の人がそのドメインにアクセスできるようにします。これらのドメインはお互いに通信し、インターネットの巨大な連絡先リストを構築できます。\n\nこのコースでは、DNSの基本をいくつか説明しますが、DNSは包括的なトピックであり、本当に詳しく学びたい場合は追加の研究が必要です。",
          "quizAnswer": "false",
          "quizQuestion": "真偽を問わず、DNSはホスト名のMACアドレスを見つけるのに役立ちますか？",
          "slug": "whatisdns",
          "title": "DNSとは何ですか？"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 2,
          "lessonContent": "インターネットのDNSデータベースは、サイトや組織がそのデータベースの一部を提供することに依存しています。そのためには、次のものが必要です:\n\n<b>ネームサーバ</b>\n\n私たちは\"ネームサーバ\"を介してDNSを設定します。ネームサーバは、私たちのDNS設定と構成を読み込み、クライアントや他のサーバからの質問に答えます。ネームサーバがそのクエリの答えを知らない場合、リクエストを他のネームサーバにリダイレクトします。ネームサーバは\"権威ある\"ことができ、それは実際に探しているDNSレコードを保持していることを意味し、また\"再帰的\"であることができ、他のサーバに尋ね、そのサーバが他のサーバに尋ねて、権威あるサーバを見つけるまで続けます。再帰サーバは、権威あるサーバに到達する代わりに、求める情報をキャッシュすることもできます。\n\n<b>ゾーンファイル</b>\n\nネームサーバ内には、ゾーンファイルと呼ばれるものが存在します。ゾーンファイルは、ドメインに関する情報やそのドメインへのアクセス方法について情報を格納する方法です。\n\n<b>リソースレコード</b>\n\nゾーンファイルは、リソースレコードのエントリで構成されています。各行はレコードであり、ホスト、ネームサーバ、その他のリソースなどに関する情報を含んでいます。フィールドには以下が含まれます:\n\n<ul>\n<li>レコード名</li>\n<li>TTL - レコードを破棄して新しいレコードを取得するまでの時間。DNSではTTLが時間で表され、レコードには1時間のTTLがあることがあります。これを行う理由は、インターネットが常に変化しているためです。ホストがX IPアドレスにマップされている一分後にはY IPアドレスになることがあります。</li>\n<li>クラス - レコード情報の名前空間。インターネットでは一般的にINが使用されます。</li>\n<li>タイプ - レコードデータに格納されている情報の種類。レコードタイプについては詳しく説明しませんが、A（アドレス）、MX（メールエクスチェンジャー）などの一般的なものを見たことがあるかもしれません。</li>\n<li>データ - このフィールドには、Aレコードの場合はIPアドレス、その他のレコードタイプに応じて他の情報が含まれることがあります。</li>\n</ul>\n<pre>\npatty    IN  A      192.168.0.4 \n</pre>",
          "quizAnswer": "MX",
          "quizQuestion": "メールエクスチェンジャーに使用されるリソースレコードタイプは何ですか？",
          "slug": "dnscomponents",
          "title": "DNSコンポーネント"
        },
        {
          "exercise": "このレッスンには練習問題はありません。",
          "id": 3,
          "lessonContent": "ホストがDNSを使用してドメイン（catzontheinterwebz.com）を見つける例を見てみましょう。基本的に、私たちはそのドメインを知っているDNSサーバーに到達するまで、階層的に進んでいきます。\n\n<b>ローカルDNSサーバー</b>\n\nまず、私たちのホストは「catzontheinterwebz.comはどこですか？」と尋ねますが、ローカルDNSサーバーはわからないので、ファンネルの先頭からRootサーバーに尋ねるために動き始めます。私たちのホストはcatzontheinterwebz.comを直接見つけるためにこれらのリクエストを行っていません。ほとんどのユーザーは、自分のISPが提供する再帰DNSサーバーに話しかけ、そのサーバーがcatzontheinterwebz.comの場所を見つけるように指示されます。\n\n<b>Rootサーバー</b>\n\nインターネットには13個のRootサーバーがあり、DNSリクエストを処理するために世界中にミラーリングされ、分散されています。実際には何百ものサーバーが稼働しており、異なる組織によって制御されています。これらのサーバーにはトップレベルドメインに関する情報が含まれています。トップレベルドメインとは、.org、.com、.netなどのアドレスのことです。したがって、Rootサーバーはcatzontheinterwebz.comの場所を知らないため、.comトップレベルドメインDNSサーバーに問い合わせるように指示します。\n\n<b>トップレベルドメイン</b>\n\n次に、\".com\"アドレスについて知っている名前サーバーに別のリクエストを送信し、catzontheinterwebz.comの場所を知っているか尋ねます。TLDにはcatzontheinterwebz.comがゾーンファイルに含まれていませんが、catzontheinterwebz.comの名前サーバーのレコードが見つかります。したがって、その名前サーバーのIPアドレスを教えてくれ、そこに問い合わせるように指示されます。\n\n<b>権威あるDNSサーバー</b>\n\n最後に、実際に欲しいレコードを持っているDNSサーバーに最終リクエストを送信します。名前サーバーはcatzontheinterwebz.comのゾーンファイルを持っており、このホストの 'www' のリソースレコードがあることを確認します。その後、このホストのIPアドレスを教えてくれ、ついにインターネット上でいくつかの猫を見ることができます。",
          "quizAnswer": "TLD",
          "quizQuestion": "「.com、.net、.orgなどのアドレスが見つかるネームサーバーの略称は何ですか？」",
          "slug": "dnsprocess",
          "title": "DNSプロセス"
        },
        {
          "exercise": "このレッスンには演習はありません。",
          "id": 4,
          "lessonContent": "<p>実際にマシンがDNSにクエリを送信する前に、まずローカルでマシンを確認します。</p><br><p><b>/etc/hosts</b></p><p>/etc/hostsファイルには、いくつかのホスト名とIPアドレスのマッピングが含まれています。フィールドはかなり自明です。IPアドレス、ホスト名、そしてホストのエイリアスがあります。</p><pre>pete@icebox:~$ cat /etc/hosts<br>127.0.0.1       localhost<br>127.0.1.1       icebox</pre><p>通常、このファイルにはローカルホストアドレスがデフォルトでリストされています。また、/etc/hosts.denyや/etc/hosts.allowファイルを変更することでホストへのアクセスを管理することもできます。ただし、セキュリティに気を配る場合、これはあまり適切な方法ではなく、代わりにファイアウォールルールを変更するべきです。</p><p>/etc/hostsの面白い例を見てみましょう。ファイルを変更して次の行を追加してください：</p><pre>123.45.6.7  www.google.com</pre><p>ファイルを保存して、www.google.comに移動してみてください。問題が発生していますね？それは、www.google.comを完全に間違ったIPアドレスにマッピングしたからです。ホストは最初にIPアドレスのマッピングをローカルで検索するため、google.comを見つけるためにDNSに到達しません。</p><p><b>/etc/resolv.conf</b></p><p>従来、より効率的なルックアップのためにDNS名前サーバーをマップするために/etc/resolv.confファイルを使用していましたが、DNSの改善により、このファイルはしばしば無関係です。実際、以下の例で示すように、/etc/resolv.confは手動で管理されていません。DNS名前サーバーのマッピングを管理するには、ディストリビューション固有の設定を参照してください。</p><pre>conf(5) file for glibc resolver(3) generated by resolvconf(8)<br>#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN<br>nameserver 127.0.1.1<br>search localdomain</pre>",
          "quizAnswer": "/etc/hosts",
          "quizQuestion": "マシン上でホスト名をIPアドレスにマップするために使用されるファイルは何ですか？",
          "slug": "etchosts",
          "title": "/etc/hosts"
        },
        {
          "exercise": "このレッスンには演習問題はありません。",
          "id": 5,
          "lessonContent": "DNSサーバーの設定方法については詳細なチュートリアルになるため、ここでは人気のあるDNSサーバーの簡単な比較リストを紹介します。\n\n<b>BIND</b>\n\nインターネットで最も人気のあるDNSサーバーであり、Linuxディストリビューションで使用されている標準です。もともとカリフォルニア大学バークレー校で開発されたものであり、そのためにBIND（バークレーインターネットネームドメイン）という名前が付けられました。機能が豊富で柔軟性が必要な場合は、BINDを選択するのが正解です。\n\n<b>DNSmasq</b>\n\nBINDよりも軽量で設定が簡単です。BINDのすべての機能が必要なく、シンプルさを求める場合はDNSmasqを使用してください。DHCPとDNSの設定に必要なすべてのツールが付属しており、小規模ネットワーク向けに推奨されています。\n\n<b>PowerDNS</b>\n\nBINDに似て機能が豊富で、より柔軟性のあるオプションを提供します。MySQL、PostgreSQLなどの複数のデータベースから情報を読み取り、管理を容易にします。これまでBINDが主流だったからといって、それが続く必要はありません。\n\nこれは完全なリストではありませんが、自分自身のDNSサーバーを設定する際の参考になるでしょう。",
          "quizAnswer": "BIND",
          "quizQuestion": "Linuxにおける事実上のDNSサーバーは何ですか？",
          "slug": "dnssetup",
          "title": "DNSのセットアップ"
        },
        {
          "exercise": "digのmanページを読んでください。",
          "id": 6,
          "lessonContent": "<b>nslookup</b>\n\n\"名前サーバールックアップ\"ツールは、リソースレコードに関する情報を検索するために名前サーバーにクエリを送信するために使用されます。google.comの名前サーバーがどこにあるかを見つけましょう。\n\n<pre>\npete@icebox:~$ nslookup www.google.com\nServer:         127.0.1.1\nAddress:        127.0.1.1#53\n\nNon-authoritative answer:\nName:   www.google.com\nAddress: 216.58.192.4\n</pre>\n\n<b>dig</b>\n\nDig（ドメイン情報グローパー）は、DNS名前サーバーに関する情報を取得するための強力なツールであり、nslookupよりも柔軟性があり、DNSの問題のトラブルシューティングに適しています。\n\n\n<pre>\npete@icebox:~$ dig www.google.com\n\n; <<>> DiG 9.9.5-3-Ubuntu <<>> www.google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42376\n;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; MBZ: 0005 , udp: 512\n;; QUESTION SECTION:\n;www.google.com.                        IN      A\n\n;; ANSWER SECTION:\nwww.google.com.         5       IN      A       74.125.239.147\nwww.google.com.         5       IN      A       74.125.239.144\nwww.google.com.         5       IN      A       74.125.239.146\nwww.google.com.         5       IN      A       74.125.239.145\nwww.google.com.         5       IN      A       74.125.239.148\n\n;; Query time: 27 msec\n;; SERVER: 127.0.1.1#53(127.0.1.1)\n;; WHEN: Sun Feb 07 10:14:00 PST 2016\n;; MSG SIZE  rcvd: 123\n</pre>",
          "quizAnswer": "dig",
          "quizQuestion": "DNS名前サーバーに関する詳細情報を取得するために使用されるツールは何ですか？",
          "slug": "dnstools",
          "title": "DNSツール"
        }
      ],
      "slug": "dns",
      "title": "DNS"
    }
  ],
  "common": {
    "chapterWrapper": {
      "content": "コンテンツ",
      "exerciseAndQuiz": "演習とクイズ"
    },
    "exerciseBox": {
      "exercise": "演習"
    },
    "hero": {
      "image": "/images/penguinLaptop.png",
      "subtitle": "Linuxの世界に初めて足を踏み入れる多くの人々を助けてきたLinuxJourneyの新しい生活。",
      "title": "Linuxの力を解放する"
    },
    "navbar": {
      "home": "ホーム",
      "language": "言語",
      "lessons": "レッスン",
      "resources": "リソース",
      "siteName": "Linux Path"
    },
    "quizBox": {
      "backToChapters": "チャプターに戻る",
      "checkAnswer": "回答を確認",
      "correctAnswer": "正解：",
      "nextLesson": "次のレッスン",
      "placeholderAnswer": "ここに回答を入力",
      "quiz": "クイズ",
      "showCorrectAnswer": "正しい回答を表示"
    },
    "resources": {
      "data": [
        {
          "description": "端末の歴史と基本コマンドの説明を行う初心者向けのステップバイステップガイド",
          "href": "https://ubuntu.com/tutorials/command-line-for-beginners",
          "image": "/images/link.png",
          "title": "公式Ubuntuチュートリアル"
        },
        {
          "description": "端末の動作の明確な概要、コマンドの実行方法、ファイルシステムのナビゲーション方法。",
          "href": "https://digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal",
          "image": "/images/link.png",
          "title": "DigitalOcean"
        },
        {
          "description": "最も高く評価されている本の1つ！",
          "href": "https://www.amazon.com/gp/product/1593275676/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275676&linkCode=as2&tag=linuxjourne0c-20&linkId=a8c48da327d15530a7214f453d5a55da",
          "image": "/images/book.png",
          "title": "How Linux Works"
        },
        {
          "description": "すべてのSysAdminにとって非常に包括的な本。",
          "href": "https://www.amazon.com/gp/product/0131480057/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0131480057&linkCode=as2&tag=linuxjourne0c-20&linkId=de7ed3d4e4bf2c29b637855e351cffd2",
          "image": "/images/book.png",
          "title": "UNIX and Linux System Administration Handbook"
        },
        {
          "description": "シェルスクリプトの包括的なガイド。",
          "href": "https://www.amazon.com/gp/product/111898384X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=111898384X&linkCode=as2&tag=linuxjourne0c-20&linkId=41767d3a073f8d20ff0db23bb11a2ac7",
          "image": "/images/book.png",
          "title": "Linux Command Bible"
        },
        {
          "description": "真剣なLinuxユーザー向け、カーネルプログラミングへの素晴らしいスタート。",
          "href": "https://www.amazon.com/gp/product/1593272200/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593272200&linkCode=as2&tag=linuxjourne0c-20&linkId=5d63b12b27c4106a518799e42a9c379d",
          "image": "/images/book.png",
          "title": "The Linux Programming Interface: A Linux and UNIX System"
        }
      ],
      "hero": {
        "image": "/images/penguinBook.png",
        "subtitle": "キュレーションされた書籍、チュートリアル、ツールを発見し、Linuxの知識を深める。",
        "title": "リソース"
      },
      "title": "リソース"
    }
  }
}