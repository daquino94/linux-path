{
  "id": 3,
  "title": "系统调用",
  "lessonContent": "还记得上一课中的 Britney 吗？假设我们想见她并一起喝点东西，我们要如何从站在人群中的室外到进入她最内圈呢？我们会使用系统调用。系统调用就像 VIP 通行证，让你直接进入通往 Britney 的秘密侧门。\n\n系统调用（syscall）为用户空间进程提供了一种请求内核为我们执行某些操作的方式。内核通过系统调用 API 提供了某些服务。这些服务允许我们读取或写入文件，修改内存使用情况，修改网络等。服务的数量是固定的，因此你不能随意添加系统调用，你的系统已经有一个包含了存在的系统调用以及每个系统调用都有唯一 ID 的表。\n\n我不会深入讲解系统调用的细节，因为那需要你了解一点 C 语言，但基本原理是，当你调用像 ls 这样的程序时，程序内部的代码包含了一个系统调用包装器（而不是实际的系统调用）。在这个包装器内部，它调用了系统调用，这将执行一个陷阱，然后这个陷阱被系统调用处理程序捕捉，然后引用系统调用表中的系统调用。假设我们正在尝试调用 stat() 系统调用，它由一个 syscall ID 标识，stat() 系统调用的目的是查询文件的状态。现在记住，你是以非特权模式运行 ls 程序。所以现在它看到你正在尝试进行系统调用，然后将你切换到内核模式，在那里它会做很多事情，但最重要的是查找你的系统调用号码，根据 syscall ID 在表中找到它，然后执行你想要运行的函数。完成后，它将返回到用户模式，你的进程将接收到一个返回状态，指示操作是否成功或是否出现错误。系统调用的内部工作非常详细，如果你想了解更多，我建议在网上查找相关信息。\n\n你可以使用 strace 命令查看进程所进行的系统调用。strace 命令对于调试程序执行方式非常有用。\n\n<pre>$ strace ls</pre>",
  "exercise": "本课程没有练习。",
  "quizQuestion": "用什么来从用户模式切换到内核模式？",
  "quizAnswer": "系统调用",
  "slug": "systemcalls"
}