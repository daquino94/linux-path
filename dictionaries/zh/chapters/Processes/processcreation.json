{
  "id": 4,
  "title": "进程创建",
  "lessonContent": "再次强调，本课程和下一课程纯粹是信息，让您了解底层情况，欢迎在更多处理进程的实践后再回顾此内容。\n\n当创建新进程时，现有进程基本上通过一种称为 fork 系统调用（系统调用将在很远的将来讨论）来克隆自身。fork 系统调用创建一个几乎相同的子进程，这个子进程获得一个新的进程 ID（PID），原始进程成为其父进程，并具有称为父进程 ID PPID 的内容。之后，子进程可以继续使用其父进程之前使用的相同程序，或者更常见的是使用 execve 系统调用启动一个新程序。这个系统调用会破坏内核为该进程设置的内存管理，并为新程序设置新的内存管理。\n\n我们可以看到这一过程：\n\n<pre>$ ps l</pre>\n\n选项 l 为我们提供了一个“长格式”或更详细的运行进程视图。您会看到一个标有 PPID 的列，这是父进程 ID。现在看看您的终端，您会看到一个正在运行的进程，那就是您的 shell，所以在我的系统上，我有一个正在运行 bash 的进程。现在回想一下，当您运行 ps l 命令时，您是从运行 bash 的进程中运行的。现在您会看到 bash shell 的 PID 是 ps l 命令的 PPID。\n\n因此，如果每个进程都必须有一个父进程，并且它们只是彼此的分支，那么必须有一个所有进程的母进程，对吧？您是正确的，系统启动时，内核会创建一个名为 init 的进程，它的 PID 为 1。init 进程无法终止，除非系统关闭。它以 root 权限运行，并运行许多保持系统运行的进程。我们将在系统引导课程中更仔细地研究 init，现在只需知道它是生成所有其他进程的进程即可。",
  "exercise": "查看您正在运行的进程，您能看到哪些进程有父进程吗？",
  "quizQuestion": "哪个系统调用会创建一个新进程？",
  "quizAnswer": "fork",
  "slug": "processcreation"
}