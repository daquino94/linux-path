{
  "id": 5,
  "title": "Прекращение процесса",
  "lessonContent": "Теперь, когда мы знаем, что происходит при создании процесса, что происходит, когда нам он больше не нужен? Будьте предупреждены, иногда Linux может стать немного мрачным...\n\nПроцесс может завершиться с помощью системного вызова _exit, это освободит ресурсы, которые процесс использовал для повторного выделения. Поэтому, когда процесс готов к завершению, он сообщает ядру, почему он завершается, с помощью чего-то, называемого статусом завершения. Наиболее распространенный статус 0 означает, что процесс завершился успешно. Однако этого недостаточно для полного завершения процесса. Родительский процесс должен подтвердить завершение дочернего процесса, используя системный вызов wait, который проверяет статус завершения дочернего процесса. Я знаю, что довольно мрачно думать об этом, но вызов wait - это необходимость, в конце концов, какой родитель не хотел бы знать, как умер его ребенок?\n\nСуществует еще один способ завершения процесса, который включает использование сигналов, о которых мы скоро поговорим.\n\n<b>Сиротские процессы</b>\n\nКогда родительский процесс умирает до дочернего процесса, ядро понимает, что не получит вызов wait, поэтому оно делает эти процессы \"сиротами\" и передает их под опеку init (помните мать всех процессов). В конечном итоге init выполнит системный вызов wait для этих сирот, чтобы они могли умереть.\n\n<b>Зомби-процессы</b>\n\nЧто происходит, когда дочерний процесс завершается, а родительский процесс еще не вызвал wait? Мы все равно хотим видеть, как завершился дочерний процесс, поэтому, даже если дочерний процесс завершился, ядро превращает его в зомби-процесс. Ресурсы, которые использовал дочерний процесс, все еще освобождаются для других процессов, однако в таблице процессов все еще есть запись об этом зомби. Зомби-процессы также не могут быть убиты, поскольку они технически \"мертвы\", поэтому их нельзя убить сигналами. В конце концов, если родительский процесс вызывает системный вызов wait, зомби исчезнет, это известно как \"пожинание\". Если родитель не делает вызов wait, init усыновит зомби и автоматически выполнит wait и удалит зомби. Бывает плохо иметь слишком много зомби-процессов, поскольку они занимают место в таблице процессов, и если она заполнится, это помешает запуску других процессов.",
  "exercise": "Урок не содержит упражнений.",
  "quizQuestion": "Какой наиболее распространенный статус завершения для успешного процесса?",
  "quizAnswer": "0",
  "slug": "processtermination"
}