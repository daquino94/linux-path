{
  "id": 5,
  "title": "プロセスの終了",
  "lessonContent": "プロセスが作成される際に何が起こるかを知ったので、それが不要になったときに何が起こっているのでしょうか？覚悟してください、時々Linuxは少し暗くなることがあります...\n\nプロセスは _exit システムコールを使用して終了することができ、これによりそのプロセスが使用していたリソースが再割り当てされます。したがって、プロセスが終了する準備ができたときに、終了ステータスというものでカーネルになぜ終了するのかを知らせます。一般的に、ステータス 0 はプロセスが成功したことを意味します。ただし、プロセスを完全に終了させるにはそれだけでは不十分です。親プロセスは、子プロセスの終了を認識するために wait システムコールを使用する必要があります。これにより、子プロセスの終了ステータスが確認されます。考えるのは残酷かもしれませんが、wait コールは必要不可欠です。やはり、どの親も自分の子供がどのように死んだのか知りたくないでしょうか？\n\nプロセスを終了する別の方法があり、それはシグナルを使用することです。これについては近々説明します。\n\n<b>孤児プロセス</b>\n\n親プロセスが子プロセスよりも先に終了した場合、カーネルは wait コールを受け取らないことを知ります。そのため、これらのプロセスを「孤児」として扱い、init（すべてのプロセスの母）の管理下に置きます。Init は最終的にこれらの孤児のために wait システムコールを実行して終了させます。\n\n<b>ゾンビプロセス</b>\n\n子プロセスが終了し、親プロセスがまだ wait を呼び出していない場合、子プロセスがどのように終了したかを確認したいと思います。したがって、子プロセスが終了したにもかかわらず、カーネルは子プロセスをゾンビプロセスに変えます。子プロセスが使用したリソースは他のプロセスに引き継がれますが、このゾンビのためにプロセステーブルにエントリが残ります。ゾンビプロセスは「死んでいる」ため、シグナルを使用して殺すことはできません。最終的に親プロセスが wait システムコールを呼び出すと、ゾンビは消えます。これを「リーピング」と呼びます。親プロセスが wait コールを実行しない場合、init がゾンビを引き取り、自動的に wait を実行してゾンビを削除します。ゾンビプロセスが多すぎると問題になることがあります。プロセステーブルにスペースを取られ、それがいっぱいになると他のプロセスの実行を妨げる可能性があります。",
  "exercise": "このレッスンには演習問題はありません。",
  "quizQuestion": "プロセスが成功する場合の最も一般的な終了ステータスは何ですか？",
  "quizAnswer": "0",
  "slug": "processtermination"
}